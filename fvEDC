[33mcommit 13562b1e42955888188bc78893c306a9f96ffae0[m[33m ([m[1;36mHEAD -> [m[1;32mmaster[m[33m, [m[1;31mgithub1/master[m[33m)[m
Author: lyj <test@lyj.com>
Date:   Mon Oct 24 10:05:59 2022 +0800

    Êó∂Èó¥‰øÆÊîπ

[1mdiff --git a/Obj/Template.axf b/Obj/Template.axf[m
[1mindex f3ce854..7c1e4df 100644[m
Binary files a/Obj/Template.axf and b/Obj/Template.axf differ
[1mdiff --git a/Obj/Template.build_log.htm b/Obj/Template.build_log.htm[m
[1mindex 408b3e8..a855437 100644[m
[1m--- a/Obj/Template.build_log.htm[m
[1m+++ b/Obj/Template.build_log.htm[m
[36m@@ -53,7 +53,7 @@[m [mPackage Vendor: Keil[m
   D:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
 [m
 <h2>Collection of Component Files used:</h2>[m
[31m-Build Time Elapsed:  00:00:02[m
[32m+[m[32mBuild Time Elapsed:  00:00:03[m
 </pre>[m
 </body>[m
 </html>[m
[1mdiff --git a/Obj/Template.hex b/Obj/Template.hex[m
[1mindex 00a15e7..89efe86 100644[m
[1m--- a/Obj/Template.hex[m
[1m+++ b/Obj/Template.hex[m
[36m@@ -73,7 +73,7 @@[m
 :1004700008ED00E000BFFEE702E008C8121F08C157[m
 :10048000002AFAD170477047002001E001C1121F15[m
 :10049000002AFBD170470000FFF716FF0FE0012193[m
[31m-:1004A0000748FFF70AFF4FF47A70FFF772FE012149[m
[32m+[m[32m:1004A0000748FFF70AFF4FF4FA70FFF772FE0121C9[m
 :1004B0000348FFF704FF4FF47A70FFF76AFEEEE798[m
 :1004C00000100140D40400080000002000040000D7[m
 :0404D0008804000894[m
[1mdiff --git a/Obj/Template.htm b/Obj/Template.htm[m
[1mindex 4c0fd64..2b6fc64 100644[m
[1m--- a/Obj/Template.htm[m
[1m+++ b/Obj/Template.htm[m
[36m@@ -3,7 +3,7 @@[m
 <title>Static Call Graph - [.\Obj\Template.axf]</title></head>[m
 <body><HR>[m
 <H1>Static Call Graph for image .\Obj\Template.axf</H1><HR>[m
[31m-<BR><P>#&#060CALLGRAPH&#062# ARM Linker, 5060061: Last Updated: Sun Oct 23 16:41:46 2022[m
[32m+[m[32m<BR><P>#&#060CALLGRAPH&#062# ARM Linker, 5060061: Last Updated: Mon Oct 24 10:03:14 2022[m
 <BR><P>[m
 <H3>Maximum Stack Usage =         32 bytes + Unknown(Cycles, Untraceable Function Pointers)</H3><H3>[m
 Call chain for Maximum Stack Depth:</H3>[m
[1mdiff --git a/Obj/Template_Target 1.dep b/Obj/Template_Target 1.dep[m
[1mindex 0b625d7..787c567 100644[m
[1m--- a/Obj/Template_Target 1.dep[m	
[1m+++ b/Obj/Template_Target 1.dep[m	
[36m@@ -1,5 +1,5 @@[m
 Dependencies for Project 'Template', Target 'Target 1': (DO NOT MODIFY !)[m
[31m-F (.\User\main.c)(0x6354FE47)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\main.o --omf_browse .\obj\main.crf --depend .\obj\main.d)[m
[32m+[m[32mF (.\User\main.c)(0x6355F25D)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\main.o --omf_browse .\obj\main.crf --depend .\obj\main.d)[m[41m[m
 I (User\stm32f10x.h)(0x4D783CB4)[m
 I (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m
 I (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m
[1mdiff --git a/Obj/core_cm3.o b/Obj/core_cm3.o[m
[1mindex e5ad926..5be5fdc 100644[m
Binary files a/Obj/core_cm3.o and b/Obj/core_cm3.o differ
[1mdiff --git a/Obj/led.o b/Obj/led.o[m
[1mindex 4860316..d026e29 100644[m
Binary files a/Obj/led.o and b/Obj/led.o differ
[1mdiff --git a/Obj/main.crf b/Obj/main.crf[m
[1mindex 86dc975..6beb06a 100644[m
Binary files a/Obj/main.crf and b/Obj/main.crf differ
[1mdiff --git a/Obj/main.o b/Obj/main.o[m
[1mindex c950164..a8d5a95 100644[m
Binary files a/Obj/main.o and b/Obj/main.o differ
[1mdiff --git a/Obj/stm32f10x_gpio.o b/Obj/stm32f10x_gpio.o[m
[1mindex d7f54d3..bd23a62 100644[m
Binary files a/Obj/stm32f10x_gpio.o and b/Obj/stm32f10x_gpio.o differ
[1mdiff --git a/Obj/stm32f10x_it.o b/Obj/stm32f10x_it.o[m
[1mindex d84a2bc..2cfe721 100644[m
Binary files a/Obj/stm32f10x_it.o and b/Obj/stm32f10x_it.o differ
[1mdiff --git a/Obj/stm32f10x_rcc.o b/Obj/stm32f10x_rcc.o[m
[1mindex de33fd8..e9e4c8c 100644[m
Binary files a/Obj/stm32f10x_rcc.o and b/Obj/stm32f10x_rcc.o differ
[1mdiff --git a/Obj/system_stm32f10x.o b/Obj/system_stm32f10x.o[m
[1mindex b7e2048..a2b5627 100644[m
Binary files a/Obj/system_stm32f10x.o and b/Obj/system_stm32f10x.o differ
[1mdiff --git "a/Template.uvguix.\346\235\216\347\207\225\345\206\233" "b/Template.uvguix.\346\235\216\347\207\225\345\206\233"[m
[1mindex 5a521b5..79c55aa 100644[m
[1m--- "a/Template.uvguix.\346\235\216\347\207\225\345\206\233"[m
[1m+++ "b/Template.uvguix.\346\235\216\347\207\225\345\206\233"[m
[36m@@ -1796,7 +1796,7 @@[m
         <Name>File</Name>[m
         <Buttons>[m
           <Len>2517</Len>[m
[31m-          <Data>00200000010000002800FFFF01001100434D4643546F6F6C426172427574746F6E00E100000000000000000000000000000000000000000000000100000001000000018001E100000000000001000000000000000000000000000000000100000001000000018003E1000000000000020000000000000000000000000000000001000000010000000180CD7F0000000000000300000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018023E100000000040004000000000000000000000000000000000100000001000000018022E100000000040005000000000000000000000000000000000100000001000000018025E10000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001802BE10000000000000700000000000000000000000000000000010000000100000001802CE10000000004000800000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001807A8A0000000000000900000000000000000000000000000000010000000100000001807B8A0000000004000A00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180D3B00000000000000B000000000000000000000000000000000100000001000000018015B10000000004000C0000000000000000000000000000000001000000010000000180F4B00000000004000D000000000000000000000000000000000100000001000000018036B10000000004000E00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FF88000000000400460000000000000000000000000000000001000000010000000180FE880000000004004500000000000000000000000000000000010000000100000001800B810000000004001300000000000000000000000000000000010000000100000001800C810000000004001400000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180F0880000020000000F000000000000000000000000000000000100000001000000FFFF0100120043555646696E64436F6D626F427574746F6EE803000000000000000000000000000000000000000000000001000000010000009600000002002050000000000550466F7574960000000000000014000550466F7574044C454430077479706564656607414E5F315F66790B414E5F345F4657526561640550585F6679067078665F46570C446F75626C655F76616C75650A446174615F76616C7565165A68695869616E675F436F6D706C6574655F466C61670F54656D705F33325F52656365697665165A6875616E6754616943686158756E5F59696E6744610A41415F446174615F434C0D5A694A69616E5F59696E674461144361694A694D696E674C696E675F59696E6744610A73706163655F7363616E0F46595F656E636F6465725F466C61670A77726974655F4C5644530B52656164496D7544617461166765745F6F70746963616C5F6E617669676174696F6E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018024E10000000000001100000000000000000000000000000000010000000100000001800A810000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6E22800000020000001500000019C6F4B6AF2FCDA3D6B9B5F7CAD4BBE1BBB0094374726C2B463500000000000000000000000001000000010000000000000000000000010000000200218022800000000000001500000019C6F4B6AF2FCDA3D6B9B5F7CAD4BBE1BBB0094374726C2B4635000000000000000000000000010000000100000000000000000000000100000000002180E0010000000000007500000012C4DCC1BFB2E2C1BFBACDCEDED0E8B5F7CAD40000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C488000000000000160000000000000000000000000000000001000000010000000180C988000000000400180000000000000000000000000000000001000000010000000180C788000000000000190000000000000000000000000000000001000000010000000180C8880000000000001700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000021804C010000020001001A00000008CFEEC4BFB4B0BFDA000000000000000000000000010000000100000000000000000000000100000008002180DD880000000000001A0000000750726F6A656374000000000000000000000000010000000100000000000000000000000100000000002180DC8B0000000000003A00000005426F6F6B73000000000000000000000000010000000100000000000000000000000100000000002180E18B0000000000003B0000000946756E6374696F6E73000000000000000000000000010000000100000000000000000000000100000000002180E28B000000000000400000000954656D706C6174657300000000000000000000000001000000010000000000000000000000010000000000218018890000000000003D0000000E536F757263652042726F777365720000000000000000000000000100000001000000000000000000000001000000000021800000000000000400FFFFFFFF00000000000000000001000000000000000100000000000000000000000100000000002180D988000000000000390000000C4275696C64204F7574707574000000000000000000000000010000000100000000000000000000000100000000002180E38B000000000000410000000B46696E64204F75747075740000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FB7F0000000000001B000000000000000000000000000000000100000001000000000000000446696C65B9030000</Data>[m
[32m+[m[32m          <Data>00200000010000002800FFFF01001100434D4643546F6F6C426172427574746F6E00E100000000000000000000000000000000000000000000000100000001000000018001E100000000000001000000000000000000000000000000000100000001000000018003E1000000000000020000000000000000000000000000000001000000010000000180CD7F0000000000000300000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018023E100000000040004000000000000000000000000000000000100000001000000018022E100000000040005000000000000000000000000000000000100000001000000018025E10000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001802BE10000000004000700000000000000000000000000000000010000000100000001802CE10000000004000800000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001807A8A0000000004000900000000000000000000000000000000010000000100000001807B8A0000000004000A00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180D3B00000000000000B000000000000000000000000000000000100000001000000018015B10000000004000C0000000000000000000000000000000001000000010000000180F4B00000000004000D000000000000000000000000000000000100000001000000018036B10000000004000E00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FF88000000000400460000000000000000000000000000000001000000010000000180FE880000000004004500000000000000000000000000000000010000000100000001800B810000000004001300000000000000000000000000000000010000000100000001800C810000000004001400000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180F0880000020000000F000000000000000000000000000000000100000001000000FFFF0100120043555646696E64436F6D626F427574746F6EE803000000000000000000000000000000000000000000000001000000010000009600000002002050000000000550466F7574960000000000000014000550466F7574044C454430077479706564656607414E5F315F66790B414E5F345F4657526561640550585F6679067078665F46570C446F75626C655F76616C75650A446174615F76616C7565165A68695869616E675F436F6D706C6574655F466C61670F54656D705F33325F52656365697665165A6875616E6754616943686158756E5F59696E6744610A41415F446174615F434C0D5A694A69616E5F59696E674461144361694A694D696E674C696E675F59696E6744610A73706163655F7363616E0F46595F656E636F6465725F466C61670A77726974655F4C5644530B52656164496D7544617461166765745F6F70746963616C5F6E617669676174696F6E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018024E10000000000001100000000000000000000000000000000010000000100000001800A810000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6E22800000020000001500000019C6F4B6AF2FCDA3D6B9B5F7CAD4BBE1BBB0094374726C2B463500000000000000000000000001000000010000000000000000000000010000000200218022800000000000001500000019C6F4B6AF2FCDA3D6B9B5F7CAD4BBE1BBB0094374726C2B4635000000000000000000000000010000000100000000000000000000000100000000002180E0010000000000007500000012C4DCC1BFB2E2C1BFBACDCEDED0E8B5F7CAD40000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C488000000000000160000000000000000000000000000000001000000010000000180C988000000000400180000000000000000000000000000000001000000010000000180C788000000000000190000000000000000000000000000000001000000010000000180C8880000000000001700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000021804C010000020001001A00000008CFEEC4BFB4B0BFDA000000000000000000000000010000000100000000000000000000000100000008002180DD880000000000001A0000000750726F6A656374000000000000000000000000010000000100000000000000000000000100000000002180DC8B0000000000003A00000005426F6F6B73000000000000000000000000010000000100000000000000000000000100000000002180E18B0000000000003B0000000946756E6374696F6E73000000000000000000000000010000000100000000000000000000000100000000002180E28B000000000000400000000954656D706C6174657300000000000000000000000001000000010000000000000000000000010000000000218018890000000000003D0000000E536F757263652042726F777365720000000000000000000000000100000001000000000000000000000001000000000021800000000000000400FFFFFFFF00000000000000000001000000000000000100000000000000000000000100000000002180D988000000000000390000000C4275696C64204F7574707574000000000000000000000000010000000100000000000000000000000100000000002180E38B000000000000410000000B46696E64204F75747075740000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FB7F0000000000001B000000000000000000000000000000000100000001000000000000000446696C65B9030000</Data>[m
         </Buttons>[m
         <OriginalItems>[m
           <Len>1423</Len>[m
[36m@@ -1812,7 +1812,7 @@[m
         <Name>Build</Name>[m
         <Buttons>[m
           <Len>960</Len>[m
[31m-          <Data>00200000010000001000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F0000000000001C0000000000000000000000000000000001000000010000000180D07F0000000000001D000000000000000000000000000000000100000001000000018030800000000000001E000000000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6EC7040000000000006A00000008C5FAC1BFB9B9BDA8000000000000000000000000010000000100000000000000000000000100000004000580C7040000000000006A00000008C5FAC1BFB9B9BDA800000000000000000000000001000000010000000000000000000000010000000000058046070000000000006B0000000CC5FAC1BFD6D8D0C2B9B9BDA80000000000000000000000000100000001000000000000000000000001000000000005804707000000000000FFFFFFFF08C5FAC1BFC7E5B3FD0100000000000000000000000100000001000000000000000000000001000000000005809E8A0000000000001F0000000BC5FAC1BFC9E8D6C32E2E2E000000000000000000000000010000000100000000000000000000000100000000000180D17F0000000004002000000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001804C8A0000000000002100000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001900434D4643546F6F6C426172436F6D626F426F78427574746F6EBA000000000000000000000000000000000000000000000000010000000100000096000000030020500000000008546172676574203196000000000000000100085461726765742031000000000180EB880000000000002200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C07F000000000000230000000000000000000000000000000001000000010000000180B08A000000000400240000000000000000000000000000000001000000010000000180A8010000000000004E00000000000000000000000000000000010000000100000001807202000000000000530000000000000000000000000000000001000000010000000180BE010000000000005000000000000000000000000000000000010000000100000000000000054275696C64DC010000</Data>[m
[32m+[m[32m          <Data>00200000010000001000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F0000000000001C0000000000000000000000000000000001000000010000000180D07F0000000002001D000000000000000000000000000000000100000001000000018030800000000000001E000000000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6EC7040000000000006A00000008C5FAC1BFB9B9BDA8000000000000000000000000010000000100000000000000000000000100000004000580C7040000000000006A00000008C5FAC1BFB9B9BDA800000000000000000000000001000000010000000000000000000000010000000000058046070000000000006B0000000CC5FAC1BFD6D8D0C2B9B9BDA80000000000000000000000000100000001000000000000000000000001000000000005804707000000000000FFFFFFFF08C5FAC1BFC7E5B3FD0100000000000000000000000100000001000000000000000000000001000000000005809E8A0000000000001F0000000BC5FAC1BFC9E8D6C32E2E2E000000000000000000000000010000000100000000000000000000000100000000000180D17F0000000004002000000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001804C8A0000000000002100000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001900434D4643546F6F6C426172436F6D626F426F78427574746F6EBA000000000000000000000000000000000000000000000000010000000100000096000000030020500000000008546172676574203196000000000000000100085461726765742031000000000180EB880000000000002200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C07F000000000000230000000000000000000000000000000001000000010000000180B08A000000000400240000000000000000000000000000000001000000010000000180A8010000000000004E00000000000000000000000000000000010000000100000001807202000000000000530000000000000000000000000000000001000000010000000180BE010000000000005000000000000000000000000000000000010000000100000000000000054275696C64DC010000</Data>[m
         </Buttons>[m
         <OriginalItems>[m
           <Len>583</Len>[m
[36m@@ -1855,9 +1855,9 @@[m
       <ActiveTab>0</ActiveTab>[m
       <Doc>[m
         <Name>.\User\main.c</Name>[m
[31m-        <ColumnNumber>20</ColumnNumber>[m
[32m+[m[32m        <ColumnNumber>1</ColumnNumber>[m
         <TopLine>1</TopLine>[m
[31m-        <CurrentLine>17</CurrentLine>[m
[32m+[m[32m        <CurrentLine>21</CurrentLine>[m
         <Folding>1</Folding>[m
         <ContractedFolders></ContractedFolders>[m
         <PaneID>0</PaneID>[m
[1mdiff --git a/User/main.c b/User/main.c[m
[1mindex a1ca891..5ba553d 100644[m
[1m--- a/User/main.c[m
[1m+++ b/User/main.c[m
[36m@@ -14,7 +14,7 @@[m [mint main()[m
 		while(1)[m
 		{[m
 				GPIO_ResetBits(LEN_PORT,GPIO_Pin_0);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      [m
[31m-				DelayMs(1000);[m
[32m+[m				[32mDelayMs(500);[m
 				GPIO_SetBits(LEN_PORT,GPIO_Pin_0);[m
 				DelayMs(1000);[m
 		}[m

[33mcommit 80257434268458cc066a77dd2aed9db7549453c9[m
Author: lyj <test@lyj.com>
Date:   Sun Oct 23 20:41:27 2022 +0800

    Â§çÂà∂Êñá‰ª∂txt

[1mdiff --git "a/\344\277\256\346\224\271\350\257\264\346\230\2162022.10.23 - \345\211\257\346\234\254.txt" "b/\344\277\256\346\224\271\350\257\264\346\230\2162022.10.23 - \345\211\257\346\234\254.txt"[m
[1mnew file mode 100644[m
[1mindex 0000000..4bd945c[m
[1m--- /dev/null[m
[1m+++ "b/\344\277\256\346\224\271\350\257\264\346\230\2162022.10.23 - \345\211\257\346\234\254.txt"[m	
[36m@@ -0,0 +1 @@[m
[32m+[m[32mÂ∞ÜLEDÁÇπ‰∫ÆÁöÑÊó∂Èó¥‰øÆÊîπ‰∏∫100ms[m
\ No newline at end of file[m

[33mcommit 83a9e7524442b2a93127521a98b830b156c379ea[m
Author: lyj <test@lyj.com>
Date:   Sun Oct 23 16:58:10 2022 +0800

    add . ‰øÆÊîπËØ¥Êòé2022.10.23 txt
    
    Signed-off-by: lyj <test@lyj.com>

[1mdiff --git a/Obj/Template.axf b/Obj/Template.axf[m
[1mnew file mode 100644[m
[1mindex 0000000..f3ce854[m
Binary files /dev/null and b/Obj/Template.axf differ
[1mdiff --git a/Obj/Template.build_log.htm b/Obj/Template.build_log.htm[m
[1mnew file mode 100644[m
[1mindex 0000000..408b3e8[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template.build_log.htm[m
[36m@@ -0,0 +1,59 @@[m
[32m+[m[32m<html>[m
[32m+[m[32m<body>[m
[32m+[m[32m<pre>[m
[32m+[m[32m<h1>µVision Build Log</h1>[m
[32m+[m[32m<h2>Tool Versions:</h2>[m
[32m+[m[32mIDE-Version: ¶ÃVision V5.25.3.0[m
[32m+[m[32mCopyright (C) 2018 ARM Ltd and ARM Germany GmbH. All rights reserved.[m
[32m+[m[32mLicense Information: »Ìº˛π‹º“ ¿Ó—‡æ¸, www.softgi.com, LIC=FQQMA-1YGUS-UM79A-154BJ-55II3-WITM4[m
[32m+[m[41m [m
[32m+[m[32mTool Versions:[m
[32m+[m[32mToolchain:       MDK-ARM Professional  Version: 5.18[m
[32m+[m[32mToolchain Path:  D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin[m
[32m+[m[32mC Compiler:      Armcc.exe V5.06 update 1 (build 61)[m
[32m+[m[32mAssembler:       Armasm.exe V5.06 update 1 (build 61)[m
[32m+[m[32mLinker/Locator:  ArmLink.exe V5.06 update 1 (build 61)[m
[32m+[m[32mLibrary Manager: ArmAr.exe V5.06 update 1 (build 61)[m
[32m+[m[32mHex Converter:   FromElf.exe V5.06 update 1 (build 61)[m
[32m+[m[32mCPU DLL:         SARMCM3.DLL V5.18[m
[32m+[m[32mDialog DLL:      DCM.DLL V1.13.6.0[m
[32m+[m[32mTarget DLL:      Segger\JL2CM3.dll V2.99.18.0[m
[32m+[m[32mDialog DLL:      TCM.DLL V1.14.8.0[m
[32m+[m[41m [m
[32m+[m[32m<h2>Project:</h2>[m
[32m+[m[32mI:\Œƒº˛\…œ—ß∆⁄º‰µƒ◊ ¡œ\—ßœ∞±‡≥Ã\STM32±‡≥Ã¡∑œ∞\STM32f103±‡≥Ã\STM32f103±‡≥Ã\4. π”√ø‚∫Ø ˝µ„¡¡LED\Template.uvprojx[m
[32m+[m[32mProject File Date:  10/23/2022[m
[32m+[m
[32m+[m[32m<h2>Output:</h2>[m
[32m+[m[32m*** Using Compiler 'V5.06 update 1 (build 61)', folder: 'D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin'[m
[32m+[m[32m*** Note: Rebuilding project, since 'Options->Output->Create Batch File' is selected.[m
[32m+[m[32mRebuild target 'Target 1'[m
[32m+[m[32mcompiling main.c...[m
[32m+[m[32mcompiling stm32f10x_it.c...[m
[32m+[m[32massembling startup_stm32f10x_hd.s...[m
[32m+[m[32mcompiling stm32f10x_gpio.c...[m
[32m+[m[32mcompiling stm32f10x_rcc.c...[m
[32m+[m[32mcompiling core_cm3.c...[m
[32m+[m[32mcompiling system_stm32f10x.c...[m
[32m+[m[32mcompiling led.c...[m
[32m+[m[32mlinking...[m
[32m+[m[32mProgram Size: Code=916 RO-data=320 RW-data=0 ZI-data=1024[m[41m  [m
[32m+[m[32mFromELF: creating hex file...[m
[32m+[m[32m".\Obj\Template.axf" - 0 Error(s), 0 Warning(s).[m
[32m+[m
[32m+[m[32m<h2>Software Packages used:</h2>[m
[32m+[m
[32m+[m[32mPackage Vendor: Keil[m
[32m+[m[32m                http://www.keil.com/pack/Keil.STM32F1xx_DFP.1.0.5.pack[m
[32m+[m[32m                Keil.STM32F1xx_DFP.1.0.5[m
[32m+[m[32m                STMicroelectronics STM32F1 Series Device Support, Drivers and Examples[m
[32m+[m
[32m+[m[32m<h2>Collection of Component include folders:</h2>[m
[32m+[m[32m  .\RTE\_Target_1[m
[32m+[m[32m  D:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m
[32m+[m[32m<h2>Collection of Component Files used:</h2>[m
[32m+[m[32mBuild Time Elapsed:  00:00:02[m
[32m+[m[32m</pre>[m
[32m+[m[32m</body>[m
[32m+[m[32m</html>[m
[1mdiff --git a/Obj/Template.hex b/Obj/Template.hex[m
[1mindex a04ceda..00a15e7 100644[m
[1m--- a/Obj/Template.hex[m
[1m+++ b/Obj/Template.hex[m
[36m@@ -24,7 +24,7 @@[m
 :100160001504000831010008064C074D06E0E06860[m
 :1001700040F0010394E8070098471034AC42F6D3EE[m
 :10018000FFF7DAFFC4040008D404000800BFFEE74C[m
[31m-:10019000704741F21841484300BF0100A0F101003F[m
[32m+[m[32m:10019000704741F21841484300BF011EA0F1010021[m
 :1001A000FBD170472DE9F0410246002500260020D2[m
 :1001B00000230024002791F803C00CF00F0591F8EC[m
 :1001C00003C00CF0100CBCF1000F03D091F802C07A[m
[1mdiff --git a/Obj/Template.htm b/Obj/Template.htm[m
[1mnew file mode 100644[m
[1mindex 0000000..4c0fd64[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template.htm[m
[36m@@ -0,0 +1,418 @@[m
[32m+[m[32m<!doctype html public "-//w3c//dtd html 4.0 transitional//en">[m
[32m+[m[32m<html><head>[m
[32m+[m[32m<title>Static Call Graph - [.\Obj\Template.axf]</title></head>[m
[32m+[m[32m<body><HR>[m
[32m+[m[32m<H1>Static Call Graph for image .\Obj\Template.axf</H1><HR>[m
[32m+[m[32m<BR><P>#&#060CALLGRAPH&#062# ARM Linker, 5060061: Last Updated: Sun Oct 23 16:41:46 2022[m
[32m+[m[32m<BR><P>[m
[32m+[m[32m<H3>Maximum Stack Usage =         32 bytes + Unknown(Cycles, Untraceable Function Pointers)</H3><H3>[m
[32m+[m[32mCall chain for Maximum Stack Depth:</H3>[m
[32m+[m[32mmain &rArr; LED_Init &rArr; GPIO_Init[m
[32m+[m[32m<P>[m
[32m+[m[32m<H3>[m
[32m+[m[32mMutually Recursive functions[m
[32m+[m[32m</H3> <LI><a href="#[1c]">ADC1_2_IRQHandler</a>&nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;<a href="#[1c]">ADC1_2_IRQHandler</a><BR>[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P>[m
[32m+[m[32m<H3>[m
[32m+[m[32mFunction Pointers[m
[32m+[m[32m</H3><UL>[m
[32m+[m[32m <LI><a href="#[1c]">ADC1_2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[39]">ADC3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[4]">BusFault_Handler</a> from stm32f10x_it.o(i.BusFault_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[1f]">CAN1_RX1_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[20]">CAN1_SCE_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[15]">DMA1_Channel1_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[16]">DMA1_Channel2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[17]">DMA1_Channel3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[18]">DMA1_Channel4_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[19]">DMA1_Channel5_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[1a]">DMA1_Channel6_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[1b]">DMA1_Channel7_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[42]">DMA2_Channel1_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[43]">DMA2_Channel2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[44]">DMA2_Channel3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[45]">DMA2_Channel4_5_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[7]">DebugMon_Handler</a> from stm32f10x_it.o(i.DebugMon_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[10]">EXTI0_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[32]">EXTI15_10_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[11]">EXTI1_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[12]">EXTI2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[13]">EXTI3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[14]">EXTI4_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[21]">EXTI9_5_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[e]">FLASH_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3a]">FSMC_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2]">HardFault_Handler</a> from stm32f10x_it.o(i.HardFault_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2a]">I2C1_ER_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[29]">I2C1_EV_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2c]">I2C2_ER_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2b]">I2C2_EV_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3]">MemManage_Handler</a> from stm32f10x_it.o(i.MemManage_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[1]">NMI_Handler</a> from stm32f10x_it.o(i.NMI_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[b]">PVD_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[8]">PendSV_Handler</a> from stm32f10x_it.o(i.PendSV_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[f]">RCC_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[33]">RTCAlarm_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[d]">RTC_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[0]">Reset_Handler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3b]">SDIO_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2d]">SPI1_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2e]">SPI2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3d]">SPI3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[6]">SVC_Handler</a> from stm32f10x_it.o(i.SVC_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[9]">SysTick_Handler</a> from stm32f10x_it.o(i.SysTick_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[47]">SystemInit</a> from system_stm32f10x.o(i.SystemInit) referenced from startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m <LI><a href="#[c]">TAMPER_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[22]">TIM1_BRK_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[25]">TIM1_CC_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[24]">TIM1_TRG_COM_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[23]">TIM1_UP_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[26]">TIM2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[27]">TIM3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[28]">TIM4_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3c]">TIM5_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[40]">TIM6_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[41]">TIM7_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[35]">TIM8_BRK_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[38]">TIM8_CC_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[37]">TIM8_TRG_COM_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[36]">TIM8_UP_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3e]">UART4_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[3f]">UART5_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[2f]">USART1_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[30]">USART2_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[31]">USART3_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[34]">USBWakeUp_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[1d]">USB_HP_CAN1_TX_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[1e]">USB_LP_CAN1_RX0_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[5]">UsageFault_Handler</a> from stm32f10x_it.o(i.UsageFault_Handler) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[a]">WWDG_IRQHandler</a> from startup_stm32f10x_hd.o(.text) referenced from startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m <LI><a href="#[48]">__main</a> from entry.o(.ARM.Collect$$$$00000000) referenced from startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m <LI><a href="#[46]">main</a> from main.o(i.main) referenced from entry9a.o(.ARM.Collect$$$$0000000B)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P>[m
[32m+[m[32m<H3>[m
[32m+[m[32mGlobal Symbols[m
[32m+[m[32m</H3>[m
[32m+[m[32m<P><STRONG><a name="[48]"></a>__main</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry.o(.ARM.Collect$$$$00000000))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[54]"></a>_main_stk</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry2.o(.ARM.Collect$$$$00000001))[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[49]"></a>_main_scatterload</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry5.o(.ARM.Collect$$$$00000004))[m
[32m+[m[32m<BR><BR>[Calls]<UL><LI><a href="#[4a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[4b]"></a>__main_after_scatterload</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry5.o(.ARM.Collect$$$$00000004))[m
[32m+[m[32m<BR><BR>[Called By]<UL><LI><a href="#[4a]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[55]"></a>_main_clock</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry7b.o(.ARM.Collect$$$$00000008))[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[56]"></a>_main_cpp_init</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry8b.o(.ARM.Collect$$$$0000000A))[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[57]"></a>_main_init</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry9a.o(.ARM.Collect$$$$0000000B))[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[58]"></a>__rt_final_cpp</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry10a.o(.ARM.Collect$$$$0000000D))[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[59]"></a>__rt_final_exit</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, entry11a.o(.ARM.Collect$$$$0000000F))[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[0]"></a>Reset_Handler</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1c]"></a>ADC1_2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR><BR>[Calls]<UL><LI><a href="#[1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ADC1_2_IRQHandler[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Called By]<UL><LI><a href="#[1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ADC1_2_IRQHandler[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[39]"></a>ADC3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1f]"></a>CAN1_RX1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[20]"></a>CAN1_SCE_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[15]"></a>DMA1_Channel1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[16]"></a>DMA1_Channel2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[17]"></a>DMA1_Channel3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[18]"></a>DMA1_Channel4_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[19]"></a>DMA1_Channel5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1a]"></a>DMA1_Channel6_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1b]"></a>DMA1_Channel7_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[42]"></a>DMA2_Channel1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[43]"></a>DMA2_Channel2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[44]"></a>DMA2_Channel3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[45]"></a>DMA2_Channel4_5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[10]"></a>EXTI0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[32]"></a>EXTI15_10_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[11]"></a>EXTI1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[12]"></a>EXTI2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[13]"></a>EXTI3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[14]"></a>EXTI4_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[21]"></a>EXTI9_5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[e]"></a>FLASH_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[3a]"></a>FSMC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[2a]"></a>I2C1_ER_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[29]"></a>I2C1_EV_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[2c]"></a>I2C2_ER_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[2b]"></a>I2C2_EV_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[b]"></a>PVD_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[f]"></a>RCC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[33]"></a>RTCAlarm_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[d]"></a>RTC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[3b]"></a>SDIO_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[2d]"></a>SPI1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[2e]"></a>SPI2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[3d]"></a>SPI3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[c]"></a>TAMPER_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[22]"></a>TIM1_BRK_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[25]"></a>TIM1_CC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[24]"></a>TIM1_TRG_COM_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[23]"></a>TIM1_UP_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[26]"></a>TIM2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[27]"></a>TIM3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[28]"></a>TIM4_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[3c]"></a>TIM5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[40]"></a>TIM6_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[41]"></a>TIM7_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[35]"></a>TIM8_BRK_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[38]"></a>TIM8_CC_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[37]"></a>TIM8_TRG_COM_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[36]"></a>TIM8_UP_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[3e]"></a>UART4_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[3f]"></a>UART5_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[2f]"></a>USART1_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[30]"></a>USART2_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[31]"></a>USART3_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[34]"></a>USBWakeUp_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1d]"></a>USB_HP_CAN1_TX_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1e]"></a>USB_LP_CAN1_RX0_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[a]"></a>WWDG_IRQHandler</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, startup_stm32f10x_hd.o(.text))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[4a]"></a>__scatterload</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, init.o(.text))[m
[32m+[m[32m<BR><BR>[Calls]<UL><LI><a href="#[4b]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__main_after_scatterload[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Called By]<UL><LI><a href="#[49]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_main_scatterload[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[5a]"></a>__scatterload_rt2</STRONG> (Thumb, 0 bytes, Stack size 0 bytes, init.o(.text), UNUSED)[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[4]"></a>BusFault_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32f10x_it.o(i.BusFault_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[7]"></a>DebugMon_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32f10x_it.o(i.DebugMon_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[53]"></a>DelayMs</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, main.o(i.DelayMs))[m
[32m+[m[32m<BR><BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[4e]"></a>GPIO_Init</STRONG> (Thumb, 278 bytes, Stack size 24 bytes, stm32f10x_gpio.o(i.GPIO_Init))[m
[32m+[m[32m<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = GPIO_Init[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Called By]<UL><LI><a href="#[4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LED_Init[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[52]"></a>GPIO_ResetBits</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32f10x_gpio.o(i.GPIO_ResetBits))[m
[32m+[m[32m<BR><BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[4f]"></a>GPIO_SetBits</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32f10x_gpio.o(i.GPIO_SetBits))[m
[32m+[m[32m<BR><BR>[Called By]<UL><LI><a href="#[4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LED_Init[m
[32m+[m[32m<LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[2]"></a>HardFault_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32f10x_it.o(i.HardFault_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[4c]"></a>LED_Init</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, led.o(i.LED_Init))[m
[32m+[m[32m<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = LED_Init &rArr; GPIO_Init[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Calls]<UL><LI><a href="#[4d]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RCC_APB2PeriphClockCmd[m
[32m+[m[32m<LI><a href="#[4e]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_Init[m
[32m+[m[32m<LI><a href="#[4f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_SetBits[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Called By]<UL><LI><a href="#[46]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;main[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[3]"></a>MemManage_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32f10x_it.o(i.MemManage_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[1]"></a>NMI_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32f10x_it.o(i.NMI_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[8]"></a>PendSV_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32f10x_it.o(i.PendSV_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[4d]"></a>RCC_APB2PeriphClockCmd</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, stm32f10x_rcc.o(i.RCC_APB2PeriphClockCmd))[m
[32m+[m[32m<BR><BR>[Called By]<UL><LI><a href="#[4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LED_Init[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[6]"></a>SVC_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32f10x_it.o(i.SVC_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[9]"></a>SysTick_Handler</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, stm32f10x_it.o(i.SysTick_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[47]"></a>SystemInit</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, system_stm32f10x.o(i.SystemInit))[m
[32m+[m[32m<BR><BR>[Stack]<UL><LI>Max Depth = 28<LI>Call Chain = SystemInit &rArr; SetSysClock &rArr; SetSysClockTo72[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Calls]<UL><LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSysClock[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[5]"></a>UsageFault_Handler</STRONG> (Thumb, 4 bytes, Stack size 0 bytes, stm32f10x_it.o(i.UsageFault_Handler))[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P><STRONG><a name="[5b]"></a>__scatterload_copy</STRONG> (Thumb, 14 bytes, Stack size unknown bytes, handlers.o(i.__scatterload_copy), UNUSED)[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[5c]"></a>__scatterload_null</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, handlers.o(i.__scatterload_null), UNUSED)[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[5d]"></a>__scatterload_zeroinit</STRONG> (Thumb, 14 bytes, Stack size unknown bytes, handlers.o(i.__scatterload_zeroinit), UNUSED)[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[46]"></a>main</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, main.o(i.main))[m
[32m+[m[32m<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = main &rArr; LED_Init &rArr; GPIO_Init[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Calls]<UL><LI><a href="#[4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LED_Init[m
[32m+[m[32m<LI><a href="#[4f]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_SetBits[m
[32m+[m[32m<LI><a href="#[52]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GPIO_ResetBits[m
[32m+[m[32m<LI><a href="#[53]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Address Reference Count : 1]<UL><LI> entry9a.o(.ARM.Collect$$$$0000000B)[m
[32m+[m[32m</UL><P>[m
[32m+[m[32m<H3>[m
[32m+[m[32mLocal Symbols[m
[32m+[m[32m</H3>[m
[32m+[m[32m<P><STRONG><a name="[50]"></a>SetSysClock</STRONG> (Thumb, 8 bytes, Stack size 8 bytes, system_stm32f10x.o(i.SetSysClock))[m
[32m+[m[32m<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = SetSysClock &rArr; SetSysClockTo72[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Calls]<UL><LI><a href="#[51]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSysClockTo72[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Called By]<UL><LI><a href="#[47]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemInit[m
[32m+[m[32m</UL>[m
[32m+[m
[32m+[m[32m<P><STRONG><a name="[51]"></a>SetSysClockTo72</STRONG> (Thumb, 214 bytes, Stack size 12 bytes, system_stm32f10x.o(i.SetSysClockTo72))[m
[32m+[m[32m<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = SetSysClockTo72[m
[32m+[m[32m</UL>[m
[32m+[m[32m<BR>[Called By]<UL><LI><a href="#[50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSysClock[m
[32m+[m[32m</UL>[m
[32m+[m[32m<P>[m
[32m+[m[32m<H3>[m
[32m+[m[32mUndefined Global Symbols[m
[32m+[m[32m</H3><HR></body></html>[m
[1mdiff --git a/Obj/Template.lnp b/Obj/Template.lnp[m
[1mnew file mode 100644[m
[1mindex 0000000..7fe61d8[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template.lnp[m
[36m@@ -0,0 +1,13 @@[m
[32m+[m[32m--cpu Cortex-M3[m
[32m+[m[32m".\obj\main.o"[m
[32m+[m[32m".\obj\stm32f10x_it.o"[m
[32m+[m[32m".\obj\startup_stm32f10x_hd.o"[m
[32m+[m[32m".\obj\stm32f10x_gpio.o"[m
[32m+[m[32m".\obj\stm32f10x_rcc.o"[m
[32m+[m[32m".\obj\core_cm3.o"[m
[32m+[m[32m".\obj\system_stm32f10x.o"[m
[32m+[m[32m".\obj\led.o"[m
[32m+[m[32m--library_type=microlib --strict --scatter ".\Obj\Template.sct"[m
[32m+[m[32m--summary_stderr --info summarysizes --map --load_addr_map_info --xref --callgraph --symbols[m
[32m+[m[32m--info sizes --info totals --info unused --info veneers[m
[32m+[m[32m--list ".\Obj\Template.map" -o .\Obj\Template.axf[m
\ No newline at end of file[m
[1mdiff --git a/Obj/Template.map b/Obj/Template.map[m
[1mnew file mode 100644[m
[1mindex 0000000..4440897[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template.map[m
[36m@@ -0,0 +1,419 @@[m
[32m+[m[32mComponent: ARM Compiler 5.06 update 1 (build 61) Tool: armlink [4d35a8][m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m[32mSection Cross References[m
[32m+[m
[32m+[m[32m    main.o(i.main) refers to led.o(i.LED_Init) for LED_Init[m
[32m+[m[32m    main.o(i.main) refers to stm32f10x_gpio.o(i.GPIO_ResetBits) for GPIO_ResetBits[m
[32m+[m[32m    main.o(i.main) refers to main.o(i.DelayMs) for DelayMs[m
[32m+[m[32m    main.o(i.main) refers to stm32f10x_gpio.o(i.GPIO_SetBits) for GPIO_SetBits[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to startup_stm32f10x_hd.o(STACK) for __initial_sp[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to startup_stm32f10x_hd.o(.text) for Reset_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.NMI_Handler) for NMI_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.HardFault_Handler) for HardFault_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.MemManage_Handler) for MemManage_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.BusFault_Handler) for BusFault_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.UsageFault_Handler) for UsageFault_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.SVC_Handler) for SVC_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.DebugMon_Handler) for DebugMon_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.PendSV_Handler) for PendSV_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(RESET) refers to stm32f10x_it.o(i.SysTick_Handler) for SysTick_Handler[m
[32m+[m[32m    startup_stm32f10x_hd.o(.text) refers to system_stm32f10x.o(i.SystemInit) for SystemInit[m
[32m+[m[32m    startup_stm32f10x_hd.o(.text) refers to entry.o(.ARM.Collect$$$$00000000) for __main[m
[32m+[m[32m    stm32f10x_gpio.o(i.GPIO_AFIODeInit) refers to stm32f10x_rcc.o(i.RCC_APB2PeriphResetCmd) for RCC_APB2PeriphResetCmd[m
[32m+[m[32m    stm32f10x_gpio.o(i.GPIO_DeInit) refers to stm32f10x_rcc.o(i.RCC_APB2PeriphResetCmd) for RCC_APB2PeriphResetCmd[m
[32m+[m[32m    stm32f10x_rcc.o(i.RCC_GetClocksFreq) refers to stm32f10x_rcc.o(.data) for APBAHBPrescTable[m
[32m+[m[32m    stm32f10x_rcc.o(i.RCC_WaitForHSEStartUp) refers to stm32f10x_rcc.o(i.RCC_GetFlagStatus) for RCC_GetFlagStatus[m
[32m+[m[32m    system_stm32f10x.o(i.SetSysClock) refers to system_stm32f10x.o(i.SetSysClockTo72) for SetSysClockTo72[m
[32m+[m[32m    system_stm32f10x.o(i.SystemCoreClockUpdate) refers to system_stm32f10x.o(.data) for SystemCoreClock[m
[32m+[m[32m    system_stm32f10x.o(i.SystemInit) refers to system_stm32f10x.o(i.SetSysClock) for SetSysClock[m
[32m+[m[32m    led.o(i.LED_Init) refers to stm32f10x_rcc.o(i.RCC_APB2PeriphClockCmd) for RCC_APB2PeriphClockCmd[m
[32m+[m[32m    led.o(i.LED_Init) refers to stm32f10x_gpio.o(i.GPIO_Init) for GPIO_Init[m
[32m+[m[32m    led.o(i.LED_Init) refers to stm32f10x_gpio.o(i.GPIO_SetBits) for GPIO_SetBits[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry10a.o(.ARM.Collect$$$$0000000D) for __rt_final_cpp[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry11a.o(.ARM.Collect$$$$0000000F) for __rt_final_exit[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry7b.o(.ARM.Collect$$$$00000008) for _main_clock[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry8b.o(.ARM.Collect$$$$0000000A) for _main_cpp_init[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry9a.o(.ARM.Collect$$$$0000000B) for _main_init[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry5.o(.ARM.Collect$$$$00000004) for _main_scatterload[m
[32m+[m[32m    entry.o(.ARM.Collect$$$$00000000) refers (Special) to entry2.o(.ARM.Collect$$$$00000001) for _main_stk[m
[32m+[m[32m    entry2.o(.ARM.Collect$$$$00000001) refers to entry2.o(.ARM.Collect$$$$00002712) for __lit__00000000[m
[32m+[m[32m    entry2.o(.ARM.Collect$$$$00002712) refers to startup_stm32f10x_hd.o(STACK) for __initial_sp[m
[32m+[m[32m    entry2.o(__vectab_stack_and_reset_area) refers to startup_stm32f10x_hd.o(STACK) for __initial_sp[m
[32m+[m[32m    entry2.o(__vectab_stack_and_reset_area) refers to entry.o(.ARM.Collect$$$$00000000) for __main[m
[32m+[m[32m    entry5.o(.ARM.Collect$$$$00000004) refers to init.o(.text) for __scatterload[m
[32m+[m[32m    entry9a.o(.ARM.Collect$$$$0000000B) refers to main.o(i.main) for main[m
[32m+[m[32m    entry9b.o(.ARM.Collect$$$$0000000C) refers to main.o(i.main) for main[m
[32m+[m[32m    init.o(.text) refers to entry5.o(.ARM.Collect$$$$00000004) for __main_after_scatterload[m
[32m+[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m[32mRemoving Unused input sections from the image.[m
[32m+[m
[32m+[m[32m    Removing startup_stm32f10x_hd.o(HEAP), (512 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_AFIODeInit), (20 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_DeInit), (200 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_ETH_MediaInterfaceConfig), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_EXTILineConfig), (64 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_EventOutputCmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_EventOutputConfig), (32 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_PinLockConfig), (18 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_PinRemapConfig), (144 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_ReadInputData), (8 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_ReadInputDataBit), (18 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_ReadOutputData), (8 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_ReadOutputDataBit), (18 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_StructInit), (16 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_Write), (4 bytes).[m
[32m+[m[32m    Removing stm32f10x_gpio.o(i.GPIO_WriteBit), (10 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_ADCCLKConfig), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_AHBPeriphClockCmd), (32 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_APB1PeriphClockCmd), (32 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_APB1PeriphResetCmd), (32 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_APB2PeriphResetCmd), (32 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_AdjustHSICalibrationValue), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_BackupResetCmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_ClearFlag), (20 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_ClearITPendingBit), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_ClockSecuritySystemCmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_DeInit), (76 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_GetClocksFreq), (212 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_GetFlagStatus), (60 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_GetITStatus), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_GetSYSCLKSource), (16 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_HCLKConfig), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_HSEConfig), (76 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_HSICmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_ITConfig), (32 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_LSEConfig), (52 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_LSICmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_MCOConfig), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_PCLK1Config), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_PCLK2Config), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_PLLCmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_PLLConfig), (28 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_RTCCLKCmd), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_RTCCLKConfig), (16 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_SYSCLKConfig), (24 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_USBCLKConfig), (12 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(i.RCC_WaitForHSEStartUp), (56 bytes).[m
[32m+[m[32m    Removing stm32f10x_rcc.o(.data), (20 bytes).[m
[32m+[m[32m    Removing core_cm3.o(.emb_text), (32 bytes).[m
[32m+[m[32m    Removing system_stm32f10x.o(i.SystemCoreClockUpdate), (164 bytes).[m
[32m+[m[32m    Removing system_stm32f10x.o(.data), (20 bytes).[m
[32m+[m
[32m+[m[32m51 unused section(s) (total 2380 bytes) removed from the image.[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m[32mImage Symbol Table[m
[32m+[m
[32m+[m[32m    Local Symbols[m
[32m+[m
[32m+[m[32m    Symbol Name                              Value     Ov Type        Size  Object(Section)[m
[32m+[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry11b.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry11a.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry10b.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry10a.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry9b.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry7a.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry9a.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry7b.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry8b.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry8a.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry5.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry2.o ABSOLUTE[m
[32m+[m[32m    ../clib/microlib/init/entry.s            0x00000000   Number         0  entry.o ABSOLUTE[m
[32m+[m[32m    APP\LED\led.c                            0x00000000   Number         0  led.o ABSOLUTE[m
[32m+[m[32m    Libraries\CMSIS\core_cm3.c               0x00000000   Number         0  core_cm3.o ABSOLUTE[m
[32m+[m[32m    Libraries\CMSIS\startup_stm32f10x_hd.s   0x00000000   Number         0  startup_stm32f10x_hd.o ABSOLUTE[m
[32m+[m[32m    Libraries\CMSIS\system_stm32f10x.c       0x00000000   Number         0  system_stm32f10x.o ABSOLUTE[m
[32m+[m[32m    Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c 0x00000000   Number         0  stm32f10x_gpio.o ABSOLUTE[m
[32m+[m[32m    Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c 0x00000000   Number         0  stm32f10x_rcc.o ABSOLUTE[m
[32m+[m[32m    Libraries\\CMSIS\\core_cm3.c             0x00000000   Number         0  core_cm3.o ABSOLUTE[m
[32m+[m[32m    User\main.c                              0x00000000   Number         0  main.o ABSOLUTE[m
[32m+[m[32m    User\stm32f10x_it.c                      0x00000000   Number         0  stm32f10x_it.o ABSOLUTE[m
[32m+[m[32m    dc.s                                     0x00000000   Number         0  dc.o ABSOLUTE[m
[32m+[m[32m    handlers.s                               0x00000000   Number         0  handlers.o ABSOLUTE[m
[32m+[m[32m    init.s                                   0x00000000   Number         0  init.o ABSOLUTE[m
[32m+[m[32m    RESET                                    0x08000000   Section      304  startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m    .ARM.Collect$$$$00000000                 0x08000130   Section        0  entry.o(.ARM.Collect$$$$00000000)[m
[32m+[m[32m    .ARM.Collect$$$$00000001                 0x08000130   Section        4  entry2.o(.ARM.Collect$$$$00000001)[m
[32m+[m[32m    .ARM.Collect$$$$00000004                 0x08000134   Section        4  entry5.o(.ARM.Collect$$$$00000004)[m
[32m+[m[32m    .ARM.Collect$$$$00000008                 0x08000138   Section        0  entry7b.o(.ARM.Collect$$$$00000008)[m
[32m+[m[32m    .ARM.Collect$$$$0000000A                 0x08000138   Section        0  entry8b.o(.ARM.Collect$$$$0000000A)[m
[32m+[m[32m    .ARM.Collect$$$$0000000B                 0x08000138   Section        8  entry9a.o(.ARM.Collect$$$$0000000B)[m
[32m+[m[32m    .ARM.Collect$$$$0000000D                 0x08000140   Section        0  entry10a.o(.ARM.Collect$$$$0000000D)[m
[32m+[m[32m    .ARM.Collect$$$$0000000F                 0x08000140   Section        0  entry11a.o(.ARM.Collect$$$$0000000F)[m
[32m+[m[32m    .ARM.Collect$$$$00002712                 0x08000140   Section        4  entry2.o(.ARM.Collect$$$$00002712)[m
[32m+[m[32m    __lit__00000000                          0x08000140   Data           4  entry2.o(.ARM.Collect$$$$00002712)[m
[32m+[m[32m    .text                                    0x08000144   Section       36  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    .text                                    0x08000168   Section       36  init.o(.text)[m
[32m+[m[32m    i.BusFault_Handler                       0x0800018c   Section        0  stm32f10x_it.o(i.BusFault_Handler)[m
[32m+[m[32m    i.DebugMon_Handler                       0x08000190   Section        0  stm32f10x_it.o(i.DebugMon_Handler)[m
[32m+[m[32m    i.DelayMs                                0x08000192   Section        0  main.o(i.DelayMs)[m
[32m+[m[32m    i.GPIO_Init                              0x080001a4   Section        0  stm32f10x_gpio.o(i.GPIO_Init)[m
[32m+[m[32m    i.GPIO_ResetBits                         0x080002ba   Section        0  stm32f10x_gpio.o(i.GPIO_ResetBits)[m
[32m+[m[32m    i.GPIO_SetBits                           0x080002be   Section        0  stm32f10x_gpio.o(i.GPIO_SetBits)[m
[32m+[m[32m    i.HardFault_Handler                      0x080002c2   Section        0  stm32f10x_it.o(i.HardFault_Handler)[m
[32m+[m[32m    i.LED_Init                               0x080002c8   Section        0  led.o(i.LED_Init)[m
[32m+[m[32m    i.MemManage_Handler                      0x080002fc   Section        0  stm32f10x_it.o(i.MemManage_Handler)[m
[32m+[m[32m    i.NMI_Handler                            0x08000300   Section        0  stm32f10x_it.o(i.NMI_Handler)[m
[32m+[m[32m    i.PendSV_Handler                         0x08000302   Section        0  stm32f10x_it.o(i.PendSV_Handler)[m
[32m+[m[32m    i.RCC_APB2PeriphClockCmd                 0x08000304   Section        0  stm32f10x_rcc.o(i.RCC_APB2PeriphClockCmd)[m
[32m+[m[32m    i.SVC_Handler                            0x08000324   Section        0  stm32f10x_it.o(i.SVC_Handler)[m
[32m+[m[32m    i.SetSysClock                            0x08000326   Section        0  system_stm32f10x.o(i.SetSysClock)[m
[32m+[m[32m    SetSysClock                              0x08000327   Thumb Code     8  system_stm32f10x.o(i.SetSysClock)[m
[32m+[m[32m    i.SetSysClockTo72                        0x08000330   Section        0  system_stm32f10x.o(i.SetSysClockTo72)[m
[32m+[m[32m    SetSysClockTo72                          0x08000331   Thumb Code   214  system_stm32f10x.o(i.SetSysClockTo72)[m
[32m+[m[32m    i.SysTick_Handler                        0x08000410   Section        0  stm32f10x_it.o(i.SysTick_Handler)[m
[32m+[m[32m    i.SystemInit                             0x08000414   Section        0  system_stm32f10x.o(i.SystemInit)[m
[32m+[m[32m    i.UsageFault_Handler                     0x08000474   Section        0  stm32f10x_it.o(i.UsageFault_Handler)[m
[32m+[m[32m    i.__scatterload_copy                     0x08000478   Section       14  handlers.o(i.__scatterload_copy)[m
[32m+[m[32m    i.__scatterload_null                     0x08000486   Section        2  handlers.o(i.__scatterload_null)[m
[32m+[m[32m    i.__scatterload_zeroinit                 0x08000488   Section       14  handlers.o(i.__scatterload_zeroinit)[m
[32m+[m[32m    i.main                                   0x08000498   Section        0  main.o(i.main)[m
[32m+[m[32m    STACK                                    0x20000000   Section     1024  startup_stm32f10x_hd.o(STACK)[m
[32m+[m
[32m+[m[32m    Global Symbols[m
[32m+[m
[32m+[m[32m    Symbol Name                              Value     Ov Type        Size  Object(Section)[m
[32m+[m
[32m+[m[32m    BuildAttributes$$THM_ISAv4$P$D$K$B$S$PE$A:L22UL41UL21$X:L11$S22US41US21$IEEE1$IW$USESV6$~STKCKD$USESV7$~SHL$OSPACE$EBA8$MICROLIB$REQ8$PRES8$EABIv2 0x00000000   Number         0  anon$$obj.o ABSOLUTE[m
[32m+[m[32m    __ARM_use_no_argv                        0x00000000   Number         0  main.o ABSOLUTE[m
[32m+[m[32m    __cpp_initialize__aeabi_                  - Undefined Weak Reference[m
[32m+[m[32m    __cxa_finalize                            - Undefined Weak Reference[m
[32m+[m[32m    __decompress                              - Undefined Weak Reference[m
[32m+[m[32m    _clock_init                               - Undefined Weak Reference[m
[32m+[m[32m    _microlib_exit                            - Undefined Weak Reference[m
[32m+[m[32m    __Vectors_Size                           0x00000130   Number         0  startup_stm32f10x_hd.o ABSOLUTE[m
[32m+[m[32m    __Vectors                                0x08000000   Data           4  startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m    __Vectors_End                            0x08000130   Data           0  startup_stm32f10x_hd.o(RESET)[m
[32m+[m[32m    __main                                   0x08000131   Thumb Code     0  entry.o(.ARM.Collect$$$$00000000)[m
[32m+[m[32m    _main_stk                                0x08000131   Thumb Code     0  entry2.o(.ARM.Collect$$$$00000001)[m
[32m+[m[32m    _main_scatterload                        0x08000135   Thumb Code     0  entry5.o(.ARM.Collect$$$$00000004)[m
[32m+[m[32m    __main_after_scatterload                 0x08000139   Thumb Code     0  entry5.o(.ARM.Collect$$$$00000004)[m
[32m+[m[32m    _main_clock                              0x08000139   Thumb Code     0  entry7b.o(.ARM.Collect$$$$00000008)[m
[32m+[m[32m    _main_cpp_init                           0x08000139   Thumb Code     0  entry8b.o(.ARM.Collect$$$$0000000A)[m
[32m+[m[32m    _main_init                               0x08000139   Thumb Code     0  entry9a.o(.ARM.Collect$$$$0000000B)[m
[32m+[m[32m    __rt_final_cpp                           0x08000141   Thumb Code     0  entry10a.o(.ARM.Collect$$$$0000000D)[m
[32m+[m[32m    __rt_final_exit                          0x08000141   Thumb Code     0  entry11a.o(.ARM.Collect$$$$0000000F)[m
[32m+[m[32m    Reset_Handler                            0x08000145   Thumb Code     8  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    ADC1_2_IRQHandler                        0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    ADC3_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    CAN1_RX1_IRQHandler                      0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    CAN1_SCE_IRQHandler                      0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel1_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel2_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel3_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel4_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel5_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel6_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA1_Channel7_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA2_Channel1_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA2_Channel2_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA2_Channel3_IRQHandler                 0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    DMA2_Channel4_5_IRQHandler               0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI0_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI15_10_IRQHandler                     0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI1_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI2_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI3_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI4_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    EXTI9_5_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    FLASH_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    FSMC_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    I2C1_ER_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    I2C1_EV_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    I2C2_ER_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    I2C2_EV_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    PVD_IRQHandler                           0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    RCC_IRQHandler                           0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    RTCAlarm_IRQHandler                      0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    RTC_IRQHandler                           0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    SDIO_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    SPI1_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    SPI2_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    SPI3_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TAMPER_IRQHandler                        0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM1_BRK_IRQHandler                      0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM1_CC_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM1_TRG_COM_IRQHandler                  0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM1_UP_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM2_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM3_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM4_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM5_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM6_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM7_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM8_BRK_IRQHandler                      0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM8_CC_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM8_TRG_COM_IRQHandler                  0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    TIM8_UP_IRQHandler                       0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    UART4_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    UART5_IRQHandler                         0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    USART1_IRQHandler                        0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    USART2_IRQHandler                        0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    USART3_IRQHandler                        0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    USBWakeUp_IRQHandler                     0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    USB_HP_CAN1_TX_IRQHandler                0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    USB_LP_CAN1_RX0_IRQHandler               0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    WWDG_IRQHandler                          0x0800015f   Thumb Code     0  startup_stm32f10x_hd.o(.text)[m
[32m+[m[32m    __scatterload                            0x08000169   Thumb Code    28  init.o(.text)[m
[32m+[m[32m    __scatterload_rt2                        0x08000169   Thumb Code     0  init.o(.text)[m
[32m+[m[32m    BusFault_Handler                         0x0800018d   Thumb Code     4  stm32f10x_it.o(i.BusFault_Handler)[m
[32m+[m[32m    DebugMon_Handler                         0x08000191   Thumb Code     2  stm32f10x_it.o(i.DebugMon_Handler)[m
[32m+[m[32m    DelayMs                                  0x08000193   Thumb Code    18  main.o(i.DelayMs)[m
[32m+[m[32m    GPIO_Init                                0x080001a5   Thumb Code   278  stm32f10x_gpio.o(i.GPIO_Init)[m
[32m+[m[32m    GPIO_ResetBits                           0x080002bb   Thumb Code     4  stm32f10x_gpio.o(i.GPIO_ResetBits)[m
[32m+[m[32m    GPIO_SetBits                             0x080002bf   Thumb Code     4  stm32f10x_gpio.o(i.GPIO_SetBits)[m
[32m+[m[32m    HardFault_Handler                        0x080002c3   Thumb Code     4  stm32f10x_it.o(i.HardFault_Handler)[m
[32m+[m[32m    LED_Init                                 0x080002c9   Thumb Code    46  led.o(i.LED_Init)[m
[32m+[m[32m    MemManage_Handler                        0x080002fd   Thumb Code     4  stm32f10x_it.o(i.MemManage_Handler)[m
[32m+[m[32m    NMI_Handler                              0x08000301   Thumb Code     2  stm32f10x_it.o(i.NMI_Handler)[m
[32m+[m[32m    PendSV_Handler                           0x08000303   Thumb Code     2  stm32f10x_it.o(i.PendSV_Handler)[m
[32m+[m[32m    RCC_APB2PeriphClockCmd                   0x08000305   Thumb Code    26  stm32f10x_rcc.o(i.RCC_APB2PeriphClockCmd)[m
[32m+[m[32m    SVC_Handler                              0x08000325   Thumb Code     2  stm32f10x_it.o(i.SVC_Handler)[m
[32m+[m[32m    SysTick_Handler                          0x08000411   Thumb Code     2  stm32f10x_it.o(i.SysTick_Handler)[m
[32m+[m[32m    SystemInit                               0x08000415   Thumb Code    78  system_stm32f10x.o(i.SystemInit)[m
[32m+[m[32m    UsageFault_Handler                       0x08000475   Thumb Code     4  stm32f10x_it.o(i.UsageFault_Handler)[m
[32m+[m[32m    __scatterload_copy                       0x08000479   Thumb Code    14  handlers.o(i.__scatterload_copy)[m
[32m+[m[32m    __scatterload_null                       0x08000487   Thumb Code     2  handlers.o(i.__scatterload_null)[m
[32m+[m[32m    __scatterload_zeroinit                   0x08000489   Thumb Code    14  handlers.o(i.__scatterload_zeroinit)[m
[32m+[m[32m    main                                     0x08000499   Thumb Code    40  main.o(i.main)[m
[32m+[m[32m    Region$$Table$$Base                      0x080004c4   Number         0  anon$$obj.o(Region$$Table)[m
[32m+[m[32m    Region$$Table$$Limit                     0x080004d4   Number         0  anon$$obj.o(Region$$Table)[m
[32m+[m[32m    __initial_sp                             0x20000400   Data           0  startup_stm32f10x_hd.o(STACK)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m[32mMemory Map of the image[m
[32m+[m
[32m+[m[32m  Image Entry point : 0x08000131[m
[32m+[m
[32m+[m[32m  Load Region LR_IROM1 (Base: 0x08000000, Size: 0x000004d4, Max: 0x00080000, ABSOLUTE)[m
[32m+[m
[32m+[m[32m    Execution Region ER_IROM1 (Exec base: 0x08000000, Load base: 0x08000000, Size: 0x000004d4, Max: 0x00080000, ABSOLUTE)[m
[32m+[m
[32m+[m[32m    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object[m
[32m+[m
[32m+[m[32m    0x08000000   0x08000000   0x00000130   Data   RO          175    RESET               startup_stm32f10x_hd.o[m
[32m+[m[32m    0x08000130   0x08000130   0x00000000   Code   RO          576  * .ARM.Collect$$$$00000000  mc_w.l(entry.o)[m
[32m+[m[32m    0x08000130   0x08000130   0x00000004   Code   RO          579    .ARM.Collect$$$$00000001  mc_w.l(entry2.o)[m
[32m+[m[32m    0x08000134   0x08000134   0x00000004   Code   RO          582    .ARM.Collect$$$$00000004  mc_w.l(entry5.o)[m
[32m+[m[32m    0x08000138   0x08000138   0x00000000   Code   RO          584    .ARM.Collect$$$$00000008  mc_w.l(entry7b.o)[m
[32m+[m[32m    0x08000138   0x08000138   0x00000000   Code   RO          586    .ARM.Collect$$$$0000000A  mc_w.l(entry8b.o)[m
[32m+[m[32m    0x08000138   0x08000138   0x00000008   Code   RO          587    .ARM.Collect$$$$0000000B  mc_w.l(entry9a.o)[m
[32m+[m[32m    0x08000140   0x08000140   0x00000000   Code   RO          589    .ARM.Collect$$$$0000000D  mc_w.l(entry10a.o)[m
[32m+[m[32m    0x08000140   0x08000140   0x00000000   Code   RO          591    .ARM.Collect$$$$0000000F  mc_w.l(entry11a.o)[m
[32m+[m[32m    0x08000140   0x08000140   0x00000004   Code   RO          580    .ARM.Collect$$$$00002712  mc_w.l(entry2.o)[m
[32m+[m[32m    0x08000144   0x08000144   0x00000024   Code   RO          176    .text               startup_stm32f10x_hd.o[m
[32m+[m[32m    0x08000168   0x08000168   0x00000024   Code   RO          593    .text               mc_w.l(init.o)[m
[32m+[m[32m    0x0800018c   0x0800018c   0x00000004   Code   RO          110    i.BusFault_Handler  stm32f10x_it.o[m
[32m+[m[32m    0x08000190   0x08000190   0x00000002   Code   RO          111    i.DebugMon_Handler  stm32f10x_it.o[m
[32m+[m[32m    0x08000192   0x08000192   0x00000012   Code   RO            1    i.DelayMs           main.o[m
[32m+[m[32m    0x080001a4   0x080001a4   0x00000116   Code   RO          187    i.GPIO_Init         stm32f10x_gpio.o[m
[32m+[m[32m    0x080002ba   0x080002ba   0x00000004   Code   RO          194    i.GPIO_ResetBits    stm32f10x_gpio.o[m
[32m+[m[32m    0x080002be   0x080002be   0x00000004   Code   RO          195    i.GPIO_SetBits      stm32f10x_gpio.o[m
[32m+[m[32m    0x080002c2   0x080002c2   0x00000004   Code   RO          112    i.HardFault_Handler  stm32f10x_it.o[m
[32m+[m[32m    0x080002c6   0x080002c6   0x00000002   PAD[m
[32m+[m[32m    0x080002c8   0x080002c8   0x00000034   Code   RO          561    i.LED_Init          led.o[m
[32m+[m[32m    0x080002fc   0x080002fc   0x00000004   Code   RO          113    i.MemManage_Handler  stm32f10x_it.o[m
[32m+[m[32m    0x08000300   0x08000300   0x00000002   Code   RO          114    i.NMI_Handler       stm32f10x_it.o[m
[32m+[m[32m    0x08000302   0x08000302   0x00000002   Code   RO          115    i.PendSV_Handler    stm32f10x_it.o[m
[32m+[m[32m    0x08000304   0x08000304   0x00000020   Code   RO          321    i.RCC_APB2PeriphClockCmd  stm32f10x_rcc.o[m
[32m+[m[32m    0x08000324   0x08000324   0x00000002   Code   RO          116    i.SVC_Handler       stm32f10x_it.o[m
[32m+[m[32m    0x08000326   0x08000326   0x00000008   Code   RO          527    i.SetSysClock       system_stm32f10x.o[m
[32m+[m[32m    0x0800032e   0x0800032e   0x00000002   PAD[m
[32m+[m[32m    0x08000330   0x08000330   0x000000e0   Code   RO          528    i.SetSysClockTo72   system_stm32f10x.o[m
[32m+[m[32m    0x08000410   0x08000410   0x00000002   Code   RO          117    i.SysTick_Handler   stm32f10x_it.o[m
[32m+[m[32m    0x08000412   0x08000412   0x00000002   PAD[m
[32m+[m[32m    0x08000414   0x08000414   0x00000060   Code   RO          530    i.SystemInit        system_stm32f10x.o[m
[32m+[m[32m    0x08000474   0x08000474   0x00000004   Code   RO          118    i.UsageFault_Handler  stm32f10x_it.o[m
[32m+[m[32m    0x08000478   0x08000478   0x0000000e   Code   RO          597    i.__scatterload_copy  mc_w.l(handlers.o)[m
[32m+[m[32m    0x08000486   0x08000486   0x00000002   Code   RO          598    i.__scatterload_null  mc_w.l(handlers.o)[m
[32m+[m[32m    0x08000488   0x08000488   0x0000000e   Code   RO          599    i.__scatterload_zeroinit  mc_w.l(handlers.o)[m
[32m+[m[32m    0x08000496   0x08000496   0x00000002   PAD[m
[32m+[m[32m    0x08000498   0x08000498   0x0000002c   Code   RO            2    i.main              main.o[m
[32m+[m[32m    0x080004c4   0x080004c4   0x00000010   Data   RO          595    Region$$Table       anon$$obj.o[m
[32m+[m
[32m+[m
[32m+[m[32m    Execution Region RW_IRAM1 (Exec base: 0x20000000, Load base: 0x080004d4, Size: 0x00000400, Max: 0x00010000, ABSOLUTE)[m
[32m+[m
[32m+[m[32m    Exec Addr    Load Addr    Size         Type   Attr      Idx    E Section Name        Object[m
[32m+[m
[32m+[m[32m    0x20000000        -       0x00000400   Zero   RW          173    STACK               startup_stm32f10x_hd.o[m
[32m+[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m[32mImage component sizes[m
[32m+[m
[32m+[m
[32m+[m[32m      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Object Name[m
[32m+[m
[32m+[m[32m        52          6          0          0          0        523   led.o[m
[32m+[m[32m        62          4          0          0          0     217157   main.o[m
[32m+[m[32m        36          8        304          0       1024        872   startup_stm32f10x_hd.o[m
[32m+[m[32m       286          0          0          0          0     206588   stm32f10x_gpio.o[m
[32m+[m[32m        26          0          0          0          0       4298   stm32f10x_it.o[m
[32m+[m[32m        32          6          0          0          0        665   stm32f10x_rcc.o[m
[32m+[m[32m       328         28          0          0          0       2153   system_stm32f10x.o[m
[32m+[m
[32m+[m[32m    ----------------------------------------------------------------------[m
[32m+[m[32m       828         52        320          0       1024     432256   Object Totals[m
[32m+[m[32m         0          0         16          0          0          0   (incl. Generated)[m
[32m+[m[32m         6          0          0          0          0          0   (incl. Padding)[m
[32m+[m
[32m+[m[32m    ----------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Library Member Name[m
[32m+[m
[32m+[m[32m         0          0          0          0          0          0   entry.o[m
[32m+[m[32m         0          0          0          0          0          0   entry10a.o[m
[32m+[m[32m         0          0          0          0          0          0   entry11a.o[m
[32m+[m[32m         8          4          0          0          0          0   entry2.o[m
[32m+[m[32m         4          0          0          0          0          0   entry5.o[m
[32m+[m[32m         0          0          0          0          0          0   entry7b.o[m
[32m+[m[32m         0          0          0          0          0          0   entry8b.o[m
[32m+[m[32m         8          4          0          0          0          0   entry9a.o[m
[32m+[m[32m        30          0          0          0          0          0   handlers.o[m
[32m+[m[32m        36          8          0          0          0         68   init.o[m
[32m+[m
[32m+[m[32m    ----------------------------------------------------------------------[m
[32m+[m[32m        88         16          0          0          0         68   Library Totals[m
[32m+[m[32m         2          0          0          0          0          0   (incl. Padding)[m
[32m+[m
[32m+[m[32m    ----------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m      Code (inc. data)   RO Data    RW Data    ZI Data      Debug   Library Name[m
[32m+[m
[32m+[m[32m        86         16          0          0          0         68   mc_w.l[m
[32m+[m
[32m+[m[32m    ----------------------------------------------------------------------[m
[32m+[m[32m        88         16          0          0          0         68   Library Totals[m
[32m+[m
[32m+[m[32m    ----------------------------------------------------------------------[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m
[32m+[m[32m      Code (inc. data)   RO Data    RW Data    ZI Data      Debug[m[41m   [m
[32m+[m
[32m+[m[32m       916         68        320          0       1024     431696   Grand Totals[m
[32m+[m[32m       916         68        320          0       1024     431696   ELF Image Totals[m
[32m+[m[32m       916         68        320          0          0          0   ROM Totals[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[32m+[m[32m    Total RO  Size (Code + RO Data)                 1236 (   1.21kB)[m
[32m+[m[32m    Total RW  Size (RW Data + ZI Data)              1024 (   1.00kB)[m
[32m+[m[32m    Total ROM Size (Code + RO Data + RW Data)       1236 (   1.21kB)[m
[32m+[m
[32m+[m[32m==============================================================================[m
[32m+[m
[1mdiff --git a/Obj/Template.sct b/Obj/Template.sct[m
[1mnew file mode 100644[m
[1mindex 0000000..d500431[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template.sct[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32m; *************************************************************[m
[32m+[m[32m; *** Scatter-Loading Description File generated by uVision ***[m
[32m+[m[32m; *************************************************************[m
[32m+[m
[32m+[m[32mLR_IROM1 0x08000000 0x00080000  {    ; load region size_region[m
[32m+[m[32m  ER_IROM1 0x08000000 0x00080000  {  ; load address = execution address[m
[32m+[m[32m   *.o (RESET, +First)[m
[32m+[m[32m   *(InRoot$$Sections)[m
[32m+[m[32m   .ANY (+RO)[m
[32m+[m[32m  }[m
[32m+[m[32m  RW_IRAM1 0x20000000 0x00010000  {  ; RW data[m
[32m+[m[32m   .ANY (+RW +ZI)[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[1mdiff --git a/Obj/Template_Target 1.dep b/Obj/Template_Target 1.dep[m
[1mnew file mode 100644[m
[1mindex 0000000..0b625d7[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template_Target 1.dep[m	
[36m@@ -0,0 +1,183 @@[m
[32m+[m[32mDependencies for Project 'Template', Target 'Target 1': (DO NOT MODIFY !)[m[41m[m
[32m+[m[32mF (.\User\main.c)(0x6354FE47)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\main.o --omf_browse .\obj\main.crf --depend .\obj\main.d)[m[41m[m
[32m+[m[32mI (User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\system_stm32f10x.h)(0x4D783CAA)[m[41m[m
[32m+[m[32mI (User\stm32f10x_conf.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\APP\LED\led.h)(0x5FAE92A2)[m[41m[m
[32m+[m[32mF (.\User\stm32f10x_it.c)(0x4D99A59E)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\stm32f10x_it.o --omf_browse .\obj\stm32f10x_it.crf --depend .\obj\stm32f10x_it.d)[m[41m[m
[32m+[m[32mI (User\stm32f10x_it.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\system_stm32f10x.h)(0x4D783CAA)[m[41m[m
[32m+[m[32mI (User\stm32f10x_conf.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mF (.\Libraries\CMSIS\startup_stm32f10x_hd.s)(0x4D783CDE)(--cpu Cortex-M3 -g --apcs=interwork --pd "__MICROLIB SETA 1"-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include--pd "__UVISION_VERSION SETA 525" --pd "STM32F10X_HD SETA 1"--list .\obj\startup_stm32f10x_hd.lst --xref -o .\obj\startup_stm32f10x_hd.o --depend .\obj\startup_stm32f10x_hd.d)[m[41m[m
[32m+[m[32mF (.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c)(0x4D79EEC6)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\stm32f10x_gpio.o --omf_browse .\obj\stm32f10x_gpio.crf --depend .\obj\stm32f10x_gpio.d)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\system_stm32f10x.h)(0x4D783CAA)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x_conf.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mF (.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c)(0x4D783BB4)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\stm32f10x_rcc.o --omf_browse .\obj\stm32f10x_rcc.crf --depend .\obj\stm32f10x_rcc.d)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\system_stm32f10x.h)(0x4D783CAA)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x_conf.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mF (.\Libraries\CMSIS\core_cm3.c)(0x4C0C587E)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\core_cm3.o --omf_browse .\obj\core_cm3.crf --depend .\obj\core_cm3.d)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mF (.\Libraries\CMSIS\system_stm32f10x.c)(0x4D783CB0)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\system_stm32f10x.o --omf_browse .\obj\system_stm32f10x.crf --depend .\obj\system_stm32f10x.d)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\system_stm32f10x.h)(0x4D783CAA)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x_conf.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mF (.\APP\LED\led.c)(0x5FAE92A2)(--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED-I.\RTE\_Target_1-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD-o .\obj\led.o --omf_browse .\obj\led.crf --depend .\obj\led.d)[m[41m[m
[32m+[m[32mI (APP\LED\led.h)(0x5FAE92A2)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x.h)(0x4D783CB4)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\core_cm3.h)(0x4D523B58)[m[41m[m
[32m+[m[32mI (D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\include\stdint.h)(0x569DEA3A)[m[41m[m
[32m+[m[32mI (.\Libraries\CMSIS\system_stm32f10x.h)(0x4D783CAA)[m[41m[m
[32m+[m[32mI (.\User\stm32f10x_conf.h)(0x4D99A59E)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h)(0x4D783BB4)[m[41m[m
[32m+[m[32mI (.\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h)(0x4D783BB4)[m[41m[m
[1mdiff --git a/Obj/core_cm3.__i b/Obj/core_cm3.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..3558c0c[m
[1m--- /dev/null[m
[1m+++ b/Obj/core_cm3.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\core_cm3.o --omf_browse .\obj\core_cm3.crf --depend .\obj\core_cm3.d "Libraries\CMSIS\core_cm3.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/core_cm3.crf b/Obj/core_cm3.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..fcff092[m
Binary files /dev/null and b/Obj/core_cm3.crf differ
[1mdiff --git a/Obj/core_cm3.d b/Obj/core_cm3.d[m
[1mnew file mode 100644[m
[1mindex 0000000..8ff9c79[m
[1m--- /dev/null[m
[1m+++ b/Obj/core_cm3.d[m
[36m@@ -0,0 +1,2 @@[m
[32m+[m[32m.\obj\core_cm3.o: Libraries\CMSIS\core_cm3.c[m
[32m+[m[32m.\obj\core_cm3.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[1mdiff --git a/Obj/core_cm3.o b/Obj/core_cm3.o[m
[1mnew file mode 100644[m
[1mindex 0000000..e5ad926[m
Binary files /dev/null and b/Obj/core_cm3.o differ
[1mdiff --git a/Obj/led.__i b/Obj/led.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..57bf827[m
[1m--- /dev/null[m
[1m+++ b/Obj/led.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\led.o --omf_browse .\obj\led.crf --depend .\obj\led.d "APP\LED\led.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/led.crf b/Obj/led.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..fdab3fa[m
Binary files /dev/null and b/Obj/led.crf differ
[1mdiff --git a/Obj/led.d b/Obj/led.d[m
[1mnew file mode 100644[m
[1mindex 0000000..841b603[m
[1m--- /dev/null[m
[1m+++ b/Obj/led.d[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m.\obj\led.o: APP\LED\led.c[m
[32m+[m[32m.\obj\led.o: APP\LED\led.h[m
[32m+[m[32m.\obj\led.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\CMSIS\core_cm3.h[m
[32m+[m[32m.\obj\led.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\CMSIS\system_stm32f10x.h[m
[32m+[m[32m.\obj\led.o: .\User\stm32f10x_conf.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h[m
[32m+[m[32m.\obj\led.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h[m
[32m+[m[32m.\obj\led.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h[m
[1mdiff --git a/Obj/led.o b/Obj/led.o[m
[1mnew file mode 100644[m
[1mindex 0000000..4860316[m
Binary files /dev/null and b/Obj/led.o differ
[1mdiff --git a/Obj/main.__i b/Obj/main.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..71b5be9[m
[1m--- /dev/null[m
[1m+++ b/Obj/main.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\main.o --omf_browse .\obj\main.crf --depend .\obj\main.d "User\main.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/main.crf b/Obj/main.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..86dc975[m
Binary files /dev/null and b/Obj/main.crf differ
[1mdiff --git a/Obj/main.d b/Obj/main.d[m
[1mnew file mode 100644[m
[1mindex 0000000..f98cbbf[m
[1m--- /dev/null[m
[1m+++ b/Obj/main.d[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m.\obj\main.o: User\main.c[m
[32m+[m[32m.\obj\main.o: User\stm32f10x.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\CMSIS\core_cm3.h[m
[32m+[m[32m.\obj\main.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\CMSIS\system_stm32f10x.h[m
[32m+[m[32m.\obj\main.o: User\stm32f10x_conf.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h[m
[32m+[m[32m.\obj\main.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h[m
[32m+[m[32m.\obj\main.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h[m
[32m+[m[32m.\obj\main.o: .\APP\LED\led.h[m
[1mdiff --git a/Obj/main.o b/Obj/main.o[m
[1mnew file mode 100644[m
[1mindex 0000000..c950164[m
Binary files /dev/null and b/Obj/main.o differ
[1mdiff --git a/Obj/startup_stm32f10x_hd._ia b/Obj/startup_stm32f10x_hd._ia[m
[1mnew file mode 100644[m
[1mindex 0000000..e8d59d9[m
[1m--- /dev/null[m
[1m+++ b/Obj/startup_stm32f10x_hd._ia[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--cpu Cortex-M3 -g --apcs=interwork --pd "__MICROLIB SETA 1"[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m--pd "__UVISION_VERSION SETA 525" --pd "STM32F10X_HD SETA 1"[m
[32m+[m[32m--list .\obj\startup_stm32f10x_hd.lst --xref -o .\obj\startup_stm32f10x_hd.o --depend .\obj\startup_stm32f10x_hd.d "Libraries\CMSIS\startup_stm32f10x_hd.s"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/startup_stm32f10x_hd.d b/Obj/startup_stm32f10x_hd.d[m
[1mnew file mode 100644[m
[1mindex 0000000..fe037fd[m
[1m--- /dev/null[m
[1m+++ b/Obj/startup_stm32f10x_hd.d[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32m.\obj\startup_stm32f10x_hd.o: Libraries\CMSIS\startup_stm32f10x_hd.s[m
[1mdiff --git a/Obj/startup_stm32f10x_hd.lst b/Obj/startup_stm32f10x_hd.lst[m
[1mnew file mode 100644[m
[1mindex 0000000..bcb3c7c[m
[1m--- /dev/null[m
[1m+++ b/Obj/startup_stm32f10x_hd.lst[m
[36m@@ -0,0 +1,1432 @@[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m    1 00000000         ;******************** (C) COPYRIGHT 2011 STMicroelectron[m
[32m+[m[32m                       ics ********************[m
[32m+[m[32m    2 00000000         ;* File Name          : startup_stm32f10x_hd.s[m
[32m+[m[32m    3 00000000         ;* Author             : MCD Application Team[m
[32m+[m[32m    4 00000000         ;* Version            : V3.5.0[m
[32m+[m[32m    5 00000000         ;* Date               : 11-March-2011[m
[32m+[m[32m    6 00000000         ;* Description        : STM32F10x High Density Devices v[m
[32m+[m[32m                       ector table for MDK-ARM[m[41m [m
[32m+[m[32m    7 00000000         ;*                      toolchain.[m[41m [m
[32m+[m[32m    8 00000000         ;*                      This module performs:[m
[32m+[m[32m    9 00000000         ;*                      - Set the initial SP[m
[32m+[m[32m   10 00000000         ;*                      - Set the initial PC == Reset_Ha[m
[32m+[m[32m                       ndler[m
[32m+[m[32m   11 00000000         ;*                      - Set the vector table entries w[m
[32m+[m[32m                       ith the exceptions ISR address[m
[32m+[m[32m   12 00000000         ;*                      - Configure the clock system and[m
[32m+[m[32m                        also configure the external[m[41m [m
[32m+[m[32m   13 00000000         ;*                        SRAM mounted on STM3210E-EVAL[m[41m [m
[32m+[m[32m                       board to be used as data[m[41m [m
[32m+[m[32m   14 00000000         ;*                        memory (optional, to be enable[m
[32m+[m[32m                       d by user)[m
[32m+[m[32m   15 00000000         ;*                      - Branches to __main in the C li[m
[32m+[m[32m                       brary (which eventually[m
[32m+[m[32m   16 00000000         ;*                        calls main()).[m
[32m+[m[32m   17 00000000         ;*                      After Reset the CortexM3 process[m
[32m+[m[32m                       or is in Thread mode,[m
[32m+[m[32m   18 00000000         ;*                      priority is Privileged, and the[m[41m [m
[32m+[m[32m                       Stack is set to Main.[m
[32m+[m[32m   19 00000000         ;* <<< Use Configuration Wizard in Context Menu >>>[m[41m   [m
[32m+[m[32m   20 00000000         ;*******************************************************[m
[32m+[m[32m                       ************************[m
[32m+[m[32m   21 00000000         ; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS A[m
[32m+[m[32m                       T PROVIDING CUSTOMERS[m
[32m+[m[32m   22 00000000         ; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN OR[m
[32m+[m[32m                       DER FOR THEM TO SAVE TIME.[m
[32m+[m[32m   23 00000000         ; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIAB[m
[32m+[m[32m                       LE FOR ANY DIRECT,[m
[32m+[m[32m   24 00000000         ; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY[m[41m [m
[32m+[m[32m                       CLAIMS ARISING FROM THE[m
[32m+[m[32m   25 00000000         ; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOM[m
[32m+[m[32m                       ERS OF THE CODING[m
[32m+[m[32m   26 00000000         ; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR[m[41m [m
[32m+[m[32m                       PRODUCTS.[m
[32m+[m[32m   27 00000000         ;*******************************************************[m
[32m+[m[32m                       ************************[m
[32m+[m[32m   28 00000000[m[41m         [m
[32m+[m[32m   29 00000000         ; Amount of memory (in bytes) allocated for Stack[m
[32m+[m[32m   30 00000000         ; Tailor this value to your application needs[m
[32m+[m[32m   31 00000000         ; <h> Stack Configuration[m
[32m+[m[32m   32 00000000         ;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>[m
[32m+[m[32m   33 00000000         ; </h>[m
[32m+[m[32m   34 00000000[m[41m         [m
[32m+[m[32m   35 00000000 00000400[m[41m [m
[32m+[m[32m                       Stack_Size[m
[32m+[m[32m                               EQU              0x00000400[m
[32m+[m[32m   36 00000000[m[41m         [m
[32m+[m[32m   37 00000000                 AREA             STACK, NOINIT, READWRITE, ALIGN[m
[32m+[m[32m=3[m
[32m+[m[32m   38 00000000         Stack_Mem[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 2[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m                               SPACE            Stack_Size[m
[32m+[m[32m   39 00000400         __initial_sp[m
[32m+[m[32m   40 00000400[m[41m         [m
[32m+[m[32m   41 00000400         ; <h> Heap Configuration[m
[32m+[m[32m   42 00000400         ;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>[m
[32m+[m[32m   43 00000400         ; </h>[m
[32m+[m[32m   44 00000400[m[41m         [m
[32m+[m[32m   45 00000400 00000200[m[41m [m
[32m+[m[32m                       Heap_Size[m
[32m+[m[32m                               EQU              0x00000200[m
[32m+[m[32m   46 00000400[m[41m         [m
[32m+[m[32m   47 00000400                 AREA             HEAP, NOINIT, READWRITE, ALIGN=[m
[32m+[m[32m3[m
[32m+[m[32m   48 00000000         __heap_base[m
[32m+[m[32m   49 00000000         Heap_Mem[m
[32m+[m[32m                               SPACE            Heap_Size[m
[32m+[m[32m   50 00000200         __heap_limit[m
[32m+[m[32m   51 00000200[m[41m         [m
[32m+[m[32m   52 00000200                 PRESERVE8[m
[32m+[m[32m   53 00000200                 THUMB[m
[32m+[m[32m   54 00000200[m[41m         [m
[32m+[m[32m   55 00000200[m[41m         [m
[32m+[m[32m   56 00000200         ; Vector Table Mapped to Address 0 at Reset[m
[32m+[m[32m   57 00000200                 AREA             RESET, DATA, READONLY[m
[32m+[m[32m   58 00000000                 EXPORT           __Vectors[m
[32m+[m[32m   59 00000000                 EXPORT           __Vectors_End[m
[32m+[m[32m   60 00000000                 EXPORT           __Vectors_Size[m
[32m+[m[32m   61 00000000[m[41m         [m
[32m+[m[32m   62 00000000 00000000[m[41m [m
[32m+[m[32m                       __Vectors[m
[32m+[m[32m                               DCD              __initial_sp ; Top of Stack[m
[32m+[m[32m   63 00000004 00000000        DCD              Reset_Handler ; Reset Handler[m
[32m+[m[32m   64 00000008 00000000        DCD              NMI_Handler ; NMI Handler[m
[32m+[m[32m   65 0000000C 00000000        DCD              HardFault_Handler ; Hard Fault[m[41m [m
[32m+[m[32m                                                            Handler[m
[32m+[m[32m   66 00000010 00000000        DCD              MemManage_Handler[m[41m [m
[32m+[m[32m                                                            ; MPU Fault Handler[m
[32m+[m[41m                                                            [m
[32m+[m[32m   67 00000014 00000000        DCD              BusFault_Handler[m[41m [m
[32m+[m[32m                                                            ; Bus Fault Handler[m
[32m+[m[41m                                                            [m
[32m+[m[32m   68 00000018 00000000        DCD              UsageFault_Handler ; Usage Faul[m
[32m+[m[32m                                                            t Handler[m
[32m+[m[32m   69 0000001C 00000000        DCD              0           ; Reserved[m
[32m+[m[32m   70 00000020 00000000        DCD              0           ; Reserved[m
[32m+[m[32m   71 00000024 00000000        DCD              0           ; Reserved[m
[32m+[m[32m   72 00000028 00000000        DCD              0           ; Reserved[m
[32m+[m[32m   73 0000002C 00000000        DCD              SVC_Handler ; SVCall Handler[m
[32m+[m[32m   74 00000030 00000000        DCD              DebugMon_Handler ; Debug Monito[m
[32m+[m[32m                                                            r Handler[m
[32m+[m[32m   75 00000034 00000000        DCD              0           ; Reserved[m
[32m+[m[32m   76 00000038 00000000        DCD              PendSV_Handler ; PendSV Handler[m
[32m+[m[41m                                                            [m
[32m+[m[32m   77 0000003C 00000000        DCD              SysTick_Handler[m[41m [m
[32m+[m[32m                                                            ; SysTick Handler[m
[32m+[m[32m   78 00000040[m[41m         [m
[32m+[m[32m   79 00000040         ; External Interrupts[m
[32m+[m[32m   80 00000040 00000000        DCD              WWDG_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; Window Watchdog[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 3[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m   81 00000044 00000000        DCD              PVD_IRQHandler ; PVD through EX[m
[32m+[m[32m                                                            TI Line detect[m
[32m+[m[32m   82 00000048 00000000        DCD              TAMPER_IRQHandler ; Tamper[m
[32m+[m[32m   83 0000004C 00000000        DCD              RTC_IRQHandler ; RTC[m
[32m+[m[32m   84 00000050 00000000        DCD              FLASH_IRQHandler ; Flash[m
[32m+[m[32m   85 00000054 00000000        DCD              RCC_IRQHandler ; RCC[m
[32m+[m[32m   86 00000058 00000000        DCD              EXTI0_IRQHandler ; EXTI Line 0[m
[32m+[m[32m   87 0000005C 00000000        DCD              EXTI1_IRQHandler ; EXTI Line 1[m
[32m+[m[32m   88 00000060 00000000        DCD              EXTI2_IRQHandler ; EXTI Line 2[m
[32m+[m[32m   89 00000064 00000000        DCD              EXTI3_IRQHandler ; EXTI Line 3[m
[32m+[m[32m   90 00000068 00000000        DCD              EXTI4_IRQHandler ; EXTI Line 4[m
[32m+[m[32m   91 0000006C 00000000        DCD              DMA1_Channel1_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 1[m
[32m+[m[32m   92 00000070 00000000        DCD              DMA1_Channel2_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 2[m
[32m+[m[32m   93 00000074 00000000        DCD              DMA1_Channel3_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 3[m
[32m+[m[32m   94 00000078 00000000        DCD              DMA1_Channel4_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 4[m
[32m+[m[32m   95 0000007C 00000000        DCD              DMA1_Channel5_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 5[m
[32m+[m[32m   96 00000080 00000000        DCD              DMA1_Channel6_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 6[m
[32m+[m[32m   97 00000084 00000000        DCD              DMA1_Channel7_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA1 Channel 7[m
[32m+[m[32m   98 00000088 00000000        DCD              ADC1_2_IRQHandler ; ADC1 & ADC2[m
[32m+[m[41m                                                            [m
[32m+[m[32m   99 0000008C 00000000        DCD              USB_HP_CAN1_TX_IRQHandler ; USB[m
[32m+[m[32m                                                             High Priority or C[m
[32m+[m[32m                                                            AN1 TX[m
[32m+[m[32m  100 00000090 00000000        DCD              USB_LP_CAN1_RX0_IRQHandler ; US[m
[32m+[m[32m                                                            B Low  Priority or[m[41m [m
[32m+[m[32m                                                            CAN1 RX0[m
[32m+[m[32m  101 00000094 00000000        DCD              CAN1_RX1_IRQHandler ; CAN1 RX1[m
[32m+[m[32m  102 00000098 00000000        DCD              CAN1_SCE_IRQHandler ; CAN1 SCE[m
[32m+[m[32m  103 0000009C 00000000        DCD              EXTI9_5_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; EXTI Line 9..5[m
[32m+[m[32m  104 000000A0 00000000        DCD              TIM1_BRK_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; TIM1 Break[m
[32m+[m[32m  105 000000A4 00000000        DCD              TIM1_UP_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; TIM1 Update[m
[32m+[m[32m  106 000000A8 00000000        DCD              TIM1_TRG_COM_IRQHandler ; TIM1[m[41m [m
[32m+[m[32m                                                            Trigger and Commuta[m
[32m+[m[32m                                                            tion[m
[32m+[m[32m  107 000000AC 00000000        DCD              TIM1_CC_IRQHandler ; TIM1 Captu[m
[32m+[m[32m                                                            re Compare[m
[32m+[m[32m  108 000000B0 00000000        DCD              TIM2_IRQHandler ; TIM2[m
[32m+[m[32m  109 000000B4 00000000        DCD              TIM3_IRQHandler ; TIM3[m
[32m+[m[32m  110 000000B8 00000000        DCD              TIM4_IRQHandler ; TIM4[m
[32m+[m[32m  111 000000BC 00000000        DCD              I2C1_EV_IRQHandler ; I2C1 Event[m
[32m+[m[41m                                                            [m
[32m+[m[32m  112 000000C0 00000000        DCD              I2C1_ER_IRQHandler ; I2C1 Error[m
[32m+[m[41m                                                            [m
[32m+[m[32m  113 000000C4 00000000        DCD              I2C2_EV_IRQHandler ; I2C2 Event[m
[32m+[m[41m                                                            [m
[32m+[m[32m  114 000000C8 00000000        DCD              I2C2_ER_IRQHandler ; I2C2 Error[m
[32m+[m[41m                                                            [m
[32m+[m[32m  115 000000CC 00000000        DCD              SPI1_IRQHandler ; SPI1[m
[32m+[m[32m  116 000000D0 00000000        DCD              SPI2_IRQHandler ; SPI2[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 4[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m  117 000000D4 00000000        DCD              USART1_IRQHandler ; USART1[m
[32m+[m[32m  118 000000D8 00000000        DCD              USART2_IRQHandler ; USART2[m
[32m+[m[32m  119 000000DC 00000000        DCD              USART3_IRQHandler ; USART3[m
[32m+[m[32m  120 000000E0 00000000        DCD              EXTI15_10_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; EXTI Line 15..10[m
[32m+[m[32m  121 000000E4 00000000        DCD              RTCAlarm_IRQHandler ; RTC Alarm[m
[32m+[m[32m                                                             through EXTI Line[m
[32m+[m[32m  122 000000E8 00000000        DCD              USBWakeUp_IRQHandler ; USB Wake[m
[32m+[m[32m                                                            up from suspend[m
[32m+[m[32m  123 000000EC 00000000        DCD              TIM8_BRK_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; TIM8 Break[m
[32m+[m[32m  124 000000F0 00000000        DCD              TIM8_UP_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; TIM8 Update[m
[32m+[m[32m  125 000000F4 00000000        DCD              TIM8_TRG_COM_IRQHandler ; TIM8[m[41m [m
[32m+[m[32m                                                            Trigger and Commuta[m
[32m+[m[32m                                                            tion[m
[32m+[m[32m  126 000000F8 00000000        DCD              TIM8_CC_IRQHandler ; TIM8 Captu[m
[32m+[m[32m                                                            re Compare[m
[32m+[m[32m  127 000000FC 00000000        DCD              ADC3_IRQHandler ; ADC3[m
[32m+[m[32m  128 00000100 00000000        DCD              FSMC_IRQHandler ; FSMC[m
[32m+[m[32m  129 00000104 00000000        DCD              SDIO_IRQHandler ; SDIO[m
[32m+[m[32m  130 00000108 00000000        DCD              TIM5_IRQHandler ; TIM5[m
[32m+[m[32m  131 0000010C 00000000        DCD              SPI3_IRQHandler ; SPI3[m
[32m+[m[32m  132 00000110 00000000        DCD              UART4_IRQHandler ; UART4[m
[32m+[m[32m  133 00000114 00000000        DCD              UART5_IRQHandler ; UART5[m
[32m+[m[32m  134 00000118 00000000        DCD              TIM6_IRQHandler ; TIM6[m
[32m+[m[32m  135 0000011C 00000000        DCD              TIM7_IRQHandler ; TIM7[m
[32m+[m[32m  136 00000120 00000000        DCD              DMA2_Channel1_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA2 Channel1[m
[32m+[m[32m  137 00000124 00000000        DCD              DMA2_Channel2_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA2 Channel2[m
[32m+[m[32m  138 00000128 00000000        DCD              DMA2_Channel3_IRQHandler[m[41m [m
[32m+[m[32m                                                            ; DMA2 Channel3[m
[32m+[m[32m  139 0000012C 00000000        DCD              DMA2_Channel4_5_IRQHandler ; DM[m
[32m+[m[32m                                                            A2 Channel4 & Chann[m
[32m+[m[32m                                                            el5[m
[32m+[m[32m  140 00000130         __Vectors_End[m
[32m+[m[32m  141 00000130[m[41m         [m
[32m+[m[32m  142 00000130 00000130[m[41m [m
[32m+[m[32m                       __Vectors_Size[m
[32m+[m[32m                               EQU              __Vectors_End - __Vectors[m
[32m+[m[32m  143 00000130[m[41m         [m
[32m+[m[32m  144 00000130                 AREA             |.text|, CODE, READONLY[m
[32m+[m[32m  145 00000000[m[41m         [m
[32m+[m[32m  146 00000000         ; Reset handler[m
[32m+[m[32m  147 00000000         Reset_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  148 00000000                 EXPORT           Reset_Handler             [WEAK[m
[32m+[m[32m][m
[32m+[m[32m  149 00000000                 IMPORT           __main[m
[32m+[m[32m  150 00000000                 IMPORT           SystemInit[m
[32m+[m[32m  151 00000000 4806            LDR              R0, =SystemInit[m
[32m+[m[32m  152 00000002 4780            BLX              R0[m
[32m+[m[32m  153 00000004 4806            LDR              R0, =__main[m
[32m+[m[32m  154 00000006 4700            BX               R0[m
[32m+[m[32m  155 00000008                 ENDP[m
[32m+[m[32m  156 00000008[m[41m         [m
[32m+[m[32m  157 00000008         ; Dummy Exception Handlers (infinite loops which can be[m[41m [m
[32m+[m[32m                       modified)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 5[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m  158 00000008[m[41m         [m
[32m+[m[32m  159 00000008         NMI_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  160 00000008                 EXPORT           NMI_Handler                [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  161 00000008 E7FE            B                .[m
[32m+[m[32m  162 0000000A                 ENDP[m
[32m+[m[32m  164 0000000A         HardFault_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  165 0000000A                 EXPORT           HardFault_Handler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  166 0000000A E7FE            B                .[m
[32m+[m[32m  167 0000000C                 ENDP[m
[32m+[m[32m  169 0000000C         MemManage_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  170 0000000C                 EXPORT           MemManage_Handler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  171 0000000C E7FE            B                .[m
[32m+[m[32m  172 0000000E                 ENDP[m
[32m+[m[32m  174 0000000E         BusFault_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  175 0000000E                 EXPORT           BusFault_Handler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  176 0000000E E7FE            B                .[m
[32m+[m[32m  177 00000010                 ENDP[m
[32m+[m[32m  179 00000010         UsageFault_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  180 00000010                 EXPORT           UsageFault_Handler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  181 00000010 E7FE            B                .[m
[32m+[m[32m  182 00000012                 ENDP[m
[32m+[m[32m  183 00000012         SVC_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  184 00000012                 EXPORT           SVC_Handler                [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  185 00000012 E7FE            B                .[m
[32m+[m[32m  186 00000014                 ENDP[m
[32m+[m[32m  188 00000014         DebugMon_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  189 00000014                 EXPORT           DebugMon_Handler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  190 00000014 E7FE            B                .[m
[32m+[m[32m  191 00000016                 ENDP[m
[32m+[m[32m  192 00000016         PendSV_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  193 00000016                 EXPORT           PendSV_Handler             [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  194 00000016 E7FE            B                .[m
[32m+[m[32m  195 00000018                 ENDP[m
[32m+[m[32m  196 00000018         SysTick_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  197 00000018                 EXPORT           SysTick_Handler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  198 00000018 E7FE            B                .[m
[32m+[m[32m  199 0000001A                 ENDP[m
[32m+[m[32m  200 0000001A[m[41m         [m
[32m+[m[32m  201 0000001A         Default_Handler[m
[32m+[m[32m                               PROC[m
[32m+[m[32m  202 0000001A[m[41m         [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 6[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m  203 0000001A                 EXPORT           WWDG_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  204 0000001A                 EXPORT           PVD_IRQHandler             [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  205 0000001A                 EXPORT           TAMPER_IRQHandler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  206 0000001A                 EXPORT           RTC_IRQHandler             [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  207 0000001A                 EXPORT           FLASH_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  208 0000001A                 EXPORT           RCC_IRQHandler             [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  209 0000001A                 EXPORT           EXTI0_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  210 0000001A                 EXPORT           EXTI1_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  211 0000001A                 EXPORT           EXTI2_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  212 0000001A                 EXPORT           EXTI3_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  213 0000001A                 EXPORT           EXTI4_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  214 0000001A                 EXPORT           DMA1_Channel1_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  215 0000001A                 EXPORT           DMA1_Channel2_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  216 0000001A                 EXPORT           DMA1_Channel3_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  217 0000001A                 EXPORT           DMA1_Channel4_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  218 0000001A                 EXPORT           DMA1_Channel5_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  219 0000001A                 EXPORT           DMA1_Channel6_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  220 0000001A                 EXPORT           DMA1_Channel7_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  221 0000001A                 EXPORT           ADC1_2_IRQHandler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  222 0000001A                 EXPORT           USB_HP_CAN1_TX_IRQHandler  [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  223 0000001A                 EXPORT           USB_LP_CAN1_RX0_IRQHandler [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  224 0000001A                 EXPORT           CAN1_RX1_IRQHandler        [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  225 0000001A                 EXPORT           CAN1_SCE_IRQHandler        [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  226 0000001A                 EXPORT           EXTI9_5_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  227 0000001A                 EXPORT           TIM1_BRK_IRQHandler        [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  228 0000001A                 EXPORT           TIM1_UP_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  229 0000001A                 EXPORT           TIM1_TRG_COM_IRQHandler    [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  230 0000001A                 EXPORT           TIM1_CC_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  231 0000001A                 EXPORT           TIM2_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  232 0000001A                 EXPORT           TIM3_IRQHandler            [WEA[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 7[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32mK][m
[32m+[m[32m  233 0000001A                 EXPORT           TIM4_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  234 0000001A                 EXPORT           I2C1_EV_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  235 0000001A                 EXPORT           I2C1_ER_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  236 0000001A                 EXPORT           I2C2_EV_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  237 0000001A                 EXPORT           I2C2_ER_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  238 0000001A                 EXPORT           SPI1_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  239 0000001A                 EXPORT           SPI2_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  240 0000001A                 EXPORT           USART1_IRQHandler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  241 0000001A                 EXPORT           USART2_IRQHandler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  242 0000001A                 EXPORT           USART3_IRQHandler          [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  243 0000001A                 EXPORT           EXTI15_10_IRQHandler       [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  244 0000001A                 EXPORT           RTCAlarm_IRQHandler        [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  245 0000001A                 EXPORT           USBWakeUp_IRQHandler       [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  246 0000001A                 EXPORT           TIM8_BRK_IRQHandler        [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  247 0000001A                 EXPORT           TIM8_UP_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  248 0000001A                 EXPORT           TIM8_TRG_COM_IRQHandler    [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  249 0000001A                 EXPORT           TIM8_CC_IRQHandler         [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  250 0000001A                 EXPORT           ADC3_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  251 0000001A                 EXPORT           FSMC_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  252 0000001A                 EXPORT           SDIO_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  253 0000001A                 EXPORT           TIM5_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  254 0000001A                 EXPORT           SPI3_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  255 0000001A                 EXPORT           UART4_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  256 0000001A                 EXPORT           UART5_IRQHandler           [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  257 0000001A                 EXPORT           TIM6_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  258 0000001A                 EXPORT           TIM7_IRQHandler            [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  259 0000001A                 EXPORT           DMA2_Channel1_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  260 0000001A                 EXPORT           DMA2_Channel2_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  261 0000001A                 EXPORT           DMA2_Channel3_IRQHandler   [WEA[m
[32m+[m[32mK][m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 8[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m  262 0000001A                 EXPORT           DMA2_Channel4_5_IRQHandler [WEA[m
[32m+[m[32mK][m
[32m+[m[32m  263 0000001A[m[41m         [m
[32m+[m[32m  264 0000001A         WWDG_IRQHandler[m
[32m+[m[32m  265 0000001A         PVD_IRQHandler[m
[32m+[m[32m  266 0000001A         TAMPER_IRQHandler[m
[32m+[m[32m  267 0000001A         RTC_IRQHandler[m
[32m+[m[32m  268 0000001A         FLASH_IRQHandler[m
[32m+[m[32m  269 0000001A         RCC_IRQHandler[m
[32m+[m[32m  270 0000001A         EXTI0_IRQHandler[m
[32m+[m[32m  271 0000001A         EXTI1_IRQHandler[m
[32m+[m[32m  272 0000001A         EXTI2_IRQHandler[m
[32m+[m[32m  273 0000001A         EXTI3_IRQHandler[m
[32m+[m[32m  274 0000001A         EXTI4_IRQHandler[m
[32m+[m[32m  275 0000001A         DMA1_Channel1_IRQHandler[m
[32m+[m[32m  276 0000001A         DMA1_Channel2_IRQHandler[m
[32m+[m[32m  277 0000001A         DMA1_Channel3_IRQHandler[m
[32m+[m[32m  278 0000001A         DMA1_Channel4_IRQHandler[m
[32m+[m[32m  279 0000001A         DMA1_Channel5_IRQHandler[m
[32m+[m[32m  280 0000001A         DMA1_Channel6_IRQHandler[m
[32m+[m[32m  281 0000001A         DMA1_Channel7_IRQHandler[m
[32m+[m[32m  282 0000001A         ADC1_2_IRQHandler[m
[32m+[m[32m  283 0000001A         USB_HP_CAN1_TX_IRQHandler[m
[32m+[m[32m  284 0000001A         USB_LP_CAN1_RX0_IRQHandler[m
[32m+[m[32m  285 0000001A         CAN1_RX1_IRQHandler[m
[32m+[m[32m  286 0000001A         CAN1_SCE_IRQHandler[m
[32m+[m[32m  287 0000001A         EXTI9_5_IRQHandler[m
[32m+[m[32m  288 0000001A         TIM1_BRK_IRQHandler[m
[32m+[m[32m  289 0000001A         TIM1_UP_IRQHandler[m
[32m+[m[32m  290 0000001A         TIM1_TRG_COM_IRQHandler[m
[32m+[m[32m  291 0000001A         TIM1_CC_IRQHandler[m
[32m+[m[32m  292 0000001A         TIM2_IRQHandler[m
[32m+[m[32m  293 0000001A         TIM3_IRQHandler[m
[32m+[m[32m  294 0000001A         TIM4_IRQHandler[m
[32m+[m[32m  295 0000001A         I2C1_EV_IRQHandler[m
[32m+[m[32m  296 0000001A         I2C1_ER_IRQHandler[m
[32m+[m[32m  297 0000001A         I2C2_EV_IRQHandler[m
[32m+[m[32m  298 0000001A         I2C2_ER_IRQHandler[m
[32m+[m[32m  299 0000001A         SPI1_IRQHandler[m
[32m+[m[32m  300 0000001A         SPI2_IRQHandler[m
[32m+[m[32m  301 0000001A         USART1_IRQHandler[m
[32m+[m[32m  302 0000001A         USART2_IRQHandler[m
[32m+[m[32m  303 0000001A         USART3_IRQHandler[m
[32m+[m[32m  304 0000001A         EXTI15_10_IRQHandler[m
[32m+[m[32m  305 0000001A         RTCAlarm_IRQHandler[m
[32m+[m[32m  306 0000001A         USBWakeUp_IRQHandler[m
[32m+[m[32m  307 0000001A         TIM8_BRK_IRQHandler[m
[32m+[m[32m  308 0000001A         TIM8_UP_IRQHandler[m
[32m+[m[32m  309 0000001A         TIM8_TRG_COM_IRQHandler[m
[32m+[m[32m  310 0000001A         TIM8_CC_IRQHandler[m
[32m+[m[32m  311 0000001A         ADC3_IRQHandler[m
[32m+[m[32m  312 0000001A         FSMC_IRQHandler[m
[32m+[m[32m  313 0000001A         SDIO_IRQHandler[m
[32m+[m[32m  314 0000001A         TIM5_IRQHandler[m
[32m+[m[32m  315 0000001A         SPI3_IRQHandler[m
[32m+[m[32m  316 0000001A         UART4_IRQHandler[m
[32m+[m[32m  317 0000001A         UART5_IRQHandler[m
[32m+[m[32m  318 0000001A         TIM6_IRQHandler[m
[32m+[m[32m  319 0000001A         TIM7_IRQHandler[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 9[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m  320 0000001A         DMA2_Channel1_IRQHandler[m
[32m+[m[32m  321 0000001A         DMA2_Channel2_IRQHandler[m
[32m+[m[32m  322 0000001A         DMA2_Channel3_IRQHandler[m
[32m+[m[32m  323 0000001A         DMA2_Channel4_5_IRQHandler[m
[32m+[m[32m  324 0000001A E7FE            B                .[m
[32m+[m[32m  325 0000001C[m[41m         [m
[32m+[m[32m  326 0000001C                 ENDP[m
[32m+[m[32m  327 0000001C[m[41m         [m
[32m+[m[32m  328 0000001C                 ALIGN[m
[32m+[m[32m  329 0000001C[m[41m         [m
[32m+[m[32m  330 0000001C         ;*******************************************************[m
[32m+[m[32m                       ************************[m
[32m+[m[32m  331 0000001C         ; User Stack and Heap initialization[m
[32m+[m[32m  332 0000001C         ;*******************************************************[m
[32m+[m[32m                       ************************[m
[32m+[m[32m  333 0000001C                 IF               :DEF:__MICROLIB[m
[32m+[m[32m  334 0000001C[m[41m         [m
[32m+[m[32m  335 0000001C                 EXPORT           __initial_sp[m
[32m+[m[32m  336 0000001C                 EXPORT           __heap_base[m
[32m+[m[32m  337 0000001C                 EXPORT           __heap_limit[m
[32m+[m[32m  338 0000001C[m[41m         [m
[32m+[m[32m  339 0000001C                 ELSE[m
[32m+[m[32m  354                          ENDIF[m
[32m+[m[32m  355 0000001C[m[41m         [m
[32m+[m[32m  356 0000001C                 END[m
[32m+[m[32m              00000000[m[41m [m
[32m+[m[32m              00000000[m[41m [m
[32m+[m[32mCommand Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M3 --apcs=interw[m
[32m+[m[32mork --depend=.\obj\startup_stm32f10x_hd.d -o.\obj\startup_stm32f10x_hd.o -I.\RT[m
[32m+[m[32mE\_Target_1 -ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0[m
[32m+[m[32m.5\Device\Include -ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include --prede[m
[32m+[m[32mfine="__MICROLIB SETA 1" --predefine="__UVISION_VERSION SETA 525" --predefine="[m
[32m+[m[32mSTM32F10X_HD SETA 1" --list=.\obj\startup_stm32f10x_hd.lst Libraries\CMSIS\star[m
[32m+[m[32mtup_stm32f10x_hd.s[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32mSTACK 00000000[m
[32m+[m
[32m+[m[32mSymbol: STACK[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 37 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: STACK unused[m
[32m+[m[32mStack_Mem 00000000[m
[32m+[m
[32m+[m[32mSymbol: Stack_Mem[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 38 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: Stack_Mem unused[m
[32m+[m[32m__initial_sp 00000400[m
[32m+[m
[32m+[m[32mSymbol: __initial_sp[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 39 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 62 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 335 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32m3 symbols[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32mHEAP 00000000[m
[32m+[m
[32m+[m[32mSymbol: HEAP[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 47 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: HEAP unused[m
[32m+[m[32mHeap_Mem 00000000[m
[32m+[m
[32m+[m[32mSymbol: Heap_Mem[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 49 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: Heap_Mem unused[m
[32m+[m[32m__heap_base 00000000[m
[32m+[m
[32m+[m[32mSymbol: __heap_base[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 48 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 336 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: __heap_base used once[m
[32m+[m[32m__heap_limit 00000200[m
[32m+[m
[32m+[m[32mSymbol: __heap_limit[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 50 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 337 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: __heap_limit used once[m
[32m+[m[32m4 symbols[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32mRESET 00000000[m
[32m+[m
[32m+[m[32mSymbol: RESET[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 57 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: RESET unused[m
[32m+[m[32m__Vectors 00000000[m
[32m+[m
[32m+[m[32mSymbol: __Vectors[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 62 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 58 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 142 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32m__Vectors_End 00000130[m
[32m+[m
[32m+[m[32mSymbol: __Vectors_End[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 140 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 59 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 142 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32m3 symbols[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32m.text 00000000[m
[32m+[m
[32m+[m[32mSymbol: .text[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 144 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: .text unused[m
[32m+[m[32mADC1_2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: ADC1_2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 282 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 98 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 221 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mADC3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: ADC3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 311 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 127 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 250 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mBusFault_Handler 0000000E[m
[32m+[m
[32m+[m[32mSymbol: BusFault_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 174 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 67 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 175 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mCAN1_RX1_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: CAN1_RX1_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 285 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 101 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 224 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mCAN1_SCE_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: CAN1_SCE_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 286 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 102 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 225 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel1_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel1_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 275 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 2 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32m      At line 91 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 214 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 276 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 92 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 215 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 277 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 93 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 216 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel4_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel4_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 278 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 94 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 217 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel5_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel5_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 279 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 95 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 218 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel6_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel6_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 280 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 96 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 219 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA1_Channel7_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA1_Channel7_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 281 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 97 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 220 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA2_Channel1_IRQHandler 0000001A[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 3 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32mSymbol: DMA2_Channel1_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 320 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 136 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 259 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA2_Channel2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA2_Channel2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 321 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 137 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 260 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA2_Channel3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA2_Channel3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 322 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 138 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 261 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDMA2_Channel4_5_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: DMA2_Channel4_5_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 323 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 139 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 262 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDebugMon_Handler 00000014[m
[32m+[m
[32m+[m[32mSymbol: DebugMon_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 188 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 74 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 189 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mDefault_Handler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: Default_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 201 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      None[m
[32m+[m[32mComment: Default_Handler unused[m
[32m+[m[32mEXTI0_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI0_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 270 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 86 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 209 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 4 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m
[32m+[m[32mEXTI15_10_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI15_10_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 304 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 120 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 243 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mEXTI1_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI1_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 271 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 87 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 210 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mEXTI2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 272 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 88 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 211 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mEXTI3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 273 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 89 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 212 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mEXTI4_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI4_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 274 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 90 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 213 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mEXTI9_5_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: EXTI9_5_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 287 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 103 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 226 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mFLASH_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: FLASH_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 5 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32m      At line 268 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 84 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 207 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mFSMC_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: FSMC_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 312 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 128 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 251 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mHardFault_Handler 0000000A[m
[32m+[m
[32m+[m[32mSymbol: HardFault_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 164 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 65 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 165 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mI2C1_ER_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: I2C1_ER_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 296 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 112 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 235 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mI2C1_EV_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: I2C1_EV_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 295 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 111 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 234 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mI2C2_ER_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: I2C2_ER_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 298 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 114 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 237 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mI2C2_EV_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: I2C2_EV_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 297 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 113 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 236 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 6 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32mMemManage_Handler 0000000C[m
[32m+[m
[32m+[m[32mSymbol: MemManage_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 169 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 66 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 170 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mNMI_Handler 00000008[m
[32m+[m
[32m+[m[32mSymbol: NMI_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 159 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 64 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 160 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mPVD_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: PVD_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 265 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 81 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 204 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mPendSV_Handler 00000016[m
[32m+[m
[32m+[m[32mSymbol: PendSV_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 192 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 76 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 193 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mRCC_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: RCC_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 269 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 85 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 208 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mRTCAlarm_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: RTCAlarm_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 305 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 121 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 244 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mRTC_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: RTC_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 267 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 7 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 83 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 206 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mReset_Handler 00000000[m
[32m+[m
[32m+[m[32mSymbol: Reset_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 147 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 63 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 148 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mSDIO_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: SDIO_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 313 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 129 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 252 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mSPI1_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: SPI1_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 299 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 115 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 238 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mSPI2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: SPI2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 300 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 116 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 239 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mSPI3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: SPI3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 315 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 131 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 254 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mSVC_Handler 00000012[m
[32m+[m
[32m+[m[32mSymbol: SVC_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 183 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 73 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 184 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mSysTick_Handler 00000018[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 8 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m
[32m+[m[32mSymbol: SysTick_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 196 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 77 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 197 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTAMPER_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TAMPER_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 266 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 82 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 205 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM1_BRK_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM1_BRK_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 288 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 104 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 227 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM1_CC_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM1_CC_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 291 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 107 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 230 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM1_TRG_COM_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM1_TRG_COM_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 290 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 106 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 229 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM1_UP_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM1_UP_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 289 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 105 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 228 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 292 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 9 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32m      At line 108 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 231 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 293 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 109 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 232 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM4_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM4_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 294 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 110 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 233 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM5_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM5_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 314 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 130 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 253 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM6_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM6_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 318 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 134 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 257 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM7_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM7_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 319 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 135 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 258 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM8_BRK_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM8_BRK_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 307 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 123 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 246 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM8_CC_IRQHandler 0000001A[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 10 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32mSymbol: TIM8_CC_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 310 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 126 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 249 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM8_TRG_COM_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM8_TRG_COM_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 309 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 125 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 248 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mTIM8_UP_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: TIM8_UP_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 308 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 124 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 247 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUART4_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: UART4_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 316 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 132 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 255 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUART5_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: UART5_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 317 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 133 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 256 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUSART1_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: USART1_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 301 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 117 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 240 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUSART2_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: USART2_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 302 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 118 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 11 Alphabetic symbol ordering[m
[32m+[m[32mRelocatable symbols[m
[32m+[m
[32m+[m[32m      At line 241 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUSART3_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: USART3_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 303 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 119 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 242 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUSBWakeUp_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: USBWakeUp_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 306 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 122 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 245 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUSB_HP_CAN1_TX_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: USB_HP_CAN1_TX_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 283 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 99 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 222 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUSB_LP_CAN1_RX0_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: USB_LP_CAN1_RX0_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 284 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 100 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 223 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mUsageFault_Handler 00000010[m
[32m+[m
[32m+[m[32mSymbol: UsageFault_Handler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 179 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 68 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 180 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32mWWDG_IRQHandler 0000001A[m
[32m+[m
[32m+[m[32mSymbol: WWDG_IRQHandler[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 264 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 80 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m      At line 203 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m
[32m+[m[32m72 symbols[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1 Alphabetic symbol ordering[m
[32m+[m[32mAbsolute symbols[m
[32m+[m
[32m+[m[32mHeap_Size 00000200[m
[32m+[m
[32m+[m[32mSymbol: Heap_Size[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 45 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 49 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: Heap_Size used once[m
[32m+[m[32mStack_Size 00000400[m
[32m+[m
[32m+[m[32mSymbol: Stack_Size[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 35 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 38 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: Stack_Size used once[m
[32m+[m[32m__Vectors_Size 00000130[m
[32m+[m
[32m+[m[32mSymbol: __Vectors_Size[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 142 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 60 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: __Vectors_Size used once[m
[32m+[m[32m3 symbols[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32mARM Macro Assembler    Page 1 Alphabetic symbol ordering[m
[32m+[m[32mExternal symbols[m
[32m+[m
[32m+[m[32mSystemInit 00000000[m
[32m+[m
[32m+[m[32mSymbol: SystemInit[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 150 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 151 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: SystemInit used once[m
[32m+[m[32m__main 00000000[m
[32m+[m
[32m+[m[32mSymbol: __main[m
[32m+[m[32m   Definitions[m
[32m+[m[32m      At line 149 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32m   Uses[m
[32m+[m[32m      At line 153 in file Libraries\CMSIS\startup_stm32f10x_hd.s[m
[32m+[m[32mComment: __main used once[m
[32m+[m[32m2 symbols[m
[32m+[m[32m422 symbols in table[m
[1mdiff --git a/Obj/startup_stm32f10x_hd.o b/Obj/startup_stm32f10x_hd.o[m
[1mnew file mode 100644[m
[1mindex 0000000..73abe99[m
Binary files /dev/null and b/Obj/startup_stm32f10x_hd.o differ
[1mdiff --git a/Obj/stm32f10x_gpio.__i b/Obj/stm32f10x_gpio.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..1de9e3f[m
[1m--- /dev/null[m
[1m+++ b/Obj/stm32f10x_gpio.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\stm32f10x_gpio.o --omf_browse .\obj\stm32f10x_gpio.crf --depend .\obj\stm32f10x_gpio.d "Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/stm32f10x_gpio.crf b/Obj/stm32f10x_gpio.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..e5f904a[m
Binary files /dev/null and b/Obj/stm32f10x_gpio.crf differ
[1mdiff --git a/Obj/stm32f10x_gpio.d b/Obj/stm32f10x_gpio.d[m
[1mnew file mode 100644[m
[1mindex 0000000..d94a1ea[m
[1m--- /dev/null[m
[1m+++ b/Obj/stm32f10x_gpio.d[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\CMSIS\core_cm3.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\CMSIS\system_stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\User\stm32f10x_conf.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h[m
[32m+[m[32m.\obj\stm32f10x_gpio.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h[m
[1mdiff --git a/Obj/stm32f10x_gpio.o b/Obj/stm32f10x_gpio.o[m
[1mnew file mode 100644[m
[1mindex 0000000..d7f54d3[m
Binary files /dev/null and b/Obj/stm32f10x_gpio.o differ
[1mdiff --git a/Obj/stm32f10x_it.__i b/Obj/stm32f10x_it.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..6ea05d8[m
[1m--- /dev/null[m
[1m+++ b/Obj/stm32f10x_it.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\stm32f10x_it.o --omf_browse .\obj\stm32f10x_it.crf --depend .\obj\stm32f10x_it.d "User\stm32f10x_it.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/stm32f10x_it.crf b/Obj/stm32f10x_it.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..09fb745[m
Binary files /dev/null and b/Obj/stm32f10x_it.crf differ
[1mdiff --git a/Obj/stm32f10x_it.d b/Obj/stm32f10x_it.d[m
[1mnew file mode 100644[m
[1mindex 0000000..85e43cc[m
[1m--- /dev/null[m
[1m+++ b/Obj/stm32f10x_it.d[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m.\obj\stm32f10x_it.o: User\stm32f10x_it.c[m
[32m+[m[32m.\obj\stm32f10x_it.o: User\stm32f10x_it.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: User\stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\CMSIS\core_cm3.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\CMSIS\system_stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: User\stm32f10x_conf.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h[m
[32m+[m[32m.\obj\stm32f10x_it.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h[m
[1mdiff --git a/Obj/stm32f10x_it.o b/Obj/stm32f10x_it.o[m
[1mnew file mode 100644[m
[1mindex 0000000..d84a2bc[m
Binary files /dev/null and b/Obj/stm32f10x_it.o differ
[1mdiff --git a/Obj/stm32f10x_rcc.__i b/Obj/stm32f10x_rcc.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..94b62e5[m
[1m--- /dev/null[m
[1m+++ b/Obj/stm32f10x_rcc.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\stm32f10x_rcc.o --omf_browse .\obj\stm32f10x_rcc.crf --depend .\obj\stm32f10x_rcc.d "Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/stm32f10x_rcc.crf b/Obj/stm32f10x_rcc.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..16434bb[m
Binary files /dev/null and b/Obj/stm32f10x_rcc.crf differ
[1mdiff --git a/Obj/stm32f10x_rcc.d b/Obj/stm32f10x_rcc.d[m
[1mnew file mode 100644[m
[1mindex 0000000..fdcba5d[m
[1m--- /dev/null[m
[1m+++ b/Obj/stm32f10x_rcc.d[m
[36m@@ -0,0 +1,31 @@[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\CMSIS\core_cm3.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\CMSIS\system_stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\User\stm32f10x_conf.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h[m
[32m+[m[32m.\obj\stm32f10x_rcc.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h[m
[1mdiff --git a/Obj/stm32f10x_rcc.o b/Obj/stm32f10x_rcc.o[m
[1mnew file mode 100644[m
[1mindex 0000000..de33fd8[m
Binary files /dev/null and b/Obj/stm32f10x_rcc.o differ
[1mdiff --git a/Obj/system_stm32f10x.__i b/Obj/system_stm32f10x.__i[m
[1mnew file mode 100644[m
[1mindex 0000000..225c6c4[m
[1m--- /dev/null[m
[1m+++ b/Obj/system_stm32f10x.__i[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m--c99 -c --cpu Cortex-M3 -D__MICROLIB -g -O0 --apcs=interwork --split_sections -I .\User -I .\Libraries\CMSIS -I .\Libraries\STM32F10x_StdPeriph_Driver\inc -I .\APP\LED[m
[32m+[m[32m-I.\RTE\_Target_1[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include[m
[32m+[m[32m-ID:\LeStoreDownload\keil5\anzhuang\ARM\CMSIS\Include[m
[32m+[m[32m-D__UVISION_VERSION="525" -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD[m
[32m+[m[32m-o .\obj\system_stm32f10x.o --omf_browse .\obj\system_stm32f10x.crf --depend .\obj\system_stm32f10x.d "Libraries\CMSIS\system_stm32f10x.c"[m
\ No newline at end of file[m
[1mdiff --git a/Obj/system_stm32f10x.crf b/Obj/system_stm32f10x.crf[m
[1mnew file mode 100644[m
[1mindex 0000000..243d56b[m
Binary files /dev/null and b/Obj/system_stm32f10x.crf differ
[1mdiff --git a/Obj/system_stm32f10x.d b/Obj/system_stm32f10x.d[m
[1mnew file mode 100644[m
[1mindex 0000000..42248a7[m
[1m--- /dev/null[m
[1m+++ b/Obj/system_stm32f10x.d[m
[36m@@ -0,0 +1,30 @@[m
[32m+[m[32m.\obj\system_stm32f10x.o: Libraries\CMSIS\system_stm32f10x.c[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\CMSIS\core_cm3.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\..\include\stdint.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\CMSIS\system_stm32f10x.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\User\stm32f10x_conf.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_adc.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\User\stm32f10x.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_bkp.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_can.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_cec.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_crc.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dac.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dbgmcu.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_dma.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_exti.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_flash.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_fsmc.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_gpio.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_i2c.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_iwdg.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_pwr.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rcc.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_rtc.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_sdio.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_tim.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_usart.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\stm32f10x_wwdg.h[m
[32m+[m[32m.\obj\system_stm32f10x.o: .\Libraries\STM32F10x_StdPeriph_Driver\inc\misc.h[m
[1mdiff --git a/Obj/system_stm32f10x.o b/Obj/system_stm32f10x.o[m
[1mnew file mode 100644[m
[1mindex 0000000..b7e2048[m
Binary files /dev/null and b/Obj/system_stm32f10x.o differ
[1mdiff --git a/Target 1.BAT b/Target 1.BAT[m
[1mnew file mode 100644[m
[1mindex 0000000..ea2e322[m
[1m--- /dev/null[m
[1m+++ b/Target 1.BAT[m	
[36m@@ -0,0 +1,18 @@[m
[32m+[m[32mSET PATH=D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin;H:\Program Files (x86)\VMware\VMware Workstation\bin\;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;C:\Windows\System32\OpenSSH\;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files\NVIDIA Corporation\NVIDIA NvDLISR;F:\Program Files\MATLAB\R2021b\runtime\win64;F:\Program Files\MATLAB\R2021b\bin;C:\Program Files\Microsoft SQL Server\150\Tools\Binn\;C:\Program Files\dotnet\;C:\Program Files\Microsoft SQL Server\Client SDK\ODBC\170\Tools\Binn\;I:\Œƒº˛\…œ—ß∆⁄º‰µƒ◊ ¡œ\–¬Ω®Œƒº˛º–\Shared\LabVIEW CLI;C:\WINDOWS\;ystem32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Users\¿Ó—‡æ¸\AppData\Local\Microsoft\WindowsApps;C:\Users\¿Ó—‡æ¸\.dotnet\tools;[m
[32m+[m[32mSET ARMCC5_ASMOPT=--diag_suppress=9931[m
[32m+[m[32mSET ARMCC5_CCOPT=--diag_suppress=9931[m
[32m+[m[32mSET ARMCC5_LINKOPT=--diag_suppress=9931[m
[32m+[m[32mSET CPU_TYPE=STM32F103ZE[m
[32m+[m[32mSET CPU_VENDOR=STMicroelectronics[m
[32m+[m[32mSET UV2_TARGET=Target 1[m
[32m+[m[32mSET CPU_CLOCK=0x00B71B00[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\main.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\stm32f10x_it.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmAsm" --Via ".\obj\startup_stm32f10x_hd._ia"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\stm32f10x_gpio.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\stm32f10x_rcc.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\core_cm3.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\system_stm32f10x.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmCC" --Via ".\obj\led.__i"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\ArmLink" --Via ".\Obj\Template.lnp"[m
[32m+[m[32m"D:\LeStoreDownload\keil5\anzhuang\ARM\ARMCC\Bin\fromelf.exe" ".\Obj\Template.axf" --i32combined --output ".\Obj\Template.hex"[m
[1mdiff --git "a/Template.uvguix.\346\235\216\347\207\225\345\206\233" "b/Template.uvguix.\346\235\216\347\207\225\345\206\233"[m
[1mnew file mode 100644[m
[1mindex 0000000..5a521b5[m
[1m--- /dev/null[m
[1m+++ "b/Template.uvguix.\346\235\216\347\207\225\345\206\233"[m
[36m@@ -0,0 +1,1868 @@[m
[32m+[m[32m<?xml version="1.0" encoding="UTF-8" standalone="no" ?>[m
[32m+[m[32m<ProjectGui xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_guix.xsd">[m
[32m+[m
[32m+[m[32m  <SchemaVersion>-6.1</SchemaVersion>[m
[32m+[m
[32m+[m[32m  <Header>### uVision Project, (C) Keil Software</Header>[m
[32m+[m
[32m+[m[32m  <ViewPool/>[m
[32m+[m
[32m+[m[32m  <SECTreeCtrl>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>38003</WinId>[m
[32m+[m[32m      <ViewName>Registers</ViewName>[m
[32m+[m[32m      <TableColWidths>115 67</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>346</WinId>[m
[32m+[m[32m      <ViewName>Code Coverage</ViewName>[m
[32m+[m[32m      <TableColWidths>770 160</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>204</WinId>[m
[32m+[m[32m      <ViewName>Performance Analyzer</ViewName>[m
[32m+[m[32m      <TableColWidths>930</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m  </SECTreeCtrl>[m
[32m+[m
[32m+[m[32m  <TreeListPane>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1506</WinId>[m
[32m+[m[32m      <ViewName>Symbols</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>64 64 64</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1936</WinId>[m
[32m+[m[32m      <ViewName>Watch 1</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>200 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1937</WinId>[m
[32m+[m[32m      <ViewName>Watch 2</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>200 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1935</WinId>[m
[32m+[m[32m      <ViewName>Call Stack + Locals</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>200 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>2506</WinId>[m
[32m+[m[32m      <ViewName>Trace Data</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>75 135 130 95 70 230 200 150</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>466</WinId>[m
[32m+[m[32m      <ViewName>Source Browser</ViewName>[m
[32m+[m[32m      <UserString>500</UserString>[m
[32m+[m[32m      <TableColWidths>300</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m  </TreeListPane>[m
[32m+[m
[32m+[m[32m  <CompViewPool/>[m
[32m+[m
[32m+[m[32m  <WindowSettings>[m
[32m+[m[32m    <LogicAnalizer>[m
[32m+[m[32m      <ShowLACursor>1</ShowLACursor>[m
[32m+[m[32m      <ShowSignalInfo>1</ShowSignalInfo>[m
[32m+[m[32m      <ShowCycles>0</ShowCycles>[m
[32m+[m[32m      <LeftSideBarSize>0</LeftSideBarSize>[m
[32m+[m[32m      <TimeBaseIndex>-1</TimeBaseIndex>[m
[32m+[m[32m    </LogicAnalizer>[m
[32m+[m[32m  </WindowSettings>[m
[32m+[m
[32m+[m[32m  <WinLayoutEx>[m
[32m+[m[32m    <sActiveDebugView></sActiveDebugView>[m
[32m+[m[32m    <WindowPosition>[m
[32m+[m[32m      <length>44</length>[m
[32m+[m[32m      <flags>2</flags>[m
[32m+[m[32m      <showCmd>3</showCmd>[m
[32m+[m[32m      <MinPosition>[m
[32m+[m[32m        <xPos>-1</xPos>[m
[32m+[m[32m        <yPos>-1</yPos>[m
[32m+[m[32m      </MinPosition>[m
[32m+[m[32m      <MaxPosition>[m
[32m+[m[32m        <xPos>-1</xPos>[m
[32m+[m[32m        <yPos>-1</yPos>[m
[32m+[m[32m      </MaxPosition>[m
[32m+[m[32m      <NormalPosition>[m
[32m+[m[32m        <Top>14</Top>[m
[32m+[m[32m        <Left>435</Left>[m
[32m+[m[32m        <Right>1419</Right>[m
[32m+[m[32m        <Bottom>758</Bottom>[m
[32m+[m[32m      </NormalPosition>[m
[32m+[m[32m    </WindowPosition>[m
[32m+[m[32m    <MDIClientArea>[m
[32m+[m[32m      <RegID>0</RegID>[m
[32m+[m[32m      <MDITabState>[m
[32m+[m[32m        <Len>301</Len>[m
[32m+[m[32m        <Data>01000000040000000100000001000000010000000100000000000000020000000000000001000000010000000000000028000000280000000100000001000000000000000100000069493A5CCEC4BCFE5CC9CFD1A7C6DABCE4B5C4D7CAC1CF5CD1A7CFB0B1E0B3CC5C53544D3332B1E0B3CCC1B7CFB05C53544D333266313033B1E0B3CC5C53544D333266313033B1E0B3CC5C342ECAB9D3C3BFE2BAAFCAFDB5E3C1C14C45445C557365725C6D61696E2E6300000000066D61696E2E6300000000C5D4F200FFFFFFFF0100000010000000C5D4F200FFDC7800BECEA100F0A0A100BCA8E1009CC1B600F7B88600D9ADC200A5C2D700B3A6BE00EAD6A300F6FA7D00B5E99D005FC3CF00C1838300CACAD500010000000000000002000000C40000006600000000060000AC020000</Data>[m
[32m+[m[32m      </MDITabState>[m
[32m+[m[32m    </MDIClientArea>[m
[32m+[m[32m    <ViewEx>[m
[32m+[m[32m      <ViewType>0</ViewType>[m
[32m+[m[32m      <ViewName>Build</ViewName>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>-1</RegID>[m
[32m+[m[32m        <PaneID>-1</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C40000004F00000070040000BC000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C40000006600000070040000D3000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1005</RegID>[m
[32m+[m[32m        <PaneID>1005</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000066000000BD0000007C020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>109</RegID>[m
[32m+[m[32m        <PaneID>109</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000066000000BD0000007C020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1465</RegID>[m
[32m+[m[32m        <PaneID>1465</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1466</RegID>[m
[32m+[m[32m        <PaneID>1466</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1467</RegID>[m
[32m+[m[32m        <PaneID>1467</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1468</RegID>[m
[32m+[m[32m        <PaneID>1468</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1506</RegID>[m
[32m+[m[32m        <PaneID>1506</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>16384</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1913</RegID>[m
[32m+[m[32m        <PaneID>1913</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1935</RegID>[m
[32m+[m[32m        <PaneID>1935</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>32768</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1936</RegID>[m
[32m+[m[32m        <PaneID>1936</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1937</RegID>[m
[32m+[m[32m        <PaneID>1937</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1939</RegID>[m
[32m+[m[32m        <PaneID>1939</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1940</RegID>[m
[32m+[m[32m        <PaneID>1940</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1941</RegID>[m
[32m+[m[32m        <PaneID>1941</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1942</RegID>[m
[32m+[m[32m        <PaneID>1942</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>195</RegID>[m
[32m+[m[32m        <PaneID>195</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000066000000BD0000007C020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>196</RegID>[m
[32m+[m[32m        <PaneID>196</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000066000000BD0000007C020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>197</RegID>[m
[32m+[m[32m        <PaneID>197</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>32768</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000AD0200000006000006030000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>198</RegID>[m
[32m+[m[32m        <PaneID>198</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>32768</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000900100007004000011020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>199</RegID>[m
[32m+[m[32m        <PaneID>199</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000B0020000FD050000ED020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>203</RegID>[m
[32m+[m[32m        <PaneID>203</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>204</RegID>[m
[32m+[m[32m        <PaneID>204</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>221</RegID>[m
[32m+[m[32m        <PaneID>221</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000000000000000000000000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>2506</RegID>[m
[32m+[m[32m        <PaneID>2506</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>2507</RegID>[m
[32m+[m[32m        <PaneID>2507</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>343</RegID>[m
[32m+[m[32m        <PaneID>343</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>346</RegID>[m
[32m+[m[32m        <PaneID>346</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35141</RegID>[m
[32m+[m[32m        <PaneID>35141</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35824</RegID>[m
[32m+[m[32m        <PaneID>35824</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35885</RegID>[m
[32m+[m[32m        <PaneID>35885</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35886</RegID>[m
[32m+[m[32m        <PaneID>35886</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35887</RegID>[m
[32m+[m[32m        <PaneID>35887</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35888</RegID>[m
[32m+[m[32m        <PaneID>35888</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35889</RegID>[m
[32m+[m[32m        <PaneID>35889</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35890</RegID>[m
[32m+[m[32m        <PaneID>35890</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35891</RegID>[m
[32m+[m[32m        <PaneID>35891</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35892</RegID>[m
[32m+[m[32m        <PaneID>35892</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35893</RegID>[m
[32m+[m[32m        <PaneID>35893</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35894</RegID>[m
[32m+[m[32m        <PaneID>35894</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35895</RegID>[m
[32m+[m[32m        <PaneID>35895</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35896</RegID>[m
[32m+[m[32m        <PaneID>35896</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35897</RegID>[m
[32m+[m[32m        <PaneID>35897</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35898</RegID>[m
[32m+[m[32m        <PaneID>35898</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35899</RegID>[m
[32m+[m[32m        <PaneID>35899</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35900</RegID>[m
[32m+[m[32m        <PaneID>35900</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35901</RegID>[m
[32m+[m[32m        <PaneID>35901</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35902</RegID>[m
[32m+[m[32m        <PaneID>35902</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35903</RegID>[m
[32m+[m[32m        <PaneID>35903</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35904</RegID>[m
[32m+[m[32m        <PaneID>35904</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35905</RegID>[m
[32m+[m[32m        <PaneID>35905</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>38003</RegID>[m
[32m+[m[32m        <PaneID>38003</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000066000000BD0000007C020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>38007</RegID>[m
[32m+[m[32m        <PaneID>38007</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000B0020000FD050000ED020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>436</RegID>[m
[32m+[m[32m        <PaneID>436</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000B0020000FD050000ED020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>437</RegID>[m
[32m+[m[32m        <PaneID>437</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>440</RegID>[m
[32m+[m[32m        <PaneID>440</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>463</RegID>[m
[32m+[m[32m        <PaneID>463</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000B0020000FD050000ED020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>466</RegID>[m
[32m+[m[32m        <PaneID>466</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000B0020000FD050000ED020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>220000003900000005010000F0010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>470</RegID>[m
[32m+[m[32m        <PaneID>470</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>C7000000660000006D040000A3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000005A020000A6000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50000</RegID>[m
[32m+[m[32m        <PaneID>50000</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50001</RegID>[m
[32m+[m[32m        <PaneID>50001</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50002</RegID>[m
[32m+[m[32m        <PaneID>50002</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50003</RegID>[m
[32m+[m[32m        <PaneID>50003</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50004</RegID>[m
[32m+[m[32m        <PaneID>50004</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50005</RegID>[m
[32m+[m[32m        <PaneID>50005</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50006</RegID>[m
[32m+[m[32m        <PaneID>50006</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50007</RegID>[m
[32m+[m[32m        <PaneID>50007</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50008</RegID>[m
[32m+[m[32m        <PaneID>50008</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50009</RegID>[m
[32m+[m[32m        <PaneID>50009</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50010</RegID>[m
[32m+[m[32m        <PaneID>50010</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50011</RegID>[m
[32m+[m[32m        <PaneID>50011</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50012</RegID>[m
[32m+[m[32m        <PaneID>50012</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50013</RegID>[m
[32m+[m[32m        <PaneID>50013</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50014</RegID>[m
[32m+[m[32m        <PaneID>50014</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50015</RegID>[m
[32m+[m[32m        <PaneID>50015</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50016</RegID>[m
[32m+[m[32m        <PaneID>50016</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50017</RegID>[m
[32m+[m[32m        <PaneID>50017</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50018</RegID>[m
[32m+[m[32m        <PaneID>50018</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>50019</RegID>[m
[32m+[m[32m        <PaneID>50019</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>B3030000660000006D04000087010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59392</RegID>[m
[32m+[m[32m        <PaneID>59392</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>953</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0000000000000000C40300001C000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59393</RegID>[m
[32m+[m[32m        <PaneID>0</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000060300000006000019030000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59399</RegID>[m
[32m+[m[32m        <PaneID>59399</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>476</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>1</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>000000001C000000E701000038000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59400</RegID>[m
[32m+[m[32m        <PaneID>59400</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>612</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>2</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000380000006F02000054000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>824</RegID>[m
[32m+[m[32m        <PaneID>824</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000A70100006D040000F8010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000E2000000D7000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <DockMan>[m
[32m+[m[32m        <Len>3317</Len>[m
[32m+[m[32m        <Data>000000000B000000000000000020000000000000FFFFFFFFFFFFFFFFC4000000BC00000070040000C0000000000000000100000004000000010000000000000000000000FFFFFFFF08000000CB00000057010000CC000000F08B00005A01000079070000D601000045890000FFFF02000B004354616262656450616E650020000000000000C40000006600000070040000D3000000C40000004F00000070040000BC0000000000000040280046080000000B446973617373656D626C7900000000CB00000001000000FFFFFFFFFFFFFFFF14506572666F726D616E636520416E616C797A6572000000005701000001000000FFFFFFFFFFFFFFFF14506572666F726D616E636520416E616C797A657200000000CC00000001000000FFFFFFFFFFFFFFFF0E4C6F67696320416E616C797A657200000000F08B000001000000FFFFFFFFFFFFFFFF0D436F646520436F766572616765000000005A01000001000000FFFFFFFFFFFFFFFF11496E737472756374696F6E205472616365000000007907000001000000FFFFFFFFFFFFFFFF0F53797374656D20416E616C797A657200000000D601000001000000FFFFFFFFFFFFFFFF104576656E742053746174697374696373000000004589000001000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000001000000FFFFFFFFCB00000001000000FFFFFFFFCB000000000000000040000000000000FFFFFFFFFFFFFFFFAC0300004F000000B0030000A0010000000000000200000004000000010000000000000000000000FFFFFFFF2B000000E2050000CA0900002D8C00002E8C00002F8C0000308C0000318C0000328C0000338C0000348C0000358C0000368C0000378C0000388C0000398C00003A8C00003B8C00003C8C00003D8C00003E8C00003F8C0000408C0000418C000050C3000051C3000052C3000053C3000054C3000055C3000056C3000057C3000058C3000059C300005AC300005BC300005CC300005DC300005EC300005FC3000060C3000061C3000062C3000063C3000001800040000000000000B00300006600000070040000B7010000B00300004F00000070040000A001000000000000404100462B0000000753796D626F6C7300000000E205000001000000FFFFFFFFFFFFFFFF0A5472616365204461746100000000CA09000001000000FFFFFFFFFFFFFFFF00000000002D8C000001000000FFFFFFFFFFFFFFFF00000000002E8C000001000000FFFFFFFFFFFFFFFF00000000002F8C000001000000FFFFFFFFFFFFFFFF0000000000308C000001000000FFFFFFFFFFFFFFFF0000000000318C000001000000FFFFFFFFFFFFFFFF0000000000328C000001000000FFFFFFFFFFFFFFFF0000000000338C000001000000FFFFFFFFFFFFFFFF0000000000348C000001000000FFFFFFFFFFFFFFFF0000000000358C000001000000FFFFFFFFFFFFFFFF0000000000368C000001000000FFFFFFFFFFFFFFFF0000000000378C000001000000FFFFFFFFFFFFFFFF0000000000388C000001000000FFFFFFFFFFFFFFFF0000000000398C000001000000FFFFFFFFFFFFFFFF00000000003A8C000001000000FFFFFFFFFFFFFFFF00000000003B8C000001000000FFFFFFFFFFFFFFFF00000000003C8C000001000000FFFFFFFFFFFFFFFF00000000003D8C000001000000FFFFFFFFFFFFFFFF00000000003E8C000001000000FFFFFFFFFFFFFFFF00000000003F8C000001000000FFFFFFFFFFFFFFFF0000000000408C000001000000FFFFFFFFFFFFFFFF0000000000418C000001000000FFFFFFFFFFFFFFFF000000000050C3000001000000FFFFFFFFFFFFFFFF000000000051C3000001000000FFFFFFFFFFFFFFFF000000000052C3000001000000FFFFFFFFFFFFFFFF000000000053C3000001000000FFFFFFFFFFFFFFFF000000000054C3000001000000FFFFFFFFFFFFFFFF000000000055C3000001000000FFFFFFFFFFFFFFFF000000000056C3000001000000FFFFFFFFFFFFFFFF000000000057C3000001000000FFFFFFFFFFFFFFFF000000000058C3000001000000FFFFFFFFFFFFFFFF000000000059C3000001000000FFFFFFFFFFFFFFFF00000000005AC3000001000000FFFFFFFFFFFFFFFF00000000005BC3000001000000FFFFFFFFFFFFFFFF00000000005CC3000001000000FFFFFFFFFFFFFFFF00000000005DC3000001000000FFFFFFFFFFFFFFFF00000000005EC3000001000000FFFFFFFFFFFFFFFF00000000005FC3000001000000FFFFFFFFFFFFFFFF000000000060C3000001000000FFFFFFFFFFFFFFFF000000000061C3000001000000FFFFFFFFFFFFFFFF000000000062C3000001000000FFFFFFFFFFFFFFFF000000000063C3000001000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000001000000FFFFFFFFE205000001000000FFFFFFFFE2050000000000000010000001000000FFFFFFFFFFFFFFFFC00000004F000000C400000095020000010000000200001004000000010000000000000000000000FFFFFFFF05000000ED0300006D000000C3000000C400000073940000018000100000010000000000000066000000C0000000AC020000000000004F000000C0000000950200000000000040410056050000000750726F6A65637401000000ED03000001000000FFFFFFFFFFFFFFFF05426F6F6B73010000006D00000001000000FFFFFFFFFFFFFFFF0946756E6374696F6E7301000000C300000001000000FFFFFFFFFFFFFFFF0954656D706C6174657301000000C400000001000000FFFFFFFFFFFFFFFF09526567697374657273000000007394000001000000FFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000001000000FFFFFFFFED03000001000000FFFFFFFFED030000000000000080000000000000FFFFFFFFFFFFFFFF000000008C010000700400009001000000000000010000000400000001000000000000000000000000000000000000000000000001000000C6000000FFFFFFFF0F0000008F070000930700009407000095070000960700009007000091070000B5010000B801000038030000B9050000BA050000BB050000BC050000CB0900000180008000000000000000000000A701000070040000280200000000000090010000700400001102000000000000404100460F0000001343616C6C20537461636B202B204C6F63616C73000000008F07000001000000FFFFFFFFFFFFFFFF0755415254202331000000009307000001000000FFFFFFFFFFFFFFFF0755415254202332000000009407000001000000FFFFFFFFFFFFFFFF0755415254202333000000009507000001000000FFFFFFFFFFFFFFFF15446562756720287072696E74662920566965776572000000009607000001000000FFFFFFFFFFFFFFFF0757617463682031000000009007000001000000FFFFFFFFFFFFFFFF0757617463682032000000009107000001000000FFFFFFFFFFFFFFFF10547261636520457863657074696F6E7300000000B501000001000000FFFFFFFFFFFFFFFF0E4576656E7420436F756E7465727300000000B801000001000000FFFFFFFFFFFFFFFF09554C494E4B706C7573000000003803000001000000FFFFFFFFFFFFFFFF084D656D6F7279203100000000B905000001000000FFFFFFFFFFFFFFFF084D656D6F7279203200000000BA05000001000000FFFFFFFFFFFFFFFF084D656D6F7279203300000000BB05000001000000FFFFFFFFFFFFFFFF084D656D6F7279203400000000BC05000001000000FFFFFFFFFFFFFFFF105472616365204E617669676174696F6E00000000CB09000001000000FFFFFFFFFFFFFFFFFFFFFFFF0000000001000000000000000000000001000000FFFFFFFF38020000900100003C0200001102000000000000020000000400000000000000000000000000000000000000000000000000000002000000C6000000FFFFFFFF8F07000001000000FFFFFFFF8F07000001000000C6000000000000000080000001000000FFFFFFFFFFFFFFFF00000000950200000006000099020000010000000100001004000000010000000000000000000000FFFFFFFF06000000C5000000C7000000B4010000D2010000CF010000779400000180008000000100000000000000B0020000000600001D030000000000009902000000060000060300000000000040820056060000000C4275696C64204F757470757401000000C500000001000000FFFFFFFFFFFFFFFF0D46696E6420496E2046696C657300000000C700000001000000FFFFFFFFFFFFFFFF0A4572726F72204C69737400000000B401000001000000FFFFFFFFFFFFFFFF0E536F757263652042726F7773657200000000D201000001000000FFFFFFFFFFFFFFFF1346696E6420416C6C205265666572656E63657300000000CF01000001000000FFFFFFFFFFFFFFFF0742726F77736572000000007794000001000000FFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000001000000FFFFFFFFC500000001000000FFFFFFFFC5000000000000000000000000000000</Data>[m
[32m+[m[32m      </DockMan>[m
[32m+[m[32m      <ToolBar>[m
[32m+[m[32m        <RegID>59392</RegID>[m
[32m+[m[32m        <Name>File</Name>[m
[32m+[m[32m        <Buttons>[m
[32m+[m[32m          <Len>2517</Len>[m
[32m+[m[32m          <Data>00200000010000002800FFFF01001100434D4643546F6F6C426172427574746F6E00E100000000000000000000000000000000000000000000000100000001000000018001E100000000000001000000000000000000000000000000000100000001000000018003E1000000000000020000000000000000000000000000000001000000010000000180CD7F0000000000000300000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018023E100000000040004000000000000000000000000000000000100000001000000018022E100000000040005000000000000000000000000000000000100000001000000018025E10000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001802BE10000000000000700000000000000000000000000000000010000000100000001802CE10000000004000800000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001807A8A0000000000000900000000000000000000000000000000010000000100000001807B8A0000000004000A00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180D3B00000000000000B000000000000000000000000000000000100000001000000018015B10000000004000C0000000000000000000000000000000001000000010000000180F4B00000000004000D000000000000000000000000000000000100000001000000018036B10000000004000E00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FF88000000000400460000000000000000000000000000000001000000010000000180FE880000000004004500000000000000000000000000000000010000000100000001800B810000000004001300000000000000000000000000000000010000000100000001800C810000000004001400000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180F0880000020000000F000000000000000000000000000000000100000001000000FFFF0100120043555646696E64436F6D626F427574746F6EE803000000000000000000000000000000000000000000000001000000010000009600000002002050000000000550466F7574960000000000000014000550466F7574044C454430077479706564656607414E5F315F66790B414E5F345F4657526561640550585F6679067078665F46570C446F75626C655F76616C75650A446174615F76616C7565165A68695869616E675F436F6D706C6574655F466C61670F54656D705F33325F52656365697665165A6875616E6754616943686158756E5F59696E6744610A41415F446174615F434C0D5A694A69616E5F59696E674461144361694A694D696E674C696E675F59696E6744610A73706163655F7363616E0F46595F656E636F6465725F466C61670A77726974655F4C5644530B52656164496D7544617461166765745F6F70746963616C5F6E617669676174696F6E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018024E10000000000001100000000000000000000000000000000010000000100000001800A810000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6E22800000020000001500000019C6F4B6AF2FCDA3D6B9B5F7CAD4BBE1BBB0094374726C2B463500000000000000000000000001000000010000000000000000000000010000000200218022800000000000001500000019C6F4B6AF2FCDA3D6B9B5F7CAD4BBE1BBB0094374726C2B4635000000000000000000000000010000000100000000000000000000000100000000002180E0010000000000007500000012C4DCC1BFB2E2C1BFBACDCEDED0E8B5F7CAD40000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C488000000000000160000000000000000000000000000000001000000010000000180C988000000000400180000000000000000000000000000000001000000010000000180C788000000000000190000000000000000000000000000000001000000010000000180C8880000000000001700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000021804C010000020001001A00000008CFEEC4BFB4B0BFDA000000000000000000000000010000000100000000000000000000000100000008002180DD880000000000001A0000000750726F6A656374000000000000000000000000010000000100000000000000000000000100000000002180DC8B0000000000003A00000005426F6F6B73000000000000000000000000010000000100000000000000000000000100000000002180E18B0000000000003B0000000946756E6374696F6E73000000000000000000000000010000000100000000000000000000000100000000002180E28B000000000000400000000954656D706C6174657300000000000000000000000001000000010000000000000000000000010000000000218018890000000000003D0000000E536F757263652042726F777365720000000000000000000000000100000001000000000000000000000001000000000021800000000000000400FFFFFFFF00000000000000000001000000000000000100000000000000000000000100000000002180D988000000000000390000000C4275696C64204F7574707574000000000000000000000000010000000100000000000000000000000100000000002180E38B000000000000410000000B46696E64204F75747075740000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FB7F0000000000001B000000000000000000000000000000000100000001000000000000000446696C65B9030000</Data>[m
[32m+[m[32m        </Buttons>[m
[32m+[m[32m        <OriginalItems>[m
[32m+[m[32m          <Len>1423</Len>[m
[32m+[m[32m          <Data>2800FFFF01001100434D4643546F6F6C426172427574746F6E00E1000000000000FFFFFFFF000100000000000000010000000000000001000000018001E1000000000000FFFFFFFF000100000000000000010000000000000001000000018003E1000000000000FFFFFFFF0001000000000000000100000000000000010000000180CD7F000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF000000000000000000010000000000000001000000018023E1000000000000FFFFFFFF000100000000000000010000000000000001000000018022E1000000000000FFFFFFFF000100000000000000010000000000000001000000018025E1000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001802BE1000000000000FFFFFFFF00010000000000000001000000000000000100000001802CE1000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001807A8A000000000000FFFFFFFF00010000000000000001000000000000000100000001807B8A000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180D3B0000000000000FFFFFFFF000100000000000000010000000000000001000000018015B1000000000000FFFFFFFF0001000000000000000100000000000000010000000180F4B0000000000000FFFFFFFF000100000000000000010000000000000001000000018036B1000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180FF88000000000000FFFFFFFF0001000000000000000100000000000000010000000180FE88000000000000FFFFFFFF00010000000000000001000000000000000100000001800B81000000000000FFFFFFFF00010000000000000001000000000000000100000001800C81000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180F088000000000000FFFFFFFF0001000000000000000100000000000000010000000180EE7F000000000000FFFFFFFF000100000000000000010000000000000001000000018024E1000000000000FFFFFFFF00010000000000000001000000000000000100000001800A81000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001802280000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180C488000000000000FFFFFFFF0001000000000000000100000000000000010000000180C988000000000000FFFFFFFF0001000000000000000100000000000000010000000180C788000000000000FFFFFFFF0001000000000000000100000000000000010000000180C888000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180DD88000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180FB7F000000000000FFFFFFFF000100000000000000010000000000000001000000</Data>[m
[32m+[m[32m        </OriginalItems>[m
[32m+[m[32m        <OrigResetItems>[m
[32m+[m[32m          <Len>1423</Len>[m
[32m+[m[32m          <Data>2800FFFF01001100434D4643546F6F6C426172427574746F6E00E100000000000000000000000000000000000000000000000100000001000000018001E100000000000001000000000000000000000000000000000100000001000000018003E1000000000000020000000000000000000000000000000001000000010000000180CD7F0000000000000300000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018023E100000000000004000000000000000000000000000000000100000001000000018022E100000000000005000000000000000000000000000000000100000001000000018025E10000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001802BE10000000000000700000000000000000000000000000000010000000100000001802CE10000000000000800000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001807A8A0000000000000900000000000000000000000000000000010000000100000001807B8A0000000000000A00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180D3B00000000000000B000000000000000000000000000000000100000001000000018015B10000000000000C0000000000000000000000000000000001000000010000000180F4B00000000000000D000000000000000000000000000000000100000001000000018036B10000000000000E00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FF880000000000000F0000000000000000000000000000000001000000010000000180FE880000000000001000000000000000000000000000000000010000000100000001800B810000000000001100000000000000000000000000000000010000000100000001800C810000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180F088000000000000130000000000000000000000000000000001000000010000000180EE7F00000000000014000000000000000000000000000000000100000001000000018024E10000000000001500000000000000000000000000000000010000000100000001800A810000000000001600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018022800000000000001700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C488000000000000180000000000000000000000000000000001000000010000000180C988000000000000190000000000000000000000000000000001000000010000000180C7880000000000001A0000000000000000000000000000000001000000010000000180C8880000000000001B00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180DD880000000000001C00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FB7F0000000000001D000000000000000000000000000000000100000001000000</Data>[m
[32m+[m[32m        </OrigResetItems>[m
[32m+[m[32m      </ToolBar>[m
[32m+[m[32m      <ToolBar>[m
[32m+[m[32m        <RegID>59399</RegID>[m
[32m+[m[32m        <Name>Build</Name>[m
[32m+[m[32m        <Buttons>[m
[32m+[m[32m          <Len>960</Len>[m
[32m+[m[32m          <Data>00200000010000001000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F0000000000001C0000000000000000000000000000000001000000010000000180D07F0000000000001D000000000000000000000000000000000100000001000000018030800000000000001E000000000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6EC7040000000000006A00000008C5FAC1BFB9B9BDA8000000000000000000000000010000000100000000000000000000000100000004000580C7040000000000006A00000008C5FAC1BFB9B9BDA800000000000000000000000001000000010000000000000000000000010000000000058046070000000000006B0000000CC5FAC1BFD6D8D0C2B9B9BDA80000000000000000000000000100000001000000000000000000000001000000000005804707000000000000FFFFFFFF08C5FAC1BFC7E5B3FD0100000000000000000000000100000001000000000000000000000001000000000005809E8A0000000000001F0000000BC5FAC1BFC9E8D6C32E2E2E000000000000000000000000010000000100000000000000000000000100000000000180D17F0000000004002000000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001804C8A0000000000002100000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001900434D4643546F6F6C426172436F6D626F426F78427574746F6EBA000000000000000000000000000000000000000000000000010000000100000096000000030020500000000008546172676574203196000000000000000100085461726765742031000000000180EB880000000000002200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C07F000000000000230000000000000000000000000000000001000000010000000180B08A000000000400240000000000000000000000000000000001000000010000000180A8010000000000004E00000000000000000000000000000000010000000100000001807202000000000000530000000000000000000000000000000001000000010000000180BE010000000000005000000000000000000000000000000000010000000100000000000000054275696C64DC010000</Data>[m
[32m+[m[32m        </Buttons>[m
[32m+[m[32m        <OriginalItems>[m
[32m+[m[32m          <Len>583</Len>[m
[32m+[m[32m          <Data>1000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F000000000000FFFFFFFF0001000000000000000100000000000000010000000180D07F000000000000FFFFFFFF00010000000000000001000000000000000100000001803080000000000000FFFFFFFF00010000000000000001000000000000000100000001809E8A000000000000FFFFFFFF0001000000000000000100000000000000010000000180D17F000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001804C8A000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001806680000000000000FFFFFFFF0001000000000000000100000000000000010000000180EB88000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180C07F000000000000FFFFFFFF0001000000000000000100000000000000010000000180B08A000000000000FFFFFFFF0001000000000000000100000000000000010000000180A801000000000000FFFFFFFF00010000000000000001000000000000000100000001807202000000000000FFFFFFFF0001000000000000000100000000000000010000000180BE01000000000000FFFFFFFF000100000000000000010000000000000001000000</Data>[m
[32m+[m[32m        </OriginalItems>[m
[32m+[m[32m        <OrigResetItems>[m
[32m+[m[32m          <Len>583</Len>[m
[32m+[m[32m          <Data>1000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F000000000000000000000000000000000000000000000001000000010000000180D07F00000000000001000000000000000000000000000000000100000001000000018030800000000000000200000000000000000000000000000000010000000100000001809E8A000000000000030000000000000000000000000000000001000000010000000180D17F0000000000000400000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001804C8A0000000000000500000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001806680000000000000060000000000000000000000000000000001000000010000000180EB880000000000000700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C07F000000000000080000000000000000000000000000000001000000010000000180B08A000000000000090000000000000000000000000000000001000000010000000180A8010000000000000A000000000000000000000000000000000100000001000000018072020000000000000B0000000000000000000000000000000001000000010000000180BE010000000000000C000000000000000000000000000000000100000001000000</Data>[m
[32m+[m[32m        </OrigResetItems>[m
[32m+[m[32m      </ToolBar>[m
[32m+[m[32m      <ToolBar>[m
[32m+[m[32m        <RegID>59400</RegID>[m
[32m+[m[32m        <Name>Debug</Name>[m
[32m+[m[32m        <Buttons>[m
[32m+[m[32m          <Len>2337</Len>[m
[32m+[m[32m          <Data>00200000000000001900FFFF01001100434D4643546F6F6C426172427574746F6ECC880000000000002500000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018017800000000000002600000000000000000000000000000000010000000100000001801D800000000000002700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001801A800000000000002800000000000000000000000000000000010000000100000001801B80000000000000290000000000000000000000000000000001000000010000000180E57F0000000000002A00000000000000000000000000000000010000000100000001801C800000000000002B00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018000890000000000002C00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180E48B0000000000002D0000000000000000000000000000000001000000010000000180F07F0000000000002E0000000000000000000000000000000001000000010000000180E8880000000000003700000000000000000000000000000000010000000100000001803B010000000000002F0000000000000000000000000000000001000000010000000180BB8A00000000000030000000000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6E0E01000000000000310000000D57617463682057696E646F7773000000000000000000000000010000000100000000000000000000000100000003001380D88B0000000000003100000007B9DBB2E2202631000000000000000000000000010000000100000000000000000000000100000000001380D98B0000000000003100000007B9DBB2E2202632000000000000000000000000010000000100000000000000000000000100000000001380CE01000000000000FFFFFFFF0C576174636820416E63686F720100000000000000010000000000000001000000000000000000000001000000000013800F01000000000000320000000E4D656D6F72792057696E646F7773000000000000000000000000010000000100000000000000000000000100000004001380D28B0000000000003200000007C4DAB4E6202631000000000000000000000000010000000100000000000000000000000100000000001380D38B0000000000003200000007C4DAB4E6202632000000000000000000000000010000000100000000000000000000000100000000001380D48B0000000000003200000007C4DAB4E6202633000000000000000000000000010000000100000000000000000000000100000000001380D58B0000000000003200000007C4DAB4E62026340000000000000000000000000100000001000000000000000000000001000000000013801001000000000000330000000E53657269616C2057696E646F777300000000000000000000000001000000010000000000000000000000010000000400138093070000000000003300000008B4AEBFDA2023263100000000000000000000000001000000010000000000000000000000010000000000138094070000000000003300000008B4AEBFDA2023263200000000000000000000000001000000010000000000000000000000010000000000138095070000000000003300000008B4AEBFDA2023263300000000000000000000000001000000010000000000000000000000010000000000138096070000000000003300000014B5F7CAD4A3A87072696E7466A3A9B2E9BFB4C6F70000000000000000000000000100000001000000000000000000000001000000000013803C010000000000003400000010416E616C797369732057696E646F7773000000000000000000000000010000000100000000000000000000000100000004001380658A000000000000340000000AC2DFBCADB7D6CEF6D2C7000000000000000000000000010000000100000000000000000000000100000000001380DC7F0000000000003E0000000AD0D4C4DCB7D6CEF6C6F7000000000000000000000000010000000100000000000000000000000100000000001380E788000000000000380000000B26B4FAC2EBB8B2B8C7C2CA000000000000000000000000010000000100000000000000000000000100000000001380CD01000000000000FFFFFFFF0F416E616C7973697320416E63686F7201000000000000000100000000000000010000000000000000000000010000000000138053010000000000003F0000000D54726163652057696E646F77730000000000000000000000000100000001000000000000000000000001000000010013805401000000000000FFFFFFFF115472616365204D656E7520416E63686F720100000000000000010000000000000001000000000000000000000001000000000013802901000000000000350000001553797374656D205669657765722057696E646F77730000000000000000000000000100000001000000000000000000000001000000010013804B01000000000000FFFFFFFF1453797374656D2056696577657220416E63686F720100000000000000010000000000000001000000000000000000000001000000000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000013800189000000000000360000000AB9A4BEDFCFE4B4B0BFDA00000000000000000000000001000000010000000000000000000000010000000300138044C5000000000000FFFFFFFF0E5570646174652057696E646F77730100000000000000010000000000000001000000000000000000000001000000000013800000000000000400FFFFFFFF000000000000000000010000000000000001000000000000000000000001000000000013805B01000000000000FFFFFFFF12546F6F6C626F78204D656E75416E63686F72010000000000000001000000000000000100000000000000000000000100000000000000000005446562756764020000</Data>[m
[32m+[m[32m        </Buttons>[m
[32m+[m[32m        <OriginalItems>[m
[32m+[m[32m          <Len>898</Len>[m
[32m+[m[32m          <Data>1900FFFF01001100434D4643546F6F6C426172427574746F6ECC88000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001801780000000000000FFFFFFFF00010000000000000001000000000000000100000001801D80000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001801A80000000000000FFFFFFFF00010000000000000001000000000000000100000001801B80000000000000FFFFFFFF0001000000000000000100000000000000010000000180E57F000000000000FFFFFFFF00010000000000000001000000000000000100000001801C80000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001800089000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180E48B000000000000FFFFFFFF0001000000000000000100000000000000010000000180F07F000000000000FFFFFFFF0001000000000000000100000000000000010000000180E888000000000000FFFFFFFF00010000000000000001000000000000000100000001803B01000000000000FFFFFFFF0001000000000000000100000000000000010000000180BB8A000000000000FFFFFFFF0001000000000000000100000000000000010000000180D88B000000000000FFFFFFFF0001000000000000000100000000000000010000000180D28B000000000000FFFFFFFF00010000000000000001000000000000000100000001809307000000000000FFFFFFFF0001000000000000000100000000000000010000000180658A000000000000FFFFFFFF0001000000000000000100000000000000010000000180C18A000000000000FFFFFFFF0001000000000000000100000000000000010000000180EE8B000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001800189000000000000FFFFFFFF000100000000000000010000000000000001000000</Data>[m
[32m+[m[32m        </OriginalItems>[m
[32m+[m[32m        <OrigResetItems>[m
[32m+[m[32m          <Len>898</Len>[m
[32m+[m[32m          <Data>1900FFFF01001100434D4643546F6F6C426172427574746F6ECC880000000000000000000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018017800000000000000100000000000000000000000000000000010000000100000001801D800000000000000200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001801A800000000000000300000000000000000000000000000000010000000100000001801B80000000000000040000000000000000000000000000000001000000010000000180E57F0000000000000500000000000000000000000000000000010000000100000001801C800000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018000890000000000000700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180E48B000000000000080000000000000000000000000000000001000000010000000180F07F000000000000090000000000000000000000000000000001000000010000000180E8880000000000000A00000000000000000000000000000000010000000100000001803B010000000000000B0000000000000000000000000000000001000000010000000180BB8A0000000000000C0000000000000000000000000000000001000000010000000180D88B0000000000000D0000000000000000000000000000000001000000010000000180D28B0000000000000E000000000000000000000000000000000100000001000000018093070000000000000F0000000000000000000000000000000001000000010000000180658A000000000000100000000000000000000000000000000001000000010000000180C18A000000000000110000000000000000000000000000000001000000010000000180EE8B0000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180018900000000000013000000000000000000000000000000000100000001000000</Data>[m
[32m+[m[32m        </OrigResetItems>[m
[32m+[m[32m      </ToolBar>[m
[32m+[m[32m      <ControlBarsSummary>[m
[32m+[m[32m        <Bars>0</Bars>[m
[32m+[m[32m        <ScreenCX>1536</ScreenCX>[m
[32m+[m[32m        <ScreenCY>864</ScreenCY>[m
[32m+[m[32m      </ControlBarsSummary>[m
[32m+[m[32m    </ViewEx>[m
[32m+[m[32m  </WinLayoutEx>[m
[32m+[m
[32m+[m[32m  <MDIGroups>[m
[32m+[m[32m    <Orientation>1</Orientation>[m
[32m+[m[32m    <ActiveMDIGroup>0</ActiveMDIGroup>[m
[32m+[m[32m    <MDIGroup>[m
[32m+[m[32m      <Size>100</Size>[m
[32m+[m[32m      <ActiveTab>0</ActiveTab>[m
[32m+[m[32m      <Doc>[m
[32m+[m[32m        <Name>.\User\main.c</Name>[m
[32m+[m[32m        <ColumnNumber>20</ColumnNumber>[m
[32m+[m[32m        <TopLine>1</TopLine>[m
[32m+[m[32m        <CurrentLine>17</CurrentLine>[m
[32m+[m[32m        <Folding>1</Folding>[m
[32m+[m[32m        <ContractedFolders></ContractedFolders>[m
[32m+[m[32m        <PaneID>0</PaneID>[m
[32m+[m[32m      </Doc>[m
[32m+[m[32m    </MDIGroup>[m
[32m+[m[32m  </MDIGroups>[m
[32m+[m
[32m+[m[32m</ProjectGui>[m
[1mdiff --git a/Template.uvoptx b/Template.uvoptx[m
[1mindex ad57117..071de5b 100644[m
[1m--- a/Template.uvoptx[m
[1m+++ b/Template.uvoptx[m
[36m@@ -78,28 +78,6 @@[m
         <IsCurrentTarget>1</IsCurrentTarget>[m
       </OPTFL>[m
       <CpuCode>18</CpuCode>[m
[31m-      <Books>[m
[31m-        <Book>[m
[31m-          <Number>0</Number>[m
[31m-          <Title>Base Board Schematics (MCBSTM32E)</Title>[m
[31m-          <Path>C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Documents\mcbstm32e-base-board-schematics.pdf</Path>[m
[31m-        </Book>[m
[31m-        <Book>[m
[31m-          <Number>1</Number>[m
[31m-          <Title>Display Board Schematics (MCBSTM32E)</Title>[m
[31m-          <Path>C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Documents\mcbstm32e-display-board-schematics.pdf</Path>[m
[31m-        </Book>[m
[31m-        <Book>[m
[31m-          <Number>2</Number>[m
[31m-          <Title>User Manual (MCBSTM32E)</Title>[m
[31m-          <Path>C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Documents\mcbstm32e.chm</Path>[m
[31m-        </Book>[m
[31m-        <Book>[m
[31m-          <Number>3</Number>[m
[31m-          <Title>MCBSTM32E Evaluation Board Web Page (MCBSTM32E)</Title>[m
[31m-          <Path>http://www.keil.com/mcbstm32e/</Path>[m
[31m-        </Book>[m
[31m-      </Books>[m
       <DebugOpt>[m
         <uSim>0</uSim>[m
         <uTrg>1</uTrg>[m
[36m@@ -122,6 +100,9 @@[m
         <tRSysVw>1</tRSysVw>[m
         <sRunDeb>0</sRunDeb>[m
         <sLrtime>0</sLrtime>[m
[32m+[m[32m        <bEvRecOn>1</bEvRecOn>[m
[32m+[m[32m        <bSchkAxf>0</bSchkAxf>[m
[32m+[m[32m        <bTchkAxf>0</bTchkAxf>[m
         <nTsel>6</nTsel>[m
         <sDll></sDll>[m
         <sDllPa></sDllPa>[m
[36m@@ -184,6 +165,17 @@[m
       </DebugFlag>[m
       <LintExecutable></LintExecutable>[m
       <LintConfigFile></LintConfigFile>[m
[32m+[m[32m      <bLintAuto>0</bLintAuto>[m
[32m+[m[32m      <bAutoGenD>0</bAutoGenD>[m
[32m+[m[32m      <LntExFlags>0</LntExFlags>[m
[32m+[m[32m      <pMisraName></pMisraName>[m
[32m+[m[32m      <pszMrule></pszMrule>[m
[32m+[m[32m      <pSingCmds></pSingCmds>[m
[32m+[m[32m      <pMultCmds></pMultCmds>[m
[32m+[m[32m      <pMisraNamep></pMisraNamep>[m
[32m+[m[32m      <pszMrulep></pszMrulep>[m
[32m+[m[32m      <pSingCmdsp></pSingCmdsp>[m
[32m+[m[32m      <pMultCmdsp></pMultCmdsp>[m
     </TargetOption>[m
   </Target>[m
 [m
[36m@@ -198,7 +190,6 @@[m
       <FileNumber>1</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\User\main.c</PathWithFileName>[m
[36m@@ -211,7 +202,6 @@[m
       <FileNumber>2</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\User\stm32f10x_it.c</PathWithFileName>[m
[36m@@ -232,7 +222,6 @@[m
       <FileNumber>3</FileNumber>[m
       <FileType>2</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\Libraries\CMSIS\startup_stm32f10x_hd.s</PathWithFileName>[m
[36m@@ -253,7 +242,6 @@[m
       <FileNumber>4</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c</PathWithFileName>[m
[36m@@ -266,7 +254,6 @@[m
       <FileNumber>5</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c</PathWithFileName>[m
[36m@@ -287,7 +274,6 @@[m
       <FileNumber>6</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\Libraries\CMSIS\core_cm3.c</PathWithFileName>[m
[36m@@ -300,7 +286,6 @@[m
       <FileNumber>7</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\Libraries\CMSIS\system_stm32f10x.c</PathWithFileName>[m
[36m@@ -321,7 +306,6 @@[m
       <FileNumber>8</FileNumber>[m
       <FileType>1</FileType>[m
       <tvExp>0</tvExp>[m
[31m-      <Focus>0</Focus>[m
       <tvExpOptDlg>0</tvExpOptDlg>[m
       <bDave2>0</bDave2>[m
       <PathWithFileName>.\APP\LED\led.c</PathWithFileName>[m
[1mdiff --git a/Template.uvprojx b/Template.uvprojx[m
[1mindex 7c81d92..7e95117 100644[m
[1m--- a/Template.uvprojx[m
[1m+++ b/Template.uvprojx[m
[36m@@ -10,6 +10,8 @@[m
       <TargetName>Target 1</TargetName>[m
       <ToolsetNumber>0x4</ToolsetNumber>[m
       <ToolsetName>ARM-ADS</ToolsetName>[m
[32m+[m[32m      <pCCUsed>5060061::V5.06 update 1 (build 61)::ARMCC</pCCUsed>[m
[32m+[m[32m      <uAC6>0</uAC6>[m
       <TargetOption>[m
         <TargetCommonOption>[m
           <Device>STM32F103ZE</Device>[m
[36m@@ -84,6 +86,8 @@[m
             <UserProg2Name></UserProg2Name>[m
             <UserProg1Dos16Mode>0</UserProg1Dos16Mode>[m
             <UserProg2Dos16Mode>0</UserProg2Dos16Mode>[m
[32m+[m[32m            <nStopA1X>0</nStopA1X>[m
[32m+[m[32m            <nStopA2X>0</nStopA2X>[m
           </AfterMake>[m
           <SelectedForBatchBuild>0</SelectedForBatchBuild>[m
           <SVCSIdString></SVCSIdString>[m
[36m@@ -122,47 +126,6 @@[m
             <HexOffset>0</HexOffset>[m
             <Oh166RecLen>16</Oh166RecLen>[m
           </OPTHX>[m
[31m-          <Simulator>[m
[31m-            <UseSimulator>0</UseSimulator>[m
[31m-            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>[m
[31m-            <RunToMain>1</RunToMain>[m
[31m-            <RestoreBreakpoints>1</RestoreBreakpoints>[m
[31m-            <RestoreWatchpoints>1</RestoreWatchpoints>[m
[31m-            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>[m
[31m-            <RestoreFunctions>1</RestoreFunctions>[m
[31m-            <RestoreToolbox>1</RestoreToolbox>[m
[31m-            <LimitSpeedToRealTime>0</LimitSpeedToRealTime>[m
[31m-            <RestoreSysVw>1</RestoreSysVw>[m
[31m-          </Simulator>[m
[31m-          <Target>[m
[31m-            <UseTarget>1</UseTarget>[m
[31m-            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>[m
[31m-            <RunToMain>1</RunToMain>[m
[31m-            <RestoreBreakpoints>1</RestoreBreakpoints>[m
[31m-            <RestoreWatchpoints>1</RestoreWatchpoints>[m
[31m-            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>[m
[31m-            <RestoreFunctions>0</RestoreFunctions>[m
[31m-            <RestoreToolbox>1</RestoreToolbox>[m
[31m-            <RestoreTracepoints>1</RestoreTracepoints>[m
[31m-            <RestoreSysVw>1</RestoreSysVw>[m
[31m-          </Target>[m
[31m-          <RunDebugAfterBuild>0</RunDebugAfterBuild>[m
[31m-          <TargetSelection>6</TargetSelection>[m
[31m-          <SimDlls>[m
[31m-            <CpuDll></CpuDll>[m
[31m-            <CpuDllArguments></CpuDllArguments>[m
[31m-            <PeripheralDll></PeripheralDll>[m
[31m-            <PeripheralDllArguments></PeripheralDllArguments>[m
[31m-            <InitializationFile></InitializationFile>[m
[31m-          </SimDlls>[m
[31m-          <TargetDlls>[m
[31m-            <CpuDll></CpuDll>[m
[31m-            <CpuDllArguments></CpuDllArguments>[m
[31m-            <PeripheralDll></PeripheralDll>[m
[31m-            <PeripheralDllArguments></PeripheralDllArguments>[m
[31m-            <InitializationFile></InitializationFile>[m
[31m-            <Driver>Segger\JL2CM3.dll</Driver>[m
[31m-          </TargetDlls>[m
         </DebugOption>[m
         <Utilities>[m
           <Flash1>[m
[36m@@ -227,6 +190,7 @@[m
             <useUlib>1</useUlib>[m
             <EndSel>0</EndSel>[m
             <uLtcg>0</uLtcg>[m
[32m+[m[32m            <nSecure>0</nSecure>[m
             <RoSelD>3</RoSelD>[m
             <RwSelD>3</RwSelD>[m
             <CodeSel>0</CodeSel>[m
[36m@@ -360,7 +324,15 @@[m
             <uThumb>0</uThumb>[m
             <uSurpInc>0</uSurpInc>[m
             <uC99>1</uC99>[m
[32m+[m[32m            <uGnu>0</uGnu>[m
             <useXO>0</useXO>[m
[32m+[m[32m            <v6Lang>1</v6Lang>[m
[32m+[m[32m            <v6LangP>1</v6LangP>[m
[32m+[m[32m            <vShortEn>1</vShortEn>[m
[32m+[m[32m            <vShortWch>1</vShortWch>[m
[32m+[m[32m            <v6Lto>0</v6Lto>[m
[32m+[m[32m            <v6WtE>0</v6WtE>[m
[32m+[m[32m            <v6Rtti>0</v6Rtti>[m
             <VariousControls>[m
               <MiscControls></MiscControls>[m
               <Define>USE_STDPERIPH_DRIVER,STM32F10X_HD</Define>[m
[36m@@ -378,6 +350,7 @@[m
             <NoWarn>0</NoWarn>[m
             <uSurpInc>0</uSurpInc>[m
             <useXO>0</useXO>[m
[32m+[m[32m            <uClangAs>0</uClangAs>[m
             <VariousControls>[m
               <MiscControls></MiscControls>[m
               <Define></Define>[m
[36m@@ -474,4 +447,10 @@[m
     </Target>[m
   </Targets>[m
 [m
[32m+[m[32m  <RTE>[m
[32m+[m[32m    <apis/>[m
[32m+[m[32m    <components/>[m
[32m+[m[32m    <files/>[m
[32m+[m[32m  </RTE>[m
[32m+[m
 </Project>[m
[1mdiff --git "a/\344\277\256\346\224\271\350\257\264\346\230\2162022.10.23.txt" "b/\344\277\256\346\224\271\350\257\264\346\230\2162022.10.23.txt"[m
[1mnew file mode 100644[m
[1mindex 0000000..4bd945c[m
[1m--- /dev/null[m
[1m+++ "b/\344\277\256\346\224\271\350\257\264\346\230\2162022.10.23.txt"[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32mÂ∞ÜLEDÁÇπ‰∫ÆÁöÑÊó∂Èó¥‰øÆÊîπ‰∏∫100ms[m
\ No newline at end of file[m

[33mcommit df3d656fe417bc160ea36379a178b1825feb480f[m[33m ([m[1;31mgithub/master[m[33m)[m
Author: lyj <test@lyj.com>
Date:   Sun Oct 23 10:59:43 2022 +0800

    files init
    
    Signed-off-by: lyj <test@lyj.com>

[1mdiff --git a/APP/LED/led.c b/APP/LED/led.c[m
[1mnew file mode 100644[m
[1mindex 0000000..ea79e07[m
[1m--- /dev/null[m
[1m+++ b/APP/LED/led.c[m
[36m@@ -0,0 +1,14 @@[m
[32m+[m[32m#include "led.h"[m
[32m+[m
[32m+[m[32mvoid LED_Init()[m
[32m+[m[32m{[m
[32m+[m		[32mGPIO_InitTypeDef GPIO_InitStructure;//[m
[32m+[m[41m		[m
[32m+[m		[32mRCC_APB2PeriphClockCmd(LED_PORT_RCC,ENABLE);[m
[32m+[m[41m		[m
[32m+[m		[32mGPIO_InitStructure.GPIO_Pin=LED_PIN;[m
[32m+[m		[32mGPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;[m
[32m+[m		[32mGPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;[m
[32m+[m		[32mGPIO_Init(LEN_PORT,&GPIO_InitStructure);[m
[32m+[m		[32mGPIO_SetBits(LEN_PORT,LED_PIN);[m
[32m+[m[32m}[m
[1mdiff --git a/APP/LED/led.h b/APP/LED/led.h[m
[1mnew file mode 100644[m
[1mindex 0000000..1ae6c01[m
[1m--- /dev/null[m
[1m+++ b/APP/LED/led.h[m
[36m@@ -0,0 +1,12 @@[m
[32m+[m[32m#ifndef _LED_H[m
[32m+[m[32m#define _LED_H[m
[32m+[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m#define LED_PORT_RCC		RCC_APB2Periph_GPIOC[m
[32m+[m[32m#define LED_PIN					GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7[m
[32m+[m[32m#define LEN_PORT				GPIOC[m
[32m+[m
[32m+[m[32mvoid LED_Init(void);[m
[32m+[m
[32m+[m[32m#endif[m
[1mdiff --git a/JLinkSettings.ini b/JLinkSettings.ini[m
[1mnew file mode 100644[m
[1mindex 0000000..2d53bb4[m
[1m--- /dev/null[m
[1m+++ b/JLinkSettings.ini[m
[36m@@ -0,0 +1,35 @@[m
[32m+[m[32m[BREAKPOINTS][m
[32m+[m[32mForceImpTypeAny = 0[m
[32m+[m[32mShowInfoWin = 1[m
[32m+[m[32mEnableFlashBP = 2[m
[32m+[m[32mBPDuringExecution = 0[m
[32m+[m[32m[CFI][m
[32m+[m[32mCFISize = 0x00[m
[32m+[m[32mCFIAddr = 0x00[m
[32m+[m[32m[CPU][m
[32m+[m[32mOverrideMemMap = 0[m
[32m+[m[32mAllowSimulation = 1[m
[32m+[m[32mScriptFile=""[m
[32m+[m[32m[FLASH][m
[32m+[m[32mCacheExcludeSize = 0x00[m
[32m+[m[32mCacheExcludeAddr = 0x00[m
[32m+[m[32mMinNumBytesFlashDL = 0[m
[32m+[m[32mSkipProgOnCRCMatch = 1[m
[32m+[m[32mVerifyDownload = 1[m
[32m+[m[32mAllowCaching = 1[m
[32m+[m[32mEnableFlashDL = 2[m
[32m+[m[32mOverride = 0[m
[32m+[m[32mDevice="UNSPECIFIED"[m
[32m+[m[32m[GENERAL][m
[32m+[m[32mWorkRAMSize = 0x00[m
[32m+[m[32mWorkRAMAddr = 0x00[m
[32m+[m[32mRAMUsageLimit = 0x00[m
[32m+[m[32m[SWO][m
[32m+[m[32mSWOLogFile=""[m
[32m+[m[32m[MEM][m
[32m+[m[32mRdOverrideOrMask = 0x00[m
[32m+[m[32mRdOverrideAndMask = 0xFFFFFFFF[m
[32m+[m[32mRdOverrideAddr = 0xFFFFFFFF[m
[32m+[m[32mWrOverrideOrMask = 0x00[m
[32m+[m[32mWrOverrideAndMask = 0xFFFFFFFF[m
[32m+[m[32mWrOverrideAddr = 0xFFFFFFFF[m
[1mdiff --git a/Libraries/CMSIS/core_cm3.c b/Libraries/CMSIS/core_cm3.c[m
[1mnew file mode 100644[m
[1mindex 0000000..fcff0d1[m
[1m--- /dev/null[m
[1m+++ b/Libraries/CMSIS/core_cm3.c[m
[36m@@ -0,0 +1,784 @@[m
[32m+[m[32m/**************************************************************************//**[m
[32m+[m[32m * @file     core_cm3.c[m
[32m+[m[32m * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Source File[m
[32m+[m[32m * @version  V1.30[m
[32m+[m[32m * @date     30. October 2009[m
[32m+[m[32m *[m
[32m+[m[32m * @note[m
[32m+[m[32m * Copyright (C) 2009 ARM Limited. All rights reserved.[m
[32m+[m[32m *[m
[32m+[m[32m * @par[m
[32m+[m[32m * ARM Limited (ARM) is supplying this software for use with Cortex-M[m[41m [m
[32m+[m[32m * processor based microcontrollers.  This file can be freely distributed[m[41m [m
[32m+[m[32m * within development tools that are supporting such ARM based processors.[m[41m [m
[32m+[m[32m *[m
[32m+[m[32m * @par[m
[32m+[m[32m * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED[m
[32m+[m[32m * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF[m
[32m+[m[32m * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.[m
[32m+[m[32m * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR[m
[32m+[m[32m * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.[m
[32m+[m[32m *[m
[32m+[m[32m ******************************************************************************/[m
[32m+[m
[32m+[m[32m#include <stdint.h>[m
[32m+[m
[32m+[m[32m/* define compiler specific symbols */[m
[32m+[m[32m#if defined ( __CC_ARM   )[m
[32m+[m[32m  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */[m
[32m+[m[32m  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */[m
[32m+[m
[32m+[m[32m#elif defined ( __ICCARM__ )[m
[32m+[m[32m  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */[m
[32m+[m[32m  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */[m
[32m+[m
[32m+[m[32m#elif defined   (  __GNUC__  )[m
[32m+[m[32m  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */[m
[32m+[m[32m  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */[m
[32m+[m
[32m+[m[32m#elif defined   (  __TASKING__  )[m
[32m+[m[32m  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */[m
[32m+[m[32m  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m/* ###################  Compiler specific Intrinsics  ########################### */[m
[32m+[m
[32m+[m[32m#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/[m
[32m+[m[32m/* ARM armcc specific functions */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return ProcessStackPointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the actual process stack pointer[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t __get_PSP(void)[m
[32m+[m[32m{[m
[32m+[m[32m  mrs r0, psp[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfProcStack  Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value ProcessStackPointer to the MSP[m[41m [m
[32m+[m[32m * (process stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __set_PSP(uint32_t topOfProcStack)[m
[32m+[m[32m{[m
[32m+[m[32m  msr psp, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the current value of the MSP (main stack pointer)[m
[32m+[m[32m * Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t __get_MSP(void)[m
[32m+[m[32m{[m
[32m+[m[32m  mrs r0, msp[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfMainStack  Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value mainStackPointer to the MSP[m[41m [m
[32m+[m[32m * (main stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __set_MSP(uint32_t mainStackPointer)[m
[32m+[m[32m{[m
[32m+[m[32m  msr msp, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in unsigned short value[m
[32m+[m[32m *[m
[32m+[m[32m * @param   value  value to reverse[m
[32m+[m[32m * @return         reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in unsigned short value[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t __REV16(uint16_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  rev16 r0, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m *[m
[32m+[m[32m * @param   value  value to reverse[m
[32m+[m[32m * @return         reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m */[m
[32m+[m[32m__ASM int32_t __REVSH(int16_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  revsh r0, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m#if (__ARMCC_VERSION < 400000)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Remove the exclusive lock created by ldrex[m
[32m+[m[32m *[m
[32m+[m[32m * Removes the exclusive lock which is created by ldrex.[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __CLREX(void)[m
[32m+[m[32m{[m
[32m+[m[32m  clrex[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @return BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the base priority register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t  __get_BASEPRI(void)[m
[32m+[m[32m{[m
[32m+[m[32m  mrs r0, basepri[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  basePri  BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Set the base priority register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __set_BASEPRI(uint32_t basePri)[m
[32m+[m[32m{[m
[32m+[m[32m  msr basepri, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return state of the priority mask bit from the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t __get_PRIMASK(void)[m
[32m+[m[32m{[m
[32m+[m[32m  mrs r0, primask[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  priMask  PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority mask bit in the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __set_PRIMASK(uint32_t priMask)[m
[32m+[m[32m{[m
[32m+[m[32m  msr primask, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return FaultMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t  __get_FAULTMASK(void)[m
[32m+[m[32m{[m
[32m+[m[32m  mrs r0, faultmask[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  faultMask  faultMask value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __set_FAULTMASK(uint32_t faultMask)[m
[32m+[m[32m{[m
[32m+[m[32m  msr faultmask, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Control Register value[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @return Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the control register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM uint32_t __get_CONTROL(void)[m
[32m+[m[32m{[m
[32m+[m[32m  mrs r0, control[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Control Register value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  control  Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the control register[m
[32m+[m[32m */[m
[32m+[m[32m__ASM void __set_CONTROL(uint32_t control)[m
[32m+[m[32m{[m
[32m+[m[32m  msr control, r0[m
[32m+[m[32m  bx lr[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#endif /* __ARMCC_VERSION  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/[m
[32m+[m[32m/* IAR iccarm specific functions */[m
[32m+[m[32m#pragma diag_suppress=Pe940[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return ProcessStackPointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the actual process stack pointer[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_PSP(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("mrs r0, psp");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfProcStack  Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value ProcessStackPointer to the MSP[m[41m [m
[32m+[m[32m * (process stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_PSP(uint32_t topOfProcStack)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("msr psp, r0");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the current value of the MSP (main stack pointer)[m
[32m+[m[32m * Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_MSP(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("mrs r0, msp");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfMainStack  Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value mainStackPointer to the MSP[m[41m [m
[32m+[m[32m * (main stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_MSP(uint32_t topOfMainStack)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("msr msp, r0");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in unsigned short value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in unsigned short value[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __REV16(uint16_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("rev16 r0, r0");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse bit order of value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse bit order of value[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __RBIT(uint32_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("rbit r0, r0");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 8 bit values)[m
[32m+[m[32m */[m
[32m+[m[32muint8_t __LDREXB(uint8_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("ldrexb r0, [r0]");[m
[32m+[m[32m  __ASM("bx lr");[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint16_t __LDREXH(uint16_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("ldrexh r0, [r0]");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __LDREXW(uint32_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("ldrex r0, [r0]");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 8 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __STREXB(uint8_t value, uint8_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("strexb r0, r0, [r1]");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __STREXH(uint16_t value, uint16_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("strexh r0, r0, [r1]");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __STREXW(uint32_t value, uint32_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM("strex r0, r0, [r1]");[m
[32m+[m[32m  __ASM("bx lr");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#pragma diag_default=Pe940[m
[32m+[m
[32m+[m
[32m+[m[32m#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/[m
[32m+[m[32m/* GNU gcc specific functions */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return ProcessStackPointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the actual process stack pointer[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_PSP(void) __attribute__( ( naked ) );[m
[32m+[m[32muint32_t __get_PSP(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m
[32m+[m[32m  __ASM volatile ("MRS %0, psp\n\t"[m[41m [m
[32m+[m[32m                  "MOV r0, %0 \n\t"[m
[32m+[m[32m                  "BX  lr     \n\t"  : "=r" (result) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfProcStack  Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value ProcessStackPointer to the MSP[m[41m [m
[32m+[m[32m * (process stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_PSP(uint32_t topOfProcStack) __attribute__( ( naked ) );[m
[32m+[m[32mvoid __set_PSP(uint32_t topOfProcStack)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM volatile ("MSR psp, %0\n\t"[m
[32m+[m[32m                  "BX  lr     \n\t" : : "r" (topOfProcStack) );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the current value of the MSP (main stack pointer)[m
[32m+[m[32m * Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_MSP(void) __attribute__( ( naked ) );[m
[32m+[m[32muint32_t __get_MSP(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m
[32m+[m[32m  __ASM volatile ("MRS %0, msp\n\t"[m[41m [m
[32m+[m[32m                  "MOV r0, %0 \n\t"[m
[32m+[m[32m                  "BX  lr     \n\t"  : "=r" (result) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfMainStack  Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value mainStackPointer to the MSP[m[41m [m
[32m+[m[32m * (main stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_MSP(uint32_t topOfMainStack) __attribute__( ( naked ) );[m
[32m+[m[32mvoid __set_MSP(uint32_t topOfMainStack)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM volatile ("MSR msp, %0\n\t"[m
[32m+[m[32m                  "BX  lr     \n\t" : : "r" (topOfMainStack) );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @return BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the base priority register[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_BASEPRI(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  basePri  BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Set the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_BASEPRI(uint32_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM volatile ("MSR basepri, %0" : : "r" (value) );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return state of the priority mask bit from the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_PRIMASK(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m
[32m+[m[32m  __ASM volatile ("MRS %0, primask" : "=r" (result) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  priMask  PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority mask bit in the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_PRIMASK(uint32_t priMask)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return FaultMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_FAULTMASK(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  faultMask  faultMask value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_FAULTMASK(uint32_t faultMask)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Control Register value[m
[32m+[m[32m*[m[41m [m
[32m+[m[32m*  @return Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the control register[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __get_CONTROL(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m
[32m+[m[32m  __ASM volatile ("MRS %0, control" : "=r" (result) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Control Register value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  control  Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the control register[m
[32m+[m[32m */[m
[32m+[m[32mvoid __set_CONTROL(uint32_t control)[m
[32m+[m[32m{[m
[32m+[m[32m  __ASM volatile ("MSR control, %0" : : "r" (control) );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in integer value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in integer value[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __REV(uint32_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in unsigned short value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in unsigned short value[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __REV16(uint16_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m */[m
[32m+[m[32mint32_t __REVSH(int16_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );[m
[32m+[m[32m  return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse bit order of value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse bit order of value[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __RBIT(uint32_t value)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 8 bit value[m
[32m+[m[32m */[m
[32m+[m[32muint8_t __LDREXB(uint8_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m    uint8_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint16_t __LDREXH(uint16_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m    uint16_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __LDREXW(uint32_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m    uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 8 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __STREXB(uint8_t value, uint8_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m   uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("strexb %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __STREXH(uint16_t value, uint16_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m   uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("strexh %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32muint32_t __STREXW(uint32_t value, uint32_t *addr)[m
[32m+[m[32m{[m
[32m+[m[32m   uint32_t result=0;[m
[32m+[m[41m  [m
[32m+[m[32m   __ASM volatile ("strex %0, %2, [%1]" : "=r" (result) : "r" (addr), "r" (value) );[m
[32m+[m[32m   return(result);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/[m
[32m+[m[32m/* TASKING carm specific functions */[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * The CMSIS functions have been implemented as intrinsics in the compiler.[m
[32m+[m[32m * Please use "carm -?i" to get an up to date list of all instrinsics,[m
[32m+[m[32m * Including the CMSIS ones.[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m#endif[m
[1mdiff --git a/Libraries/CMSIS/core_cm3.h b/Libraries/CMSIS/core_cm3.h[m
[1mnew file mode 100644[m
[1mindex 0000000..7ab7b4b[m
[1m--- /dev/null[m
[1m+++ b/Libraries/CMSIS/core_cm3.h[m
[36m@@ -0,0 +1,1818 @@[m
[32m+[m[32m/**************************************************************************//**[m
[32m+[m[32m * @file     core_cm3.h[m
[32m+[m[32m * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File[m
[32m+[m[32m * @version  V1.30[m
[32m+[m[32m * @date     30. October 2009[m
[32m+[m[32m *[m
[32m+[m[32m * @note[m
[32m+[m[32m * Copyright (C) 2009 ARM Limited. All rights reserved.[m
[32m+[m[32m *[m
[32m+[m[32m * @par[m
[32m+[m[32m * ARM Limited (ARM) is supplying this software for use with Cortex-M[m[41m [m
[32m+[m[32m * processor based microcontrollers.  This file can be freely distributed[m[41m [m
[32m+[m[32m * within development tools that are supporting such ARM based processors.[m[41m [m
[32m+[m[32m *[m
[32m+[m[32m * @par[m
[32m+[m[32m * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED[m
[32m+[m[32m * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF[m
[32m+[m[32m * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.[m
[32m+[m[32m * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR[m
[32m+[m[32m * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.[m
[32m+[m[32m *[m
[32m+[m[32m ******************************************************************************/[m
[32m+[m
[32m+[m[32m#ifndef __CM3_CORE_H__[m
[32m+[m[32m#define __CM3_CORE_H__[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_core_LintCinfiguration CMSIS CM3 Core Lint Configuration[m
[32m+[m[32m *[m
[32m+[m[32m * List of Lint messages which will be suppressed and not shown:[m
[32m+[m[32m *   - Error 10: \n[m
[32m+[m[32m *     register uint32_t __regBasePri         __asm("basepri"); \n[m
[32m+[m[32m *     Error 10: Expecting ';'[m
[32m+[m[32m * .[m
[32m+[m[32m *   - Error 530: \n[m
[32m+[m[32m *     return(__regBasePri); \n[m
[32m+[m[32m *     Warning 530: Symbol '__regBasePri' (line 264) not initialized[m
[32m+[m[32m * .[m[41m [m
[32m+[m[32m *   - Error 550: \n[m
[32m+[m[32m *     __regBasePri = (basePri & 0x1ff); \n[m
[32m+[m[32m *     Warning 550: Symbol '__regBasePri' (line 271) not accessed[m
[32m+[m[32m * .[m
[32m+[m[32m *   - Error 754: \n[m
[32m+[m[32m *     uint32_t RESERVED0[24]; \n[m
[32m+[m[32m *     Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced[m
[32m+[m[32m * .[m
[32m+[m[32m *   - Error 750: \n[m
[32m+[m[32m *     #define __CM3_CORE_H__ \n[m
[32m+[m[32m *     Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced[m
[32m+[m[32m * .[m
[32m+[m[32m *   - Error 528: \n[m
[32m+[m[32m *     static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n[m
[32m+[m[32m *     Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced[m
[32m+[m[32m * .[m
[32m+[m[32m *   - Error 751: \n[m
[32m+[m[32m *     } InterruptType_Type; \n[m
[32m+[m[32m *     Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced[m
[32m+[m[32m * .[m
[32m+[m[32m * Note:  To re-enable a Message, insert a space before 'lint' *[m
[32m+[m[32m *[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m/*lint -save */[m
[32m+[m[32m/*lint -e10  */[m
[32m+[m[32m/*lint -e530 */[m
[32m+[m[32m/*lint -e550 */[m
[32m+[m[32m/*lint -e754 */[m
[32m+[m[32m/*lint -e750 */[m
[32m+[m[32m/*lint -e528 */[m
[32m+[m[32m/*lint -e751 */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_core_definitions CM3 Core Definitions[m
[32m+[m[32m  This file defines all structures and symbols for CMSIS core:[m
[32m+[m[32m    - CMSIS version number[m
[32m+[m[32m    - Cortex-M core registers and bitfields[m
[32m+[m[32m    - Cortex-M core peripheral base address[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m[41m [m
[32m+[m
[32m+[m[32m#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */[m
[32m+[m[32m#define __CM3_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */[m
[32m+[m[32m#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */[m
[32m+[m
[32m+[m[32m#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */[m
[32m+[m
[32m+[m[32m#include <stdint.h>                           /* Include standard types */[m
[32m+[m
[32m+[m[32m#if defined (__ICCARM__)[m
[32m+[m[32m  #include <intrinsics.h>                     /* IAR Intrinsics   */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m#ifndef __NVIC_PRIO_BITS[m
[32m+[m[32m  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * IO definitions[m
[32m+[m[32m *[m
[32m+[m[32m * define access restrictions to peripheral registers[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m  #define     __I     volatile                /*!< defines 'read only' permissions      */[m
[32m+[m[32m#else[m
[32m+[m[32m  #define     __I     volatile const          /*!< defines 'read only' permissions      */[m
[32m+[m[32m#endif[m
[32m+[m[32m#define     __O     volatile                  /*!< defines 'write only' permissions     */[m
[32m+[m[32m#define     __IO    volatile                  /*!< defines 'read / write' permissions   */[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/*******************************************************************************[m
[32m+[m[32m *                 Register Abstraction[m
[32m+[m[32m ******************************************************************************/[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_core_register CMSIS CM3 Core Register[m
[32m+[m[32m @{[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_NVIC CMSIS CM3 NVIC[m
[32m+[m[32m  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t ISER[8];                      /*!< Offset: 0x000  Interrupt Set Enable Register           */[m
[32m+[m[32m       uint32_t RESERVED0[24];[m[41m                                   [m
[32m+[m[32m  __IO uint32_t ICER[8];                      /*!< Offset: 0x080  Interrupt Clear Enable Register         */[m
[32m+[m[32m       uint32_t RSERVED1[24];[m[41m                                    [m
[32m+[m[32m  __IO uint32_t ISPR[8];                      /*!< Offset: 0x100  Interrupt Set Pending Register          */[m
[32m+[m[32m       uint32_t RESERVED2[24];[m[41m                                   [m
[32m+[m[32m  __IO uint32_t ICPR[8];                      /*!< Offset: 0x180  Interrupt Clear Pending Register        */[m
[32m+[m[32m       uint32_t RESERVED3[24];[m[41m                                   [m
[32m+[m[32m  __IO uint32_t IABR[8];                      /*!< Offset: 0x200  Interrupt Active bit Register           */[m
[32m+[m[32m       uint32_t RESERVED4[56];[m[41m                                   [m
[32m+[m[32m  __IO uint8_t  IP[240];                      /*!< Offset: 0x300  Interrupt Priority Register (8Bit wide) */[m
[32m+[m[32m       uint32_t RESERVED5[644];[m[41m                                  [m
[32m+[m[32m  __O  uint32_t STIR;                         /*!< Offset: 0xE00  Software Trigger Interrupt Register     */[m
[32m+[m[32m}  NVIC_Type;[m[41m                                               [m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_NVIC */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_SCB CMSIS CM3 SCB[m
[32m+[m[32m  memory mapped structure for System Control Block (SCB)[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */[m
[32m+[m[32m  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */[m
[32m+[m[32m  __IO uint32_t VTOR;                         /*!< Offset: 0x08  Vector Table Offset Register                          */[m
[32m+[m[32m  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */[m
[32m+[m[32m  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */[m
[32m+[m[32m  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */[m
[32m+[m[32m  __IO uint8_t  SHP[12];                      /*!< Offset: 0x18  System Handlers Priority Registers (4-7, 8-11, 12-15) */[m
[32m+[m[32m  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */[m
[32m+[m[32m  __IO uint32_t CFSR;                         /*!< Offset: 0x28  Configurable Fault Status Register                    */[m
[32m+[m[32m  __IO uint32_t HFSR;                         /*!< Offset: 0x2C  Hard Fault Status Register                            */[m
[32m+[m[32m  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */[m
[32m+[m[32m  __IO uint32_t MMFAR;                        /*!< Offset: 0x34  Mem Manage Address Register                           */[m
[32m+[m[32m  __IO uint32_t BFAR;                         /*!< Offset: 0x38  Bus Fault Address Register                            */[m
[32m+[m[32m  __IO uint32_t AFSR;                         /*!< Offset: 0x3C  Auxiliary Fault Status Register                       */[m
[32m+[m[32m  __I  uint32_t PFR[2];                       /*!< Offset: 0x40  Processor Feature Register                            */[m
[32m+[m[32m  __I  uint32_t DFR;                          /*!< Offset: 0x48  Debug Feature Register                                */[m
[32m+[m[32m  __I  uint32_t ADR;                          /*!< Offset: 0x4C  Auxiliary Feature Register                            */[m
[32m+[m[32m  __I  uint32_t MMFR[4];                      /*!< Offset: 0x50  Memory Model Feature Register                         */[m
[32m+[m[32m  __I  uint32_t ISAR[5];                      /*!< Offset: 0x60  ISA Feature Register                                  */[m
[32m+[m[32m} SCB_Type;[m[41m                                                [m
[32m+[m
[32m+[m[32m/* SCB CPUID Register Definitions */[m
[32m+[m[32m#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */[m
[32m+[m[32m#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */[m
[32m+[m[32m#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */[m
[32m+[m[32m#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */[m
[32m+[m[32m#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */[m
[32m+[m
[32m+[m[32m/* SCB Interrupt Control State Register Definitions */[m
[32m+[m[32m#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */[m
[32m+[m[32m#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */[m
[32m+[m[32m#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */[m
[32m+[m[32m#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */[m
[32m+[m[32m#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */[m
[32m+[m[32m#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */[m
[32m+[m[32m#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */[m
[32m+[m[32m#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */[m
[32m+[m[32m#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */[m
[32m+[m[32m#define SCB_ICSR_RETTOBASE_Msk             (1ul << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */[m
[32m+[m
[32m+[m[32m#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */[m
[32m+[m[32m#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */[m
[32m+[m
[32m+[m[32m/* SCB Interrupt Control State Register Definitions */[m
[32m+[m[32m#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */[m
[32m+[m[32m#define SCB_VTOR_TBLBASE_Msk               (0x1FFul << SCB_VTOR_TBLBASE_Pos)              /*!< SCB VTOR: TBLBASE Mask */[m
[32m+[m
[32m+[m[32m#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */[m
[32m+[m[32m#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFul << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */[m
[32m+[m
[32m+[m[32m/* SCB Application Interrupt and Reset Control Register Definitions */[m
[32m+[m[32m#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */[m
[32m+[m[32m#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */[m
[32m+[m
[32m+[m[32m#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */[m
[32m+[m[32m#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */[m
[32m+[m[32m#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */[m
[32m+[m
[32m+[m[32m#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */[m
[32m+[m[32m#define SCB_AIRCR_PRIGROUP_Msk             (7ul << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */[m
[32m+[m
[32m+[m[32m#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */[m
[32m+[m[32m#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */[m
[32m+[m
[32m+[m[32m#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */[m
[32m+[m[32m#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */[m
[32m+[m
[32m+[m[32m#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */[m
[32m+[m[32m#define SCB_AIRCR_VECTRESET_Msk            (1ul << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */[m
[32m+[m
[32m+[m[32m/* SCB System Control Register Definitions */[m
[32m+[m[32m#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */[m
[32m+[m[32m#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */[m
[32m+[m[32m#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */[m
[32m+[m[32m#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */[m
[32m+[m
[32m+[m[32m/* SCB Configuration Control Register Definitions */[m
[32m+[m[32m#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */[m
[32m+[m[32m#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */[m
[32m+[m[32m#define SCB_CCR_BFHFNMIGN_Msk              (1ul << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */[m
[32m+[m[32m#define SCB_CCR_DIV_0_TRP_Msk              (1ul << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */[m
[32m+[m[32m#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */[m
[32m+[m[32m#define SCB_CCR_USERSETMPEND_Msk           (1ul << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */[m
[32m+[m[32m#define SCB_CCR_NONBASETHRDENA_Msk         (1ul << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */[m
[32m+[m
[32m+[m[32m/* SCB System Handler Control and State Register Definitions */[m
[32m+[m[32m#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */[m
[32m+[m[32m#define SCB_SHCSR_USGFAULTENA_Msk          (1ul << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */[m
[32m+[m[32m#define SCB_SHCSR_BUSFAULTENA_Msk          (1ul << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */[m
[32m+[m[32m#define SCB_SHCSR_MEMFAULTENA_Msk          (1ul << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */[m
[32m+[m[32m#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */[m
[32m+[m[32m#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1ul << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */[m
[32m+[m[32m#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1ul << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */[m
[32m+[m[32m#define SCB_SHCSR_USGFAULTPENDED_Msk       (1ul << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */[m
[32m+[m[32m#define SCB_SHCSR_SYSTICKACT_Msk           (1ul << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */[m
[32m+[m[32m#define SCB_SHCSR_PENDSVACT_Msk            (1ul << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */[m
[32m+[m[32m#define SCB_SHCSR_MONITORACT_Msk           (1ul << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */[m
[32m+[m[32m#define SCB_SHCSR_SVCALLACT_Msk            (1ul << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */[m
[32m+[m[41m                                     [m
[32m+[m[32m#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */[m
[32m+[m[32m#define SCB_SHCSR_USGFAULTACT_Msk          (1ul << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */[m
[32m+[m[32m#define SCB_SHCSR_BUSFAULTACT_Msk          (1ul << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */[m
[32m+[m[32m#define SCB_SHCSR_MEMFAULTACT_Msk          (1ul << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */[m
[32m+[m
[32m+[m[32m/* SCB Configurable Fault Status Registers Definitions */[m
[32m+[m[32m#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */[m
[32m+[m[32m#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFul << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */[m
[32m+[m[32m#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFul << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */[m
[32m+[m
[32m+[m[32m#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */[m
[32m+[m[32m#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFul << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */[m
[32m+[m
[32m+[m[32m/* SCB Hard Fault Status Registers Definitions */[m
[32m+[m[32m#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */[m
[32m+[m[32m#define SCB_HFSR_DEBUGEVT_Msk              (1ul << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */[m
[32m+[m[32m#define SCB_HFSR_FORCED_Msk                (1ul << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */[m
[32m+[m
[32m+[m[32m#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */[m
[32m+[m[32m#define SCB_HFSR_VECTTBL_Msk               (1ul << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */[m
[32m+[m
[32m+[m[32m/* SCB Debug Fault Status Register Definitions */[m
[32m+[m[32m#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */[m
[32m+[m[32m#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */[m
[32m+[m
[32m+[m[32m#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */[m
[32m+[m[32m#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */[m
[32m+[m
[32m+[m[32m#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */[m
[32m+[m[32m#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */[m
[32m+[m
[32m+[m[32m#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */[m
[32m+[m[32m#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */[m
[32m+[m
[32m+[m[32m#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */[m
[32m+[m[32m#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_SCB */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_SysTick CMSIS CM3 SysTick[m
[32m+[m[32m  memory mapped structure for SysTick[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */[m
[32m+[m[32m  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */[m
[32m+[m[32m  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */[m
[32m+[m[32m  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */[m
[32m+[m[32m} SysTick_Type;[m
[32m+[m
[32m+[m[32m/* SysTick Control / Status Register Definitions */[m
[32m+[m[32m#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */[m
[32m+[m[32m#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */[m
[32m+[m
[32m+[m[32m#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */[m
[32m+[m[32m#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */[m
[32m+[m
[32m+[m[32m#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */[m
[32m+[m[32m#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */[m
[32m+[m
[32m+[m[32m#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */[m
[32m+[m[32m#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */[m
[32m+[m
[32m+[m[32m/* SysTick Reload Register Definitions */[m
[32m+[m[32m#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */[m
[32m+[m[32m#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */[m
[32m+[m
[32m+[m[32m/* SysTick Current Register Definitions */[m
[32m+[m[32m#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */[m
[32m+[m[32m#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */[m
[32m+[m
[32m+[m[32m/* SysTick Calibration Register Definitions */[m
[32m+[m[32m#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */[m
[32m+[m[32m#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */[m
[32m+[m
[32m+[m[32m#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */[m
[32m+[m[32m#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */[m
[32m+[m
[32m+[m[32m#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */[m
[32m+[m[32m#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_SysTick */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_ITM CMSIS CM3 ITM[m
[32m+[m[32m  memory mapped structure for Instrumentation Trace Macrocell (ITM)[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __O  union[m[41m  [m
[32m+[m[32m  {[m
[32m+[m[32m    __O  uint8_t    u8;                       /*!< Offset:       ITM Stimulus Port 8-bit                   */[m
[32m+[m[32m    __O  uint16_t   u16;                      /*!< Offset:       ITM Stimulus Port 16-bit                  */[m
[32m+[m[32m    __O  uint32_t   u32;                      /*!< Offset:       ITM Stimulus Port 32-bit                  */[m
[32m+[m[32m  }  PORT [32];                               /*!< Offset: 0x00  ITM Stimulus Port Registers               */[m
[32m+[m[32m       uint32_t RESERVED0[864];[m[41m                                 [m
[32m+[m[32m  __IO uint32_t TER;                          /*!< Offset:       ITM Trace Enable Register                 */[m
[32m+[m[32m       uint32_t RESERVED1[15];[m[41m                                  [m
[32m+[m[32m  __IO uint32_t TPR;                          /*!< Offset:       ITM Trace Privilege Register              */[m
[32m+[m[32m       uint32_t RESERVED2[15];[m[41m                                  [m
[32m+[m[32m  __IO uint32_t TCR;                          /*!< Offset:       ITM Trace Control Register                */[m
[32m+[m[32m       uint32_t RESERVED3[29];[m[41m                                  [m
[32m+[m[32m  __IO uint32_t IWR;                          /*!< Offset:       ITM Integration Write Register            */[m
[32m+[m[32m  __IO uint32_t IRR;                          /*!< Offset:       ITM Integration Read Register             */[m
[32m+[m[32m  __IO uint32_t IMCR;                         /*!< Offset:       ITM Integration Mode Control Register     */[m
[32m+[m[32m       uint32_t RESERVED4[43];[m[41m                                  [m
[32m+[m[32m  __IO uint32_t LAR;                          /*!< Offset:       ITM Lock Access Register                  */[m
[32m+[m[32m  __IO uint32_t LSR;                          /*!< Offset:       ITM Lock Status Register                  */[m
[32m+[m[32m       uint32_t RESERVED5[6];[m[41m                                   [m
[32m+[m[32m  __I  uint32_t PID4;                         /*!< Offset:       ITM Peripheral Identification Register #4 */[m
[32m+[m[32m  __I  uint32_t PID5;                         /*!< Offset:       ITM Peripheral Identification Register #5 */[m
[32m+[m[32m  __I  uint32_t PID6;                         /*!< Offset:       ITM Peripheral Identification Register #6 */[m
[32m+[m[32m  __I  uint32_t PID7;                         /*!< Offset:       ITM Peripheral Identification Register #7 */[m
[32m+[m[32m  __I  uint32_t PID0;                         /*!< Offset:       ITM Peripheral Identification Register #0 */[m
[32m+[m[32m  __I  uint32_t PID1;                         /*!< Offset:       ITM Peripheral Identification Register #1 */[m
[32m+[m[32m  __I  uint32_t PID2;                         /*!< Offset:       ITM Peripheral Identification Register #2 */[m
[32m+[m[32m  __I  uint32_t PID3;                         /*!< Offset:       ITM Peripheral Identification Register #3 */[m
[32m+[m[32m  __I  uint32_t CID0;                         /*!< Offset:       ITM Component  Identification Register #0 */[m
[32m+[m[32m  __I  uint32_t CID1;                         /*!< Offset:       ITM Component  Identification Register #1 */[m
[32m+[m[32m  __I  uint32_t CID2;                         /*!< Offset:       ITM Component  Identification Register #2 */[m
[32m+[m[32m  __I  uint32_t CID3;                         /*!< Offset:       ITM Component  Identification Register #3 */[m
[32m+[m[32m} ITM_Type;[m[41m                                                [m
[32m+[m
[32m+[m[32m/* ITM Trace Privilege Register Definitions */[m
[32m+[m[32m#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */[m
[32m+[m[32m#define ITM_TPR_PRIVMASK_Msk               (0xFul << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */[m
[32m+[m
[32m+[m[32m/* ITM Trace Control Register Definitions */[m
[32m+[m[32m#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */[m
[32m+[m[32m#define ITM_TCR_BUSY_Msk                   (1ul << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_ATBID_Pos                  16                                             /*!< ITM TCR: ATBID Position */[m
[32m+[m[32m#define ITM_TCR_ATBID_Msk                  (0x7Ful << ITM_TCR_ATBID_Pos)                  /*!< ITM TCR: ATBID Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */[m
[32m+[m[32m#define ITM_TCR_TSPrescale_Msk             (3ul << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */[m
[32m+[m[32m#define ITM_TCR_SWOENA_Msk                 (1ul << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */[m
[32m+[m[32m#define ITM_TCR_DWTENA_Msk                 (1ul << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */[m
[32m+[m[32m#define ITM_TCR_SYNCENA_Msk                (1ul << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */[m
[32m+[m[32m#define ITM_TCR_TSENA_Msk                  (1ul << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */[m
[32m+[m
[32m+[m[32m#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */[m
[32m+[m[32m#define ITM_TCR_ITMENA_Msk                 (1ul << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */[m
[32m+[m
[32m+[m[32m/* ITM Integration Write Register Definitions */[m
[32m+[m[32m#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */[m
[32m+[m[32m#define ITM_IWR_ATVALIDM_Msk               (1ul << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */[m
[32m+[m
[32m+[m[32m/* ITM Integration Read Register Definitions */[m
[32m+[m[32m#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */[m
[32m+[m[32m#define ITM_IRR_ATREADYM_Msk               (1ul << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */[m
[32m+[m
[32m+[m[32m/* ITM Integration Mode Control Register Definitions */[m
[32m+[m[32m#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */[m
[32m+[m[32m#define ITM_IMCR_INTEGRATION_Msk           (1ul << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */[m
[32m+[m
[32m+[m[32m/* ITM Lock Status Register Definitions */[m
[32m+[m[32m#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */[m
[32m+[m[32m#define ITM_LSR_ByteAcc_Msk                (1ul << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */[m
[32m+[m
[32m+[m[32m#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */[m
[32m+[m[32m#define ITM_LSR_Access_Msk                 (1ul << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */[m
[32m+[m
[32m+[m[32m#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */[m
[32m+[m[32m#define ITM_LSR_Present_Msk                (1ul << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_ITM */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_InterruptType CMSIS CM3 Interrupt Type[m
[32m+[m[32m  memory mapped structure for Interrupt Type[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m       uint32_t RESERVED0;[m
[32m+[m[32m  __I  uint32_t ICTR;                         /*!< Offset: 0x04  Interrupt Control Type Register */[m
[32m+[m[32m#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))[m
[32m+[m[32m  __IO uint32_t ACTLR;                        /*!< Offset: 0x08  Auxiliary Control Register      */[m
[32m+[m[32m#else[m
[32m+[m[32m       uint32_t RESERVED1;[m
[32m+[m[32m#endif[m
[32m+[m[32m} InterruptType_Type;[m
[32m+[m
[32m+[m[32m/* Interrupt Controller Type Register Definitions */[m
[32m+[m[32m#define InterruptType_ICTR_INTLINESNUM_Pos  0                                             /*!< InterruptType ICTR: INTLINESNUM Position */[m
[32m+[m[32m#define InterruptType_ICTR_INTLINESNUM_Msk (0x1Ful << InterruptType_ICTR_INTLINESNUM_Pos) /*!< InterruptType ICTR: INTLINESNUM Mask */[m
[32m+[m
[32m+[m[32m/* Auxiliary Control Register Definitions */[m
[32m+[m[32m#define InterruptType_ACTLR_DISFOLD_Pos     2                                             /*!< InterruptType ACTLR: DISFOLD Position */[m
[32m+[m[32m#define InterruptType_ACTLR_DISFOLD_Msk    (1ul << InterruptType_ACTLR_DISFOLD_Pos)       /*!< InterruptType ACTLR: DISFOLD Mask */[m
[32m+[m
[32m+[m[32m#define InterruptType_ACTLR_DISDEFWBUF_Pos  1                                             /*!< InterruptType ACTLR: DISDEFWBUF Position */[m
[32m+[m[32m#define InterruptType_ACTLR_DISDEFWBUF_Msk (1ul << InterruptType_ACTLR_DISDEFWBUF_Pos)    /*!< InterruptType ACTLR: DISDEFWBUF Mask */[m
[32m+[m
[32m+[m[32m#define InterruptType_ACTLR_DISMCYCINT_Pos  0                                             /*!< InterruptType ACTLR: DISMCYCINT Position */[m
[32m+[m[32m#define InterruptType_ACTLR_DISMCYCINT_Msk (1ul << InterruptType_ACTLR_DISMCYCINT_Pos)    /*!< InterruptType ACTLR: DISMCYCINT Mask */[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_InterruptType */[m
[32m+[m
[32m+[m
[32m+[m[32m#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_MPU CMSIS CM3 MPU[m
[32m+[m[32m  memory mapped structure for Memory Protection Unit (MPU)[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __I  uint32_t TYPE;                         /*!< Offset: 0x00  MPU Type Register                              */[m
[32m+[m[32m  __IO uint32_t CTRL;                         /*!< Offset: 0x04  MPU Control Register                           */[m
[32m+[m[32m  __IO uint32_t RNR;                          /*!< Offset: 0x08  MPU Region RNRber Register                     */[m
[32m+[m[32m  __IO uint32_t RBAR;                         /*!< Offset: 0x0C  MPU Region Base Address Register               */[m
[32m+[m[32m  __IO uint32_t RASR;                         /*!< Offset: 0x10  MPU Region Attribute and Size Register         */[m
[32m+[m[32m  __IO uint32_t RBAR_A1;                      /*!< Offset: 0x14  MPU Alias 1 Region Base Address Register       */[m
[32m+[m[32m  __IO uint32_t RASR_A1;                      /*!< Offset: 0x18  MPU Alias 1 Region Attribute and Size Register */[m
[32m+[m[32m  __IO uint32_t RBAR_A2;                      /*!< Offset: 0x1C  MPU Alias 2 Region Base Address Register       */[m
[32m+[m[32m  __IO uint32_t RASR_A2;                      /*!< Offset: 0x20  MPU Alias 2 Region Attribute and Size Register */[m
[32m+[m[32m  __IO uint32_t RBAR_A3;                      /*!< Offset: 0x24  MPU Alias 3 Region Base Address Register       */[m
[32m+[m[32m  __IO uint32_t RASR_A3;                      /*!< Offset: 0x28  MPU Alias 3 Region Attribute and Size Register */[m
[32m+[m[32m} MPU_Type;[m[41m                                                [m
[32m+[m
[32m+[m[32m/* MPU Type Register */[m
[32m+[m[32m#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */[m
[32m+[m[32m#define MPU_TYPE_IREGION_Msk               (0xFFul << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */[m
[32m+[m
[32m+[m[32m#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */[m
[32m+[m[32m#define MPU_TYPE_DREGION_Msk               (0xFFul << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */[m
[32m+[m
[32m+[m[32m#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */[m
[32m+[m[32m#define MPU_TYPE_SEPARATE_Msk              (1ul << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */[m
[32m+[m
[32m+[m[32m/* MPU Control Register */[m
[32m+[m[32m#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */[m
[32m+[m[32m#define MPU_CTRL_PRIVDEFENA_Msk            (1ul << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */[m
[32m+[m
[32m+[m[32m#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */[m
[32m+[m[32m#define MPU_CTRL_HFNMIENA_Msk              (1ul << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */[m
[32m+[m
[32m+[m[32m#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */[m
[32m+[m[32m#define MPU_CTRL_ENABLE_Msk                (1ul << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */[m
[32m+[m
[32m+[m[32m/* MPU Region Number Register */[m
[32m+[m[32m#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */[m
[32m+[m[32m#define MPU_RNR_REGION_Msk                 (0xFFul << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */[m
[32m+[m
[32m+[m[32m/* MPU Region Base Address Register */[m
[32m+[m[32m#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */[m
[32m+[m[32m#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFul << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */[m
[32m+[m[32m#define MPU_RBAR_VALID_Msk                 (1ul << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */[m
[32m+[m[32m#define MPU_RBAR_REGION_Msk                (0xFul << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */[m
[32m+[m
[32m+[m[32m/* MPU Region Attribute and Size Register */[m
[32m+[m[32m#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: XN Position */[m
[32m+[m[32m#define MPU_RASR_XN_Msk                    (1ul << MPU_RASR_XN_Pos)                       /*!< MPU RASR: XN Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: AP Position */[m
[32m+[m[32m#define MPU_RASR_AP_Msk                    (7ul << MPU_RASR_AP_Pos)                       /*!< MPU RASR: AP Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: TEX Position */[m
[32m+[m[32m#define MPU_RASR_TEX_Msk                   (7ul << MPU_RASR_TEX_Pos)                      /*!< MPU RASR: TEX Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: Shareable bit Position */[m
[32m+[m[32m#define MPU_RASR_S_Msk                     (1ul << MPU_RASR_S_Pos)                        /*!< MPU RASR: Shareable bit Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: Cacheable bit Position */[m
[32m+[m[32m#define MPU_RASR_C_Msk                     (1ul << MPU_RASR_C_Pos)                        /*!< MPU RASR: Cacheable bit Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: Bufferable bit Position */[m
[32m+[m[32m#define MPU_RASR_B_Msk                     (1ul << MPU_RASR_B_Pos)                        /*!< MPU RASR: Bufferable bit Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */[m
[32m+[m[32m#define MPU_RASR_SRD_Msk                   (0xFFul << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */[m
[32m+[m[32m#define MPU_RASR_SIZE_Msk                  (0x1Ful << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */[m
[32m+[m
[32m+[m[32m#define MPU_RASR_ENA_Pos                     0                                            /*!< MPU RASR: Region enable bit Position */[m
[32m+[m[32m#define MPU_RASR_ENA_Msk                    (0x1Ful << MPU_RASR_ENA_Pos)                  /*!< MPU RASR: Region enable bit Disable Mask */[m
[32m+[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_MPU */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_CoreDebug CMSIS CM3 Core Debug[m
[32m+[m[32m  memory mapped structure for Core Debug Register[m
[32m+[m[32m  @{[m
[32m+[m[32m */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */[m
[32m+[m[32m  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */[m
[32m+[m[32m  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */[m
[32m+[m[32m  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */[m
[32m+[m[32m} CoreDebug_Type;[m
[32m+[m
[32m+[m[32m/* Debug Halting Control and Status Register */[m
[32m+[m[32m#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1ul << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */[m
[32m+[m[32m#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */[m
[32m+[m
[32m+[m[32m/* Debug Core Register Selector Register */[m
[32m+[m[32m#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */[m
[32m+[m[32m#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */[m
[32m+[m[32m#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */[m
[32m+[m
[32m+[m[32m/* Debug Exception and Monitor Control Register */[m
[32m+[m[32m#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_TRCENA_Msk         (1ul << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_REQ_Msk        (1ul << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_STEP_Msk       (1ul << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_PEND_Msk       (1ul << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_MON_EN_Msk         (1ul << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_INTERR_Msk      (1ul << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1ul << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_STATERR_Msk     (1ul << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1ul << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1ul << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_MMERR_Msk       (1ul << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */[m
[32m+[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */[m
[32m+[m[32m#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_CoreDebug */[m
[32m+[m
[32m+[m
[32m+[m[32m/* Memory mapping of Cortex-M3 Hardware */[m
[32m+[m[32m#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */[m
[32m+[m[32m#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                  */[m
[32m+[m[32m#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */[m
[32m+[m[32m#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */[m
[32m+[m[32m#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */[m
[32m+[m[32m#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */[m
[32m+[m
[32m+[m[32m#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register           */[m
[32m+[m[32m#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */[m
[32m+[m[32m#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */[m
[32m+[m[32m#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */[m
[32m+[m[32m#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct          */[m
[32m+[m[32m#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */[m
[32m+[m
[32m+[m[32m#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)[m
[32m+[m[32m  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit            */[m
[32m+[m[32m  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit            */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_core_register */[m
[32m+[m
[32m+[m
[32m+[m[32m/*******************************************************************************[m
[32m+[m[32m *                Hardware Abstraction Layer[m
[32m+[m[32m ******************************************************************************/[m
[32m+[m
[32m+[m[32m#if defined ( __CC_ARM   )[m
[32m+[m[32m  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */[m
[32m+[m[32m  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */[m
[32m+[m
[32m+[m[32m#elif defined ( __ICCARM__ )[m
[32m+[m[32m  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */[m
[32m+[m[32m  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */[m
[32m+[m
[32m+[m[32m#elif defined   (  __GNUC__  )[m
[32m+[m[32m  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */[m
[32m+[m[32m  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */[m
[32m+[m
[32m+[m[32m#elif defined   (  __TASKING__  )[m
[32m+[m[32m  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */[m
[32m+[m[32m  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m/* ###################  Compiler specific Intrinsics  ########################### */[m
[32m+[m
[32m+[m[32m#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/[m
[32m+[m[32m/* ARM armcc specific functions */[m
[32m+[m
[32m+[m[32m#define __enable_fault_irq                __enable_fiq[m
[32m+[m[32m#define __disable_fault_irq               __disable_fiq[m
[32m+[m
[32m+[m[32m#define __NOP                             __nop[m
[32m+[m[32m#define __WFI                             __wfi[m
[32m+[m[32m#define __WFE                             __wfe[m
[32m+[m[32m#define __SEV                             __sev[m
[32m+[m[32m#define __ISB()                           __isb(0)[m
[32m+[m[32m#define __DSB()                           __dsb(0)[m
[32m+[m[32m#define __DMB()                           __dmb(0)[m
[32m+[m[32m#define __REV                             __rev[m
[32m+[m[32m#define __RBIT                            __rbit[m
[32m+[m[32m#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))[m
[32m+[m[32m#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))[m
[32m+[m[32m#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))[m
[32m+[m[32m#define __STREXB(value, ptr)              __strex(value, ptr)[m
[32m+[m[32m#define __STREXH(value, ptr)              __strex(value, ptr)[m
[32m+[m[32m#define __STREXW(value, ptr)              __strex(value, ptr)[m
[32m+[m
[32m+[m
[32m+[m[32m/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */[m
[32m+[m[32m/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */[m
[32m+[m[32m/* intrinsic void __enable_irq();     */[m
[32m+[m[32m/* intrinsic void __disable_irq();    */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return ProcessStackPointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the actual process stack pointer[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_PSP(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfProcStack  Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value ProcessStackPointer to the MSP[m[41m [m
[32m+[m[32m * (process stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_PSP(uint32_t topOfProcStack);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the current value of the MSP (main stack pointer)[m
[32m+[m[32m * Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_MSP(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfMainStack  Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value mainStackPointer to the MSP[m[41m [m
[32m+[m[32m * (main stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_MSP(uint32_t topOfMainStack);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in unsigned short value[m
[32m+[m[32m *[m
[32m+[m[32m * @param   value  value to reverse[m
[32m+[m[32m * @return         reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in unsigned short value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __REV16(uint16_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m *[m
[32m+[m[32m * @param   value  value to reverse[m
[32m+[m[32m * @return         reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m */[m
[32m+[m[32mextern int32_t __REVSH(int16_t value);[m
[32m+[m
[32m+[m
[32m+[m[32m#if (__ARMCC_VERSION < 400000)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Remove the exclusive lock created by ldrex[m
[32m+[m[32m *[m
[32m+[m[32m * Removes the exclusive lock which is created by ldrex.[m
[32m+[m[32m */[m
[32m+[m[32mextern void __CLREX(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @return BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_BASEPRI(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  basePri  BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Set the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_BASEPRI(uint32_t basePri);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return state of the priority mask bit from the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_PRIMASK(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param   priMask  PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority mask bit in the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_PRIMASK(uint32_t priMask);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return FaultMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_FAULTMASK(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  faultMask faultMask value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_FAULTMASK(uint32_t faultMask);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Control Register value[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @return Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the control register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_CONTROL(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Control Register value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  control  Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the control register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_CONTROL(uint32_t control);[m
[32m+[m
[32m+[m[32m#else  /* (__ARMCC_VERSION >= 400000)  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Remove the exclusive lock created by ldrex[m
[32m+[m[32m *[m
[32m+[m[32m * Removes the exclusive lock which is created by ldrex.[m
[32m+[m[32m */[m
[32m+[m[32m#define __CLREX                           __clrex[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @return BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t  __get_BASEPRI(void)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regBasePri         __ASM("basepri");[m
[32m+[m[32m  return(__regBasePri);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  basePri  BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Set the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void __set_BASEPRI(uint32_t basePri)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regBasePri         __ASM("basepri");[m
[32m+[m[32m  __regBasePri = (basePri & 0xff);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return state of the priority mask bit from the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t __get_PRIMASK(void)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regPriMask         __ASM("primask");[m
[32m+[m[32m  return(__regPriMask);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  priMask  PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority mask bit in the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void __set_PRIMASK(uint32_t priMask)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regPriMask         __ASM("primask");[m
[32m+[m[32m  __regPriMask = (priMask);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return FaultMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t __get_FAULTMASK(void)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regFaultMask       __ASM("faultmask");[m
[32m+[m[32m  return(__regFaultMask);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  faultMask  faultMask value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regFaultMask       __ASM("faultmask");[m
[32m+[m[32m  __regFaultMask = (faultMask & 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Control Register value[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @return Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the control register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t __get_CONTROL(void)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regControl         __ASM("control");[m
[32m+[m[32m  return(__regControl);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Control Register value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  control  Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the control register[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void __set_CONTROL(uint32_t control)[m
[32m+[m[32m{[m
[32m+[m[32m  register uint32_t __regControl         __ASM("control");[m
[32m+[m[32m  __regControl = control;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#endif /* __ARMCC_VERSION  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/[m
[32m+[m[32m/* IAR iccarm specific functions */[m
[32m+[m
[32m+[m[32m#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */[m
[32m+[m[32m#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */[m
[32m+[m
[32m+[m[32mstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }[m
[32m+[m[32mstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }[m
[32m+[m
[32m+[m[32m#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */[m[41m [m
[32m+[m[32mstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }[m
[32m+[m[32mstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }[m
[32m+[m[32mstatic __INLINE  void __SEV()                     { __ASM ("sev"); }[m
[32m+[m[32mstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }[m
[32m+[m
[32m+[m[32m/* intrinsic void __ISB(void)                                     */[m
[32m+[m[32m/* intrinsic void __DSB(void)                                     */[m
[32m+[m[32m/* intrinsic void __DMB(void)                                     */[m
[32m+[m[32m/* intrinsic void __set_PRIMASK();                                */[m
[32m+[m[32m/* intrinsic void __get_PRIMASK();                                */[m
[32m+[m[32m/* intrinsic void __set_FAULTMASK();                              */[m
[32m+[m[32m/* intrinsic void __get_FAULTMASK();                              */[m
[32m+[m[32m/* intrinsic uint32_t __REV(uint32_t value);                      */[m
[32m+[m[32m/* intrinsic uint32_t __REVSH(uint32_t value);                    */[m
[32m+[m[32m/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */[m
[32m+[m[32m/* intrinsic unsigned long __LDREX(unsigned long *);              */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return ProcessStackPointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the actual process stack pointer[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_PSP(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfProcStack  Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value ProcessStackPointer to the MSP[m[41m [m
[32m+[m[32m * (process stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_PSP(uint32_t topOfProcStack);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the current value of the MSP (main stack pointer)[m
[32m+[m[32m * Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_MSP(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfMainStack  Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value mainStackPointer to the MSP[m[41m [m
[32m+[m[32m * (main stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_MSP(uint32_t topOfMainStack);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in unsigned short value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in unsigned short value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __REV16(uint16_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse bit order of value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse bit order of value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __RBIT(uint32_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 8 bit values)[m
[32m+[m[32m */[m
[32m+[m[32mextern uint8_t __LDREXB(uint8_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint16_t __LDREXH(uint16_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __LDREXW(uint32_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 8 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __STREXB(uint8_t value, uint8_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __STREXH(uint16_t value, uint16_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __STREXW(uint32_t value, uint32_t *addr);[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/[m
[32m+[m[32m/* GNU gcc specific functions */[m
[32m+[m
[32m+[m[32mstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }[m
[32m+[m[32mstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }[m
[32m+[m
[32m+[m[32mstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }[m
[32m+[m[32mstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }[m
[32m+[m
[32m+[m[32mstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }[m
[32m+[m[32mstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }[m
[32m+[m[32mstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }[m
[32m+[m[32mstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }[m
[32m+[m[32mstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }[m
[32m+[m[32mstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }[m
[32m+[m[32mstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }[m
[32m+[m[32mstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return ProcessStackPointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the actual process stack pointer[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_PSP(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfProcStack  Process Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value ProcessStackPointer to the MSP[m[41m [m
[32m+[m[32m * (process stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_PSP(uint32_t topOfProcStack);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @return Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Return the current value of the MSP (main stack pointer)[m
[32m+[m[32m * Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_MSP(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  topOfMainStack  Main Stack Pointer[m
[32m+[m[32m *[m
[32m+[m[32m * Assign the value mainStackPointer to the MSP[m[41m [m
[32m+[m[32m * (main stack pointer) Cortex processor register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_MSP(uint32_t topOfMainStack);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @return BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_BASEPRI(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Base Priority value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  basePri  BasePriority[m
[32m+[m[32m *[m
[32m+[m[32m * Set the base priority register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_BASEPRI(uint32_t basePri);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return state of the priority mask bit from the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t  __get_PRIMASK(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Priority Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  priMask  PriMask[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority mask bit in the priority mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_PRIMASK(uint32_t priMask);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @return FaultMask[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_FAULTMASK(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Fault Mask value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  faultMask  faultMask value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the fault mask register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_FAULTMASK(uint32_t faultMask);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Return the Control Register value[m
[32m+[m[32m*[m[41m [m
[32m+[m[32m*  @return Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Return the content of the control register[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __get_CONTROL(void);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Control Register value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  control  Control value[m
[32m+[m[32m *[m
[32m+[m[32m * Set the control register[m
[32m+[m[32m */[m
[32m+[m[32mextern void __set_CONTROL(uint32_t control);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in integer value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in integer value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __REV(uint32_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in unsigned short value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in unsigned short value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __REV16(uint16_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse byte order in signed short value with sign extension to integer[m
[32m+[m[32m */[m
[32m+[m[32mextern int32_t __REVSH(int16_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Reverse bit order of value[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to reverse[m
[32m+[m[32m * @return        reversed value[m
[32m+[m[32m *[m
[32m+[m[32m * Reverse bit order of value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __RBIT(uint32_t value);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 8 bit value[m
[32m+[m[32m */[m
[32m+[m[32mextern uint8_t __LDREXB(uint8_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint16_t __LDREXH(uint16_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  LDR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        value of (*address)[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive LDR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __LDREXW(uint32_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (8 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 8 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __STREXB(uint8_t value, uint8_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (16 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 16 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __STREXH(uint16_t value, uint16_t *addr);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  STR Exclusive (32 bit)[m
[32m+[m[32m *[m
[32m+[m[32m * @param  value  value to store[m
[32m+[m[32m * @param  *addr  address pointer[m
[32m+[m[32m * @return        successful / failed[m
[32m+[m[32m *[m
[32m+[m[32m * Exclusive STR command for 32 bit values[m
[32m+[m[32m */[m
[32m+[m[32mextern uint32_t __STREXW(uint32_t value, uint32_t *addr);[m
[32m+[m
[32m+[m
[32m+[m[32m#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/[m
[32m+[m[32m/* TASKING carm specific functions */[m
[32m+[m
[32m+[m[32m/*[m
[32m+[m[32m * The CMSIS functions have been implemented as intrinsics in the compiler.[m
[32m+[m[32m * Please use "carm -?i" to get an up to date list of all instrinsics,[m
[32m+[m[32m * Including the CMSIS ones.[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_Core_FunctionInterface CMSIS CM3 Core Function Interface[m
[32m+[m[32m  Core  Function Interface containing:[m
[32m+[m[32m  - Core NVIC Functions[m
[32m+[m[32m  - Core SysTick Functions[m
[32m+[m[32m  - Core Reset Functions[m
[32m+[m[32m*/[m
[32m+[m[32m/*@{*/[m
[32m+[m
[32m+[m[32m/* ##########################   NVIC functions  #################################### */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the Priority Grouping in NVIC Interrupt Controller[m
[32m+[m[32m *[m
[32m+[m[32m * @param  PriorityGroup is priority grouping field[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority grouping field using the required unlock sequence.[m
[32m+[m[32m * The parameter priority_grouping is assigned to the field[m[41m [m
[32m+[m[32m * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.[m
[32m+[m[32m * In case of a conflict between priority grouping and available[m
[32m+[m[32m * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t reg_value;[m
[32m+[m[32m  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */[m
[32m+[m[41m  [m
[32m+[m[32m  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */[m
[32m+[m[32m  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */[m
[32m+[m[32m  reg_value  =  (reg_value                       |[m
[32m+[m[32m                (0x5FA << SCB_AIRCR_VECTKEY_Pos) |[m[41m [m
[32m+[m[32m                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */[m
[32m+[m[32m  SCB->AIRCR =  reg_value;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Get the Priority Grouping from NVIC Interrupt Controller[m
[32m+[m[32m *[m
[32m+[m[32m * @return priority grouping field[m[41m [m
[32m+[m[32m *[m
[32m+[m[32m * Get the priority grouping from NVIC Interrupt Controller.[m
[32m+[m[32m * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Enable Interrupt in NVIC Interrupt Controller[m
[32m+[m[32m *[m
[32m+[m[32m * @param  IRQn   The positive number of the external interrupt to enable[m
[32m+[m[32m *[m
[32m+[m[32m * Enable a device specific interupt in the NVIC interrupt controller.[m
[32m+[m[32m * The interrupt number cannot be a negative value.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m[32m  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Disable the interrupt line for external interrupt specified[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @param  IRQn   The positive number of the external interrupt to disable[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * Disable a device specific interupt in the NVIC interrupt controller.[m
[32m+[m[32m * The interrupt number cannot be a negative value.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m[32m  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Read the interrupt pending bit for a device specific interrupt source[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @param  IRQn    The number of the device specifc interrupt[m
[32m+[m[32m * @return         1 = interrupt pending, 0 = interrupt not pending[m
[32m+[m[32m *[m
[32m+[m[32m * Read the pending register in NVIC and return 1 if its status is pending,[m[41m [m
[32m+[m[32m * otherwise it returns 0[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m[32m  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the pending bit for an external interrupt[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m * @param  IRQn    The number of the interrupt for set pending[m
[32m+[m[32m *[m
[32m+[m[32m * Set the pending bit for the specified interrupt.[m
[32m+[m[32m * The interrupt number cannot be a negative value.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m[32m  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Clear the pending bit for an external interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * @param  IRQn    The number of the interrupt for clear pending[m
[32m+[m[32m *[m
[32m+[m[32m * Clear the pending bit for the specified interrupt.[m[41m [m
[32m+[m[32m * The interrupt number cannot be a negative value.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m[32m  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Read the active bit for an external interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * @param  IRQn    The number of the interrupt for read active bit[m
[32m+[m[32m * @return         1 = interrupt active, 0 = interrupt not active[m
[32m+[m[32m *[m
[32m+[m[32m * Read the active register in NVIC and returns 1 if its status is active,[m[41m [m
[32m+[m[32m * otherwise it returns 0.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m[32m  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Set the priority for an interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * @param  IRQn      The number of the interrupt for set priority[m
[32m+[m[32m * @param  priority  The priority to set[m
[32m+[m[32m *[m
[32m+[m[32m * Set the priority for the specified interrupt. The interrupt[m[41m [m
[32m+[m[32m * number can be positive to specify an external (device specific)[m[41m [m
[32m+[m[32m * interrupt, or negative to specify an internal (core) interrupt.[m
[32m+[m[32m *[m
[32m+[m[32m * Note: The priority cannot be set for every core interrupt.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)[m
[32m+[m[32m{[m
[32m+[m[32m  if(IRQn < 0) {[m
[32m+[m[32m    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */[m
[32m+[m[32m  else {[m
[32m+[m[32m    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Read the priority for an interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * @param  IRQn      The number of the interrupt for get priority[m
[32m+[m[32m * @return           The priority for the interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * Read the priority for the specified interrupt. The interrupt[m[41m [m
[32m+[m[32m * number can be positive to specify an external (device specific)[m[41m [m
[32m+[m[32m * interrupt, or negative to specify an internal (core) interrupt.[m
[32m+[m[32m *[m
[32m+[m[32m * The returned priority value is automatically aligned to the implemented[m
[32m+[m[32m * priority bits of the microcontroller.[m
[32m+[m[32m *[m
[32m+[m[32m * Note: The priority cannot be set for every core interrupt.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m  if(IRQn < 0) {[m
[32m+[m[32m    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */[m
[32m+[m[32m  else {[m
[32m+[m[32m    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Encode the priority for an interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * @param  PriorityGroup    The used priority group[m
[32m+[m[32m * @param  PreemptPriority  The preemptive priority value (starting from 0)[m
[32m+[m[32m * @param  SubPriority      The sub priority value (starting from 0)[m
[32m+[m[32m * @return                  The encoded priority for the interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * Encode the priority for an interrupt with the given priority group,[m
[32m+[m[32m * preemptive priority value and sub priority value.[m
[32m+[m[32m * In case of a conflict between priority grouping and available[m
[32m+[m[32m * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.[m
[32m+[m[32m *[m
[32m+[m[32m * The returned priority value can be used for NVIC_SetPriority(...) function[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */[m
[32m+[m[32m  uint32_t PreemptPriorityBits;[m
[32m+[m[32m  uint32_t SubPriorityBits;[m
[32m+[m
[32m+[m[32m  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;[m
[32m+[m[32m  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;[m
[32m+[m[41m [m
[32m+[m[32m  return ([m
[32m+[m[32m           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |[m
[32m+[m[32m           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))[m
[32m+[m[32m         );[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Decode the priority of an interrupt[m
[32m+[m[32m *[m
[32m+[m[32m * @param  Priority           The priority for the interrupt[m
[32m+[m[32m * @param  PriorityGroup      The used priority group[m
[32m+[m[32m * @param  pPreemptPriority   The preemptive priority value (starting from 0)[m
[32m+[m[32m * @param  pSubPriority       The sub priority value (starting from 0)[m
[32m+[m[32m *[m
[32m+[m[32m * Decode an interrupt priority value with the given priority group to[m[41m [m
[32m+[m[32m * preemptive priority value and sub priority value.[m
[32m+[m[32m * In case of a conflict between priority grouping and available[m
[32m+[m[32m * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.[m
[32m+[m[32m *[m
[32m+[m[32m * The priority value can be retrieved with NVIC_GetPriority(...) function[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */[m
[32m+[m[32m  uint32_t PreemptPriorityBits;[m
[32m+[m[32m  uint32_t SubPriorityBits;[m
[32m+[m
[32m+[m[32m  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;[m
[32m+[m[32m  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;[m
[32m+[m[41m  [m
[32m+[m[32m  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);[m
[32m+[m[32m  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/* ##################################    SysTick function  ############################################ */[m
[32m+[m
[32m+[m[32m#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Initialize and start the SysTick counter and its interrupt.[m
[32m+[m[32m *[m
[32m+[m[32m * @param   ticks   number of ticks between two interrupts[m
[32m+[m[32m * @return  1 = failed, 0 = successful[m
[32m+[m[32m *[m
[32m+[m[32m * Initialise the system tick timer and its interrupt and start the[m
[32m+[m[32m * system tick timer / counter in free running mode to generate[m[41m [m
[32m+[m[32m * periodical interrupts.[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */[m
[32m+[m[41m                                                               [m
[32m+[m[32m  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */[m
[32m+[m[32m  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */[m
[32m+[m[32m  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */[m
[32m+[m[32m  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |[m[41m [m
[32m+[m[32m                   SysTick_CTRL_TICKINT_Msk   |[m[41m [m
[32m+[m[32m                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */[m
[32m+[m[32m  return (0);                                                  /* Function successful */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/* ##################################    Reset function  ############################################ */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Initiate a system reset request.[m
[32m+[m[32m *[m
[32m+[m[32m * Initiate a system reset request to reset the MCU[m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE void NVIC_SystemReset(void)[m
[32m+[m[32m{[m
[32m+[m[32m  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |[m[41m [m
[32m+[m[32m                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |[m[41m [m
[32m+[m[32m                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */[m
[32m+[m[32m  __DSB();                                                     /* Ensure completion of memory access */[m[41m              [m
[32m+[m[32m  while(1);                                                    /* wait until reset */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_Core_FunctionInterface */[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/* ##################################### Debug In/Output function ########################################### */[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS_CM3_CoreDebugInterface CMSIS CM3 Core Debug Interface[m
[32m+[m[32m  Core Debug Interface containing:[m
[32m+[m[32m  - Core Debug Receive / Transmit Functions[m
[32m+[m[32m  - Core Debug Defines[m
[32m+[m[32m  - Core Debug Variables[m
[32m+[m[32m*/[m
[32m+[m[32m/*@{*/[m
[32m+[m
[32m+[m[32mextern volatile int ITM_RxBuffer;                    /*!< variable to receive characters                             */[m
[32m+[m[32m#define             ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< value identifying ITM_RxBuffer is ready for next character */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Outputs a character via the ITM channel 0[m
[32m+[m[32m *[m
[32m+[m[32m * @param  ch   character to output[m
[32m+[m[32m * @return      character to output[m
[32m+[m[32m *[m
[32m+[m[32m * The function outputs a character via the ITM channel 0.[m[41m [m
[32m+[m[32m * The function returns when no debugger is connected that has booked the output.[m[41m  [m
[32m+[m[32m * It is blocking when a debugger is connected, but the previous character send is not transmitted.[m[41m [m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)[m
[32m+[m[32m{[m
[32m+[m[32m  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA_Msk)  &&      /* Trace enabled */[m
[32m+[m[32m      (ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */[m
[32m+[m[32m      (ITM->TER & (1ul << 0)        )                    )     /* ITM Port #0 enabled */[m
[32m+[m[32m  {[m
[32m+[m[32m    while (ITM->PORT[0].u32 == 0);[m
[32m+[m[32m    ITM->PORT[0].u8 = (uint8_t) ch;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  return (ch);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Inputs a character via variable ITM_RxBuffer[m
[32m+[m[32m *[m
[32m+[m[32m * @return      received character, -1 = no character received[m
[32m+[m[32m *[m
[32m+[m[32m * The function inputs a character via variable ITM_RxBuffer.[m[41m [m
[32m+[m[32m * The function returns when no debugger is connected that has booked the output.[m[41m  [m
[32m+[m[32m * It is blocking when a debugger is connected, but the previous character send is not transmitted.[m[41m [m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE int ITM_ReceiveChar (void) {[m
[32m+[m[32m  int ch = -1;                               /* no character available */[m
[32m+[m
[32m+[m[32m  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {[m
[32m+[m[32m    ch = ITM_RxBuffer;[m
[32m+[m[32m    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  return (ch);[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief  Check if a character via variable ITM_RxBuffer is available[m
[32m+[m[32m *[m
[32m+[m[32m * @return      1 = character available, 0 = no character available[m
[32m+[m[32m *[m
[32m+[m[32m * The function checks  variable ITM_RxBuffer whether a character is available or not.[m[41m [m
[32m+[m[32m * The function returns '1' if a character is available and '0' if no character is available.[m[41m [m
[32m+[m[32m */[m
[32m+[m[32mstatic __INLINE int ITM_CheckChar (void) {[m
[32m+[m
[32m+[m[32m  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {[m
[32m+[m[32m    return (0);                                 /* no character available */[m
[32m+[m[32m  } else {[m
[32m+[m[32m    return (1);                                 /*    character available */[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_core_DebugInterface */[m
[32m+[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*@}*/ /* end of group CMSIS_CM3_core_definitions */[m
[32m+[m
[32m+[m[32m#endif /* __CM3_CORE_H__ */[m
[32m+[m
[32m+[m[32m/*lint -restore */[m
[1mdiff --git a/Libraries/CMSIS/startup_stm32f10x_hd.s b/Libraries/CMSIS/startup_stm32f10x_hd.s[m
[1mnew file mode 100644[m
[1mindex 0000000..8a19827[m
[1m--- /dev/null[m
[1m+++ b/Libraries/CMSIS/startup_stm32f10x_hd.s[m
[36m@@ -0,0 +1,358 @@[m
[32m+[m[32m;******************** (C) COPYRIGHT 2011 STMicroelectronics ********************[m
[32m+[m[32m;* File Name          : startup_stm32f10x_hd.s[m
[32m+[m[32m;* Author             : MCD Application Team[m
[32m+[m[32m;* Version            : V3.5.0[m
[32m+[m[32m;* Date               : 11-March-2011[m
[32m+[m[32m;* Description        : STM32F10x High Density Devices vector table for MDK-ARM[m[41m [m
[32m+[m[32m;*                      toolchain.[m[41m [m
[32m+[m[32m;*                      This module performs:[m
[32m+[m[32m;*                      - Set the initial SP[m
[32m+[m[32m;*                      - Set the initial PC == Reset_Handler[m
[32m+[m[32m;*                      - Set the vector table entries with the exceptions ISR address[m
[32m+[m[32m;*                      - Configure the clock system and also configure the external[m[41m [m
[32m+[m[32m;*                        SRAM mounted on STM3210E-EVAL board to be used as data[m[41m [m
[32m+[m[32m;*                        memory (optional, to be enabled by user)[m
[32m+[m[32m;*                      - Branches to __main in the C library (which eventually[m
[32m+[m[32m;*                        calls main()).[m
[32m+[m[32m;*                      After Reset the CortexM3 processor is in Thread mode,[m
[32m+[m[32m;*                      priority is Privileged, and the Stack is set to Main.[m
[32m+[m[32m;* <<< Use Configuration Wizard in Context Menu >>>[m[41m   [m
[32m+[m[32m;*******************************************************************************[m
[32m+[m[32m; THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m; WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.[m
[32m+[m[32m; AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,[m
[32m+[m[32m; INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE[m
[32m+[m[32m; CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING[m
[32m+[m[32m; INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m;*******************************************************************************[m
[32m+[m
[32m+[m[32m; Amount of memory (in bytes) allocated for Stack[m
[32m+[m[32m; Tailor this value to your application needs[m
[32m+[m[32m; <h> Stack Configuration[m
[32m+[m[32m;   <o> Stack Size (in Bytes) <0x0-0xFFFFFFFF:8>[m
[32m+[m[32m; </h>[m
[32m+[m
[32m+[m[32mStack_Size      EQU     0x00000400[m
[32m+[m
[32m+[m[32m                AREA    STACK, NOINIT, READWRITE, ALIGN=3[m
[32m+[m[32mStack_Mem       SPACE   Stack_Size[m
[32m+[m[32m__initial_sp[m
[32m+[m[41m                                                  [m
[32m+[m[32m; <h> Heap Configuration[m
[32m+[m[32m;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>[m
[32m+[m[32m; </h>[m
[32m+[m
[32m+[m[32mHeap_Size       EQU     0x00000200[m
[32m+[m
[32m+[m[32m                AREA    HEAP, NOINIT, READWRITE, ALIGN=3[m
[32m+[m[32m__heap_base[m
[32m+[m[32mHeap_Mem        SPACE   Heap_Size[m
[32m+[m[32m__heap_limit[m
[32m+[m
[32m+[m[32m                PRESERVE8[m
[32m+[m[32m                THUMB[m
[32m+[m
[32m+[m
[32m+[m[32m; Vector Table Mapped to Address 0 at Reset[m
[32m+[m[32m                AREA    RESET, DATA, READONLY[m
[32m+[m[32m                EXPORT  __Vectors[m
[32m+[m[32m                EXPORT  __Vectors_End[m
[32m+[m[32m                EXPORT  __Vectors_Size[m
[32m+[m
[32m+[m[32m__Vectors       DCD     __initial_sp               ; Top of Stack[m
[32m+[m[32m                DCD     Reset_Handler              ; Reset Handler[m
[32m+[m[32m                DCD     NMI_Handler                ; NMI Handler[m
[32m+[m[32m                DCD     HardFault_Handler          ; Hard Fault Handler[m
[32m+[m[32m                DCD     MemManage_Handler          ; MPU Fault Handler[m
[32m+[m[32m                DCD     BusFault_Handler           ; Bus Fault Handler[m
[32m+[m[32m                DCD     UsageFault_Handler         ; Usage Fault Handler[m
[32m+[m[32m                DCD     0                          ; Reserved[m
[32m+[m[32m                DCD     0                          ; Reserved[m
[32m+[m[32m                DCD     0                          ; Reserved[m
[32m+[m[32m                DCD     0                          ; Reserved[m
[32m+[m[32m                DCD     SVC_Handler                ; SVCall Handler[m
[32m+[m[32m                DCD     DebugMon_Handler           ; Debug Monitor Handler[m
[32m+[m[32m                DCD     0                          ; Reserved[m
[32m+[m[32m                DCD     PendSV_Handler             ; PendSV Handler[m
[32m+[m[32m                DCD     SysTick_Handler            ; SysTick Handler[m
[32m+[m
[32m+[m[32m                ; External Interrupts[m
[32m+[m[32m                DCD     WWDG_IRQHandler            ; Window Watchdog[m
[32m+[m[32m                DCD     PVD_IRQHandler             ; PVD through EXTI Line detect[m
[32m+[m[32m                DCD     TAMPER_IRQHandler          ; Tamper[m
[32m+[m[32m                DCD     RTC_IRQHandler             ; RTC[m
[32m+[m[32m                DCD     FLASH_IRQHandler           ; Flash[m
[32m+[m[32m                DCD     RCC_IRQHandler             ; RCC[m
[32m+[m[32m                DCD     EXTI0_IRQHandler           ; EXTI Line 0[m
[32m+[m[32m                DCD     EXTI1_IRQHandler           ; EXTI Line 1[m
[32m+[m[32m                DCD     EXTI2_IRQHandler           ; EXTI Line 2[m
[32m+[m[32m                DCD     EXTI3_IRQHandler           ; EXTI Line 3[m
[32m+[m[32m                DCD     EXTI4_IRQHandler           ; EXTI Line 4[m
[32m+[m[32m                DCD     DMA1_Channel1_IRQHandler   ; DMA1 Channel 1[m
[32m+[m[32m                DCD     DMA1_Channel2_IRQHandler   ; DMA1 Channel 2[m
[32m+[m[32m                DCD     DMA1_Channel3_IRQHandler   ; DMA1 Channel 3[m
[32m+[m[32m                DCD     DMA1_Channel4_IRQHandler   ; DMA1 Channel 4[m
[32m+[m[32m                DCD     DMA1_Channel5_IRQHandler   ; DMA1 Channel 5[m
[32m+[m[32m                DCD     DMA1_Channel6_IRQHandler   ; DMA1 Channel 6[m
[32m+[m[32m                DCD     DMA1_Channel7_IRQHandler   ; DMA1 Channel 7[m
[32m+[m[32m                DCD     ADC1_2_IRQHandler          ; ADC1 & ADC2[m
[32m+[m[32m                DCD     USB_HP_CAN1_TX_IRQHandler  ; USB High Priority or CAN1 TX[m
[32m+[m[32m                DCD     USB_LP_CAN1_RX0_IRQHandler ; USB Low  Priority or CAN1 RX0[m
[32m+[m[32m                DCD     CAN1_RX1_IRQHandler        ; CAN1 RX1[m
[32m+[m[32m                DCD     CAN1_SCE_IRQHandler        ; CAN1 SCE[m
[32m+[m[32m                DCD     EXTI9_5_IRQHandler         ; EXTI Line 9..5[m
[32m+[m[32m                DCD     TIM1_BRK_IRQHandler        ; TIM1 Break[m
[32m+[m[32m                DCD     TIM1_UP_IRQHandler         ; TIM1 Update[m
[32m+[m[32m                DCD     TIM1_TRG_COM_IRQHandler    ; TIM1 Trigger and Commutation[m
[32m+[m[32m                DCD     TIM1_CC_IRQHandler         ; TIM1 Capture Compare[m
[32m+[m[32m                DCD     TIM2_IRQHandler            ; TIM2[m
[32m+[m[32m                DCD     TIM3_IRQHandler            ; TIM3[m
[32m+[m[32m                DCD     TIM4_IRQHandler            ; TIM4[m
[32m+[m[32m                DCD     I2C1_EV_IRQHandler         ; I2C1 Event[m
[32m+[m[32m                DCD     I2C1_ER_IRQHandler         ; I2C1 Error[m
[32m+[m[32m                DCD     I2C2_EV_IRQHandler         ; I2C2 Event[m
[32m+[m[32m                DCD     I2C2_ER_IRQHandler         ; I2C2 Error[m
[32m+[m[32m                DCD     SPI1_IRQHandler            ; SPI1[m
[32m+[m[32m                DCD     SPI2_IRQHandler            ; SPI2[m
[32m+[m[32m                DCD     USART1_IRQHandler          ; USART1[m
[32m+[m[32m                DCD     USART2_IRQHandler          ; USART2[m
[32m+[m[32m                DCD     USART3_IRQHandler          ; USART3[m
[32m+[m[32m                DCD     EXTI15_10_IRQHandler       ; EXTI Line 15..10[m
[32m+[m[32m                DCD     RTCAlarm_IRQHandler        ; RTC Alarm through EXTI Line[m
[32m+[m[32m                DCD     USBWakeUp_IRQHandler       ; USB Wakeup from suspend[m
[32m+[m[32m                DCD     TIM8_BRK_IRQHandler        ; TIM8 Break[m
[32m+[m[32m                DCD     TIM8_UP_IRQHandler         ; TIM8 Update[m
[32m+[m[32m                DCD     TIM8_TRG_COM_IRQHandler    ; TIM8 Trigger and Commutation[m
[32m+[m[32m                DCD     TIM8_CC_IRQHandler         ; TIM8 Capture Compare[m
[32m+[m[32m                DCD     ADC3_IRQHandler            ; ADC3[m
[32m+[m[32m                DCD     FSMC_IRQHandler            ; FSMC[m
[32m+[m[32m                DCD     SDIO_IRQHandler            ; SDIO[m
[32m+[m[32m                DCD     TIM5_IRQHandler            ; TIM5[m
[32m+[m[32m                DCD     SPI3_IRQHandler            ; SPI3[m
[32m+[m[32m                DCD     UART4_IRQHandler           ; UART4[m
[32m+[m[32m                DCD     UART5_IRQHandler           ; UART5[m
[32m+[m[32m                DCD     TIM6_IRQHandler            ; TIM6[m
[32m+[m[32m                DCD     TIM7_IRQHandler            ; TIM7[m
[32m+[m[32m                DCD     DMA2_Channel1_IRQHandler   ; DMA2 Channel1[m
[32m+[m[32m                DCD     DMA2_Channel2_IRQHandler   ; DMA2 Channel2[m
[32m+[m[32m                DCD     DMA2_Channel3_IRQHandler   ; DMA2 Channel3[m
[32m+[m[32m                DCD     DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 & Channel5[m
[32m+[m[32m__Vectors_End[m
[32m+[m
[32m+[m[32m__Vectors_Size  EQU  __Vectors_End - __Vectors[m
[32m+[m
[32m+[m[32m                AREA    |.text|, CODE, READONLY[m
[32m+[m[41m                [m
[32m+[m[32m; Reset handler[m
[32m+[m[32mReset_Handler   PROC[m
[32m+[m[32m                EXPORT  Reset_Handler             [WEAK][m
[32m+[m[32m                IMPORT  __main[m
[32m+[m[32m                IMPORT  SystemInit[m
[32m+[m[32m                LDR     R0, =SystemInit[m
[32m+[m[32m                BLX     R0[m[41m               [m
[32m+[m[32m                LDR     R0, =__main[m
[32m+[m[32m                BX      R0[m
[32m+[m[32m                ENDP[m
[32m+[m[41m                [m
[32m+[m[32m; Dummy Exception Handlers (infinite loops which can be modified)[m
[32m+[m
[32m+[m[32mNMI_Handler     PROC[m
[32m+[m[32m                EXPORT  NMI_Handler                [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mHardFault_Handler\[m
[32m+[m[32m                PROC[m
[32m+[m[32m                EXPORT  HardFault_Handler          [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mMemManage_Handler\[m
[32m+[m[32m                PROC[m
[32m+[m[32m                EXPORT  MemManage_Handler          [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mBusFault_Handler\[m
[32m+[m[32m                PROC[m
[32m+[m[32m                EXPORT  BusFault_Handler           [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mUsageFault_Handler\[m
[32m+[m[32m                PROC[m
[32m+[m[32m                EXPORT  UsageFault_Handler         [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mSVC_Handler     PROC[m
[32m+[m[32m                EXPORT  SVC_Handler                [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mDebugMon_Handler\[m
[32m+[m[32m                PROC[m
[32m+[m[32m                EXPORT  DebugMon_Handler           [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mPendSV_Handler  PROC[m
[32m+[m[32m                EXPORT  PendSV_Handler             [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m[32mSysTick_Handler PROC[m
[32m+[m[32m                EXPORT  SysTick_Handler            [WEAK][m
[32m+[m[32m                B       .[m
[32m+[m[32m                ENDP[m
[32m+[m
[32m+[m[32mDefault_Handler PROC[m
[32m+[m
[32m+[m[32m                EXPORT  WWDG_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  PVD_IRQHandler             [WEAK][m
[32m+[m[32m                EXPORT  TAMPER_IRQHandler          [WEAK][m
[32m+[m[32m                EXPORT  RTC_IRQHandler             [WEAK][m
[32m+[m[32m                EXPORT  FLASH_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  RCC_IRQHandler             [WEAK][m
[32m+[m[32m                EXPORT  EXTI0_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  EXTI1_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  EXTI2_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  EXTI3_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  EXTI4_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel1_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel2_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel3_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel4_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel5_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel6_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA1_Channel7_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  ADC1_2_IRQHandler          [WEAK][m
[32m+[m[32m                EXPORT  USB_HP_CAN1_TX_IRQHandler  [WEAK][m
[32m+[m[32m                EXPORT  USB_LP_CAN1_RX0_IRQHandler [WEAK][m
[32m+[m[32m                EXPORT  CAN1_RX1_IRQHandler        [WEAK][m
[32m+[m[32m                EXPORT  CAN1_SCE_IRQHandler        [WEAK][m
[32m+[m[32m                EXPORT  EXTI9_5_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  TIM1_BRK_IRQHandler        [WEAK][m
[32m+[m[32m                EXPORT  TIM1_UP_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  TIM1_TRG_COM_IRQHandler    [WEAK][m
[32m+[m[32m                EXPORT  TIM1_CC_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  TIM2_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  TIM3_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  TIM4_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  I2C1_EV_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  I2C1_ER_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  I2C2_EV_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  I2C2_ER_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  SPI1_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  SPI2_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  USART1_IRQHandler          [WEAK][m
[32m+[m[32m                EXPORT  USART2_IRQHandler          [WEAK][m
[32m+[m[32m                EXPORT  USART3_IRQHandler          [WEAK][m
[32m+[m[32m                EXPORT  EXTI15_10_IRQHandler       [WEAK][m
[32m+[m[32m                EXPORT  RTCAlarm_IRQHandler        [WEAK][m
[32m+[m[32m                EXPORT  USBWakeUp_IRQHandler       [WEAK][m
[32m+[m[32m                EXPORT  TIM8_BRK_IRQHandler        [WEAK][m
[32m+[m[32m                EXPORT  TIM8_UP_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  TIM8_TRG_COM_IRQHandler    [WEAK][m
[32m+[m[32m                EXPORT  TIM8_CC_IRQHandler         [WEAK][m
[32m+[m[32m                EXPORT  ADC3_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  FSMC_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  SDIO_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  TIM5_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  SPI3_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  UART4_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  UART5_IRQHandler           [WEAK][m
[32m+[m[32m                EXPORT  TIM6_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  TIM7_IRQHandler            [WEAK][m
[32m+[m[32m                EXPORT  DMA2_Channel1_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA2_Channel2_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA2_Channel3_IRQHandler   [WEAK][m
[32m+[m[32m                EXPORT  DMA2_Channel4_5_IRQHandler [WEAK][m
[32m+[m
[32m+[m[32mWWDG_IRQHandler[m
[32m+[m[32mPVD_IRQHandler[m
[32m+[m[32mTAMPER_IRQHandler[m
[32m+[m[32mRTC_IRQHandler[m
[32m+[m[32mFLASH_IRQHandler[m
[32m+[m[32mRCC_IRQHandler[m
[32m+[m[32mEXTI0_IRQHandler[m
[32m+[m[32mEXTI1_IRQHandler[m
[32m+[m[32mEXTI2_IRQHandler[m
[32m+[m[32mEXTI3_IRQHandler[m
[32m+[m[32mEXTI4_IRQHandler[m
[32m+[m[32mDMA1_Channel1_IRQHandler[m
[32m+[m[32mDMA1_Channel2_IRQHandler[m
[32m+[m[32mDMA1_Channel3_IRQHandler[m
[32m+[m[32mDMA1_Channel4_IRQHandler[m
[32m+[m[32mDMA1_Channel5_IRQHandler[m
[32m+[m[32mDMA1_Channel6_IRQHandler[m
[32m+[m[32mDMA1_Channel7_IRQHandler[m
[32m+[m[32mADC1_2_IRQHandler[m
[32m+[m[32mUSB_HP_CAN1_TX_IRQHandler[m
[32m+[m[32mUSB_LP_CAN1_RX0_IRQHandler[m
[32m+[m[32mCAN1_RX1_IRQHandler[m
[32m+[m[32mCAN1_SCE_IRQHandler[m
[32m+[m[32mEXTI9_5_IRQHandler[m
[32m+[m[32mTIM1_BRK_IRQHandler[m
[32m+[m[32mTIM1_UP_IRQHandler[m
[32m+[m[32mTIM1_TRG_COM_IRQHandler[m
[32m+[m[32mTIM1_CC_IRQHandler[m
[32m+[m[32mTIM2_IRQHandler[m
[32m+[m[32mTIM3_IRQHandler[m
[32m+[m[32mTIM4_IRQHandler[m
[32m+[m[32mI2C1_EV_IRQHandler[m
[32m+[m[32mI2C1_ER_IRQHandler[m
[32m+[m[32mI2C2_EV_IRQHandler[m
[32m+[m[32mI2C2_ER_IRQHandler[m
[32m+[m[32mSPI1_IRQHandler[m
[32m+[m[32mSPI2_IRQHandler[m
[32m+[m[32mUSART1_IRQHandler[m
[32m+[m[32mUSART2_IRQHandler[m
[32m+[m[32mUSART3_IRQHandler[m
[32m+[m[32mEXTI15_10_IRQHandler[m
[32m+[m[32mRTCAlarm_IRQHandler[m
[32m+[m[32mUSBWakeUp_IRQHandler[m
[32m+[m[32mTIM8_BRK_IRQHandler[m
[32m+[m[32mTIM8_UP_IRQHandler[m
[32m+[m[32mTIM8_TRG_COM_IRQHandler[m
[32m+[m[32mTIM8_CC_IRQHandler[m
[32m+[m[32mADC3_IRQHandler[m
[32m+[m[32mFSMC_IRQHandler[m
[32m+[m[32mSDIO_IRQHandler[m
[32m+[m[32mTIM5_IRQHandler[m
[32m+[m[32mSPI3_IRQHandler[m
[32m+[m[32mUART4_IRQHandler[m
[32m+[m[32mUART5_IRQHandler[m
[32m+[m[32mTIM6_IRQHandler[m
[32m+[m[32mTIM7_IRQHandler[m
[32m+[m[32mDMA2_Channel1_IRQHandler[m
[32m+[m[32mDMA2_Channel2_IRQHandler[m
[32m+[m[32mDMA2_Channel3_IRQHandler[m
[32m+[m[32mDMA2_Channel4_5_IRQHandler[m
[32m+[m[32m                B       .[m
[32m+[m
[32m+[m[32m                ENDP[m
[32m+[m
[32m+[m[32m                ALIGN[m
[32m+[m
[32m+[m[32m;*******************************************************************************[m
[32m+[m[32m; User Stack and Heap initialization[m
[32m+[m[32m;*******************************************************************************[m
[32m+[m[32m                 IF      :DEF:__MICROLIB[m
[32m+[m[41m                [m
[32m+[m[32m                 EXPORT  __initial_sp[m
[32m+[m[32m                 EXPORT  __heap_base[m
[32m+[m[32m                 EXPORT  __heap_limit[m
[32m+[m[41m                [m
[32m+[m[32m                 ELSE[m
[32m+[m[41m                [m
[32m+[m[32m                 IMPORT  __use_two_region_memory[m
[32m+[m[32m                 EXPORT  __user_initial_stackheap[m
[32m+[m[41m                 [m
[32m+[m[32m__user_initial_stackheap[m
[32m+[m
[32m+[m[32m                 LDR     R0, =  Heap_Mem[m
[32m+[m[32m                 LDR     R1, =(Stack_Mem + Stack_Size)[m
[32m+[m[32m                 LDR     R2, = (Heap_Mem +  Heap_Size)[m
[32m+[m[32m                 LDR     R3, = Stack_Mem[m
[32m+[m[32m                 BX      LR[m
[32m+[m
[32m+[m[32m                 ALIGN[m
[32m+[m
[32m+[m[32m                 ENDIF[m
[32m+[m
[32m+[m[32m                 END[m
[32m+[m
[32m+[m[32m;******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE*****[m
[1mdiff --git a/Libraries/CMSIS/system_stm32f10x.c b/Libraries/CMSIS/system_stm32f10x.c[m
[1mnew file mode 100644[m
[1mindex 0000000..71efc85[m
[1m--- /dev/null[m
[1m+++ b/Libraries/CMSIS/system_stm32f10x.c[m
[36m@@ -0,0 +1,1094 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    system_stm32f10x.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * 1.  This file provides two functions and one global variable to be called from[m[41m [m
[32m+[m[32m  *     user application:[m
[32m+[m[32m  *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier[m
[32m+[m[32m  *                      factors, AHB/APBx prescalers and Flash settings).[m[41m [m
[32m+[m[32m  *                      This function is called at startup just after reset and[m[41m [m
[32m+[m[32m  *                      before branch to main program. This call is made inside[m
[32m+[m[32m  *                      the "startup_stm32f10x_xx.s" file.[m
[32m+[m[32m  *[m
[32m+[m[32m  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used[m
[32m+[m[32m  *                                  by the user application to setup the SysTick[m[41m [m
[32m+[m[32m  *                                  timer or configure other parameters.[m
[32m+[m[32m  *[m[41m                                     [m
[32m+[m[32m  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must[m
[32m+[m[32m  *                                 be called whenever the core clock is changed[m
[32m+[m[32m  *                                 during program execution.[m
[32m+[m[32m  *[m
[32m+[m[32m  * 2. After each device reset the HSI (8 MHz) is used as system clock source.[m
[32m+[m[32m  *    Then SystemInit() function is called, in "startup_stm32f10x_xx.s" file, to[m
[32m+[m[32m  *    configure the system clock before to branch to main program.[m
[32m+[m[32m  *[m
[32m+[m[32m  * 3. If the system clock source selected by user fails to startup, the SystemInit()[m
[32m+[m[32m  *    function will do nothing and HSI still used as system clock source. User can[m[41m [m
[32m+[m[32m  *    add some code to deal with this issue inside the SetSysClock() function.[m
[32m+[m[32m  *[m
[32m+[m[32m  * 4. The default value of HSE crystal is set to 8 MHz (or 25 MHz, depedning on[m
[32m+[m[32m  *    the product used), refer to "HSE_VALUE" define in "stm32f10x.h" file.[m[41m [m
[32m+[m[32m  *    When HSE is used as system clock source, directly or through PLL, and you[m
[32m+[m[32m  *    are using different crystal you have to adapt the HSE value to your own[m
[32m+[m[32m  *    configuration.[m
[32m+[m[32m  *[m[41m        [m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup stm32f10x_system[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_Includes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/*!< Uncomment the line corresponding to the desired System clock (SYSCLK)[m
[32m+[m[32m   frequency (after reset the HSI is used as SYSCLK source)[m
[32m+[m[41m   [m
[32m+[m[32m   IMPORTANT NOTE:[m
[32m+[m[32m   ==============[m[41m [m
[32m+[m[32m   1. After each device reset the HSI is used as System clock source.[m
[32m+[m
[32m+[m[32m   2. Please make sure that the selected System clock doesn't exceed your device's[m
[32m+[m[32m      maximum frequency.[m
[32m+[m[41m      [m
[32m+[m[32m   3. If none of the define below is enabled, the HSI is used as System clock[m
[32m+[m[32m    source.[m
[32m+[m
[32m+[m[32m   4. The System clock configuration functions provided within this file assume that:[m
[32m+[m[32m        - For Low, Medium and High density Value line devices an external 8MHz[m[41m [m
[32m+[m[32m          crystal is used to drive the System clock.[m
[32m+[m[32m        - For Low, Medium and High density devices an external 8MHz crystal is[m
[32m+[m[32m          used to drive the System clock.[m
[32m+[m[32m        - For Connectivity line devices an external 25MHz crystal is used to drive[m
[32m+[m[32m          the System clock.[m
[32m+[m[32m     If you are using different crystal you have to adapt those functions accordingly.[m
[32m+[m[32m    */[m
[32m+[m[41m    [m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)[m
[32m+[m[32m/* #define SYSCLK_FREQ_HSE    HSE_VALUE */[m
[32m+[m[32m #define SYSCLK_FREQ_24MHz  24000000[m
[32m+[m[32m#else[m
[32m+[m[32m/* #define SYSCLK_FREQ_HSE    HSE_VALUE */[m
[32m+[m[32m/* #define SYSCLK_FREQ_24MHz  24000000 */[m[41m [m
[32m+[m[32m/* #define SYSCLK_FREQ_36MHz  36000000 */[m
[32m+[m[32m/* #define SYSCLK_FREQ_48MHz  48000000 */[m
[32m+[m[32m/* #define SYSCLK_FREQ_56MHz  56000000 */[m
[32m+[m[32m#define SYSCLK_FREQ_72MHz  72000000[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*!< Uncomment the following line if you need to use external SRAM mounted[m
[32m+[m[32m     on STM3210E-EVAL board (STM32 High density and XL-density devices) or on[m[41m [m
[32m+[m[32m     STM32100E-EVAL board (STM32 High-density value line devices) as data memory */[m[41m [m
[32m+[m[32m#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)[m
[32m+[m[32m/* #define DATA_IN_ExtSRAM */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*!< Uncomment the following line if you need to relocate your vector Table in[m
[32m+[m[32m     Internal SRAM. */[m[41m [m
[32m+[m[32m/* #define VECT_TAB_SRAM */[m
[32m+[m[32m#define VECT_TAB_OFFSET  0x0 /*!< Vector Table base offset field.[m[41m [m
[32m+[m[32m                                  This value must be a multiple of 0x200. */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/*******************************************************************************[m
[32m+[m[32m*  Clock Definitions[m
[32m+[m[32m*******************************************************************************/[m
[32m+[m[32m#ifdef SYSCLK_FREQ_HSE[m
[32m+[m[32m  uint32_t SystemCoreClock         = SYSCLK_FREQ_HSE;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#elif defined SYSCLK_FREQ_24MHz[m
[32m+[m[32m  uint32_t SystemCoreClock         = SYSCLK_FREQ_24MHz;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#elif defined SYSCLK_FREQ_36MHz[m
[32m+[m[32m  uint32_t SystemCoreClock         = SYSCLK_FREQ_36MHz;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#elif defined SYSCLK_FREQ_48MHz[m
[32m+[m[32m  uint32_t SystemCoreClock         = SYSCLK_FREQ_48MHz;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#elif defined SYSCLK_FREQ_56MHz[m
[32m+[m[32m  uint32_t SystemCoreClock         = SYSCLK_FREQ_56MHz;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#elif defined SYSCLK_FREQ_72MHz[m
[32m+[m[32m  uint32_t SystemCoreClock         = SYSCLK_FREQ_72MHz;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#else /*!< HSI Selected as System Clock source */[m
[32m+[m[32m  uint32_t SystemCoreClock         = HSI_VALUE;        /*!< System Clock Frequency (Core Clock) */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m__I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mstatic void SetSysClock(void);[m
[32m+[m
[32m+[m[32m#ifdef SYSCLK_FREQ_HSE[m
[32m+[m[32m  static void SetSysClockToHSE(void);[m
[32m+[m[32m#elif defined SYSCLK_FREQ_24MHz[m
[32m+[m[32m  static void SetSysClockTo24(void);[m
[32m+[m[32m#elif defined SYSCLK_FREQ_36MHz[m
[32m+[m[32m  static void SetSysClockTo36(void);[m
[32m+[m[32m#elif defined SYSCLK_FREQ_48MHz[m
[32m+[m[32m  static void SetSysClockTo48(void);[m
[32m+[m[32m#elif defined SYSCLK_FREQ_56MHz[m
[32m+[m[32m  static void SetSysClockTo56(void);[m[41m  [m
[32m+[m[32m#elif defined SYSCLK_FREQ_72MHz[m
[32m+[m[32m  static void SetSysClockTo72(void);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef DATA_IN_ExtSRAM[m
[32m+[m[32m  static void SystemInit_ExtMemCtl(void);[m[41m [m
[32m+[m[32m#endif /* DATA_IN_ExtSRAM */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Setup the microcontroller system[m
[32m+[m[32m  *         Initialize the Embedded Flash Interface, the PLL and update the[m[41m [m
[32m+[m[32m  *         SystemCoreClock variable.[m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SystemInit (void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */[m
[32m+[m[32m  /* Set HSION bit */[m
[32m+[m[32m  RCC->CR |= (uint32_t)0x00000001;[m
[32m+[m
[32m+[m[32m  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m  RCC->CFGR &= (uint32_t)0xF8FF0000;[m
[32m+[m[32m#else[m
[32m+[m[32m  RCC->CFGR &= (uint32_t)0xF0FF0000;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m   [m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset HSEON, CSSON and PLLON bits */[m
[32m+[m[32m  RCC->CR &= (uint32_t)0xFEF6FFFF;[m
[32m+[m
[32m+[m[32m  /* Reset HSEBYP bit */[m
[32m+[m[32m  RCC->CR &= (uint32_t)0xFFFBFFFF;[m
[32m+[m
[32m+[m[32m  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */[m
[32m+[m[32m  RCC->CFGR &= (uint32_t)0xFF80FFFF;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m  /* Reset PLL2ON and PLL3ON bits */[m
[32m+[m[32m  RCC->CR &= (uint32_t)0xEBFFFFFF;[m
[32m+[m
[32m+[m[32m  /* Disable all interrupts and clear pending bits  */[m
[32m+[m[32m  RCC->CIR = 0x00FF0000;[m
[32m+[m
[32m+[m[32m  /* Reset CFGR2 register */[m
[32m+[m[32m  RCC->CFGR2 = 0x00000000;[m
[32m+[m[32m#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)[m
[32m+[m[32m  /* Disable all interrupts and clear pending bits  */[m
[32m+[m[32m  RCC->CIR = 0x009F0000;[m
[32m+[m
[32m+[m[32m  /* Reset CFGR2 register */[m
[32m+[m[32m  RCC->CFGR2 = 0x00000000;[m[41m      [m
[32m+[m[32m#else[m
[32m+[m[32m  /* Disable all interrupts and clear pending bits  */[m
[32m+[m[32m  RCC->CIR = 0x009F0000;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m[41m    [m
[32m+[m[32m#if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)[m
[32m+[m[32m  #ifdef DATA_IN_ExtSRAM[m
[32m+[m[32m    SystemInit_ExtMemCtl();[m[41m [m
[32m+[m[32m  #endif /* DATA_IN_ExtSRAM */[m
[32m+[m[32m#endif[m[41m [m
[32m+[m
[32m+[m[32m  /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */[m
[32m+[m[32m  /* Configure the Flash Latency cycles and enable prefetch buffer */[m
[32m+[m[32m  SetSysClock();[m
[32m+[m
[32m+[m[32m#ifdef VECT_TAB_SRAM[m
[32m+[m[32m  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */[m
[32m+[m[32m#else[m
[32m+[m[32m  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */[m
[32m+[m[32m#endif[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Update SystemCoreClock variable according to Clock Register Values.[m
[32m+[m[32m  *         The SystemCoreClock variable contains the core clock (HCLK), it can[m
[32m+[m[32m  *         be used by the user application to setup the SysTick timer or configure[m
[32m+[m[32m  *         other parameters.[m
[32m+[m[32m  *[m[41m           [m
[32m+[m[32m  * @note   Each time the core clock (HCLK) changes, this function must be called[m
[32m+[m[32m  *         to update SystemCoreClock variable value. Otherwise, any configuration[m
[32m+[m[32m  *         based on this variable will be incorrect.[m[41m         [m
[32m+[m[32m  *[m[41m     [m
[32m+[m[32m  * @note   - The system frequency computed by this function is not the real[m[41m [m
[32m+[m[32m  *           frequency in the chip. It is calculated based on the predefined[m[41m [m
[32m+[m[32m  *           constant and the selected clock source:[m
[32m+[m[32m  *[m[41m             [m
[32m+[m[32m  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)[m
[32m+[m[32m  *[m[41m                                              [m
[32m+[m[32m  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)[m
[32m+[m[32m  *[m[41m                          [m
[32m+[m[32m  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**)[m[41m [m
[32m+[m[32m  *             or HSI_VALUE(*) multiplied by the PLL factors.[m
[32m+[m[32m  *[m[41m         [m
[32m+[m[32m  *         (*) HSI_VALUE is a constant defined in stm32f1xx.h file (default value[m
[32m+[m[32m  *             8 MHz) but the real value may vary depending on the variations[m
[32m+[m[32m  *             in voltage and temperature.[m[41m   [m
[32m+[m[32m  *[m[41m    [m
[32m+[m[32m  *         (**) HSE_VALUE is a constant defined in stm32f1xx.h file (default value[m
[32m+[m[32m  *              8 MHz or 25 MHz, depedning on the product used), user has to ensure[m
[32m+[m[32m  *              that HSE_VALUE is same as the real frequency of the crystal used.[m
[32m+[m[32m  *              Otherwise, this function may have wrong result.[m
[32m+[m[32m  *[m[41m                [m
[32m+[m[32m  *         - The result of this function could be not correct when using fractional[m
[32m+[m[32m  *           value for HSE crystal.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SystemCoreClockUpdate (void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0, pllmull = 0, pllsource = 0;[m
[32m+[m
[32m+[m[32m#ifdef  STM32F10X_CL[m
[32m+[m[32m  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)[m
[32m+[m[32m  uint32_t prediv1factor = 0;[m
[32m+[m[32m#endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */[m
[32m+[m[41m    [m
[32m+[m[32m  /* Get SYSCLK source -------------------------------------------------------*/[m
[32m+[m[32m  tmp = RCC->CFGR & RCC_CFGR_SWS;[m
[32m+[m[41m  [m
[32m+[m[32m  switch (tmp)[m
[32m+[m[32m  {[m
[32m+[m[32m    case 0x00:  /* HSI used as system clock */[m
[32m+[m[32m      SystemCoreClock = HSI_VALUE;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case 0x04:  /* HSE used as system clock */[m
[32m+[m[32m      SystemCoreClock = HSE_VALUE;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case 0x08:  /* PLL used as system clock */[m
[32m+[m
[32m+[m[32m      /* Get PLL clock source and multiplication factor ----------------------*/[m
[32m+[m[32m      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;[m
[32m+[m[32m      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;[m
[32m+[m[41m      [m
[32m+[m[32m#ifndef STM32F10X_CL[m[41m      [m
[32m+[m[32m      pllmull = ( pllmull >> 18) + 2;[m
[32m+[m[41m      [m
[32m+[m[32m      if (pllsource == 0x00)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* HSI oscillator clock divided by 2 selected as PLL clock entry */[m
[32m+[m[32m        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)[m
[32m+[m[32m       prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;[m
[32m+[m[32m       /* HSE oscillator clock selected as PREDIV1 clock entry */[m
[32m+[m[32m       SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;[m[41m [m
[32m+[m[32m #else[m
[32m+[m[32m        /* HSE selected as PLL clock entry */[m
[32m+[m[32m        if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)[m
[32m+[m[32m        {/* HSE oscillator clock divided by 2 */[m
[32m+[m[32m          SystemCoreClock = (HSE_VALUE >> 1) * pllmull;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m          SystemCoreClock = HSE_VALUE * pllmull;[m
[32m+[m[32m        }[m
[32m+[m[32m #endif[m
[32m+[m[32m      }[m
[32m+[m[32m#else[m
[32m+[m[32m      pllmull = pllmull >> 18;[m
[32m+[m[41m      [m
[32m+[m[32m      if (pllmull != 0x0D)[m
[32m+[m[32m      {[m
[32m+[m[32m         pllmull += 2;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      { /* PLL multiplication factor = PLL input clock * 6.5 */[m
[32m+[m[32m        pllmull = 13 / 2;[m[41m [m
[32m+[m[32m      }[m
[32m+[m[41m            [m
[32m+[m[32m      if (pllsource == 0x00)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* HSI oscillator clock divided by 2 selected as PLL clock entry */[m
[32m+[m[32m        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {/* PREDIV1 selected as PLL clock entry */[m
[32m+[m[41m        [m
[32m+[m[32m        /* Get PREDIV1 clock source and division factor */[m
[32m+[m[32m        prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;[m
[32m+[m[32m        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;[m
[32m+[m[41m        [m
[32m+[m[32m        if (prediv1source == 0)[m
[32m+[m[32m        {[m[41m [m
[32m+[m[32m          /* HSE oscillator clock selected as PREDIV1 clock entry */[m
[32m+[m[32m          SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;[m[41m          [m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {/* PLL2 clock selected as PREDIV1 clock entry */[m
[32m+[m[41m          [m
[32m+[m[32m          /* Get PREDIV2 division factor and PLL2 multiplication factor */[m
[32m+[m[32m          prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;[m
[32m+[m[32m          pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2;[m[41m [m
[32m+[m[32m          SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;[m[41m                         [m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m[32m      break;[m
[32m+[m
[32m+[m[32m    default:[m
[32m+[m[32m      SystemCoreClock = HSI_VALUE;[m
[32m+[m[32m      break;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Compute HCLK clock frequency ----------------*/[m
[32m+[m[32m  /* Get HCLK prescaler */[m
[32m+[m[32m  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];[m
[32m+[m[32m  /* HCLK clock frequency */[m
[32m+[m[32m  SystemCoreClock >>= tmp;[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClock(void)[m
[32m+[m[32m{[m
[32m+[m[32m#ifdef SYSCLK_FREQ_HSE[m
[32m+[m[32m  SetSysClockToHSE();[m
[32m+[m[32m#elif defined SYSCLK_FREQ_24MHz[m
[32m+[m[32m  SetSysClockTo24();[m
[32m+[m[32m#elif defined SYSCLK_FREQ_36MHz[m
[32m+[m[32m  SetSysClockTo36();[m
[32m+[m[32m#elif defined SYSCLK_FREQ_48MHz[m
[32m+[m[32m  SetSysClockTo48();[m
[32m+[m[32m#elif defined SYSCLK_FREQ_56MHz[m
[32m+[m[32m  SetSysClockTo56();[m[41m  [m
[32m+[m[32m#elif defined SYSCLK_FREQ_72MHz[m
[32m+[m[32m  SetSysClockTo72();[m
[32m+[m[32m#endif[m
[32m+[m[41m [m
[32m+[m[32m /* If none of the define above is enabled, the HSI is used as System clock[m
[32m+[m[32m    source (default after reset) */[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Setup the external memory controller. Called in startup_stm32f10x.s[m[41m [m
[32m+[m[32m  *          before jump to __main[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#ifdef DATA_IN_ExtSRAM[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Setup the external memory controller.[m[41m [m
[32m+[m[32m  *         Called in startup_stm32f10x_xx.s/.c before jump to main.[m
[32m+[m[32m  * 	      This function configures the external SRAM mounted on STM3210E-EVAL[m
[32m+[m[32m  *         board (STM32 High density devices). This SRAM will be used as program[m
[32m+[m[32m  *         data memory (including heap and stack).[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32mvoid SystemInit_ExtMemCtl(void)[m[41m [m
[32m+[m[32m{[m
[32m+[m[32m/*!< FSMC Bank1 NOR/SRAM3 is used for the STM3210E-EVAL, if another Bank is[m[41m [m
[32m+[m[32m  required, then adjust the Register Addresses */[m
[32m+[m
[32m+[m[32m  /* Enable FSMC clock */[m
[32m+[m[32m  RCC->AHBENR = 0x00000114;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Enable GPIOD, GPIOE, GPIOF and GPIOG clocks */[m[41m  [m
[32m+[m[32m  RCC->APB2ENR = 0x000001E0;[m
[32m+[m[41m  [m
[32m+[m[32m/* ---------------  SRAM Data lines, NOE and NWE configuration ---------------*/[m
[32m+[m[32m/*----------------  SRAM Address lines configuration -------------------------*/[m
[32m+[m[32m/*----------------  NOE and NWE configuration --------------------------------*/[m[41m  [m
[32m+[m[32m/*----------------  NE3 configuration ----------------------------------------*/[m
[32m+[m[32m/*----------------  NBL0, NBL1 configuration ---------------------------------*/[m
[32m+[m[41m  [m
[32m+[m[32m  GPIOD->CRL = 0x44BB44BB;[m[41m  [m
[32m+[m[32m  GPIOD->CRH = 0xBBBBBBBB;[m
[32m+[m
[32m+[m[32m  GPIOE->CRL = 0xB44444BB;[m[41m  [m
[32m+[m[32m  GPIOE->CRH = 0xBBBBBBBB;[m
[32m+[m
[32m+[m[32m  GPIOF->CRL = 0x44BBBBBB;[m[41m  [m
[32m+[m[32m  GPIOF->CRH = 0xBBBB4444;[m
[32m+[m
[32m+[m[32m  GPIOG->CRL = 0x44BBBBBB;[m[41m  [m
[32m+[m[32m  GPIOG->CRH = 0x44444B44;[m
[32m+[m[41m   [m
[32m+[m[32m/*----------------  FSMC Configuration ---------------------------------------*/[m[41m  [m
[32m+[m[32m/*----------------  Enable FSMC Bank1_SRAM Bank ------------------------------*/[m
[32m+[m[41m  [m
[32m+[m[32m  FSMC_Bank1->BTCR[4] = 0x00001011;[m
[32m+[m[32m  FSMC_Bank1->BTCR[5] = 0x00000200;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* DATA_IN_ExtSRAM */[m
[32m+[m
[32m+[m[32m#ifdef SYSCLK_FREQ_HSE[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects HSE as System clock source and configure HCLK, PCLK2[m
[32m+[m[32m  *         and PCLK1 prescalers.[m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClockToHSE(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/[m[41m    [m
[32m+[m[32m  /* Enable HSE */[m[41m    [m
[32m+[m[32m  RCC->CR |= ((uint32_t)RCC_CR_HSEON);[m
[32m+[m[41m [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC->CR & RCC_CR_HSERDY;[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));[m
[32m+[m
[32m+[m[32m  if ((RCC->CR & RCC_CR_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x01;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x00;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m  if (HSEStatus == (uint32_t)0x01)[m
[32m+[m[32m  {[m
[32m+[m
[32m+[m[32m#if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL[m
[32m+[m[32m    /* Enable Prefetch Buffer */[m
[32m+[m[32m    FLASH->ACR |= FLASH_ACR_PRFTBE;[m
[32m+[m
[32m+[m[32m    /* Flash 0 wait state */[m
[32m+[m[32m    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;[m
[32m+[m[32m#else[m
[32m+[m[32m    if (HSE_VALUE <= 24000000)[m
[32m+[m	[32m{[m
[32m+[m[32m      FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;[m
[32m+[m	[32m}[m
[32m+[m	[32melse[m
[32m+[m	[32m{[m
[32m+[m[32m      FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;[m
[32m+[m	[32m}[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m[32m#endif[m
[32m+[m[41m [m
[32m+[m[32m    /* HCLK = SYSCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;[m
[32m+[m[41m      [m
[32m+[m[32m    /* PCLK2 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* PCLK1 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Select HSE as system clock source */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSE;[m[41m    [m
[32m+[m
[32m+[m[32m    /* Wait till HSE is used as system clock source */[m
[32m+[m[32m    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  { /* If HSE fails to start-up, the application will have wrong clock[m[41m [m
[32m+[m[32m         configuration. User can add here some code to deal with this error */[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m}[m
[32m+[m[32m#elif defined SYSCLK_FREQ_24MHz[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2[m[41m [m
[32m+[m[32m  *         and PCLK1 prescalers.[m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClockTo24(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/[m[41m    [m
[32m+[m[32m  /* Enable HSE */[m[41m    [m
[32m+[m[32m  RCC->CR |= ((uint32_t)RCC_CR_HSEON);[m
[32m+[m[41m [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC->CR & RCC_CR_HSERDY;[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));[m
[32m+[m
[32m+[m[32m  if ((RCC->CR & RCC_CR_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x01;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x00;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m  if (HSEStatus == (uint32_t)0x01)[m
[32m+[m[32m  {[m
[32m+[m[32m#if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL && !defined STM32F10X_HD_VL[m[41m [m
[32m+[m[32m    /* Enable Prefetch Buffer */[m
[32m+[m[32m    FLASH->ACR |= FLASH_ACR_PRFTBE;[m
[32m+[m
[32m+[m[32m    /* Flash 0 wait state */[m
[32m+[m[32m    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);[m
[32m+[m[32m    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;[m[41m    [m
[32m+[m[32m#endif[m
[32m+[m[41m [m
[32m+[m[32m    /* HCLK = SYSCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;[m
[32m+[m[41m      [m
[32m+[m[32m    /* PCLK2 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* PCLK1 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m    /* Configure PLLs ------------------------------------------------------*/[m
[32m+[m[32m    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */[m[41m [m
[32m+[m[32m    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |[m[41m [m
[32m+[m[32m                            RCC_CFGR_PLLMULL6);[m[41m [m
[32m+[m
[32m+[m[32m    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */[m
[32m+[m[32m    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */[m[41m       [m
[32m+[m[32m    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |[m
[32m+[m[32m                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);[m
[32m+[m[32m    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |[m
[32m+[m[32m                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);[m
[32m+[m[41m  [m
[32m+[m[32m    /* Enable PLL2 */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLL2ON;[m
[32m+[m[32m    /* Wait till PLL2 is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLL2RDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m[41m   [m
[32m+[m[32m#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);[m
[32m+[m[32m#else[m[41m    [m
[32m+[m[32m    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m    /* Enable PLL */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLLON;[m
[32m+[m
[32m+[m[32m    /* Wait till PLL is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLLRDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Select PLL as system clock source */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;[m[41m    [m
[32m+[m
[32m+[m[32m    /* Wait till PLL is used as system clock source */[m
[32m+[m[32m    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  { /* If HSE fails to start-up, the application will have wrong clock[m[41m [m
[32m+[m[32m         configuration. User can add here some code to deal with this error */[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m}[m
[32m+[m[32m#elif defined SYSCLK_FREQ_36MHz[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2[m[41m [m
[32m+[m[32m  *         and PCLK1 prescalers.[m[41m [m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClockTo36(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/[m[41m    [m
[32m+[m[32m  /* Enable HSE */[m[41m    [m
[32m+[m[32m  RCC->CR |= ((uint32_t)RCC_CR_HSEON);[m
[32m+[m[41m [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC->CR & RCC_CR_HSERDY;[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));[m
[32m+[m
[32m+[m[32m  if ((RCC->CR & RCC_CR_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x01;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x00;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m  if (HSEStatus == (uint32_t)0x01)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable Prefetch Buffer */[m
[32m+[m[32m    FLASH->ACR |= FLASH_ACR_PRFTBE;[m
[32m+[m
[32m+[m[32m    /* Flash 1 wait state */[m
[32m+[m[32m    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);[m
[32m+[m[32m    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;[m[41m    [m
[32m+[m[41m [m
[32m+[m[32m    /* HCLK = SYSCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;[m
[32m+[m[41m      [m
[32m+[m[32m    /* PCLK2 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* PCLK1 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m    /* Configure PLLs ------------------------------------------------------*/[m
[32m+[m[41m    [m
[32m+[m[32m    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 36 MHz */[m[41m [m
[32m+[m[32m    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |[m[41m [m
[32m+[m[32m                            RCC_CFGR_PLLMULL9);[m[41m [m
[32m+[m
[32m+[m	[32m/*!< PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */[m
[32m+[m[32m    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */[m
[32m+[m[41m        [m
[32m+[m[32m    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |[m
[32m+[m[32m                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);[m
[32m+[m[32m    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |[m
[32m+[m[32m                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);[m
[32m+[m[41m  [m
[32m+[m[32m    /* Enable PLL2 */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLL2ON;[m
[32m+[m[32m    /* Wait till PLL2 is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLL2RDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m#else[m[41m    [m
[32m+[m[32m    /*  PLL configuration: PLLCLK = (HSE / 2) * 9 = 36 MHz */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL9);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m    /* Enable PLL */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLLON;[m
[32m+[m
[32m+[m[32m    /* Wait till PLL is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLLRDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Select PLL as system clock source */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;[m[41m    [m
[32m+[m
[32m+[m[32m    /* Wait till PLL is used as system clock source */[m
[32m+[m[32m    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  { /* If HSE fails to start-up, the application will have wrong clock[m[41m [m
[32m+[m[32m         configuration. User can add here some code to deal with this error */[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m}[m
[32m+[m[32m#elif defined SYSCLK_FREQ_48MHz[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2[m[41m [m
[32m+[m[32m  *         and PCLK1 prescalers.[m[41m [m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClockTo48(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/[m[41m    [m
[32m+[m[32m  /* Enable HSE */[m[41m    [m
[32m+[m[32m  RCC->CR |= ((uint32_t)RCC_CR_HSEON);[m
[32m+[m[41m [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC->CR & RCC_CR_HSERDY;[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));[m
[32m+[m
[32m+[m[32m  if ((RCC->CR & RCC_CR_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x01;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x00;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m  if (HSEStatus == (uint32_t)0x01)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable Prefetch Buffer */[m
[32m+[m[32m    FLASH->ACR |= FLASH_ACR_PRFTBE;[m
[32m+[m
[32m+[m[32m    /* Flash 1 wait state */[m
[32m+[m[32m    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);[m
[32m+[m[32m    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;[m[41m    [m
[32m+[m[41m [m
[32m+[m[32m    /* HCLK = SYSCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;[m
[32m+[m[41m      [m
[32m+[m[32m    /* PCLK2 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* PCLK1 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;[m
[32m+[m[41m    [m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m    /* Configure PLLs ------------------------------------------------------*/[m
[32m+[m[32m    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */[m
[32m+[m[32m    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */[m
[32m+[m[41m        [m
[32m+[m[32m    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |[m
[32m+[m[32m                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);[m
[32m+[m[32m    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |[m
[32m+[m[32m                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);[m
[32m+[m[41m  [m
[32m+[m[32m    /* Enable PLL2 */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLL2ON;[m
[32m+[m[32m    /* Wait till PLL2 is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLL2RDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[41m   [m
[32m+[m[32m    /* PLL configuration: PLLCLK = PREDIV1 * 6 = 48 MHz */[m[41m [m
[32m+[m[32m    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |[m[41m [m
[32m+[m[32m                            RCC_CFGR_PLLMULL6);[m[41m [m
[32m+[m[32m#else[m[41m    [m
[32m+[m[32m    /*  PLL configuration: PLLCLK = HSE * 6 = 48 MHz */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m    /* Enable PLL */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLLON;[m
[32m+[m
[32m+[m[32m    /* Wait till PLL is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLLRDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Select PLL as system clock source */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;[m[41m    [m
[32m+[m
[32m+[m[32m    /* Wait till PLL is used as system clock source */[m
[32m+[m[32m    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  { /* If HSE fails to start-up, the application will have wrong clock[m[41m [m
[32m+[m[32m         configuration. User can add here some code to deal with this error */[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#elif defined SYSCLK_FREQ_56MHz[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets System clock frequency to 56MHz and configure HCLK, PCLK2[m[41m [m
[32m+[m[32m  *         and PCLK1 prescalers.[m[41m [m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClockTo56(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/[m[41m   [m
[32m+[m[32m  /* Enable HSE */[m[41m    [m
[32m+[m[32m  RCC->CR |= ((uint32_t)RCC_CR_HSEON);[m
[32m+[m[41m [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC->CR & RCC_CR_HSERDY;[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));[m
[32m+[m
[32m+[m[32m  if ((RCC->CR & RCC_CR_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x01;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x00;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m  if (HSEStatus == (uint32_t)0x01)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable Prefetch Buffer */[m
[32m+[m[32m    FLASH->ACR |= FLASH_ACR_PRFTBE;[m
[32m+[m
[32m+[m[32m    /* Flash 2 wait state */[m
[32m+[m[32m    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);[m
[32m+[m[32m    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;[m[41m    [m
[32m+[m[41m [m
[32m+[m[32m    /* HCLK = SYSCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;[m
[32m+[m[41m      [m
[32m+[m[32m    /* PCLK2 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* PCLK1 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m    /* Configure PLLs ------------------------------------------------------*/[m
[32m+[m[32m    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */[m
[32m+[m[32m    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */[m
[32m+[m[41m        [m
[32m+[m[32m    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |[m
[32m+[m[32m                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);[m
[32m+[m[32m    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |[m
[32m+[m[32m                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);[m
[32m+[m[41m  [m
[32m+[m[32m    /* Enable PLL2 */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLL2ON;[m
[32m+[m[32m    /* Wait till PLL2 is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLL2RDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[41m   [m
[32m+[m[32m    /* PLL configuration: PLLCLK = PREDIV1 * 7 = 56 MHz */[m[41m [m
[32m+[m[32m    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |[m[41m [m
[32m+[m[32m                            RCC_CFGR_PLLMULL7);[m[41m [m
[32m+[m[32m#else[m[41m     [m
[32m+[m[32m    /* PLL configuration: PLLCLK = HSE * 7 = 56 MHz */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL7);[m
[32m+[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m    /* Enable PLL */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLLON;[m
[32m+[m
[32m+[m[32m    /* Wait till PLL is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLLRDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Select PLL as system clock source */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;[m[41m    [m
[32m+[m
[32m+[m[32m    /* Wait till PLL is used as system clock source */[m
[32m+[m[32m    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  { /* If HSE fails to start-up, the application will have wrong clock[m[41m [m
[32m+[m[32m         configuration. User can add here some code to deal with this error */[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#elif defined SYSCLK_FREQ_72MHz[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2[m[41m [m
[32m+[m[32m  *         and PCLK1 prescalers.[m[41m [m
[32m+[m[32m  * @note   This function should be used only after reset.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void SetSysClockTo72(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/[m[41m    [m
[32m+[m[32m  /* Enable HSE */[m[41m    [m
[32m+[m[32m  RCC->CR |= ((uint32_t)RCC_CR_HSEON);[m
[32m+[m[41m [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC->CR & RCC_CR_HSERDY;[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));[m
[32m+[m
[32m+[m[32m  if ((RCC->CR & RCC_CR_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x01;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = (uint32_t)0x00;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m  if (HSEStatus == (uint32_t)0x01)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable Prefetch Buffer */[m
[32m+[m[32m    FLASH->ACR |= FLASH_ACR_PRFTBE;[m
[32m+[m
[32m+[m[32m    /* Flash 2 wait state */[m
[32m+[m[32m    FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);[m
[32m+[m[32m    FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;[m[41m    [m
[32m+[m
[32m+[m[41m [m
[32m+[m[32m    /* HCLK = SYSCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;[m
[32m+[m[41m      [m
[32m+[m[32m    /* PCLK2 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;[m
[32m+[m[41m    [m
[32m+[m[32m    /* PCLK1 = HCLK */[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m    /* Configure PLLs ------------------------------------------------------*/[m
[32m+[m[32m    /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */[m
[32m+[m[32m    /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */[m
[32m+[m[41m        [m
[32m+[m[32m    RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |[m
[32m+[m[32m                              RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);[m
[32m+[m[32m    RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |[m
[32m+[m[32m                             RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);[m
[32m+[m[41m  [m
[32m+[m[32m    /* Enable PLL2 */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLL2ON;[m
[32m+[m[32m    /* Wait till PLL2 is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLL2RDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[41m   [m
[32m+[m[32m    /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */[m[41m [m
[32m+[m[32m    RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 |[m[41m [m
[32m+[m[32m                            RCC_CFGR_PLLMULL9);[m[41m [m
[32m+[m[32m#else[m[41m    [m
[32m+[m[32m    /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |[m
[32m+[m[32m                                        RCC_CFGR_PLLMULL));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m    /* Enable PLL */[m
[32m+[m[32m    RCC->CR |= RCC_CR_PLLON;[m
[32m+[m
[32m+[m[32m    /* Wait till PLL is ready */[m
[32m+[m[32m    while((RCC->CR & RCC_CR_PLLRDY) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    /* Select PLL as system clock source */[m
[32m+[m[32m    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));[m
[32m+[m[32m    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;[m[41m    [m
[32m+[m
[32m+[m[32m    /* Wait till PLL is used as system clock source */[m
[32m+[m[32m    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  { /* If HSE fails to start-up, the application will have wrong clock[m[41m [m
[32m+[m[32m         configuration. User can add here some code to deal with this error */[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m    [m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/CMSIS/system_stm32f10x.h b/Libraries/CMSIS/system_stm32f10x.h[m
[1mnew file mode 100644[m
[1mindex 0000000..54bc1ab[m
[1m--- /dev/null[m
[1m+++ b/Libraries/CMSIS/system_stm32f10x.h[m
[36m@@ -0,0 +1,98 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    system_stm32f10x.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Header File.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup stm32f10x_system[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief Define to prevent recursive inclusion[m
[32m+[m[32m  */[m
[32m+[m[32m#ifndef __SYSTEM_STM32F10X_H[m
[32m+[m[32m#define __SYSTEM_STM32F10X_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m[41m [m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Includes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Exported_types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mextern uint32_t SystemCoreClock;          /*!< System Clock Frequency (Core Clock) */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_System_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mextern void SystemInit(void);[m
[32m+[m[32mextern void SystemCoreClockUpdate(void);[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__SYSTEM_STM32F10X_H */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m  [m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h[m
[1mnew file mode 100644[m
[1mindex 0000000..9a6bd07[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/misc.h[m
[36m@@ -0,0 +1,220 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    misc.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the miscellaneous[m
[32m+[m[32m  *          firmware library functions (add-on to CMSIS functions).[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __MISC_H[m
[32m+[m[32m#define __MISC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup MISC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  NVIC Init Structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.[m
[32m+[m[32m                                                   This parameter can be a value of @ref IRQn_Type[m[41m [m
[32m+[m[32m                                                   (For the complete STM32 Devices IRQ Channels list, please[m
[32m+[m[32m                                                    refer to stm32f10x.h file) */[m
[32m+[m
[32m+[m[32m  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel[m
[32m+[m[32m                                                   specified in NVIC_IRQChannel. This parameter can be a value[m
[32m+[m[32m                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */[m
[32m+[m
[32m+[m[32m  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified[m
[32m+[m[32m                                                   in NVIC_IRQChannel. This parameter can be a value[m
[32m+[m[32m                                                   between 0 and 15 as described in the table @ref NVIC_Priority_Table */[m
[32m+[m
[32m+[m[32m  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel[m
[32m+[m[32m                                                   will be enabled or disabled.[m[41m [m
[32m+[m[32m                                                   This parameter can be set either to ENABLE or DISABLE */[m[41m   [m
[32m+[m[32m} NVIC_InitTypeDef;[m
[32m+[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup NVIC_Priority_Table[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m@code[m[41m  [m
[32m+[m[32m The table below gives the allowed values of the pre-emption priority and subpriority according[m
[32m+[m[32m to the Priority Grouping configuration performed by NVIC_PriorityGroupConfig function[m
[32m+[m[32m  ============================================================================================================================[m
[32m+[m[32m    NVIC_PriorityGroup   | NVIC_IRQChannelPreemptionPriority | NVIC_IRQChannelSubPriority  | Description[m
[32m+[m[32m  ============================================================================================================================[m
[32m+[m[32m   NVIC_PriorityGroup_0  |                0                  |            0-15             |   0 bits for pre-emption priority[m
[32m+[m[32m                         |                                   |                             |   4 bits for subpriority[m
[32m+[m[32m  ----------------------------------------------------------------------------------------------------------------------------[m
[32m+[m[32m   NVIC_PriorityGroup_1  |                0-1                |            0-7              |   1 bits for pre-emption priority[m
[32m+[m[32m                         |                                   |                             |   3 bits for subpriority[m
[32m+[m[32m  ----------------------------------------------------------------------------------------------------------------------------[m[41m    [m
[32m+[m[32m   NVIC_PriorityGroup_2  |                0-3                |            0-3              |   2 bits for pre-emption priority[m
[32m+[m[32m                         |                                   |                             |   2 bits for subpriority[m
[32m+[m[32m  ----------------------------------------------------------------------------------------------------------------------------[m[41m    [m
[32m+[m[32m   NVIC_PriorityGroup_3  |                0-7                |            0-1              |   3 bits for pre-emption priority[m
[32m+[m[32m                         |                                   |                             |   1 bits for subpriority[m
[32m+[m[32m  ----------------------------------------------------------------------------------------------------------------------------[m[41m    [m
[32m+[m[32m   NVIC_PriorityGroup_4  |                0-15               |            0                |   4 bits for pre-emption priority[m
[32m+[m[32m                         |                                   |                             |   0 bits for subpriority[m[41m                       [m
[32m+[m[32m  ============================================================================================================================[m
[32m+[m[32m@endcode[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Vector_Table_Base[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)[m
[32m+[m[32m#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)[m
[32m+[m[32m#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \[m
[32m+[m[32m                                  ((VECTTAB) == NVIC_VectTab_FLASH))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup System_Low_Power[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)[m
[32m+[m[32m#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)[m
[32m+[m[32m#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)[m
[32m+[m[32m#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \[m
[32m+[m[32m                        ((LP) == NVIC_LP_SLEEPDEEP) || \[m
[32m+[m[32m                        ((LP) == NVIC_LP_SLEEPONEXIT))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Preemption_Priority_Group[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority[m
[32m+[m[32m                                                            4 bits for subpriority */[m
[32m+[m[32m#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority[m
[32m+[m[32m                                                            3 bits for subpriority */[m
[32m+[m[32m#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority[m
[32m+[m[32m                                                            2 bits for subpriority */[m
[32m+[m[32m#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority[m
[32m+[m[32m                                                            1 bits for subpriority */[m
[32m+[m[32m#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority[m
[32m+[m[32m                                                            0 bits for subpriority */[m
[32m+[m
[32m+[m[32m#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \[m
[32m+[m[32m                                       ((GROUP) == NVIC_PriorityGroup_1) || \[m
[32m+[m[32m                                       ((GROUP) == NVIC_PriorityGroup_2) || \[m
[32m+[m[32m                                       ((GROUP) == NVIC_PriorityGroup_3) || \[m
[32m+[m[32m                                       ((GROUP) == NVIC_PriorityGroup_4))[m
[32m+[m
[32m+[m[32m#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)[m
[32m+[m
[32m+[m[32m#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)[m
[32m+[m
[32m+[m[32m#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SysTick_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)[m
[32m+[m[32m#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)[m
[32m+[m[32m#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \[m
[32m+[m[32m                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);[m
[32m+[m[32mvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);[m
[32m+[m[32mvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);[m
[32m+[m[32mvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);[m
[32m+[m[32mvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __MISC_H */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h[m
[1mnew file mode 100644[m
[1mindex 0000000..c465d33[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_adc.h[m
[36m@@ -0,0 +1,483 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_adc.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the ADC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_ADC_H[m
[32m+[m[32m#define __STM32F10x_ADC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup ADC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  ADC Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t ADC_Mode;                      /*!< Configures the ADC to operate in independent or[m
[32m+[m[32m                                               dual mode.[m[41m [m
[32m+[m[32m                                               This parameter can be a value of @ref ADC_mode */[m
[32m+[m
[32m+[m[32m  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion is performed in[m
[32m+[m[32m                                               Scan (multichannels) or Single (one channel) mode.[m
[32m+[m[32m                                               This parameter can be set to ENABLE or DISABLE */[m
[32m+[m
[32m+[m[32m  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in[m
[32m+[m[32m                                               Continuous or Single mode.[m
[32m+[m[32m                                               This parameter can be set to ENABLE or DISABLE. */[m
[32m+[m
[32m+[m[32m  uint32_t ADC_ExternalTrigConv;          /*!< Defines the external trigger used to start the analog[m
[32m+[m[32m                                               to digital conversion of regular channels. This parameter[m
[32m+[m[32m                                               can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion */[m
[32m+[m
[32m+[m[32m  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data alignment is left or right.[m
[32m+[m[32m                                               This parameter can be a value of @ref ADC_data_align */[m
[32m+[m
[32m+[m[32m  uint8_t ADC_NbrOfChannel;               /*!< Specifies the number of ADC channels that will be converted[m
[32m+[m[32m                                               using the sequencer for regular channel group.[m
[32m+[m[32m                                               This parameter must range from 1 to 16. */[m
[32m+[m[32m}ADC_InitTypeDef;[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \[m
[32m+[m[32m                                   ((PERIPH) == ADC2) || \[m
[32m+[m[32m                                   ((PERIPH) == ADC3))[m
[32m+[m
[32m+[m[32m#define IS_ADC_DMA_PERIPH(PERIPH) (((PERIPH) == ADC1) || \[m
[32m+[m[32m                                   ((PERIPH) == ADC3))[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_Mode_Independent                       ((uint32_t)0x00000000)[m
[32m+[m[32m#define ADC_Mode_RegInjecSimult                    ((uint32_t)0x00010000)[m
[32m+[m[32m#define ADC_Mode_RegSimult_AlterTrig               ((uint32_t)0x00020000)[m
[32m+[m[32m#define ADC_Mode_InjecSimult_FastInterl            ((uint32_t)0x00030000)[m
[32m+[m[32m#define ADC_Mode_InjecSimult_SlowInterl            ((uint32_t)0x00040000)[m
[32m+[m[32m#define ADC_Mode_InjecSimult                       ((uint32_t)0x00050000)[m
[32m+[m[32m#define ADC_Mode_RegSimult                         ((uint32_t)0x00060000)[m
[32m+[m[32m#define ADC_Mode_FastInterl                        ((uint32_t)0x00070000)[m
[32m+[m[32m#define ADC_Mode_SlowInterl                        ((uint32_t)0x00080000)[m
[32m+[m[32m#define ADC_Mode_AlterTrig                         ((uint32_t)0x00090000)[m
[32m+[m
[32m+[m[32m#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_RegInjecSimult) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_InjecSimult_FastInterl) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_InjecSimult_SlowInterl) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_InjecSimult) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_RegSimult) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_FastInterl) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_SlowInterl) || \[m
[32m+[m[32m                           ((MODE) == ADC_Mode_AlterTrig))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_external_trigger_sources_for_regular_channels_conversion[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x00020000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x00060000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x00080000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x000A0000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((uint32_t)0x000C0000) /*!< For ADC1 and ADC2 */[m
[32m+[m
[32m+[m[32m#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x00040000) /*!< For ADC1, ADC2 and ADC3 */[m
[32m+[m[32m#define ADC_ExternalTrigConv_None                  ((uint32_t)0x000E0000) /*!< For ADC1, ADC2 and ADC3 */[m
[32m+[m
[32m+[m[32m#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x00000000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x00020000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x00060000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x00080000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x000A0000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x000C0000) /*!< For ADC3 only */[m
[32m+[m
[32m+[m[32m#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_None) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \[m
[32m+[m[32m                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_data_align[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)[m
[32m+[m[32m#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)[m
[32m+[m[32m#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \[m
[32m+[m[32m                                  ((ALIGN) == ADC_DataAlign_Left))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_channels[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_Channel_0                               ((uint8_t)0x00)[m
[32m+[m[32m#define ADC_Channel_1                               ((uint8_t)0x01)[m
[32m+[m[32m#define ADC_Channel_2                               ((uint8_t)0x02)[m
[32m+[m[32m#define ADC_Channel_3                               ((uint8_t)0x03)[m
[32m+[m[32m#define ADC_Channel_4                               ((uint8_t)0x04)[m
[32m+[m[32m#define ADC_Channel_5                               ((uint8_t)0x05)[m
[32m+[m[32m#define ADC_Channel_6                               ((uint8_t)0x06)[m
[32m+[m[32m#define ADC_Channel_7                               ((uint8_t)0x07)[m
[32m+[m[32m#define ADC_Channel_8                               ((uint8_t)0x08)[m
[32m+[m[32m#define ADC_Channel_9                               ((uint8_t)0x09)[m
[32m+[m[32m#define ADC_Channel_10                              ((uint8_t)0x0A)[m
[32m+[m[32m#define ADC_Channel_11                              ((uint8_t)0x0B)[m
[32m+[m[32m#define ADC_Channel_12                              ((uint8_t)0x0C)[m
[32m+[m[32m#define ADC_Channel_13                              ((uint8_t)0x0D)[m
[32m+[m[32m#define ADC_Channel_14                              ((uint8_t)0x0E)[m
[32m+[m[32m#define ADC_Channel_15                              ((uint8_t)0x0F)[m
[32m+[m[32m#define ADC_Channel_16                              ((uint8_t)0x10)[m
[32m+[m[32m#define ADC_Channel_17                              ((uint8_t)0x11)[m
[32m+[m
[32m+[m[32m#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)[m
[32m+[m[32m#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)[m
[32m+[m
[32m+[m[32m#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \[m
[32m+[m[32m                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_sampling_time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_SampleTime_1Cycles5                    ((uint8_t)0x00)[m
[32m+[m[32m#define ADC_SampleTime_7Cycles5                    ((uint8_t)0x01)[m
[32m+[m[32m#define ADC_SampleTime_13Cycles5                   ((uint8_t)0x02)[m
[32m+[m[32m#define ADC_SampleTime_28Cycles5                   ((uint8_t)0x03)[m
[32m+[m[32m#define ADC_SampleTime_41Cycles5                   ((uint8_t)0x04)[m
[32m+[m[32m#define ADC_SampleTime_55Cycles5                   ((uint8_t)0x05)[m
[32m+[m[32m#define ADC_SampleTime_71Cycles5                   ((uint8_t)0x06)[m
[32m+[m[32m#define ADC_SampleTime_239Cycles5                  ((uint8_t)0x07)[m
[32m+[m[32m#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_7Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_13Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_28Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_41Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_55Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_71Cycles5) || \[m
[32m+[m[32m                                  ((TIME) == ADC_SampleTime_239Cycles5))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_external_trigger_sources_for_injected_channels_conversion[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00002000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00003000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00004000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00005000) /*!< For ADC1 and ADC2 */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((uint32_t)0x00006000) /*!< For ADC1 and ADC2 */[m
[32m+[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00000000) /*!< For ADC1, ADC2 and ADC3 */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00001000) /*!< For ADC1, ADC2 and ADC3 */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_None              ((uint32_t)0x00007000) /*!< For ADC1, ADC2 and ADC3 */[m
[32m+[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00002000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x00003000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x00004000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x00005000) /*!< For ADC3 only */[m
[32m+[m[32m#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x00006000) /*!< For ADC3 only */[m
[32m+[m
[32m+[m[32m#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \[m
[32m+[m[32m                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_injected_channel_selection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_InjectedChannel_1                       ((uint8_t)0x14)[m
[32m+[m[32m#define ADC_InjectedChannel_2                       ((uint8_t)0x18)[m
[32m+[m[32m#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)[m
[32m+[m[32m#define ADC_InjectedChannel_4                       ((uint8_t)0x20)[m
[32m+[m[32m#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \[m
[32m+[m[32m                                          ((CHANNEL) == ADC_InjectedChannel_2) || \[m
[32m+[m[32m                                          ((CHANNEL) == ADC_InjectedChannel_3) || \[m
[32m+[m[32m                                          ((CHANNEL) == ADC_InjectedChannel_4))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_analog_watchdog_selection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)[m
[32m+[m[32m#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)[m
[32m+[m[32m#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)[m
[32m+[m[32m#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)[m
[32m+[m[32m#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)[m
[32m+[m[32m#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)[m
[32m+[m[32m#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)[m
[32m+[m
[32m+[m[32m#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \[m
[32m+[m[32m                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \[m
[32m+[m[32m                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \[m
[32m+[m[32m                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \[m
[32m+[m[32m                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \[m
[32m+[m[32m                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \[m
[32m+[m[32m                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_IT_EOC                                 ((uint16_t)0x0220)[m
[32m+[m[32m#define ADC_IT_AWD                                 ((uint16_t)0x0140)[m
[32m+[m[32m#define ADC_IT_JEOC                                ((uint16_t)0x0480)[m
[32m+[m
[32m+[m[32m#define IS_ADC_IT(IT) ((((IT) & (uint16_t)0xF81F) == 0x00) && ((IT) != 0x00))[m
[32m+[m
[32m+[m[32m#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \[m
[32m+[m[32m                           ((IT) == ADC_IT_JEOC))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_flags_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define ADC_FLAG_AWD                               ((uint8_t)0x01)[m
[32m+[m[32m#define ADC_FLAG_EOC                               ((uint8_t)0x02)[m
[32m+[m[32m#define ADC_FLAG_JEOC                              ((uint8_t)0x04)[m
[32m+[m[32m#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)[m
[32m+[m[32m#define ADC_FLAG_STRT                              ((uint8_t)0x10)[m
[32m+[m[32m#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xE0) == 0x00) && ((FLAG) != 0x00))[m
[32m+[m[32m#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \[m
[32m+[m[32m                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \[m
[32m+[m[32m                               ((FLAG) == ADC_FLAG_STRT))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_thresholds[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_injected_offset[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_injected_length[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_injected_rank[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_regular_length[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_regular_rank[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_regular_discontinuous_mode_number[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid ADC_DeInit(ADC_TypeDef* ADCx);[m
[32m+[m[32mvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);[m
[32m+[m[32mvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);[m
[32m+[m[32mvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_ResetCalibration(ADC_TypeDef* ADCx);[m
[32m+[m[32mFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);[m
[32m+[m[32mvoid ADC_StartCalibration(ADC_TypeDef* ADCx);[m
[32m+[m[32mFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);[m
[32m+[m[32mvoid ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);[m
[32m+[m[32mvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);[m
[32m+[m[32mvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);[m
[32m+[m[32mvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32muint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);[m
[32m+[m[32muint32_t ADC_GetDualModeConversionValue(void);[m
[32m+[m[32mvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);[m
[32m+[m[32mvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);[m
[32m+[m[32mFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);[m
[32m+[m[32mvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);[m
[32m+[m[32mvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);[m
[32m+[m[32mvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);[m
[32m+[m[32muint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);[m
[32m+[m[32mvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);[m
[32m+[m[32mvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold, uint16_t LowThreshold);[m
[32m+[m[32mvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);[m
[32m+[m[32mvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);[m
[32m+[m[32mFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);[m
[32m+[m[32mvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);[m
[32m+[m[32mITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);[m
[32m+[m[32mvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_ADC_H */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h[m
[1mnew file mode 100644[m
[1mindex 0000000..275c5e1[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_bkp.h[m
[36m@@ -0,0 +1,195 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_bkp.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the BKP firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_BKP_H[m
[32m+[m[32m#define __STM32F10x_BKP_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup BKP[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Tamper_Pin_active_level[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define BKP_TamperPinLevel_High           ((uint16_t)0x0000)[m
[32m+[m[32m#define BKP_TamperPinLevel_Low            ((uint16_t)0x0001)[m
[32m+[m[32m#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \[m
[32m+[m[32m                                        ((LEVEL) == BKP_TamperPinLevel_Low))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_output_source_to_output_on_the_Tamper_pin[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define BKP_RTCOutputSource_None          ((uint16_t)0x0000)[m
[32m+[m[32m#define BKP_RTCOutputSource_CalibClock    ((uint16_t)0x0080)[m
[32m+[m[32m#define BKP_RTCOutputSource_Alarm         ((uint16_t)0x0100)[m
[32m+[m[32m#define BKP_RTCOutputSource_Second        ((uint16_t)0x0300)[m
[32m+[m[32m#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \[m
[32m+[m[32m                                          ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \[m
[32m+[m[32m                                          ((SOURCE) == BKP_RTCOutputSource_Alarm) || \[m
[32m+[m[32m                                          ((SOURCE) == BKP_RTCOutputSource_Second))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Data_Backup_Register[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define BKP_DR1                           ((uint16_t)0x0004)[m
[32m+[m[32m#define BKP_DR2                           ((uint16_t)0x0008)[m
[32m+[m[32m#define BKP_DR3                           ((uint16_t)0x000C)[m
[32m+[m[32m#define BKP_DR4                           ((uint16_t)0x0010)[m
[32m+[m[32m#define BKP_DR5                           ((uint16_t)0x0014)[m
[32m+[m[32m#define BKP_DR6                           ((uint16_t)0x0018)[m
[32m+[m[32m#define BKP_DR7                           ((uint16_t)0x001C)[m
[32m+[m[32m#define BKP_DR8                           ((uint16_t)0x0020)[m
[32m+[m[32m#define BKP_DR9                           ((uint16_t)0x0024)[m
[32m+[m[32m#define BKP_DR10                          ((uint16_t)0x0028)[m
[32m+[m[32m#define BKP_DR11                          ((uint16_t)0x0040)[m
[32m+[m[32m#define BKP_DR12                          ((uint16_t)0x0044)[m
[32m+[m[32m#define BKP_DR13                          ((uint16_t)0x0048)[m
[32m+[m[32m#define BKP_DR14                          ((uint16_t)0x004C)[m
[32m+[m[32m#define BKP_DR15                          ((uint16_t)0x0050)[m
[32m+[m[32m#define BKP_DR16                          ((uint16_t)0x0054)[m
[32m+[m[32m#define BKP_DR17                          ((uint16_t)0x0058)[m
[32m+[m[32m#define BKP_DR18                          ((uint16_t)0x005C)[m
[32m+[m[32m#define BKP_DR19                          ((uint16_t)0x0060)[m
[32m+[m[32m#define BKP_DR20                          ((uint16_t)0x0064)[m
[32m+[m[32m#define BKP_DR21                          ((uint16_t)0x0068)[m
[32m+[m[32m#define BKP_DR22                          ((uint16_t)0x006C)[m
[32m+[m[32m#define BKP_DR23                          ((uint16_t)0x0070)[m
[32m+[m[32m#define BKP_DR24                          ((uint16_t)0x0074)[m
[32m+[m[32m#define BKP_DR25                          ((uint16_t)0x0078)[m
[32m+[m[32m#define BKP_DR26                          ((uint16_t)0x007C)[m
[32m+[m[32m#define BKP_DR27                          ((uint16_t)0x0080)[m
[32m+[m[32m#define BKP_DR28                          ((uint16_t)0x0084)[m
[32m+[m[32m#define BKP_DR29                          ((uint16_t)0x0088)[m
[32m+[m[32m#define BKP_DR30                          ((uint16_t)0x008C)[m
[32m+[m[32m#define BKP_DR31                          ((uint16_t)0x0090)[m
[32m+[m[32m#define BKP_DR32                          ((uint16_t)0x0094)[m
[32m+[m[32m#define BKP_DR33                          ((uint16_t)0x0098)[m
[32m+[m[32m#define BKP_DR34                          ((uint16_t)0x009C)[m
[32m+[m[32m#define BKP_DR35                          ((uint16_t)0x00A0)[m
[32m+[m[32m#define BKP_DR36                          ((uint16_t)0x00A4)[m
[32m+[m[32m#define BKP_DR37                          ((uint16_t)0x00A8)[m
[32m+[m[32m#define BKP_DR38                          ((uint16_t)0x00AC)[m
[32m+[m[32m#define BKP_DR39                          ((uint16_t)0x00B0)[m
[32m+[m[32m#define BKP_DR40                          ((uint16_t)0x00B4)[m
[32m+[m[32m#define BKP_DR41                          ((uint16_t)0x00B8)[m
[32m+[m[32m#define BKP_DR42                          ((uint16_t)0x00BC)[m
[32m+[m
[32m+[m[32m#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \[m
[32m+[m[32m                       ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \[m
[32m+[m[32m                       ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \[m
[32m+[m[32m                       ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) || \[m
[32m+[m[32m                       ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) || \[m
[32m+[m[32m                       ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) || \[m
[32m+[m[32m                       ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) || \[m
[32m+[m[32m                       ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) || \[m
[32m+[m[32m                       ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) || \[m
[32m+[m[32m                       ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) || \[m
[32m+[m[32m                       ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) || \[m
[32m+[m[32m                       ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) || \[m
[32m+[m[32m                       ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) || \[m
[32m+[m[32m                       ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))[m
[32m+[m
[32m+[m[32m#define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x7F)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid BKP_DeInit(void);[m
[32m+[m[32mvoid BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel);[m
[32m+[m[32mvoid BKP_TamperPinCmd(FunctionalState NewState);[m
[32m+[m[32mvoid BKP_ITConfig(FunctionalState NewState);[m
[32m+[m[32mvoid BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource);[m
[32m+[m[32mvoid BKP_SetRTCCalibrationValue(uint8_t CalibrationValue);[m
[32m+[m[32mvoid BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data);[m
[32m+[m[32muint16_t BKP_ReadBackupRegister(uint16_t BKP_DR);[m
[32m+[m[32mFlagStatus BKP_GetFlagStatus(void);[m
[32m+[m[32mvoid BKP_ClearFlag(void);[m
[32m+[m[32mITStatus BKP_GetITStatus(void);[m
[32m+[m[32mvoid BKP_ClearITPendingBit(void);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_BKP_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h[m
[1mnew file mode 100644[m
[1mindex 0000000..d185aa2[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_can.h[m
[36m@@ -0,0 +1,697 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_can.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the CAN firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_CAN_H[m
[32m+[m[32m#define __STM32F10x_CAN_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup CAN[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \[m
[32m+[m[32m                                   ((PERIPH) == CAN2))[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  CAN init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum.[m[41m [m
[32m+[m[32m                                 It ranges from 1 to 1024. */[m
[32m+[m[41m  [m
[32m+[m[32m  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.[m
[32m+[m[32m                                 This parameter can be a value of[m[41m [m
[32m+[m[32m                                @ref CAN_operating_mode */[m
[32m+[m
[32m+[m[32m  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta[m[41m [m
[32m+[m[32m                                 the CAN hardware is allowed to lengthen or[m[41m [m
[32m+[m[32m                                 shorten a bit to perform resynchronization.[m
[32m+[m[32m                                 This parameter can be a value of[m[41m [m
[32m+[m[32m                                 @ref CAN_synchronisation_jump_width */[m
[32m+[m
[32m+[m[32m  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit[m[41m [m
[32m+[m[32m                                 Segment 1. This parameter can be a value of[m[41m [m
[32m+[m[32m                                 @ref CAN_time_quantum_in_bit_segment_1 */[m
[32m+[m
[32m+[m[32m  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit[m[41m [m
[32m+[m[32m                                 Segment 2.[m
[32m+[m[32m                                 This parameter can be a value of[m[41m [m
[32m+[m[32m                                 @ref CAN_time_quantum_in_bit_segment_2 */[m
[32m+[m[41m  [m
[32m+[m[32m  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered[m[41m [m
[32m+[m[32m                                 communication mode. This parameter can be set[m[41m [m
[32m+[m[32m                                 either to ENABLE or DISABLE. */[m
[32m+[m[41m  [m
[32m+[m[32m  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off[m[41m [m
[32m+[m[32m                                  management. This parameter can be set either[m[41m [m
[32m+[m[32m                                  to ENABLE or DISABLE. */[m
[32m+[m
[32m+[m[32m  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode.[m[41m [m
[32m+[m[32m                                  This parameter can be set either to ENABLE or[m[41m [m
[32m+[m[32m                                  DISABLE. */[m
[32m+[m
[32m+[m[32m  FunctionalState CAN_NART;  /*!< Enable or disable the no-automatic[m[41m [m
[32m+[m[32m                                  retransmission mode. This parameter can be[m[41m [m
[32m+[m[32m                                  set either to ENABLE or DISABLE. */[m
[32m+[m
[32m+[m[32m  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.[m
[32m+[m[32m                                  This parameter can be set either to ENABLE[m[41m [m
[32m+[m[32m                                  or DISABLE. */[m
[32m+[m
[32m+[m[32m  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.[m
[32m+[m[32m                                  This parameter can be set either to ENABLE[m[41m [m
[32m+[m[32m                                  or DISABLE. */[m
[32m+[m[32m} CAN_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  CAN filter init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit[m
[32m+[m[32m                                              configuration, first one for a 16-bit configuration).[m
[32m+[m[32m                                              This parameter can be a value between 0x0000 and 0xFFFF */[m
[32m+[m
[32m+[m[32m  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit[m
[32m+[m[32m                                              configuration, second one for a 16-bit configuration).[m
[32m+[m[32m                                              This parameter can be a value between 0x0000 and 0xFFFF */[m
[32m+[m
[32m+[m[32m  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,[m
[32m+[m[32m                                              according to the mode (MSBs for a 32-bit configuration,[m
[32m+[m[32m                                              first one for a 16-bit configuration).[m
[32m+[m[32m                                              This parameter can be a value between 0x0000 and 0xFFFF */[m
[32m+[m
[32m+[m[32m  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,[m
[32m+[m[32m                                              according to the mode (LSBs for a 32-bit configuration,[m
[32m+[m[32m                                              second one for a 16-bit configuration).[m
[32m+[m[32m                                              This parameter can be a value between 0x0000 and 0xFFFF */[m
[32m+[m
[32m+[m[32m  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.[m
[32m+[m[32m                                              This parameter can be a value of @ref CAN_filter_FIFO */[m
[32m+[m[41m  [m
[32m+[m[32m  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */[m
[32m+[m
[32m+[m[32m  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.[m
[32m+[m[32m                                              This parameter can be a value of @ref CAN_filter_mode */[m
[32m+[m
[32m+[m[32m  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.[m
[32m+[m[32m                                              This parameter can be a value of @ref CAN_filter_scale */[m
[32m+[m
[32m+[m[32m  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.[m
[32m+[m[32m                                              This parameter can be set either to ENABLE or DISABLE. */[m
[32m+[m[32m} CAN_FilterInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  CAN Tx message structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t StdId;  /*!< Specifies the standard identifier.[m
[32m+[m[32m                        This parameter can be a value between 0 to 0x7FF. */[m
[32m+[m
[32m+[m[32m  uint32_t ExtId;  /*!< Specifies the extended identifier.[m
[32m+[m[32m                        This parameter can be a value between 0 to 0x1FFFFFFF. */[m
[32m+[m
[32m+[m[32m  uint8_t IDE;     /*!< Specifies the type of identifier for the message that[m[41m [m
[32m+[m[32m                        will be transmitted. This parameter can be a value[m[41m [m
[32m+[m[32m                        of @ref CAN_identifier_type */[m
[32m+[m
[32m+[m[32m  uint8_t RTR;     /*!< Specifies the type of frame for the message that will[m[41m [m
[32m+[m[32m                        be transmitted. This parameter can be a value of[m[41m [m
[32m+[m[32m                        @ref CAN_remote_transmission_request */[m
[32m+[m
[32m+[m[32m  uint8_t DLC;     /*!< Specifies the length of the frame that will be[m[41m [m
[32m+[m[32m                        transmitted. This parameter can be a value between[m[41m [m
[32m+[m[32m                        0 to 8 */[m
[32m+[m
[32m+[m[32m  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0[m[41m [m
[32m+[m[32m                        to 0xFF. */[m
[32m+[m[32m} CanTxMsg;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  CAN Rx message structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t StdId;  /*!< Specifies the standard identifier.[m
[32m+[m[32m                        This parameter can be a value between 0 to 0x7FF. */[m
[32m+[m
[32m+[m[32m  uint32_t ExtId;  /*!< Specifies the extended identifier.[m
[32m+[m[32m                        This parameter can be a value between 0 to 0x1FFFFFFF. */[m
[32m+[m
[32m+[m[32m  uint8_t IDE;     /*!< Specifies the type of identifier for the message that[m[41m [m
[32m+[m[32m                        will be received. This parameter can be a value of[m[41m [m
[32m+[m[32m                        @ref CAN_identifier_type */[m
[32m+[m
[32m+[m[32m  uint8_t RTR;     /*!< Specifies the type of frame for the received message.[m
[32m+[m[32m                        This parameter can be a value of[m[41m [m
[32m+[m[32m                        @ref CAN_remote_transmission_request */[m
[32m+[m
[32m+[m[32m  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.[m
[32m+[m[32m                        This parameter can be a value between 0 to 8 */[m
[32m+[m
[32m+[m[32m  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to[m[41m [m
[32m+[m[32m                        0xFF. */[m
[32m+[m
[32m+[m[32m  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in[m[41m [m
[32m+[m[32m                        the mailbox passes through. This parameter can be a[m[41m [m
[32m+[m[32m                        value between 0 to 0xFF */[m
[32m+[m[32m} CanRxMsg;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_sleep_constants[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */[m
[32m+[m[32m#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */[m
[32m+[m[32m#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */[m
[32m+[m[32m#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */[m
[32m+[m[32m#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */[m
[32m+[m
[32m+[m[32m#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \[m
[32m+[m[32m                           ((MODE) == CAN_Mode_LoopBack)|| \[m
[32m+[m[32m                           ((MODE) == CAN_Mode_Silent) || \[m
[32m+[m[32m                           ((MODE) == CAN_Mode_Silent_LoopBack))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @defgroup CAN_Operating_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m[32m#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */[m
[32m+[m[32m#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */[m
[32m+[m[32m#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */[m
[32m+[m
[32m+[m
[32m+[m[32m#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\[m
[32m+[m[32m                                    ((MODE) == CAN_OperatingMode_Normal)|| \[m
[32m+[m																		[32m((MODE) == CAN_OperatingMode_Sleep))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @defgroup CAN_Mode_Status[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m
[32m+[m[32m#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */[m
[32m+[m[32m#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_synchronisation_jump_width[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */[m
[32m+[m[32m#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */[m
[32m+[m[32m#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */[m
[32m+[m[32m#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */[m
[32m+[m
[32m+[m[32m#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \[m
[32m+[m[32m                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_time_quantum_in_bit_segment_1[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */[m
[32m+[m[32m#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */[m
[32m+[m[32m#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */[m
[32m+[m[32m#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */[m
[32m+[m[32m#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */[m
[32m+[m[32m#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */[m
[32m+[m[32m#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */[m
[32m+[m[32m#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */[m
[32m+[m[32m#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */[m
[32m+[m[32m#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */[m
[32m+[m[32m#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */[m
[32m+[m[32m#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */[m
[32m+[m[32m#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */[m
[32m+[m[32m#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */[m
[32m+[m[32m#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */[m
[32m+[m[32m#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */[m
[32m+[m
[32m+[m[32m#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_time_quantum_in_bit_segment_2[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */[m
[32m+[m[32m#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */[m
[32m+[m[32m#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */[m
[32m+[m[32m#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */[m
[32m+[m[32m#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */[m
[32m+[m[32m#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */[m
[32m+[m[32m#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */[m
[32m+[m[32m#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */[m
[32m+[m
[32m+[m[32m#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_clock_prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_filter_number[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 13)[m
[32m+[m[32m#else[m
[32m+[m[32m  #define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_filter_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */[m
[32m+[m[32m#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */[m
[32m+[m
[32m+[m[32m#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \[m
[32m+[m[32m                                  ((MODE) == CAN_FilterMode_IdList))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_filter_scale[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */[m
[32m+[m[32m#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */[m
[32m+[m
[32m+[m[32m#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \[m
[32m+[m[32m                                    ((SCALE) == CAN_FilterScale_32bit))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_filter_FIFO[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */[m
[32m+[m[32m#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */[m
[32m+[m[32m#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \[m
[32m+[m[32m                                  ((FIFO) == CAN_FilterFIFO1))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Start_bank_filter_for_slave_CAN[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Tx[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))[m
[32m+[m[32m#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))[m
[32m+[m[32m#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))[m
[32m+[m[32m#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_identifier_type[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */[m
[32m+[m[32m#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */[m
[32m+[m[32m#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \[m
[32m+[m[32m                               ((IDTYPE) == CAN_Id_Extended))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_remote_transmission_request[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */[m
[32m+[m[32m#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */[m
[32m+[m[32m#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_transmit_constants[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */[m
[32m+[m[32m#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */[m
[32m+[m[32m#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */[m
[32m+[m[32m#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide an empty mailbox */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_receive_FIFO_number_constants[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */[m
[32m+[m[32m#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */[m
[32m+[m
[32m+[m[32m#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_sleep_constants[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */[m
[32m+[m[32m#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_wake_up_constants[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */[m
[32m+[m[32m#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @defgroup   CAN_Error_Code_constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m[41m                                                                [m
[32m+[m[32m#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */[m[41m [m
[32m+[m[32m#define	CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()[m
[32m+[m[32m   and CAN_ClearFlag() functions. */[m
[32m+[m[32m/* If the flag is 0x1XXXXXXX, it means that it can only be used with CAN_GetFlagStatus() function.  */[m
[32m+[m
[32m+[m[32m/* Transmit Flags */[m
[32m+[m[32m#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */[m
[32m+[m[32m#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */[m
[32m+[m[32m#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */[m
[32m+[m
[32m+[m[32m/* Receive Flags */[m
[32m+[m[32m#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */[m
[32m+[m[32m#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */[m
[32m+[m[32m#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */[m
[32m+[m[32m#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */[m
[32m+[m[32m#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */[m
[32m+[m[32m#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */[m
[32m+[m
[32m+[m[32m/* Operating Mode Flags */[m
[32m+[m[32m#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */[m
[32m+[m[32m#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */[m
[32m+[m[32m/* Note: When SLAK intterupt is disabled (SLKIE=0), no polling on SLAKI is possible.[m[41m [m
[32m+[m[32m         In this case the SLAK bit can be polled.*/[m
[32m+[m
[32m+[m[32m/* Error Flags */[m
[32m+[m[32m#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */[m
[32m+[m[32m#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */[m
[32m+[m[32m#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */[m
[32m+[m[32m#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */[m
[32m+[m
[32m+[m[32m#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \[m
[32m+[m[32m                               ((FLAG) == CAN_FLAG_SLAK ))[m
[32m+[m
[32m+[m[32m#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \[m
[32m+[m[32m                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \[m
[32m+[m[32m                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\[m
[32m+[m[32m                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \[m
[32m+[m[32m                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[41m  [m
[32m+[m[32m/** @defgroup CAN_interrupts[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[41m  [m
[32m+[m[32m#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/[m
[32m+[m
[32m+[m[32m/* Receive Interrupts */[m
[32m+[m[32m#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/[m
[32m+[m[32m#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/[m
[32m+[m[32m#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/[m
[32m+[m[32m#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/[m
[32m+[m[32m#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/[m
[32m+[m[32m#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/[m
[32m+[m
[32m+[m[32m/* Operating Mode Interrupts */[m
[32m+[m[32m#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/[m
[32m+[m[32m#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/[m
[32m+[m
[32m+[m[32m/* Error Interrupts */[m
[32m+[m[32m#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/[m
[32m+[m[32m#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/[m
[32m+[m[32m#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/[m
[32m+[m[32m#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/[m
[32m+[m[32m#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/[m
[32m+[m
[32m+[m[32m/* Flags named as Interrupts : kept only for FW compatibility */[m
[32m+[m[32m#define CAN_IT_RQCP0   CAN_IT_TME[m
[32m+[m[32m#define CAN_IT_RQCP1   CAN_IT_TME[m
[32m+[m[32m#define CAN_IT_RQCP2   CAN_IT_TME[m
[32m+[m
[32m+[m
[32m+[m[32m#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))[m
[32m+[m
[32m+[m[32m#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\[m
[32m+[m[32m                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Legacy[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define CANINITFAILED               CAN_InitStatus_Failed[m
[32m+[m[32m#define CANINITOK                   CAN_InitStatus_Success[m
[32m+[m[32m#define CAN_FilterFIFO0             CAN_Filter_FIFO0[m
[32m+[m[32m#define CAN_FilterFIFO1             CAN_Filter_FIFO1[m
[32m+[m[32m#define CAN_ID_STD                  CAN_Id_Standard[m[41m           [m
[32m+[m[32m#define CAN_ID_EXT                  CAN_Id_Extended[m
[32m+[m[32m#define CAN_RTR_DATA                CAN_RTR_Data[m[41m         [m
[32m+[m[32m#define CAN_RTR_REMOTE              CAN_RTR_Remote[m
[32m+[m[32m#define CANTXFAILE                  CAN_TxStatus_Failed[m
[32m+[m[32m#define CANTXOK                     CAN_TxStatus_Ok[m
[32m+[m[32m#define CANTXPENDING                CAN_TxStatus_Pending[m
[32m+[m[32m#define CAN_NO_MB                   CAN_TxStatus_NoMailBox[m
[32m+[m[32m#define CANSLEEPFAILED              CAN_Sleep_Failed[m
[32m+[m[32m#define CANSLEEPOK                  CAN_Sleep_Ok[m
[32m+[m[32m#define CANWAKEUPFAILED             CAN_WakeUp_Failed[m[41m        [m
[32m+[m[32m#define CANWAKEUPOK                 CAN_WakeUp_Ok[m[41m        [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m/*  Function used to set the CAN configuration to the default reset state *****/[m[41m [m
[32m+[m[32mvoid CAN_DeInit(CAN_TypeDef* CANx);[m
[32m+[m
[32m+[m[32m/* Initialization and Configuration functions *********************************/[m[41m [m
[32m+[m[32muint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);[m
[32m+[m[32mvoid CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);[m
[32m+[m[32mvoid CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);[m
[32m+[m[32mvoid CAN_SlaveStartBank(uint8_t CAN_BankNumber);[m[41m [m
[32m+[m[32mvoid CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);[m
[32m+[m[32mvoid CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);[m
[32m+[m
[32m+[m[32m/* Transmit functions *********************************************************/[m
[32m+[m[32muint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);[m
[32m+[m[32muint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);[m
[32m+[m[32mvoid CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);[m
[32m+[m
[32m+[m[32m/* Receive functions **********************************************************/[m
[32m+[m[32mvoid CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);[m
[32m+[m[32mvoid CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);[m
[32m+[m[32muint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);[m
[32m+[m
[32m+[m
[32m+[m[32m/* Operation modes functions **************************************************/[m
[32m+[m[32muint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);[m
[32m+[m[32muint8_t CAN_Sleep(CAN_TypeDef* CANx);[m
[32m+[m[32muint8_t CAN_WakeUp(CAN_TypeDef* CANx);[m
[32m+[m
[32m+[m[32m/* Error management functions *************************************************/[m
[32m+[m[32muint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);[m
[32m+[m[32muint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);[m
[32m+[m[32muint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);[m
[32m+[m
[32m+[m[32m/* Interrupts and flags management functions **********************************/[m
[32m+[m[32mvoid CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);[m
[32m+[m[32mFlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);[m
[32m+[m[32mvoid CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);[m
[32m+[m[32mITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);[m
[32m+[m[32mvoid CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_CAN_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h[m
[1mnew file mode 100644[m
[1mindex 0000000..7ce6896[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_cec.h[m
[36m@@ -0,0 +1,210 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_cec.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the CEC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_CEC_H[m
[32m+[m[32m#define __STM32F10x_CEC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup CEC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m   [m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  CEC Init structure definition[m[41m  [m
[32m+[m[32m  */[m[41m [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t CEC_BitTimingMode; /*!< Configures the CEC Bit Timing Error Mode.[m[41m [m
[32m+[m[32m                               This parameter can be a value of @ref CEC_BitTiming_Mode */[m
[32m+[m[32m  uint16_t CEC_BitPeriodMode; /*!< Configures the CEC Bit Period Error Mode.[m[41m [m
[32m+[m[32m                               This parameter can be a value of @ref CEC_BitPeriod_Mode */[m
[32m+[m[32m}CEC_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m/** @defgroup CEC_BitTiming_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define CEC_BitTimingStdMode                    ((uint16_t)0x00) /*!< Bit timing error Standard Mode */[m
[32m+[m[32m#define CEC_BitTimingErrFreeMode                CEC_CFGR_BTEM   /*!< Bit timing error Free Mode */[m
[32m+[m
[32m+[m[32m#define IS_CEC_BIT_TIMING_ERROR_MODE(MODE) (((MODE) == CEC_BitTimingStdMode) || \[m
[32m+[m[32m                                            ((MODE) == CEC_BitTimingErrFreeMode))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_BitPeriod_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define CEC_BitPeriodStdMode                    ((uint16_t)0x00) /*!< Bit period error Standard Mode */[m
[32m+[m[32m#define CEC_BitPeriodFlexibleMode                CEC_CFGR_BPEM   /*!< Bit period error Flexible Mode */[m
[32m+[m
[32m+[m[32m#define IS_CEC_BIT_PERIOD_ERROR_MODE(MODE) (((MODE) == CEC_BitPeriodStdMode) || \[m
[32m+[m[32m                                            ((MODE) == CEC_BitPeriodFlexibleMode))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define CEC_IT_TERR                              CEC_CSR_TERR[m
[32m+[m[32m#define CEC_IT_TBTRF                             CEC_CSR_TBTRF[m
[32m+[m[32m#define CEC_IT_RERR                              CEC_CSR_RERR[m
[32m+[m[32m#define CEC_IT_RBTF                              CEC_CSR_RBTF[m
[32m+[m[32m#define IS_CEC_GET_IT(IT) (((IT) == CEC_IT_TERR) || ((IT) == CEC_IT_TBTRF) || \[m
[32m+[m[32m                           ((IT) == CEC_IT_RERR) || ((IT) == CEC_IT_RBTF))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Own_Address[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define IS_CEC_ADDRESS(ADDRESS) ((ADDRESS) < 0x10)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define IS_CEC_PRESCALER(PRESCALER) ((PRESCALER) <= 0x3FFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_flags_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m   [m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  ESR register flags[m[41m  [m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define CEC_FLAG_BTE                            ((uint32_t)0x10010000)[m
[32m+[m[32m#define CEC_FLAG_BPE                            ((uint32_t)0x10020000)[m
[32m+[m[32m#define CEC_FLAG_RBTFE                          ((uint32_t)0x10040000)[m
[32m+[m[32m#define CEC_FLAG_SBE                            ((uint32_t)0x10080000)[m
[32m+[m[32m#define CEC_FLAG_ACKE                           ((uint32_t)0x10100000)[m
[32m+[m[32m#define CEC_FLAG_LINE                           ((uint32_t)0x10200000)[m
[32m+[m[32m#define CEC_FLAG_TBTFE                          ((uint32_t)0x10400000)[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  CSR register flags[m[41m  [m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define CEC_FLAG_TEOM                           ((uint32_t)0x00000002)[m[41m  [m
[32m+[m[32m#define CEC_FLAG_TERR                           ((uint32_t)0x00000004)[m
[32m+[m[32m#define CEC_FLAG_TBTRF                          ((uint32_t)0x00000008)[m
[32m+[m[32m#define CEC_FLAG_RSOM                           ((uint32_t)0x00000010)[m
[32m+[m[32m#define CEC_FLAG_REOM                           ((uint32_t)0x00000020)[m
[32m+[m[32m#define CEC_FLAG_RERR                           ((uint32_t)0x00000040)[m
[32m+[m[32m#define CEC_FLAG_RBTF                           ((uint32_t)0x00000080)[m
[32m+[m
[32m+[m[32m#define IS_CEC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFF03) == 0x00) && ((FLAG) != 0x00))[m
[32m+[m[41m                               [m
[32m+[m[32m#define IS_CEC_GET_FLAG(FLAG) (((FLAG) == CEC_FLAG_BTE) || ((FLAG) == CEC_FLAG_BPE) || \[m
[32m+[m[32m                               ((FLAG) == CEC_FLAG_RBTFE) || ((FLAG)== CEC_FLAG_SBE) || \[m
[32m+[m[32m                               ((FLAG) == CEC_FLAG_ACKE) || ((FLAG) == CEC_FLAG_LINE) || \[m
[32m+[m[32m                               ((FLAG) == CEC_FLAG_TBTFE) || ((FLAG) == CEC_FLAG_TEOM) || \[m
[32m+[m[32m                               ((FLAG) == CEC_FLAG_TERR) || ((FLAG) == CEC_FLAG_TBTRF) || \[m
[32m+[m[32m                               ((FLAG) == CEC_FLAG_RSOM) || ((FLAG) == CEC_FLAG_REOM) || \[m
[32m+[m[32m                               ((FLAG) == CEC_FLAG_RERR) || ((FLAG) == CEC_FLAG_RBTF))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32mvoid CEC_DeInit(void);[m
[32m+[m[32mvoid CEC_Init(CEC_InitTypeDef* CEC_InitStruct);[m
[32m+[m[32mvoid CEC_Cmd(FunctionalState NewState);[m
[32m+[m[32mvoid CEC_ITConfig(FunctionalState NewState);[m
[32m+[m[32mvoid CEC_OwnAddressConfig(uint8_t CEC_OwnAddress);[m
[32m+[m[32mvoid CEC_SetPrescaler(uint16_t CEC_Prescaler);[m
[32m+[m[32mvoid CEC_SendDataByte(uint8_t Data);[m
[32m+[m[32muint8_t CEC_ReceiveDataByte(void);[m
[32m+[m[32mvoid CEC_StartOfMessage(void);[m
[32m+[m[32mvoid CEC_EndOfMessageCmd(FunctionalState NewState);[m
[32m+[m[32mFlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG);[m
[32m+[m[32mvoid CEC_ClearFlag(uint32_t CEC_FLAG);[m
[32m+[m[32mITStatus CEC_GetITStatus(uint8_t CEC_IT);[m
[32m+[m[32mvoid CEC_ClearITPendingBit(uint16_t CEC_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_CEC_H */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h[m
[1mnew file mode 100644[m
[1mindex 0000000..3362fca[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_crc.h[m
[36m@@ -0,0 +1,94 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_crc.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the CRC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_CRC_H[m
[32m+[m[32m#define __STM32F10x_CRC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup CRC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid CRC_ResetDR(void);[m
[32m+[m[32muint32_t CRC_CalcCRC(uint32_t Data);[m
[32m+[m[32muint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);[m
[32m+[m[32muint32_t CRC_GetCRC(void);[m
[32m+[m[32mvoid CRC_SetIDRegister(uint8_t IDValue);[m
[32m+[m[32muint8_t CRC_GetIDRegister(void);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_CRC_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h[m
[1mnew file mode 100644[m
[1mindex 0000000..174773c[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dac.h[m
[36m@@ -0,0 +1,317 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_dac.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the DAC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_DAC_H[m
[32m+[m[32m#define __STM32F10x_DAC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup DAC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  DAC Init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.[m
[32m+[m[32m                                                  This parameter can be a value of @ref DAC_trigger_selection */[m
[32m+[m
[32m+[m[32m  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves[m
[32m+[m[32m                                                  are generated, or whether no wave is generated.[m
[32m+[m[32m                                                  This parameter can be a value of @ref DAC_wave_generation */[m
[32m+[m
[32m+[m[32m  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or[m
[32m+[m[32m                                                  the maximum amplitude triangle generation for the DAC channel.[m[41m [m
[32m+[m[32m                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */[m
[32m+[m
[32m+[m[32m  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.[m
[32m+[m[32m                                                  This parameter can be a value of @ref DAC_output_buffer */[m
[32m+[m[32m}DAC_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_trigger_selection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register[m[41m [m
[32m+[m[32m                                                                       has been loaded, and not by external trigger */[m
[32m+[m[32m#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */[m
[32m+[m[32m#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel[m
[32m+[m[32m                                                                       only in High-density devices*/[m
[32m+[m[32m#define DAC_Trigger_T3_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel[m
[32m+[m[32m                                                                       only in Connectivity line, Medium-density and Low-density Value Line devices */[m
[32m+[m[32m#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */[m
[32m+[m[32m#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */[m
[32m+[m[32m#define DAC_Trigger_T15_TRGO               ((uint32_t)0x0000001C) /*!< TIM15 TRGO selected as external conversion trigger for DAC channel[m[41m [m
[32m+[m[32m                                                                       only in Medium-density and Low-density Value Line devices*/[m
[32m+[m[32m#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */[m
[32m+[m[32m#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */[m
[32m+[m[32m#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */[m
[32m+[m[32m#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */[m
[32m+[m
[32m+[m[32m#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \[m
[32m+[m[32m                                 ((TRIGGER) == DAC_Trigger_Software))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_wave_generation[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)[m
[32m+[m[32m#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)[m
[32m+[m[32m#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)[m
[32m+[m[32m#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \[m
[32m+[m[32m                                    ((WAVE) == DAC_WaveGeneration_Noise) || \[m
[32m+[m[32m                                    ((WAVE) == DAC_WaveGeneration_Triangle))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_lfsrunmask_triangleamplitude[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */[m
[32m+[m[32m#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */[m
[32m+[m[32m#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */[m
[32m+[m[32m#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */[m
[32m+[m
[32m+[m[32m#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \[m
[32m+[m[32m                                                      ((VALUE) == DAC_TriangleAmplitude_4095))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_output_buffer[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)[m
[32m+[m[32m#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)[m
[32m+[m[32m#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \[m
[32m+[m[32m                                           ((STATE) == DAC_OutputBuffer_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Channel_selection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_Channel_1                      ((uint32_t)0x00000000)[m
[32m+[m[32m#define DAC_Channel_2                      ((uint32_t)0x00000010)[m
[32m+[m[32m#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \[m
[32m+[m[32m                                 ((CHANNEL) == DAC_Channel_2))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_data_alignment[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_Align_12b_R                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define DAC_Align_12b_L                    ((uint32_t)0x00000004)[m
[32m+[m[32m#define DAC_Align_8b_R                     ((uint32_t)0x00000008)[m
[32m+[m[32m#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \[m
[32m+[m[32m                             ((ALIGN) == DAC_Align_12b_L) || \[m
[32m+[m[32m                             ((ALIGN) == DAC_Align_8b_R))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_wave_generation[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DAC_Wave_Noise                     ((uint32_t)0x00000040)[m
[32m+[m[32m#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)[m
[32m+[m[32m#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \[m
[32m+[m[32m                           ((WAVE) == DAC_Wave_Triangle))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_data[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0)[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)  || defined (STM32F10X_HD_VL)[m
[32m+[m[32m/** @defgroup DAC_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)[m[41m  [m
[32m+[m[32m#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR))[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup DAC_flags_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)[m[41m  [m
[32m+[m[32m#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))[m[41m  [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid DAC_DeInit(void);[m
[32m+[m[32mvoid DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);[m
[32m+[m[32mvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);[m
[32m+[m[32mvoid DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32mvoid DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);[m
[32m+[m[32m#endif[m
[32m+[m[32mvoid DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);[m
[32m+[m[32mvoid DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);[m
[32m+[m[32mvoid DAC_DualSoftwareTriggerCmd(FunctionalState NewState);[m
[32m+[m[32mvoid DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);[m
[32m+[m[32mvoid DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);[m
[32m+[m[32mvoid DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);[m
[32m+[m[32mvoid DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);[m
[32m+[m[32muint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m[41m [m
[32m+[m[32mFlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);[m
[32m+[m[32mvoid DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);[m
[32m+[m[32mITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);[m
[32m+[m[32mvoid DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_DAC_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h[m
[1mnew file mode 100644[m
[1mindex 0000000..89ceb9a[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dbgmcu.h[m
[36m@@ -0,0 +1,119 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_dbgmcu.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the DBGMCU[m[41m [m
[32m+[m[32m  *          firmware library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_DBGMCU_H[m
[32m+[m[32m#define __STM32F10x_DBGMCU_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup DBGMCU[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)[m
[32m+[m[32m#define DBGMCU_STOP                  ((uint32_t)0x00000002)[m
[32m+[m[32m#define DBGMCU_STANDBY               ((uint32_t)0x00000004)[m
[32m+[m[32m#define DBGMCU_IWDG_STOP             ((uint32_t)0x00000100)[m
[32m+[m[32m#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000200)[m
[32m+[m[32m#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000400)[m
[32m+[m[32m#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000800)[m
[32m+[m[32m#define DBGMCU_TIM3_STOP             ((uint32_t)0x00001000)[m
[32m+[m[32m#define DBGMCU_TIM4_STOP             ((uint32_t)0x00002000)[m
[32m+[m[32m#define DBGMCU_CAN1_STOP             ((uint32_t)0x00004000)[m
[32m+[m[32m#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)[m
[32m+[m[32m#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)[m
[32m+[m[32m#define DBGMCU_TIM8_STOP             ((uint32_t)0x00020000)[m
[32m+[m[32m#define DBGMCU_TIM5_STOP             ((uint32_t)0x00040000)[m
[32m+[m[32m#define DBGMCU_TIM6_STOP             ((uint32_t)0x00080000)[m
[32m+[m[32m#define DBGMCU_TIM7_STOP             ((uint32_t)0x00100000)[m
[32m+[m[32m#define DBGMCU_CAN2_STOP             ((uint32_t)0x00200000)[m
[32m+[m[32m#define DBGMCU_TIM15_STOP            ((uint32_t)0x00400000)[m
[32m+[m[32m#define DBGMCU_TIM16_STOP            ((uint32_t)0x00800000)[m
[32m+[m[32m#define DBGMCU_TIM17_STOP            ((uint32_t)0x01000000)[m
[32m+[m[32m#define DBGMCU_TIM12_STOP            ((uint32_t)0x02000000)[m
[32m+[m[32m#define DBGMCU_TIM13_STOP            ((uint32_t)0x04000000)[m
[32m+[m[32m#define DBGMCU_TIM14_STOP            ((uint32_t)0x08000000)[m
[32m+[m[32m#define DBGMCU_TIM9_STOP             ((uint32_t)0x10000000)[m
[32m+[m[32m#define DBGMCU_TIM10_STOP            ((uint32_t)0x20000000)[m
[32m+[m[32m#define DBGMCU_TIM11_STOP            ((uint32_t)0x40000000)[m
[32m+[m[41m                                              [m
[32m+[m[32m#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0x800000F8) == 0x00) && ((PERIPH) != 0x00))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32muint32_t DBGMCU_GetREVID(void);[m
[32m+[m[32muint32_t DBGMCU_GetDEVID(void);[m
[32m+[m[32mvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_DBGMCU_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h[m
[1mnew file mode 100644[m
[1mindex 0000000..14275fe[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_dma.h[m
[36m@@ -0,0 +1,439 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_dma.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the DMA firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_DMA_H[m
[32m+[m[32m#define __STM32F10x_DMA_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup DMA[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  DMA Init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_MemoryBaseAddr;     /*!< Specifies the memory base address for DMAy Channelx. */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_DIR;                /*!< Specifies if the peripheral is the source or destination.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_data_transfer_direction */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Channel.[m[41m [m
[32m+[m[32m                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize[m
[32m+[m[32m                                        or DMA_MemoryDataSize members depending in the transfer direction. */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register is incremented or not.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register is incremented or not.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_memory_incremented_mode */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_peripheral_data_size */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_memory_data_size */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Channelx.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_circular_normal_mode.[m
[32m+[m[32m                                        @note: The circular buffer mode cannot be used if the memory-to-memory[m
[32m+[m[32m                                              data transfer is configured on the selected Channel */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Channelx.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_priority_level */[m
[32m+[m
[32m+[m[32m  uint32_t DMA_M2M;                /*!< Specifies if the DMAy Channelx will be used in memory-to-memory transfer.[m
[32m+[m[32m                                        This parameter can be a value of @ref DMA_memory_to_memory */[m
[32m+[m[32m}DMA_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA1_Channel2) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA1_Channel3) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA1_Channel4) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA1_Channel5) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA1_Channel6) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA1_Channel7) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA2_Channel1) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA2_Channel2) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA2_Channel3) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA2_Channel4) || \[m
[32m+[m[32m                                   ((PERIPH) == DMA2_Channel5))[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_data_transfer_direction[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_DIR_PeripheralDST              ((uint32_t)0x00000010)[m
[32m+[m[32m#define DMA_DIR_PeripheralSRC              ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_DMA_DIR(DIR) (((DIR) == DMA_DIR_PeripheralDST) || \[m
[32m+[m[32m                         ((DIR) == DMA_DIR_PeripheralSRC))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_peripheral_incremented_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_PeripheralInc_Enable           ((uint32_t)0x00000040)[m
[32m+[m[32m#define DMA_PeripheralInc_Disable          ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \[m
[32m+[m[32m                                            ((STATE) == DMA_PeripheralInc_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_memory_incremented_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_MemoryInc_Enable               ((uint32_t)0x00000080)[m
[32m+[m[32m#define DMA_MemoryInc_Disable              ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \[m
[32m+[m[32m                                        ((STATE) == DMA_MemoryInc_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_peripheral_data_size[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_PeripheralDataSize_Byte        ((uint32_t)0x00000000)[m
[32m+[m[32m#define DMA_PeripheralDataSize_HalfWord    ((uint32_t)0x00000100)[m
[32m+[m[32m#define DMA_PeripheralDataSize_Word        ((uint32_t)0x00000200)[m
[32m+[m[32m#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte) || \[m
[32m+[m[32m                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \[m
[32m+[m[32m                                           ((SIZE) == DMA_PeripheralDataSize_Word))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_memory_data_size[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_MemoryDataSize_Byte            ((uint32_t)0x00000000)[m
[32m+[m[32m#define DMA_MemoryDataSize_HalfWord        ((uint32_t)0x00000400)[m
[32m+[m[32m#define DMA_MemoryDataSize_Word            ((uint32_t)0x00000800)[m
[32m+[m[32m#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte) || \[m
[32m+[m[32m                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \[m
[32m+[m[32m                                       ((SIZE) == DMA_MemoryDataSize_Word))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_circular_normal_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_Mode_Circular                  ((uint32_t)0x00000020)[m
[32m+[m[32m#define DMA_Mode_Normal                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Circular) || ((MODE) == DMA_Mode_Normal))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_priority_level[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_Priority_VeryHigh              ((uint32_t)0x00003000)[m
[32m+[m[32m#define DMA_Priority_High                  ((uint32_t)0x00002000)[m
[32m+[m[32m#define DMA_Priority_Medium                ((uint32_t)0x00001000)[m
[32m+[m[32m#define DMA_Priority_Low                   ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_VeryHigh) || \[m
[32m+[m[32m                                   ((PRIORITY) == DMA_Priority_High) || \[m
[32m+[m[32m                                   ((PRIORITY) == DMA_Priority_Medium) || \[m
[32m+[m[32m                                   ((PRIORITY) == DMA_Priority_Low))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_memory_to_memory[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_M2M_Enable                     ((uint32_t)0x00004000)[m
[32m+[m[32m#define DMA_M2M_Disable                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_DMA_M2M_STATE(STATE) (((STATE) == DMA_M2M_Enable) || ((STATE) == DMA_M2M_Disable))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define DMA_IT_TC                          ((uint32_t)0x00000002)[m
[32m+[m[32m#define DMA_IT_HT                          ((uint32_t)0x00000004)[m
[32m+[m[32m#define DMA_IT_TE                          ((uint32_t)0x00000008)[m
[32m+[m[32m#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFFF1) == 0x00) && ((IT) != 0x00))[m
[32m+[m
[32m+[m[32m#define DMA1_IT_GL1                        ((uint32_t)0x00000001)[m
[32m+[m[32m#define DMA1_IT_TC1                        ((uint32_t)0x00000002)[m
[32m+[m[32m#define DMA1_IT_HT1                        ((uint32_t)0x00000004)[m
[32m+[m[32m#define DMA1_IT_TE1                        ((uint32_t)0x00000008)[m
[32m+[m[32m#define DMA1_IT_GL2                        ((uint32_t)0x00000010)[m
[32m+[m[32m#define DMA1_IT_TC2                        ((uint32_t)0x00000020)[m
[32m+[m[32m#define DMA1_IT_HT2                        ((uint32_t)0x00000040)[m
[32m+[m[32m#define DMA1_IT_TE2                        ((uint32_t)0x00000080)[m
[32m+[m[32m#define DMA1_IT_GL3                        ((uint32_t)0x00000100)[m
[32m+[m[32m#define DMA1_IT_TC3                        ((uint32_t)0x00000200)[m
[32m+[m[32m#define DMA1_IT_HT3                        ((uint32_t)0x00000400)[m
[32m+[m[32m#define DMA1_IT_TE3                        ((uint32_t)0x00000800)[m
[32m+[m[32m#define DMA1_IT_GL4                        ((uint32_t)0x00001000)[m
[32m+[m[32m#define DMA1_IT_TC4                        ((uint32_t)0x00002000)[m
[32m+[m[32m#define DMA1_IT_HT4                        ((uint32_t)0x00004000)[m
[32m+[m[32m#define DMA1_IT_TE4                        ((uint32_t)0x00008000)[m
[32m+[m[32m#define DMA1_IT_GL5                        ((uint32_t)0x00010000)[m
[32m+[m[32m#define DMA1_IT_TC5                        ((uint32_t)0x00020000)[m
[32m+[m[32m#define DMA1_IT_HT5                        ((uint32_t)0x00040000)[m
[32m+[m[32m#define DMA1_IT_TE5                        ((uint32_t)0x00080000)[m
[32m+[m[32m#define DMA1_IT_GL6                        ((uint32_t)0x00100000)[m
[32m+[m[32m#define DMA1_IT_TC6                        ((uint32_t)0x00200000)[m
[32m+[m[32m#define DMA1_IT_HT6                        ((uint32_t)0x00400000)[m
[32m+[m[32m#define DMA1_IT_TE6                        ((uint32_t)0x00800000)[m
[32m+[m[32m#define DMA1_IT_GL7                        ((uint32_t)0x01000000)[m
[32m+[m[32m#define DMA1_IT_TC7                        ((uint32_t)0x02000000)[m
[32m+[m[32m#define DMA1_IT_HT7                        ((uint32_t)0x04000000)[m
[32m+[m[32m#define DMA1_IT_TE7                        ((uint32_t)0x08000000)[m
[32m+[m
[32m+[m[32m#define DMA2_IT_GL1                        ((uint32_t)0x10000001)[m
[32m+[m[32m#define DMA2_IT_TC1                        ((uint32_t)0x10000002)[m
[32m+[m[32m#define DMA2_IT_HT1                        ((uint32_t)0x10000004)[m
[32m+[m[32m#define DMA2_IT_TE1                        ((uint32_t)0x10000008)[m
[32m+[m[32m#define DMA2_IT_GL2                        ((uint32_t)0x10000010)[m
[32m+[m[32m#define DMA2_IT_TC2                        ((uint32_t)0x10000020)[m
[32m+[m[32m#define DMA2_IT_HT2                        ((uint32_t)0x10000040)[m
[32m+[m[32m#define DMA2_IT_TE2                        ((uint32_t)0x10000080)[m
[32m+[m[32m#define DMA2_IT_GL3                        ((uint32_t)0x10000100)[m
[32m+[m[32m#define DMA2_IT_TC3                        ((uint32_t)0x10000200)[m
[32m+[m[32m#define DMA2_IT_HT3                        ((uint32_t)0x10000400)[m
[32m+[m[32m#define DMA2_IT_TE3                        ((uint32_t)0x10000800)[m
[32m+[m[32m#define DMA2_IT_GL4                        ((uint32_t)0x10001000)[m
[32m+[m[32m#define DMA2_IT_TC4                        ((uint32_t)0x10002000)[m
[32m+[m[32m#define DMA2_IT_HT4                        ((uint32_t)0x10004000)[m
[32m+[m[32m#define DMA2_IT_TE4                        ((uint32_t)0x10008000)[m
[32m+[m[32m#define DMA2_IT_GL5                        ((uint32_t)0x10010000)[m
[32m+[m[32m#define DMA2_IT_TC5                        ((uint32_t)0x10020000)[m
[32m+[m[32m#define DMA2_IT_HT5                        ((uint32_t)0x10040000)[m
[32m+[m[32m#define DMA2_IT_TE5                        ((uint32_t)0x10080000)[m
[32m+[m
[32m+[m[32m#define IS_DMA_CLEAR_IT(IT) (((((IT) & 0xF0000000) == 0x00) || (((IT) & 0xEFF00000) == 0x00)) && ((IT) != 0x00))[m
[32m+[m
[32m+[m[32m#define IS_DMA_GET_IT(IT) (((IT) == DMA1_IT_GL1) || ((IT) == DMA1_IT_TC1) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT1) || ((IT) == DMA1_IT_TE1) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_GL2) || ((IT) == DMA1_IT_TC2) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT2) || ((IT) == DMA1_IT_TE2) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_GL3) || ((IT) == DMA1_IT_TC3) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT3) || ((IT) == DMA1_IT_TE3) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_GL4) || ((IT) == DMA1_IT_TC4) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT4) || ((IT) == DMA1_IT_TE4) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_GL5) || ((IT) == DMA1_IT_TC5) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT5) || ((IT) == DMA1_IT_TE5) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_GL6) || ((IT) == DMA1_IT_TC6) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT6) || ((IT) == DMA1_IT_TE6) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_GL7) || ((IT) == DMA1_IT_TC7) || \[m
[32m+[m[32m                           ((IT) == DMA1_IT_HT7) || ((IT) == DMA1_IT_TE7) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_GL1) || ((IT) == DMA2_IT_TC1) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_HT1) || ((IT) == DMA2_IT_TE1) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_GL2) || ((IT) == DMA2_IT_TC2) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_HT2) || ((IT) == DMA2_IT_TE2) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_GL3) || ((IT) == DMA2_IT_TC3) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_HT3) || ((IT) == DMA2_IT_TE3) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_GL4) || ((IT) == DMA2_IT_TC4) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_HT4) || ((IT) == DMA2_IT_TE4) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_GL5) || ((IT) == DMA2_IT_TC5) || \[m
[32m+[m[32m                           ((IT) == DMA2_IT_HT5) || ((IT) == DMA2_IT_TE5))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_flags_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define DMA1_FLAG_GL1                      ((uint32_t)0x00000001)[m
[32m+[m[32m#define DMA1_FLAG_TC1                      ((uint32_t)0x00000002)[m
[32m+[m[32m#define DMA1_FLAG_HT1                      ((uint32_t)0x00000004)[m
[32m+[m[32m#define DMA1_FLAG_TE1                      ((uint32_t)0x00000008)[m
[32m+[m[32m#define DMA1_FLAG_GL2                      ((uint32_t)0x00000010)[m
[32m+[m[32m#define DMA1_FLAG_TC2                      ((uint32_t)0x00000020)[m
[32m+[m[32m#define DMA1_FLAG_HT2                      ((uint32_t)0x00000040)[m
[32m+[m[32m#define DMA1_FLAG_TE2                      ((uint32_t)0x00000080)[m
[32m+[m[32m#define DMA1_FLAG_GL3                      ((uint32_t)0x00000100)[m
[32m+[m[32m#define DMA1_FLAG_TC3                      ((uint32_t)0x00000200)[m
[32m+[m[32m#define DMA1_FLAG_HT3                      ((uint32_t)0x00000400)[m
[32m+[m[32m#define DMA1_FLAG_TE3                      ((uint32_t)0x00000800)[m
[32m+[m[32m#define DMA1_FLAG_GL4                      ((uint32_t)0x00001000)[m
[32m+[m[32m#define DMA1_FLAG_TC4                      ((uint32_t)0x00002000)[m
[32m+[m[32m#define DMA1_FLAG_HT4                      ((uint32_t)0x00004000)[m
[32m+[m[32m#define DMA1_FLAG_TE4                      ((uint32_t)0x00008000)[m
[32m+[m[32m#define DMA1_FLAG_GL5                      ((uint32_t)0x00010000)[m
[32m+[m[32m#define DMA1_FLAG_TC5                      ((uint32_t)0x00020000)[m
[32m+[m[32m#define DMA1_FLAG_HT5                      ((uint32_t)0x00040000)[m
[32m+[m[32m#define DMA1_FLAG_TE5                      ((uint32_t)0x00080000)[m
[32m+[m[32m#define DMA1_FLAG_GL6                      ((uint32_t)0x00100000)[m
[32m+[m[32m#define DMA1_FLAG_TC6                      ((uint32_t)0x00200000)[m
[32m+[m[32m#define DMA1_FLAG_HT6                      ((uint32_t)0x00400000)[m
[32m+[m[32m#define DMA1_FLAG_TE6                      ((uint32_t)0x00800000)[m
[32m+[m[32m#define DMA1_FLAG_GL7                      ((uint32_t)0x01000000)[m
[32m+[m[32m#define DMA1_FLAG_TC7                      ((uint32_t)0x02000000)[m
[32m+[m[32m#define DMA1_FLAG_HT7                      ((uint32_t)0x04000000)[m
[32m+[m[32m#define DMA1_FLAG_TE7                      ((uint32_t)0x08000000)[m
[32m+[m
[32m+[m[32m#define DMA2_FLAG_GL1                      ((uint32_t)0x10000001)[m
[32m+[m[32m#define DMA2_FLAG_TC1                      ((uint32_t)0x10000002)[m
[32m+[m[32m#define DMA2_FLAG_HT1                      ((uint32_t)0x10000004)[m
[32m+[m[32m#define DMA2_FLAG_TE1                      ((uint32_t)0x10000008)[m
[32m+[m[32m#define DMA2_FLAG_GL2                      ((uint32_t)0x10000010)[m
[32m+[m[32m#define DMA2_FLAG_TC2                      ((uint32_t)0x10000020)[m
[32m+[m[32m#define DMA2_FLAG_HT2                      ((uint32_t)0x10000040)[m
[32m+[m[32m#define DMA2_FLAG_TE2                      ((uint32_t)0x10000080)[m
[32m+[m[32m#define DMA2_FLAG_GL3                      ((uint32_t)0x10000100)[m
[32m+[m[32m#define DMA2_FLAG_TC3                      ((uint32_t)0x10000200)[m
[32m+[m[32m#define DMA2_FLAG_HT3                      ((uint32_t)0x10000400)[m
[32m+[m[32m#define DMA2_FLAG_TE3                      ((uint32_t)0x10000800)[m
[32m+[m[32m#define DMA2_FLAG_GL4                      ((uint32_t)0x10001000)[m
[32m+[m[32m#define DMA2_FLAG_TC4                      ((uint32_t)0x10002000)[m
[32m+[m[32m#define DMA2_FLAG_HT4                      ((uint32_t)0x10004000)[m
[32m+[m[32m#define DMA2_FLAG_TE4                      ((uint32_t)0x10008000)[m
[32m+[m[32m#define DMA2_FLAG_GL5                      ((uint32_t)0x10010000)[m
[32m+[m[32m#define DMA2_FLAG_TC5                      ((uint32_t)0x10020000)[m
[32m+[m[32m#define DMA2_FLAG_HT5                      ((uint32_t)0x10040000)[m
[32m+[m[32m#define DMA2_FLAG_TE5                      ((uint32_t)0x10080000)[m
[32m+[m
[32m+[m[32m#define IS_DMA_CLEAR_FLAG(FLAG) (((((FLAG) & 0xF0000000) == 0x00) || (((FLAG) & 0xEFF00000) == 0x00)) && ((FLAG) != 0x00))[m
[32m+[m
[32m+[m[32m#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA1_FLAG_GL1) || ((FLAG) == DMA1_FLAG_TC1) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT1) || ((FLAG) == DMA1_FLAG_TE1) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_GL2) || ((FLAG) == DMA1_FLAG_TC2) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT2) || ((FLAG) == DMA1_FLAG_TE2) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_GL3) || ((FLAG) == DMA1_FLAG_TC3) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT3) || ((FLAG) == DMA1_FLAG_TE3) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_GL4) || ((FLAG) == DMA1_FLAG_TC4) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT4) || ((FLAG) == DMA1_FLAG_TE4) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_GL5) || ((FLAG) == DMA1_FLAG_TC5) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT5) || ((FLAG) == DMA1_FLAG_TE5) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_GL6) || ((FLAG) == DMA1_FLAG_TC6) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT6) || ((FLAG) == DMA1_FLAG_TE6) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_GL7) || ((FLAG) == DMA1_FLAG_TC7) || \[m
[32m+[m[32m                               ((FLAG) == DMA1_FLAG_HT7) || ((FLAG) == DMA1_FLAG_TE7) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_GL1) || ((FLAG) == DMA2_FLAG_TC1) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_HT1) || ((FLAG) == DMA2_FLAG_TE1) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_GL2) || ((FLAG) == DMA2_FLAG_TC2) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_HT2) || ((FLAG) == DMA2_FLAG_TE2) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_GL3) || ((FLAG) == DMA2_FLAG_TC3) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_HT3) || ((FLAG) == DMA2_FLAG_TE3) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_GL4) || ((FLAG) == DMA2_FLAG_TC4) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_HT4) || ((FLAG) == DMA2_FLAG_TE4) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_GL5) || ((FLAG) == DMA2_FLAG_TC5) || \[m
[32m+[m[32m                               ((FLAG) == DMA2_FLAG_HT5) || ((FLAG) == DMA2_FLAG_TE5))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Buffer_Size[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx);[m
[32m+[m[32mvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct);[m
[32m+[m[32mvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);[m
[32m+[m[32mvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState);[m
[32m+[m[32mvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState);[m
[32m+[m[32mvoid DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber);[m[41m [m
[32m+[m[32muint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx);[m
[32m+[m[32mFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG);[m
[32m+[m[32mvoid DMA_ClearFlag(uint32_t DMAy_FLAG);[m
[32m+[m[32mITStatus DMA_GetITStatus(uint32_t DMAy_IT);[m
[32m+[m[32mvoid DMA_ClearITPendingBit(uint32_t DMAy_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_DMA_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h[m
[1mnew file mode 100644[m
[1mindex 0000000..bb9d7f6[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_exti.h[m
[36m@@ -0,0 +1,184 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_exti.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the EXTI firmware[m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_EXTI_H[m
[32m+[m[32m#define __STM32F10x_EXTI_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup EXTI[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  EXTI mode enumeration[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef enum[m
[32m+[m[32m{[m
[32m+[m[32m  EXTI_Mode_Interrupt = 0x00,[m
[32m+[m[32m  EXTI_Mode_Event = 0x04[m
[32m+[m[32m}EXTIMode_TypeDef;[m
[32m+[m
[32m+[m[32m#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  EXTI Trigger enumeration[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef enum[m
[32m+[m[32m{[m
[32m+[m[32m  EXTI_Trigger_Rising = 0x08,[m
[32m+[m[32m  EXTI_Trigger_Falling = 0x0C,[m[41m  [m
[32m+[m[32m  EXTI_Trigger_Rising_Falling = 0x10[m
[32m+[m[32m}EXTITrigger_TypeDef;[m
[32m+[m
[32m+[m[32m#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \[m
[32m+[m[32m                                  ((TRIGGER) == EXTI_Trigger_Falling) || \[m
[32m+[m[32m                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  EXTI Init Structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.[m
[32m+[m[32m                                         This parameter can be any combination of @ref EXTI_Lines */[m
[32m+[m[41m   [m
[32m+[m[32m  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.[m
[32m+[m[32m                                         This parameter can be a value of @ref EXTIMode_TypeDef */[m
[32m+[m
[32m+[m[32m  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.[m
[32m+[m[32m                                         This parameter can be a value of @ref EXTIMode_TypeDef */[m
[32m+[m
[32m+[m[32m  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.[m
[32m+[m[32m                                         This parameter can be set either to ENABLE or DISABLE */[m[41m [m
[32m+[m[32m}EXTI_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Lines[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define EXTI_Line0       ((uint32_t)0x00001)  /*!< External interrupt line 0 */[m
[32m+[m[32m#define EXTI_Line1       ((uint32_t)0x00002)  /*!< External interrupt line 1 */[m
[32m+[m[32m#define EXTI_Line2       ((uint32_t)0x00004)  /*!< External interrupt line 2 */[m
[32m+[m[32m#define EXTI_Line3       ((uint32_t)0x00008)  /*!< External interrupt line 3 */[m
[32m+[m[32m#define EXTI_Line4       ((uint32_t)0x00010)  /*!< External interrupt line 4 */[m
[32m+[m[32m#define EXTI_Line5       ((uint32_t)0x00020)  /*!< External interrupt line 5 */[m
[32m+[m[32m#define EXTI_Line6       ((uint32_t)0x00040)  /*!< External interrupt line 6 */[m
[32m+[m[32m#define EXTI_Line7       ((uint32_t)0x00080)  /*!< External interrupt line 7 */[m
[32m+[m[32m#define EXTI_Line8       ((uint32_t)0x00100)  /*!< External interrupt line 8 */[m
[32m+[m[32m#define EXTI_Line9       ((uint32_t)0x00200)  /*!< External interrupt line 9 */[m
[32m+[m[32m#define EXTI_Line10      ((uint32_t)0x00400)  /*!< External interrupt line 10 */[m
[32m+[m[32m#define EXTI_Line11      ((uint32_t)0x00800)  /*!< External interrupt line 11 */[m
[32m+[m[32m#define EXTI_Line12      ((uint32_t)0x01000)  /*!< External interrupt line 12 */[m
[32m+[m[32m#define EXTI_Line13      ((uint32_t)0x02000)  /*!< External interrupt line 13 */[m
[32m+[m[32m#define EXTI_Line14      ((uint32_t)0x04000)  /*!< External interrupt line 14 */[m
[32m+[m[32m#define EXTI_Line15      ((uint32_t)0x08000)  /*!< External interrupt line 15 */[m
[32m+[m[32m#define EXTI_Line16      ((uint32_t)0x10000)  /*!< External interrupt line 16 Connected to the PVD Output */[m
[32m+[m[32m#define EXTI_Line17      ((uint32_t)0x20000)  /*!< External interrupt line 17 Connected to the RTC Alarm event */[m
[32m+[m[32m#define EXTI_Line18      ((uint32_t)0x40000)  /*!< External interrupt line 18 Connected to the USB Device/USB OTG FS[m
[32m+[m[32m                                                   Wakeup from suspend event */[m[41m                                    [m
[32m+[m[32m#define EXTI_Line19      ((uint32_t)0x80000)  /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */[m
[32m+[m[41m                                          [m
[32m+[m[32m#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFFF00000) == 0x00) && ((LINE) != (uint16_t)0x00))[m
[32m+[m[32m#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \[m
[32m+[m[32m                            ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19))[m
[32m+[m
[32m+[m[41m                    [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid EXTI_DeInit(void);[m
[32m+[m[32mvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);[m
[32m+[m[32mvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);[m
[32m+[m[32mvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);[m
[32m+[m[32mFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);[m
[32m+[m[32mvoid EXTI_ClearFlag(uint32_t EXTI_Line);[m
[32m+[m[32mITStatus EXTI_GetITStatus(uint32_t EXTI_Line);[m
[32m+[m[32mvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_EXTI_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h[m
[1mnew file mode 100644[m
[1mindex 0000000..63720de[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_flash.h[m
[36m@@ -0,0 +1,426 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_flash.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the FLASH[m[41m [m
[32m+[m[32m  *          firmware library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_FLASH_H[m
[32m+[m[32m#define __STM32F10x_FLASH_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup FLASH[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  FLASH Status[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef enum[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  FLASH_BUSY = 1,[m
[32m+[m[32m  FLASH_ERROR_PG,[m
[32m+[m[32m  FLASH_ERROR_WRP,[m
[32m+[m[32m  FLASH_COMPLETE,[m
[32m+[m[32m  FLASH_TIMEOUT[m
[32m+[m[32m}FLASH_Status;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Flash_Latency[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FLASH_Latency_0                ((uint32_t)0x00000000)  /*!< FLASH Zero Latency cycle */[m
[32m+[m[32m#define FLASH_Latency_1                ((uint32_t)0x00000001)  /*!< FLASH One Latency cycle */[m
[32m+[m[32m#define FLASH_Latency_2                ((uint32_t)0x00000002)  /*!< FLASH Two Latency cycles */[m
[32m+[m[32m#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \[m
[32m+[m[32m                                   ((LATENCY) == FLASH_Latency_1) || \[m
[32m+[m[32m                                   ((LATENCY) == FLASH_Latency_2))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Half_Cycle_Enable_Disable[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FLASH_HalfCycleAccess_Enable   ((uint32_t)0x00000008)  /*!< FLASH Half Cycle Enable */[m
[32m+[m[32m#define FLASH_HalfCycleAccess_Disable  ((uint32_t)0x00000000)  /*!< FLASH Half Cycle Disable */[m
[32m+[m[32m#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \[m
[32m+[m[32m                                               ((STATE) == FLASH_HalfCycleAccess_Disable))[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Prefetch_Buffer_Enable_Disable[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FLASH_PrefetchBuffer_Enable    ((uint32_t)0x00000010)  /*!< FLASH Prefetch Buffer Enable */[m
[32m+[m[32m#define FLASH_PrefetchBuffer_Disable   ((uint32_t)0x00000000)  /*!< FLASH Prefetch Buffer Disable */[m
[32m+[m[32m#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \[m
[32m+[m[32m                                              ((STATE) == FLASH_PrefetchBuffer_Disable))[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Option_Bytes_Write_Protection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Values to be used with STM32 Low and Medium density devices */[m
[32m+[m[32m#define FLASH_WRProt_Pages0to3         ((uint32_t)0x00000001) /*!< STM32 Low and Medium density devices: Write protection of page 0 to 3 */[m
[32m+[m[32m#define FLASH_WRProt_Pages4to7         ((uint32_t)0x00000002) /*!< STM32 Low and Medium density devices: Write protection of page 4 to 7 */[m
[32m+[m[32m#define FLASH_WRProt_Pages8to11        ((uint32_t)0x00000004) /*!< STM32 Low and Medium density devices: Write protection of page 8 to 11 */[m
[32m+[m[32m#define FLASH_WRProt_Pages12to15       ((uint32_t)0x00000008) /*!< STM32 Low and Medium density devices: Write protection of page 12 to 15 */[m
[32m+[m[32m#define FLASH_WRProt_Pages16to19       ((uint32_t)0x00000010) /*!< STM32 Low and Medium density devices: Write protection of page 16 to 19 */[m
[32m+[m[32m#define FLASH_WRProt_Pages20to23       ((uint32_t)0x00000020) /*!< STM32 Low and Medium density devices: Write protection of page 20 to 23 */[m
[32m+[m[32m#define FLASH_WRProt_Pages24to27       ((uint32_t)0x00000040) /*!< STM32 Low and Medium density devices: Write protection of page 24 to 27 */[m
[32m+[m[32m#define FLASH_WRProt_Pages28to31       ((uint32_t)0x00000080) /*!< STM32 Low and Medium density devices: Write protection of page 28 to 31 */[m
[32m+[m
[32m+[m[32m/* Values to be used with STM32 Medium-density devices */[m
[32m+[m[32m#define FLASH_WRProt_Pages32to35       ((uint32_t)0x00000100) /*!< STM32 Medium-density devices: Write protection of page 32 to 35 */[m
[32m+[m[32m#define FLASH_WRProt_Pages36to39       ((uint32_t)0x00000200) /*!< STM32 Medium-density devices: Write protection of page 36 to 39 */[m
[32m+[m[32m#define FLASH_WRProt_Pages40to43       ((uint32_t)0x00000400) /*!< STM32 Medium-density devices: Write protection of page 40 to 43 */[m
[32m+[m[32m#define FLASH_WRProt_Pages44to47       ((uint32_t)0x00000800) /*!< STM32 Medium-density devices: Write protection of page 44 to 47 */[m
[32m+[m[32m#define FLASH_WRProt_Pages48to51       ((uint32_t)0x00001000) /*!< STM32 Medium-density devices: Write protection of page 48 to 51 */[m
[32m+[m[32m#define FLASH_WRProt_Pages52to55       ((uint32_t)0x00002000) /*!< STM32 Medium-density devices: Write protection of page 52 to 55 */[m
[32m+[m[32m#define FLASH_WRProt_Pages56to59       ((uint32_t)0x00004000) /*!< STM32 Medium-density devices: Write protection of page 56 to 59 */[m
[32m+[m[32m#define FLASH_WRProt_Pages60to63       ((uint32_t)0x00008000) /*!< STM32 Medium-density devices: Write protection of page 60 to 63 */[m
[32m+[m[32m#define FLASH_WRProt_Pages64to67       ((uint32_t)0x00010000) /*!< STM32 Medium-density devices: Write protection of page 64 to 67 */[m
[32m+[m[32m#define FLASH_WRProt_Pages68to71       ((uint32_t)0x00020000) /*!< STM32 Medium-density devices: Write protection of page 68 to 71 */[m
[32m+[m[32m#define FLASH_WRProt_Pages72to75       ((uint32_t)0x00040000) /*!< STM32 Medium-density devices: Write protection of page 72 to 75 */[m
[32m+[m[32m#define FLASH_WRProt_Pages76to79       ((uint32_t)0x00080000) /*!< STM32 Medium-density devices: Write protection of page 76 to 79 */[m
[32m+[m[32m#define FLASH_WRProt_Pages80to83       ((uint32_t)0x00100000) /*!< STM32 Medium-density devices: Write protection of page 80 to 83 */[m
[32m+[m[32m#define FLASH_WRProt_Pages84to87       ((uint32_t)0x00200000) /*!< STM32 Medium-density devices: Write protection of page 84 to 87 */[m
[32m+[m[32m#define FLASH_WRProt_Pages88to91       ((uint32_t)0x00400000) /*!< STM32 Medium-density devices: Write protection of page 88 to 91 */[m
[32m+[m[32m#define FLASH_WRProt_Pages92to95       ((uint32_t)0x00800000) /*!< STM32 Medium-density devices: Write protection of page 92 to 95 */[m
[32m+[m[32m#define FLASH_WRProt_Pages96to99       ((uint32_t)0x01000000) /*!< STM32 Medium-density devices: Write protection of page 96 to 99 */[m
[32m+[m[32m#define FLASH_WRProt_Pages100to103     ((uint32_t)0x02000000) /*!< STM32 Medium-density devices: Write protection of page 100 to 103 */[m
[32m+[m[32m#define FLASH_WRProt_Pages104to107     ((uint32_t)0x04000000) /*!< STM32 Medium-density devices: Write protection of page 104 to 107 */[m
[32m+[m[32m#define FLASH_WRProt_Pages108to111     ((uint32_t)0x08000000) /*!< STM32 Medium-density devices: Write protection of page 108 to 111 */[m
[32m+[m[32m#define FLASH_WRProt_Pages112to115     ((uint32_t)0x10000000) /*!< STM32 Medium-density devices: Write protection of page 112 to 115 */[m
[32m+[m[32m#define FLASH_WRProt_Pages116to119     ((uint32_t)0x20000000) /*!< STM32 Medium-density devices: Write protection of page 115 to 119 */[m
[32m+[m[32m#define FLASH_WRProt_Pages120to123     ((uint32_t)0x40000000) /*!< STM32 Medium-density devices: Write protection of page 120 to 123 */[m
[32m+[m[32m#define FLASH_WRProt_Pages124to127     ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 124 to 127 */[m
[32m+[m
[32m+[m[32m/* Values to be used with STM32 High-density and STM32F10X Connectivity line devices */[m
[32m+[m[32m#define FLASH_WRProt_Pages0to1         ((uint32_t)0x00000001) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 0 to 1 */[m
[32m+[m[32m#define FLASH_WRProt_Pages2to3         ((uint32_t)0x00000002) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 2 to 3 */[m
[32m+[m[32m#define FLASH_WRProt_Pages4to5         ((uint32_t)0x00000004) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 4 to 5 */[m
[32m+[m[32m#define FLASH_WRProt_Pages6to7         ((uint32_t)0x00000008) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 6 to 7 */[m
[32m+[m[32m#define FLASH_WRProt_Pages8to9         ((uint32_t)0x00000010) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 8 to 9 */[m
[32m+[m[32m#define FLASH_WRProt_Pages10to11       ((uint32_t)0x00000020) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 10 to 11 */[m
[32m+[m[32m#define FLASH_WRProt_Pages12to13       ((uint32_t)0x00000040) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 12 to 13 */[m
[32m+[m[32m#define FLASH_WRProt_Pages14to15       ((uint32_t)0x00000080) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 14 to 15 */[m
[32m+[m[32m#define FLASH_WRProt_Pages16to17       ((uint32_t)0x00000100) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 16 to 17 */[m
[32m+[m[32m#define FLASH_WRProt_Pages18to19       ((uint32_t)0x00000200) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 18 to 19 */[m
[32m+[m[32m#define FLASH_WRProt_Pages20to21       ((uint32_t)0x00000400) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 20 to 21 */[m
[32m+[m[32m#define FLASH_WRProt_Pages22to23       ((uint32_t)0x00000800) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 22 to 23 */[m
[32m+[m[32m#define FLASH_WRProt_Pages24to25       ((uint32_t)0x00001000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 24 to 25 */[m
[32m+[m[32m#define FLASH_WRProt_Pages26to27       ((uint32_t)0x00002000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 26 to 27 */[m
[32m+[m[32m#define FLASH_WRProt_Pages28to29       ((uint32_t)0x00004000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 28 to 29 */[m
[32m+[m[32m#define FLASH_WRProt_Pages30to31       ((uint32_t)0x00008000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 30 to 31 */[m
[32m+[m[32m#define FLASH_WRProt_Pages32to33       ((uint32_t)0x00010000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 32 to 33 */[m
[32m+[m[32m#define FLASH_WRProt_Pages34to35       ((uint32_t)0x00020000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 34 to 35 */[m
[32m+[m[32m#define FLASH_WRProt_Pages36to37       ((uint32_t)0x00040000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 36 to 37 */[m
[32m+[m[32m#define FLASH_WRProt_Pages38to39       ((uint32_t)0x00080000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 38 to 39 */[m
[32m+[m[32m#define FLASH_WRProt_Pages40to41       ((uint32_t)0x00100000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 40 to 41 */[m
[32m+[m[32m#define FLASH_WRProt_Pages42to43       ((uint32_t)0x00200000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 42 to 43 */[m
[32m+[m[32m#define FLASH_WRProt_Pages44to45       ((uint32_t)0x00400000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 44 to 45 */[m
[32m+[m[32m#define FLASH_WRProt_Pages46to47       ((uint32_t)0x00800000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 46 to 47 */[m
[32m+[m[32m#define FLASH_WRProt_Pages48to49       ((uint32_t)0x01000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 48 to 49 */[m
[32m+[m[32m#define FLASH_WRProt_Pages50to51       ((uint32_t)0x02000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 50 to 51 */[m
[32m+[m[32m#define FLASH_WRProt_Pages52to53       ((uint32_t)0x04000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 52 to 53 */[m
[32m+[m[32m#define FLASH_WRProt_Pages54to55       ((uint32_t)0x08000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 54 to 55 */[m
[32m+[m[32m#define FLASH_WRProt_Pages56to57       ((uint32_t)0x10000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 56 to 57 */[m
[32m+[m[32m#define FLASH_WRProt_Pages58to59       ((uint32_t)0x20000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 58 to 59 */[m
[32m+[m[32m#define FLASH_WRProt_Pages60to61       ((uint32_t)0x40000000) /*!< STM32 High-density, XL-density and Connectivity line devices:[m
[32m+[m[32m                                                                   Write protection of page 60 to 61 */[m
[32m+[m[32m#define FLASH_WRProt_Pages62to127      ((uint32_t)0x80000000) /*!< STM32 Connectivity line devices: Write protection of page 62 to 127 */[m
[32m+[m[32m#define FLASH_WRProt_Pages62to255      ((uint32_t)0x80000000) /*!< STM32 Medium-density devices: Write protection of page 62 to 255 */[m
[32m+[m[32m#define FLASH_WRProt_Pages62to511      ((uint32_t)0x80000000) /*!< STM32 XL-density devices: Write protection of page 62 to 511 */[m
[32m+[m
[32m+[m[32m#define FLASH_WRProt_AllPages          ((uint32_t)0xFFFFFFFF) /*!< Write protection of all Pages */[m
[32m+[m
[32m+[m[32m#define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))[m
[32m+[m
[32m+[m[32m#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x080FFFFF))[m
[32m+[m
[32m+[m[32m#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Option_Bytes_IWatchdog[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define OB_IWDG_SW                     ((uint16_t)0x0001)  /*!< Software IWDG selected */[m
[32m+[m[32m#define OB_IWDG_HW                     ((uint16_t)0x0000)  /*!< Hardware IWDG selected */[m
[32m+[m[32m#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Option_Bytes_nRST_STOP[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define OB_STOP_NoRST                  ((uint16_t)0x0002) /*!< No reset generated when entering in STOP */[m
[32m+[m[32m#define OB_STOP_RST                    ((uint16_t)0x0000) /*!< Reset generated when entering in STOP */[m
[32m+[m[32m#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Option_Bytes_nRST_STDBY[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define OB_STDBY_NoRST                 ((uint16_t)0x0004) /*!< No reset generated when entering in STANDBY */[m
[32m+[m[32m#define OB_STDBY_RST                   ((uint16_t)0x0000) /*!< Reset generated when entering in STANDBY */[m
[32m+[m[32m#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m/** @defgroup FLASH_Boot[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define FLASH_BOOT_Bank1  ((uint16_t)0x0000) /*!< At startup, if boot pins are set in boot from user Flash position[m
[32m+[m[32m                                                  and this parameter is selected the device will boot from Bank1(Default) */[m
[32m+[m[32m#define FLASH_BOOT_Bank2  ((uint16_t)0x0001) /*!< At startup, if boot pins are set in boot from user Flash position[m
[32m+[m[32m                                                  and this parameter is selected the device will boot from Bank 2 or Bank 1,[m
[32m+[m[32m                                                  depending on the activation of the bank */[m
[32m+[m[32m#define IS_FLASH_BOOT(BOOT) (((BOOT) == FLASH_BOOT_Bank1) || ((BOOT) == FLASH_BOOT_Bank2))[m
[32m+[m[32m#endif[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m/** @defgroup FLASH_Interrupts[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m#define FLASH_IT_BANK2_ERROR                 ((uint32_t)0x80000400)  /*!< FPEC BANK2 error interrupt source */[m
[32m+[m[32m#define FLASH_IT_BANK2_EOP                   ((uint32_t)0x80001000)  /*!< End of FLASH BANK2 Operation Interrupt source */[m
[32m+[m
[32m+[m[32m#define FLASH_IT_BANK1_ERROR                 FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */[m
[32m+[m[32m#define FLASH_IT_BANK1_EOP                   FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */[m
[32m+[m
[32m+[m[32m#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC BANK1 error interrupt source */[m
[32m+[m[32m#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH BANK1 Operation Interrupt source */[m
[32m+[m[32m#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0x7FFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))[m
[32m+[m[32m#else[m
[32m+[m[32m#define FLASH_IT_ERROR                 ((uint32_t)0x00000400)  /*!< FPEC error interrupt source */[m
[32m+[m[32m#define FLASH_IT_EOP                   ((uint32_t)0x00001000)  /*!< End of FLASH Operation Interrupt source */[m
[32m+[m[32m#define FLASH_IT_BANK1_ERROR           FLASH_IT_ERROR          /*!< FPEC BANK1 error interrupt source */[m
[32m+[m[32m#define FLASH_IT_BANK1_EOP             FLASH_IT_EOP            /*!< End of FLASH BANK1 Operation Interrupt source */[m
[32m+[m
[32m+[m[32m#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m#define FLASH_FLAG_BANK2_BSY                 ((uint32_t)0x80000001)  /*!< FLASH BANK2 Busy flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK2_EOP                 ((uint32_t)0x80000020)  /*!< FLASH BANK2 End of Operation flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK2_PGERR               ((uint32_t)0x80000004)  /*!< FLASH BANK2 Program error flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK2_WRPRTERR            ((uint32_t)0x80000010)  /*!< FLASH BANK2 Write protected error flag */[m
[32m+[m
[32m+[m[32m#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/[m
[32m+[m[32m#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */[m
[32m+[m
[32m+[m[32m#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */[m
[32m+[m[32m#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */[m
[32m+[m[32m#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */[m
[32m+[m[32m#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */[m
[32m+[m[32m#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */[m
[32m+[m[41m [m
[32m+[m[32m#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0x7FFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))[m
[32m+[m[32m#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_OPTERR)|| \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_BANK2_BSY) || ((FLAG) == FLASH_FLAG_BANK2_EOP) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_BANK2_PGERR) || ((FLAG) == FLASH_FLAG_BANK2_WRPRTERR))[m
[32m+[m[32m#else[m
[32m+[m[32m#define FLASH_FLAG_BSY                 ((uint32_t)0x00000001)  /*!< FLASH Busy flag */[m
[32m+[m[32m#define FLASH_FLAG_EOP                 ((uint32_t)0x00000020)  /*!< FLASH End of Operation flag */[m
[32m+[m[32m#define FLASH_FLAG_PGERR               ((uint32_t)0x00000004)  /*!< FLASH Program error flag */[m
[32m+[m[32m#define FLASH_FLAG_WRPRTERR            ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag */[m
[32m+[m[32m#define FLASH_FLAG_OPTERR              ((uint32_t)0x00000001)  /*!< FLASH Option Byte error flag */[m
[32m+[m
[32m+[m[32m#define FLASH_FLAG_BANK1_BSY                 FLASH_FLAG_BSY       /*!< FLASH BANK1 Busy flag*/[m
[32m+[m[32m#define FLASH_FLAG_BANK1_EOP                 FLASH_FLAG_EOP       /*!< FLASH BANK1 End of Operation flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK1_PGERR               FLASH_FLAG_PGERR     /*!< FLASH BANK1 Program error flag */[m
[32m+[m[32m#define FLASH_FLAG_BANK1_WRPRTERR            FLASH_FLAG_WRPRTERR  /*!< FLASH BANK1 Write protected error flag */[m
[32m+[m[41m [m
[32m+[m[32m#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))[m
[32m+[m[32m#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \[m
[32m+[m								[32m  ((FLAG) == FLASH_FLAG_BANK1_BSY) || ((FLAG) == FLASH_FLAG_BANK1_EOP) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_BANK1_PGERR) || ((FLAG) == FLASH_FLAG_BANK1_WRPRTERR) || \[m
[32m+[m[32m                                  ((FLAG) == FLASH_FLAG_OPTERR))[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/*------------ Functions used for all STM32F10x devices -----*/[m
[32m+[m[32mvoid FLASH_SetLatency(uint32_t FLASH_Latency);[m
[32m+[m[32mvoid FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess);[m
[32m+[m[32mvoid FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer);[m
[32m+[m[32mvoid FLASH_Unlock(void);[m
[32m+[m[32mvoid FLASH_Lock(void);[m
[32m+[m[32mFLASH_Status FLASH_ErasePage(uint32_t Page_Address);[m
[32m+[m[32mFLASH_Status FLASH_EraseAllPages(void);[m
[32m+[m[32mFLASH_Status FLASH_EraseOptionBytes(void);[m
[32m+[m[32mFLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);[m
[32m+[m[32mFLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);[m
[32m+[m[32mFLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data);[m
[32m+[m[32mFLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages);[m
[32m+[m[32mFLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);[m
[32m+[m[32mFLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY);[m
[32m+[m[32muint32_t FLASH_GetUserOptionByte(void);[m
[32m+[m[32muint32_t FLASH_GetWriteProtectionOptionByte(void);[m
[32m+[m[32mFlagStatus FLASH_GetReadOutProtectionStatus(void);[m
[32m+[m[32mFlagStatus FLASH_GetPrefetchBufferStatus(void);[m
[32m+[m[32mvoid FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);[m
[32m+[m[32mFlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG);[m
[32m+[m[32mvoid FLASH_ClearFlag(uint32_t FLASH_FLAG);[m
[32m+[m[32mFLASH_Status FLASH_GetStatus(void);[m
[32m+[m[32mFLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout);[m
[32m+[m
[32m+[m[32m/*------------ New function used for all STM32F10x devices -----*/[m
[32m+[m[32mvoid FLASH_UnlockBank1(void);[m
[32m+[m[32mvoid FLASH_LockBank1(void);[m
[32m+[m[32mFLASH_Status FLASH_EraseAllBank1Pages(void);[m
[32m+[m[32mFLASH_Status FLASH_GetBank1Status(void);[m
[32m+[m[32mFLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout);[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/*---- New Functions used only with STM32F10x_XL density devices -----*/[m
[32m+[m[32mvoid FLASH_UnlockBank2(void);[m
[32m+[m[32mvoid FLASH_LockBank2(void);[m
[32m+[m[32mFLASH_Status FLASH_EraseAllBank2Pages(void);[m
[32m+[m[32mFLASH_Status FLASH_GetBank2Status(void);[m
[32m+[m[32mFLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout);[m
[32m+[m[32mFLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_FLASH_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h[m
[1mnew file mode 100644[m
[1mindex 0000000..6e1769d[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_fsmc.h[m
[36m@@ -0,0 +1,733 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_fsmc.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the FSMC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_FSMC_H[m
[32m+[m[32m#define __STM32F10x_FSMC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup FSMC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Timing parameters For NOR/SRAM Banks[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure[m
[32m+[m[32m                                             the duration of the address setup time.[m[41m [m
[32m+[m[32m                                             This parameter can be a value between 0 and 0xF.[m
[32m+[m[32m                                             @note: It is not used with synchronous NOR Flash memories. */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure[m
[32m+[m[32m                                             the duration of the address hold time.[m
[32m+[m[32m                                             This parameter can be a value between 0 and 0xF.[m[41m [m
[32m+[m[32m                                             @note: It is not used with synchronous NOR Flash memories.*/[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure[m
[32m+[m[32m                                             the duration of the data setup time.[m
[32m+[m[32m                                             This parameter can be a value between 0 and 0xFF.[m
[32m+[m[32m                                             @note: It is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure[m
[32m+[m[32m                                             the duration of the bus turnaround.[m
[32m+[m[32m                                             This parameter can be a value between 0 and 0xF.[m
[32m+[m[32m                                             @note: It is only used for multiplexed NOR Flash memories. */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.[m
[32m+[m[32m                                             This parameter can be a value between 1 and 0xF.[m
[32m+[m[32m                                             @note: This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue[m
[32m+[m[32m                                             to the memory before getting the first data.[m
[32m+[m[32m                                             The value of this parameter depends on the memory type as shown below:[m
[32m+[m[32m                                              - It must be set to 0 in case of a CRAM[m
[32m+[m[32m                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses[m
[32m+[m[32m                                              - It may assume a value between 0 and 0xF in NOR Flash memories[m
[32m+[m[32m                                                with synchronous burst mode enable */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode.[m[41m [m
[32m+[m[32m                                             This parameter can be a value of @ref FSMC_Access_Mode */[m
[32m+[m[32m}FSMC_NORSRAMTimingInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  FSMC NOR/SRAM Init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are[m
[32m+[m[32m                                          multiplexed on the databus or not.[m[41m [m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to[m
[32m+[m[32m                                          the corresponding memory bank.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Memory_Type */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Data_Width */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,[m
[32m+[m[32m                                          valid only with synchronous burst Flash memories.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */[m
[32m+[m[41m                                       [m
[32m+[m[32m  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,[m
[32m+[m[32m                                          valid only with asynchronous Flash memories.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_AsynchronousWait */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing[m
[32m+[m[32m                                          the Flash memory in burst mode.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash[m
[32m+[m[32m                                          memory, valid only when accessing Flash memories in burst mode.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Wrap_Mode */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one[m
[32m+[m[32m                                          clock cycle before the wait state or during the wait state,[m
[32m+[m[32m                                          valid only when accessing memories in burst mode.[m[41m [m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Wait_Timing */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC.[m[41m [m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Write_Operation */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait-state insertion via wait[m
[32m+[m[32m                                          signal, valid for Flash memory access in burst mode.[m[41m [m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Wait_Signal */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Extended_Mode */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.[m
[32m+[m[32m                                          This parameter can be a value of @ref FSMC_Write_Burst */[m[41m [m
[32m+[m
[32m+[m[32m  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  ExtendedMode is not used*/[m[41m  [m
[32m+[m
[32m+[m[32m  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  ExtendedMode is used*/[m[41m      [m
[32m+[m[32m}FSMC_NORSRAMInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Timing parameters For FSMC NAND and PCCARD Banks[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before[m
[32m+[m[32m                                     the command assertion for NAND-Flash read or write access[m
[32m+[m[32m                                     to common/Attribute or I/O memory space (depending on[m
[32m+[m[32m                                     the memory space timing to be configured).[m
[32m+[m[32m                                     This parameter can be a value between 0 and 0xFF.*/[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the[m
[32m+[m[32m                                     command for NAND-Flash read or write access to[m
[32m+[m[32m                                     common/Attribute or I/O memory space (depending on the[m
[32m+[m[32m                                     memory space timing to be configured).[m[41m [m
[32m+[m[32m                                     This parameter can be a number between 0x00 and 0xFF */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address[m
[32m+[m[32m                                     (and data for write access) after the command deassertion[m
[32m+[m[32m                                     for NAND-Flash read or write access to common/Attribute[m
[32m+[m[32m                                     or I/O memory space (depending on the memory space timing[m
[32m+[m[32m                                     to be configured).[m
[32m+[m[32m                                     This parameter can be a number between 0x00 and 0xFF */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the[m
[32m+[m[32m                                     databus is kept in HiZ after the start of a NAND-Flash[m
[32m+[m[32m                                     write access to common/Attribute or I/O memory space (depending[m
[32m+[m[32m                                     on the memory space timing to be configured).[m
[32m+[m[32m                                     This parameter can be a number between 0x00 and 0xFF */[m
[32m+[m[32m}FSMC_NAND_PCCARDTimingInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  FSMC NAND Init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.[m
[32m+[m[32m                                      This parameter can be a value of @ref FSMC_NAND_Bank */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.[m
[32m+[m[32m                                       This parameter can be any value of @ref FSMC_Wait_feature */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.[m
[32m+[m[32m                                       This parameter can be any value of @ref FSMC_Data_Width */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.[m
[32m+[m[32m                                       This parameter can be any value of @ref FSMC_ECC */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.[m
[32m+[m[32m                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the[m
[32m+[m[32m                                       delay between CLE low and RE low.[m
[32m+[m[32m                                       This parameter can be a value between 0 and 0xFF. */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the[m
[32m+[m[32m                                       delay between ALE low and RE low.[m
[32m+[m[32m                                       This parameter can be a number between 0x0 and 0xFF */[m[41m [m
[32m+[m
[32m+[m[32m  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */[m[41m [m
[32m+[m
[32m+[m[32m  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */[m
[32m+[m[32m}FSMC_NANDInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  FSMC PCCARD Init structure definition[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.[m
[32m+[m[32m                                    This parameter can be any value of @ref FSMC_Wait_feature */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the[m
[32m+[m[32m                                     delay between CLE low and RE low.[m
[32m+[m[32m                                     This parameter can be a value between 0 and 0xFF. */[m
[32m+[m
[32m+[m[32m  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the[m
[32m+[m[32m                                     delay between ALE low and RE low.[m
[32m+[m[32m                                     This parameter can be a number between 0x0 and 0xFF */[m[41m [m
[32m+[m
[32m+[m[41m  [m
[32m+[m[32m  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */[m
[32m+[m
[32m+[m[32m  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */[m[41m  [m
[32m+[m[32m}FSMC_PCCARDInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_NORSRAM_Bank[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define FSMC_Bank1_NORSRAM1                             ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_Bank1_NORSRAM2                             ((uint32_t)0x00000002)[m
[32m+[m[32m#define FSMC_Bank1_NORSRAM3                             ((uint32_t)0x00000004)[m
[32m+[m[32m#define FSMC_Bank1_NORSRAM4                             ((uint32_t)0x00000006)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_NAND_Bank[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m[32m#define FSMC_Bank2_NAND                                 ((uint32_t)0x00000010)[m
[32m+[m[32m#define FSMC_Bank3_NAND                                 ((uint32_t)0x00000100)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_PCCARD_Bank[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m    [m
[32m+[m[32m#define FSMC_Bank4_PCCARD                               ((uint32_t)0x00001000)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \[m
[32m+[m[32m                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \[m
[32m+[m[32m                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \[m
[32m+[m[32m                                    ((BANK) == FSMC_Bank1_NORSRAM4))[m
[32m+[m
[32m+[m[32m#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \[m
[32m+[m[32m                                 ((BANK) == FSMC_Bank3_NAND))[m
[32m+[m
[32m+[m[32m#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \[m
[32m+[m[32m                                    ((BANK) == FSMC_Bank3_NAND) || \[m
[32m+[m[32m                                    ((BANK) == FSMC_Bank4_PCCARD))[m
[32m+[m
[32m+[m[32m#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \[m
[32m+[m[32m                               ((BANK) == FSMC_Bank3_NAND) || \[m
[32m+[m[32m                               ((BANK) == FSMC_Bank4_PCCARD))[m
[32m+[m
[32m+[m[32m/** @defgroup NOR_SRAM_Controller[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Data_Address_Bus_Multiplexing[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_DataAddressMux_Disable                       ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_DataAddressMux_Enable                        ((uint32_t)0x00000002)[m
[32m+[m[32m#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \[m
[32m+[m[32m                          ((MUX) == FSMC_DataAddressMux_Enable))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Memory_Type[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_MemoryType_SRAM                            ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_MemoryType_PSRAM                           ((uint32_t)0x00000004)[m
[32m+[m[32m#define FSMC_MemoryType_NOR                             ((uint32_t)0x00000008)[m
[32m+[m[32m#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \[m
[32m+[m[32m                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \[m
[32m+[m[32m                                ((MEMORY) == FSMC_MemoryType_NOR))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Data_Width[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_MemoryDataWidth_8b                         ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_MemoryDataWidth_16b                        ((uint32_t)0x00000010)[m
[32m+[m[32m#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \[m
[32m+[m[32m                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Burst_Access_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_BurstAccessMode_Disable                    ((uint32_t)0x00000000)[m[41m [m
[32m+[m[32m#define FSMC_BurstAccessMode_Enable                     ((uint32_t)0x00000100)[m
[32m+[m[32m#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \[m
[32m+[m[32m                                  ((STATE) == FSMC_BurstAccessMode_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/** @defgroup FSMC_AsynchronousWait[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define FSMC_AsynchronousWait_Disable                   ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_AsynchronousWait_Enable                    ((uint32_t)0x00008000)[m
[32m+[m[32m#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \[m
[32m+[m[32m                                 ((STATE) == FSMC_AsynchronousWait_Enable))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/** @defgroup FSMC_Wait_Signal_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_WaitSignalPolarity_Low                     ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_WaitSignalPolarity_High                    ((uint32_t)0x00000200)[m
[32m+[m[32m#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \[m
[32m+[m[32m                                         ((POLARITY) == FSMC_WaitSignalPolarity_High))[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Wrap_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_WrapMode_Disable                           ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_WrapMode_Enable                            ((uint32_t)0x00000400)[m[41m [m
[32m+[m[32m#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \[m
[32m+[m[32m                                 ((MODE) == FSMC_WrapMode_Enable))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Wait_Timing[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_WaitSignalActive_BeforeWaitState           ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_WaitSignalActive_DuringWaitState           ((uint32_t)0x00000800)[m[41m [m
[32m+[m[32m#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \[m
[32m+[m[32m                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Write_Operation[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)[m
[32m+[m[32m#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \[m
[32m+[m[32m                                            ((OPERATION) == FSMC_WriteOperation_Enable))[m
[32m+[m[41m                              [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Wait_Signal[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_WaitSignal_Disable                         ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_WaitSignal_Enable                          ((uint32_t)0x00002000)[m[41m [m
[32m+[m[32m#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \[m
[32m+[m[32m                                      ((SIGNAL) == FSMC_WaitSignal_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Extended_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_ExtendedMode_Disable                       ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_ExtendedMode_Enable                        ((uint32_t)0x00004000)[m
[32m+[m
[32m+[m[32m#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \[m
[32m+[m[32m                                     ((MODE) == FSMC_ExtendedMode_Enable))[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Write_Burst[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_WriteBurst_Disable                         ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_WriteBurst_Enable                          ((uint32_t)0x00080000)[m[41m [m
[32m+[m[32m#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \[m
[32m+[m[32m                                    ((BURST) == FSMC_WriteBurst_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Address_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Address_Hold_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Data_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Bus_Turn_around_Duration[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_CLK_Division[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Data_Latency[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Access_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_AccessMode_A                               ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_AccessMode_B                               ((uint32_t)0x10000000)[m[41m [m
[32m+[m[32m#define FSMC_AccessMode_C                               ((uint32_t)0x20000000)[m
[32m+[m[32m#define FSMC_AccessMode_D                               ((uint32_t)0x30000000)[m
[32m+[m[32m#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \[m
[32m+[m[32m                                   ((MODE) == FSMC_AccessMode_B) || \[m
[32m+[m[32m                                   ((MODE) == FSMC_AccessMode_C) || \[m
[32m+[m[32m                                   ((MODE) == FSMC_AccessMode_D))[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/** @defgroup NAND_PCCARD_Controller[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Wait_feature[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_Waitfeature_Disable                        ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_Waitfeature_Enable                         ((uint32_t)0x00000002)[m
[32m+[m[32m#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \[m
[32m+[m[32m                                       ((FEATURE) == FSMC_Waitfeature_Enable))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_ECC[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_ECC_Disable                                ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_ECC_Enable                                 ((uint32_t)0x00000040)[m
[32m+[m[32m#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \[m
[32m+[m[32m                                  ((STATE) == FSMC_ECC_Enable))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_ECC_Page_Size[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_ECCPageSize_256Bytes                       ((uint32_t)0x00000000)[m
[32m+[m[32m#define FSMC_ECCPageSize_512Bytes                       ((uint32_t)0x00020000)[m
[32m+[m[32m#define FSMC_ECCPageSize_1024Bytes                      ((uint32_t)0x00040000)[m
[32m+[m[32m#define FSMC_ECCPageSize_2048Bytes                      ((uint32_t)0x00060000)[m
[32m+[m[32m#define FSMC_ECCPageSize_4096Bytes                      ((uint32_t)0x00080000)[m
[32m+[m[32m#define FSMC_ECCPageSize_8192Bytes                      ((uint32_t)0x000A0000)[m
[32m+[m[32m#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \[m
[32m+[m[32m                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \[m
[32m+[m[32m                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \[m
[32m+[m[32m                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \[m
[32m+[m[32m                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \[m
[32m+[m[32m                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_TCLR_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_TAR_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Wait_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Hold_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_HiZ_Setup_Time[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Interrupt_sources[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_IT_RisingEdge                              ((uint32_t)0x00000008)[m
[32m+[m[32m#define FSMC_IT_Level                                   ((uint32_t)0x00000010)[m
[32m+[m[32m#define FSMC_IT_FallingEdge                             ((uint32_t)0x00000020)[m
[32m+[m[32m#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))[m
[32m+[m[32m#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \[m
[32m+[m[32m                            ((IT) == FSMC_IT_Level) || \[m
[32m+[m[32m                            ((IT) == FSMC_IT_FallingEdge))[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define FSMC_FLAG_RisingEdge                            ((uint32_t)0x00000001)[m
[32m+[m[32m#define FSMC_FLAG_Level                                 ((uint32_t)0x00000002)[m
[32m+[m[32m#define FSMC_FLAG_FallingEdge                           ((uint32_t)0x00000004)[m
[32m+[m[32m#define FSMC_FLAG_FEMPT                                 ((uint32_t)0x00000040)[m
[32m+[m[32m#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \[m
[32m+[m[32m                                ((FLAG) == FSMC_FLAG_Level) || \[m
[32m+[m[32m                                ((FLAG) == FSMC_FLAG_FallingEdge) || \[m
[32m+[m[32m                                ((FLAG) == FSMC_FLAG_FEMPT))[m
[32m+[m
[32m+[m[32m#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);[m
[32m+[m[32mvoid FSMC_NANDDeInit(uint32_t FSMC_Bank);[m
[32m+[m[32mvoid FSMC_PCCARDDeInit(void);[m
[32m+[m[32mvoid FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);[m
[32m+[m[32mvoid FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);[m
[32m+[m[32mvoid FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);[m
[32m+[m[32mvoid FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);[m
[32m+[m[32mvoid FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);[m
[32m+[m[32mvoid FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);[m
[32m+[m[32mvoid FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);[m
[32m+[m[32mvoid FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);[m
[32m+[m[32mvoid FSMC_PCCARDCmd(FunctionalState NewState);[m
[32m+[m[32mvoid FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);[m
[32m+[m[32muint32_t FSMC_GetECC(uint32_t FSMC_Bank);[m
[32m+[m[32mvoid FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);[m
[32m+[m[32mFlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);[m
[32m+[m[32mvoid FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);[m
[32m+[m[32mITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);[m
[32m+[m[32mvoid FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_FSMC_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h[m
[1mnew file mode 100644[m
[1mindex 0000000..dd28da8[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_gpio.h[m
[36m@@ -0,0 +1,385 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_gpio.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the GPIO[m[41m [m
[32m+[m[32m  *          firmware library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_GPIO_H[m
[32m+[m[32m#define __STM32F10x_GPIO_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup GPIO[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \[m
[32m+[m[32m                                    ((PERIPH) == GPIOB) || \[m
[32m+[m[32m                                    ((PERIPH) == GPIOC) || \[m
[32m+[m[32m                                    ((PERIPH) == GPIOD) || \[m
[32m+[m[32m                                    ((PERIPH) == GPIOE) || \[m
[32m+[m[32m                                    ((PERIPH) == GPIOF) || \[m
[32m+[m[32m                                    ((PERIPH) == GPIOG))[m
[32m+[m[41m                                     [m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Output Maximum frequency selection[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef enum[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  GPIO_Speed_10MHz = 1,[m
[32m+[m[32m  GPIO_Speed_2MHz,[m[41m [m
[32m+[m[32m  GPIO_Speed_50MHz[m
[32m+[m[32m}GPIOSpeed_TypeDef;[m
[32m+[m[32m#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \[m
[32m+[m[32m                              ((SPEED) == GPIO_Speed_50MHz))[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Configuration Mode enumeration[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef enum[m
[32m+[m[32m{ GPIO_Mode_AIN = 0x0,[m
[32m+[m[32m  GPIO_Mode_IN_FLOATING = 0x04,[m
[32m+[m[32m  GPIO_Mode_IPD = 0x28,[m
[32m+[m[32m  GPIO_Mode_IPU = 0x48,[m
[32m+[m[32m  GPIO_Mode_Out_OD = 0x14,[m
[32m+[m[32m  GPIO_Mode_Out_PP = 0x10,[m
[32m+[m[32m  GPIO_Mode_AF_OD = 0x1C,[m
[32m+[m[32m  GPIO_Mode_AF_PP = 0x18[m
[32m+[m[32m}GPIOMode_TypeDef;[m
[32m+[m
[32m+[m[32m#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \[m
[32m+[m[32m                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \[m
[32m+[m[32m                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \[m
[32m+[m[32m                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  GPIO Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.[m
[32m+[m[32m                                      This parameter can be any value of @ref GPIO_pins_define */[m
[32m+[m
[32m+[m[32m  GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.[m
[32m+[m[32m                                      This parameter can be a value of @ref GPIOSpeed_TypeDef */[m
[32m+[m
[32m+[m[32m  GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.[m
[32m+[m[32m                                      This parameter can be a value of @ref GPIOMode_TypeDef */[m
[32m+[m[32m}GPIO_InitTypeDef;[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Bit_SET and Bit_RESET enumeration[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef enum[m
[32m+[m[32m{ Bit_RESET = 0,[m
[32m+[m[32m  Bit_SET[m
[32m+[m[32m}BitAction;[m
[32m+[m
[32m+[m[32m#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_pins_define[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define GPIO_Pin_0                 ((uint16_t)0x0001)  /*!< Pin 0 selected */[m
[32m+[m[32m#define GPIO_Pin_1                 ((uint16_t)0x0002)  /*!< Pin 1 selected */[m
[32m+[m[32m#define GPIO_Pin_2                 ((uint16_t)0x0004)  /*!< Pin 2 selected */[m
[32m+[m[32m#define GPIO_Pin_3                 ((uint16_t)0x0008)  /*!< Pin 3 selected */[m
[32m+[m[32m#define GPIO_Pin_4                 ((uint16_t)0x0010)  /*!< Pin 4 selected */[m
[32m+[m[32m#define GPIO_Pin_5                 ((uint16_t)0x0020)  /*!< Pin 5 selected */[m
[32m+[m[32m#define GPIO_Pin_6                 ((uint16_t)0x0040)  /*!< Pin 6 selected */[m
[32m+[m[32m#define GPIO_Pin_7                 ((uint16_t)0x0080)  /*!< Pin 7 selected */[m
[32m+[m[32m#define GPIO_Pin_8                 ((uint16_t)0x0100)  /*!< Pin 8 selected */[m
[32m+[m[32m#define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */[m
[32m+[m[32m#define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */[m
[32m+[m[32m#define GPIO_Pin_11                ((uint16_t)0x0800)  /*!< Pin 11 selected */[m
[32m+[m[32m#define GPIO_Pin_12                ((uint16_t)0x1000)  /*!< Pin 12 selected */[m
[32m+[m[32m#define GPIO_Pin_13                ((uint16_t)0x2000)  /*!< Pin 13 selected */[m
[32m+[m[32m#define GPIO_Pin_14                ((uint16_t)0x4000)  /*!< Pin 14 selected */[m
[32m+[m[32m#define GPIO_Pin_15                ((uint16_t)0x8000)  /*!< Pin 15 selected */[m
[32m+[m[32m#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /*!< All pins selected */[m
[32m+[m
[32m+[m[32m#define IS_GPIO_PIN(PIN) ((((PIN) & (uint16_t)0x00) == 0x00) && ((PIN) != (uint16_t)0x00))[m
[32m+[m
[32m+[m[32m#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_1) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_2) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_3) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_4) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_5) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_6) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_7) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_8) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_9) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_10) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_11) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_12) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_13) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_14) || \[m
[32m+[m[32m                              ((PIN) == GPIO_Pin_15))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Remap_define[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define GPIO_Remap_SPI1             ((uint32_t)0x00000001)  /*!< SPI1 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap_I2C1             ((uint32_t)0x00000002)  /*!< I2C1 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap_USART1           ((uint32_t)0x00000004)  /*!< USART1 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap_USART2           ((uint32_t)0x00000008)  /*!< USART2 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_PartialRemap_USART3    ((uint32_t)0x00140010)  /*!< USART3 Partial Alternate Function mapping */[m
[32m+[m[32m#define GPIO_FullRemap_USART3       ((uint32_t)0x00140030)  /*!< USART3 Full Alternate Function mapping */[m
[32m+[m[32m#define GPIO_PartialRemap_TIM1      ((uint32_t)0x00160040)  /*!< TIM1 Partial Alternate Function mapping */[m
[32m+[m[32m#define GPIO_FullRemap_TIM1         ((uint32_t)0x001600C0)  /*!< TIM1 Full Alternate Function mapping */[m
[32m+[m[32m#define GPIO_PartialRemap1_TIM2     ((uint32_t)0x00180100)  /*!< TIM2 Partial1 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_PartialRemap2_TIM2     ((uint32_t)0x00180200)  /*!< TIM2 Partial2 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_FullRemap_TIM2         ((uint32_t)0x00180300)  /*!< TIM2 Full Alternate Function mapping */[m
[32m+[m[32m#define GPIO_PartialRemap_TIM3      ((uint32_t)0x001A0800)  /*!< TIM3 Partial Alternate Function mapping */[m
[32m+[m[32m#define GPIO_FullRemap_TIM3         ((uint32_t)0x001A0C00)  /*!< TIM3 Full Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap_TIM4             ((uint32_t)0x00001000)  /*!< TIM4 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap1_CAN1            ((uint32_t)0x001D4000)  /*!< CAN1 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap2_CAN1            ((uint32_t)0x001D6000)  /*!< CAN1 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap_PD01             ((uint32_t)0x00008000)  /*!< PD01 Alternate Function mapping */[m
[32m+[m[32m#define GPIO_Remap_TIM5CH4_LSI      ((uint32_t)0x00200001)  /*!< LSI connected to TIM5 Channel4 input capture for calibration */[m
[32m+[m[32m#define GPIO_Remap_ADC1_ETRGINJ     ((uint32_t)0x00200002)  /*!< ADC1 External Trigger Injected Conversion remapping */[m
[32m+[m[32m#define GPIO_Remap_ADC1_ETRGREG     ((uint32_t)0x00200004)  /*!< ADC1 External Trigger Regular Conversion remapping */[m
[32m+[m[32m#define GPIO_Remap_ADC2_ETRGINJ     ((uint32_t)0x00200008)  /*!< ADC2 External Trigger Injected Conversion remapping */[m
[32m+[m[32m#define GPIO_Remap_ADC2_ETRGREG     ((uint32_t)0x00200010)  /*!< ADC2 External Trigger Regular Conversion remapping */[m
[32m+[m[32m#define GPIO_Remap_ETH              ((uint32_t)0x00200020)  /*!< Ethernet remapping (only for Connectivity line devices) */[m
[32m+[m[32m#define GPIO_Remap_CAN2             ((uint32_t)0x00200040)  /*!< CAN2 remapping (only for Connectivity line devices) */[m
[32m+[m[32m#define GPIO_Remap_SWJ_NoJTRST      ((uint32_t)0x00300100)  /*!< Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */[m
[32m+[m[32m#define GPIO_Remap_SWJ_JTAGDisable  ((uint32_t)0x00300200)  /*!< JTAG-DP Disabled and SW-DP Enabled */[m
[32m+[m[32m#define GPIO_Remap_SWJ_Disable      ((uint32_t)0x00300400)  /*!< Full SWJ Disabled (JTAG-DP + SW-DP) */[m
[32m+[m[32m#define GPIO_Remap_SPI3             ((uint32_t)0x00201100)  /*!< SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM2ITR1_PTP_SOF ((uint32_t)0x00202000)  /*!< Ethernet PTP output or USB OTG SOF (Start of Frame) connected[m
[32m+[m[32m                                                                 to TIM2 Internal Trigger 1 for calibration[m
[32m+[m[32m                                                                 (only for Connectivity line devices) */[m
[32m+[m[32m#define GPIO_Remap_PTP_PPS          ((uint32_t)0x00204000)  /*!< Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices) */[m
[32m+[m
[32m+[m[32m#define GPIO_Remap_TIM15            ((uint32_t)0x80000001)  /*!< TIM15 Alternate Function mapping (only for Value line devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM16            ((uint32_t)0x80000002)  /*!< TIM16 Alternate Function mapping (only for Value line devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM17            ((uint32_t)0x80000004)  /*!< TIM17 Alternate Function mapping (only for Value line devices) */[m
[32m+[m[32m#define GPIO_Remap_CEC              ((uint32_t)0x80000008)  /*!< CEC Alternate Function mapping (only for Value line devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM1_DMA         ((uint32_t)0x80000010)  /*!< TIM1 DMA requests mapping (only for Value line devices) */[m
[32m+[m
[32m+[m[32m#define GPIO_Remap_TIM9             ((uint32_t)0x80000020)  /*!< TIM9 Alternate Function mapping (only for XL-density devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM10            ((uint32_t)0x80000040)  /*!< TIM10 Alternate Function mapping (only for XL-density devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM11            ((uint32_t)0x80000080)  /*!< TIM11 Alternate Function mapping (only for XL-density devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM13            ((uint32_t)0x80000100)  /*!< TIM13 Alternate Function mapping (only for High density Value line and XL-density devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM14            ((uint32_t)0x80000200)  /*!< TIM14 Alternate Function mapping (only for High density Value line and XL-density devices) */[m
[32m+[m[32m#define GPIO_Remap_FSMC_NADV        ((uint32_t)0x80000400)  /*!< FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices) */[m
[32m+[m
[32m+[m[32m#define GPIO_Remap_TIM67_DAC_DMA    ((uint32_t)0x80000800)  /*!< TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices) */[m
[32m+[m[32m#define GPIO_Remap_TIM12            ((uint32_t)0x80001000)  /*!< TIM12 Alternate Function mapping (only for High density Value line devices) */[m
[32m+[m[32m#define GPIO_Remap_MISC             ((uint32_t)0x80002000)  /*!< Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping,[m[41m [m
[32m+[m[32m                                                                 only for High density Value line devices) */[m[41m                                                       [m
[32m+[m
[32m+[m[32m#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap1_CAN1) || ((REMAP) == GPIO_Remap2_CAN1) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_ETH) ||((REMAP) == GPIO_Remap_CAN2) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_SWJ_Disable)|| ((REMAP) == GPIO_Remap_SPI3) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM2ITR1_PTP_SOF) || ((REMAP) == GPIO_Remap_PTP_PPS) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM15) || ((REMAP) == GPIO_Remap_TIM16) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM17) || ((REMAP) == GPIO_Remap_CEC) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM1_DMA) || ((REMAP) == GPIO_Remap_TIM9) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM10) || ((REMAP) == GPIO_Remap_TIM11) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM13) || ((REMAP) == GPIO_Remap_TIM14) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_FSMC_NADV) || ((REMAP) == GPIO_Remap_TIM67_DAC_DMA) || \[m
[32m+[m[32m                              ((REMAP) == GPIO_Remap_TIM12) || ((REMAP) == GPIO_Remap_MISC))[m
[32m+[m[41m                              [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Port_Sources[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define GPIO_PortSourceGPIOA       ((uint8_t)0x00)[m
[32m+[m[32m#define GPIO_PortSourceGPIOB       ((uint8_t)0x01)[m
[32m+[m[32m#define GPIO_PortSourceGPIOC       ((uint8_t)0x02)[m
[32m+[m[32m#define GPIO_PortSourceGPIOD       ((uint8_t)0x03)[m
[32m+[m[32m#define GPIO_PortSourceGPIOE       ((uint8_t)0x04)[m
[32m+[m[32m#define GPIO_PortSourceGPIOF       ((uint8_t)0x05)[m
[32m+[m[32m#define GPIO_PortSourceGPIOG       ((uint8_t)0x06)[m
[32m+[m[32m#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \[m
[32m+[m[32m                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \[m
[32m+[m[32m                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \[m
[32m+[m[32m                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \[m
[32m+[m[32m                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOE))[m
[32m+[m
[32m+[m[32m#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \[m
[32m+[m[32m                                              ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \[m
[32m+[m[32m                                              ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \[m
[32m+[m[32m                                              ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \[m
[32m+[m[32m                                              ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \[m
[32m+[m[32m                                              ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \[m
[32m+[m[32m                                              ((PORTSOURCE) == GPIO_PortSourceGPIOG))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Pin_sources[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define GPIO_PinSource0            ((uint8_t)0x00)[m
[32m+[m[32m#define GPIO_PinSource1            ((uint8_t)0x01)[m
[32m+[m[32m#define GPIO_PinSource2            ((uint8_t)0x02)[m
[32m+[m[32m#define GPIO_PinSource3            ((uint8_t)0x03)[m
[32m+[m[32m#define GPIO_PinSource4            ((uint8_t)0x04)[m
[32m+[m[32m#define GPIO_PinSource5            ((uint8_t)0x05)[m
[32m+[m[32m#define GPIO_PinSource6            ((uint8_t)0x06)[m
[32m+[m[32m#define GPIO_PinSource7            ((uint8_t)0x07)[m
[32m+[m[32m#define GPIO_PinSource8            ((uint8_t)0x08)[m
[32m+[m[32m#define GPIO_PinSource9            ((uint8_t)0x09)[m
[32m+[m[32m#define GPIO_PinSource10           ((uint8_t)0x0A)[m
[32m+[m[32m#define GPIO_PinSource11           ((uint8_t)0x0B)[m
[32m+[m[32m#define GPIO_PinSource12           ((uint8_t)0x0C)[m
[32m+[m[32m#define GPIO_PinSource13           ((uint8_t)0x0D)[m
[32m+[m[32m#define GPIO_PinSource14           ((uint8_t)0x0E)[m
[32m+[m[32m#define GPIO_PinSource15           ((uint8_t)0x0F)[m
[32m+[m
[32m+[m[32m#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource1) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource2) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource3) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource4) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource5) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource6) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource7) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource8) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource9) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource10) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource11) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource12) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource13) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource14) || \[m
[32m+[m[32m                                       ((PINSOURCE) == GPIO_PinSource15))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Ethernet_Media_Interface[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define GPIO_ETH_MediaInterface_MII    ((u32)0x00000000)[m[41m [m
[32m+[m[32m#define GPIO_ETH_MediaInterface_RMII   ((u32)0x00000001)[m[41m                                       [m
[32m+[m
[32m+[m[32m#define IS_GPIO_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == GPIO_ETH_MediaInterface_MII) || \[m
[32m+[m[32m                                                ((INTERFACE) == GPIO_ETH_MediaInterface_RMII))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m                                                [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);[m
[32m+[m[32mvoid GPIO_AFIODeInit(void);[m
[32m+[m[32mvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);[m
[32m+[m[32mvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);[m
[32m+[m[32muint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);[m
[32m+[m[32muint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);[m
[32m+[m[32muint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);[m
[32m+[m[32muint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);[m
[32m+[m[32mvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);[m
[32m+[m[32mvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);[m
[32m+[m[32mvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);[m
[32m+[m[32mvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);[m
[32m+[m[32mvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);[m
[32m+[m[32mvoid GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);[m
[32m+[m[32mvoid GPIO_EventOutputCmd(FunctionalState NewState);[m
[32m+[m[32mvoid GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState);[m
[32m+[m[32mvoid GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);[m
[32m+[m[32mvoid GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_GPIO_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h[m
[1mnew file mode 100644[m
[1mindex 0000000..60e4b14[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_i2c.h[m
[36m@@ -0,0 +1,684 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_i2c.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the I2C firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_I2C_H[m
[32m+[m[32m#define __STM32F10x_I2C_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup I2C[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  I2C Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.[m
[32m+[m[32m                                         This parameter must be set to a value lower than 400kHz */[m
[32m+[m
[32m+[m[32m  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.[m
[32m+[m[32m                                         This parameter can be a value of @ref I2C_mode */[m
[32m+[m
[32m+[m[32m  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.[m
[32m+[m[32m                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */[m
[32m+[m
[32m+[m[32m  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.[m
[32m+[m[32m                                         This parameter can be a 7-bit or 10-bit address. */[m
[32m+[m
[32m+[m[32m  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.[m
[32m+[m[32m                                         This parameter can be a value of @ref I2C_acknowledgement */[m
[32m+[m
[32m+[m[32m  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.[m
[32m+[m[32m                                         This parameter can be a value of @ref I2C_acknowledged_address */[m
[32m+[m[32m}I2C_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \[m
[32m+[m[32m                                   ((PERIPH) == I2C2))[m
[32m+[m[32m/** @defgroup I2C_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_Mode_I2C                    ((uint16_t)0x0000)[m
[32m+[m[32m#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)[m[41m  [m
[32m+[m[32m#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)[m
[32m+[m[32m#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \[m
[32m+[m[32m                           ((MODE) == I2C_Mode_SMBusDevice) || \[m
[32m+[m[32m                           ((MODE) == I2C_Mode_SMBusHost))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_duty_cycle_in_fast_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */[m
[32m+[m[32m#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */[m
[32m+[m[32m#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \[m
[32m+[m[32m                                  ((CYCLE) == I2C_DutyCycle_2))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2C_acknowledgement[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_Ack_Enable                  ((uint16_t)0x0400)[m
[32m+[m[32m#define I2C_Ack_Disable                 ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \[m
[32m+[m[32m                                 ((STATE) == I2C_Ack_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_transfer_direction[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define  I2C_Direction_Transmitter      ((uint8_t)0x00)[m
[32m+[m[32m#define  I2C_Direction_Receiver         ((uint8_t)0x01)[m
[32m+[m[32m#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \[m
[32m+[m[32m                                     ((DIRECTION) == I2C_Direction_Receiver))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_acknowledged_address[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)[m
[32m+[m[32m#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)[m
[32m+[m[32m#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \[m
[32m+[m[32m                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2C_registers[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_Register_CR1                ((uint8_t)0x00)[m
[32m+[m[32m#define I2C_Register_CR2                ((uint8_t)0x04)[m
[32m+[m[32m#define I2C_Register_OAR1               ((uint8_t)0x08)[m
[32m+[m[32m#define I2C_Register_OAR2               ((uint8_t)0x0C)[m
[32m+[m[32m#define I2C_Register_DR                 ((uint8_t)0x10)[m
[32m+[m[32m#define I2C_Register_SR1                ((uint8_t)0x14)[m
[32m+[m[32m#define I2C_Register_SR2                ((uint8_t)0x18)[m
[32m+[m[32m#define I2C_Register_CCR                ((uint8_t)0x1C)[m
[32m+[m[32m#define I2C_Register_TRISE              ((uint8_t)0x20)[m
[32m+[m[32m#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_CR2) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_OAR1) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_OAR2) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_DR) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_SR1) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_SR2) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_CCR) || \[m
[32m+[m[32m                                   ((REGISTER) == I2C_Register_TRISE))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_SMBus_alert_pin_level[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)[m
[32m+[m[32m#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)[m
[32m+[m[32m#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \[m
[32m+[m[32m                                   ((ALERT) == I2C_SMBusAlert_High))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_PEC_position[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_PECPosition_Next            ((uint16_t)0x0800)[m
[32m+[m[32m#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)[m
[32m+[m[32m#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \[m
[32m+[m[32m                                       ((POSITION) == I2C_PECPosition_Current))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2C_NCAK_position[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_NACKPosition_Next           ((uint16_t)0x0800)[m
[32m+[m[32m#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)[m
[32m+[m[32m#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \[m
[32m+[m[32m                                         ((POSITION) == I2C_NACKPosition_Current))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2C_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_IT_BUF                      ((uint16_t)0x0400)[m
[32m+[m[32m#define I2C_IT_EVT                      ((uint16_t)0x0200)[m
[32m+[m[32m#define I2C_IT_ERR                      ((uint16_t)0x0100)[m
[32m+[m[32m#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2C_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)[m
[32m+[m[32m#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)[m
[32m+[m[32m#define I2C_IT_PECERR                   ((uint32_t)0x01001000)[m
[32m+[m[32m#define I2C_IT_OVR                      ((uint32_t)0x01000800)[m
[32m+[m[32m#define I2C_IT_AF                       ((uint32_t)0x01000400)[m
[32m+[m[32m#define I2C_IT_ARLO                     ((uint32_t)0x01000200)[m
[32m+[m[32m#define I2C_IT_BERR                     ((uint32_t)0x01000100)[m
[32m+[m[32m#define I2C_IT_TXE                      ((uint32_t)0x06000080)[m
[32m+[m[32m#define I2C_IT_RXNE                     ((uint32_t)0x06000040)[m
[32m+[m[32m#define I2C_IT_STOPF                    ((uint32_t)0x02000010)[m
[32m+[m[32m#define I2C_IT_ADD10                    ((uint32_t)0x02000008)[m
[32m+[m[32m#define I2C_IT_BTF                      ((uint32_t)0x02000004)[m
[32m+[m[32m#define I2C_IT_ADDR                     ((uint32_t)0x02000002)[m
[32m+[m[32m#define I2C_IT_SB                       ((uint32_t)0x02000001)[m
[32m+[m
[32m+[m[32m#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))[m
[32m+[m
[32m+[m[32m#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \[m
[32m+[m[32m                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \[m
[32m+[m[32m                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \[m
[32m+[m[32m                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \[m
[32m+[m[32m                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \[m
[32m+[m[32m                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \[m
[32m+[m[32m                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_flags_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  SR2 register flags[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)[m
[32m+[m[32m#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)[m
[32m+[m[32m#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)[m
[32m+[m[32m#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)[m
[32m+[m[32m#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)[m
[32m+[m[32m#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)[m
[32m+[m[32m#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  SR1 register flags[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)[m
[32m+[m[32m#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)[m
[32m+[m[32m#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)[m
[32m+[m[32m#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)[m
[32m+[m[32m#define I2C_FLAG_AF                     ((uint32_t)0x10000400)[m
[32m+[m[32m#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)[m
[32m+[m[32m#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)[m
[32m+[m[32m#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)[m
[32m+[m[32m#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)[m
[32m+[m[32m#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)[m
[32m+[m[32m#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)[m
[32m+[m[32m#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)[m
[32m+[m[32m#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)[m
[32m+[m[32m#define I2C_FLAG_SB                     ((uint32_t)0x10000001)[m
[32m+[m
[32m+[m[32m#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))[m
[32m+[m
[32m+[m[32m#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \[m
[32m+[m[32m                               ((FLAG) == I2C_FLAG_SB))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Events[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/*========================================[m
[32m+[m[41m     [m
[32m+[m[32m                     I2C Master Events (Events grouped in order of communication)[m
[32m+[m[32m                                                        ==========================================*/[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Communication start[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * After sending the START condition (I2C_GenerateSTART() function) the master[m[41m [m
[32m+[m[32m  * has to wait for this event. It means that the Start condition has been correctly[m[41m [m
[32m+[m[32m  * released on the I2C bus (the bus is free, no other devices is communicating).[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32m/* --EV5 */[m
[32m+[m[32m#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Address Acknowledge[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * After checking on EV5 (start condition correctly released on the bus), the[m[41m [m
[32m+[m[32m  * master sends the address of the slave(s) with which it will communicate[m[41m [m
[32m+[m[32m  * (I2C_Send7bitAddress() function, it also determines the direction of the communication:[m[41m [m
[32m+[m[32m  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges[m[41m [m
[32m+[m[32m  * his address. If an acknowledge is sent on the bus, one of the following events will[m[41m [m
[32m+[m[32m  * be set:[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED[m[41m [m
[32m+[m[32m  *     event is set.[m
[32m+[m[32m  *[m[41m  [m
[32m+[m[32m  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED[m[41m [m
[32m+[m[32m  *     is set[m
[32m+[m[32m  *[m[41m  [m
[32m+[m[32m  *  3) In case of 10-Bit addressing mode, the master (just after generating the START[m[41m [m
[32m+[m[32m  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData()[m[41m [m
[32m+[m[32m  *  function). Then master should wait on EV9. It means that the 10-bit addressing[m[41m [m
[32m+[m[32m  *  header has been correctly sent on the bus. Then master should send the second part of[m[41m [m
[32m+[m[32m  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master[m[41m [m
[32m+[m[32m  *  should wait for event EV6.[m[41m [m
[32m+[m[32m  *[m[41m     [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* --EV6 */[m
[32m+[m[32m#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */[m
[32m+[m[32m#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */[m
[32m+[m[32m/* --EV9 */[m
[32m+[m[32m#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Communication events[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * If a communication is established (START condition generated and slave address[m[41m [m
[32m+[m[32m  * acknowledged) then the master has to check on one of the following events for[m[41m [m
[32m+[m[32m  * communication procedures:[m
[32m+[m[32m  *[m[41m  [m
[32m+[m[32m  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read[m[41m [m
[32m+[m[32m  *    the data received from the slave (I2C_ReceiveData() function).[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * 2) Master Transmitter mode: The master has to send data (I2C_SendData()[m[41m [m
[32m+[m[32m  *    function) then to wait on event EV8 or EV8_2.[m
[32m+[m[32m  *    These two events are similar:[m[41m [m
[32m+[m[32m  *     - EV8 means that the data has been written in the data register and is[m[41m [m
[32m+[m[32m  *       being shifted out.[m
[32m+[m[32m  *     - EV8_2 means that the data has been physically shifted out and output[m[41m [m
[32m+[m[32m  *       on the bus.[m
[32m+[m[32m  *     In most cases, using EV8 is sufficient for the application.[m
[32m+[m[32m  *     Using EV8_2 leads to a slower communication but ensure more reliable test.[m
[32m+[m[32m  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission[m[41m [m
[32m+[m[32m  *     (before Stop condition generation).[m
[32m+[m[32m  *[m[41m     [m
[32m+[m[32m  *  @note In case the  user software does not guarantee that this event EV7 is[m[41m [m
[32m+[m[32m  *  managed before the current byte end of transfer, then user may check on EV7[m[41m [m
[32m+[m[32m  *  and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).[m
[32m+[m[32m  *  In this case the communication may be slower.[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Master RECEIVER mode -----------------------------*/[m[41m [m
[32m+[m[32m/* --EV7 */[m
[32m+[m[32m#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */[m
[32m+[m
[32m+[m[32m/* Master TRANSMITTER mode --------------------------*/[m
[32m+[m[32m/* --EV8 */[m
[32m+[m[32m#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */[m
[32m+[m[32m/* --EV8_2 */[m
[32m+[m[32m#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */[m
[32m+[m
[32m+[m
[32m+[m[32m/*========================================[m
[32m+[m[41m     [m
[32m+[m[32m                     I2C Slave Events (Events grouped in order of communication)[m
[32m+[m[32m                                                        ==========================================*/[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Communication start events[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * Wait on one of these events at the start of the communication. It means that[m[41m [m
[32m+[m[32m  * the I2C peripheral detected a Start condition on the bus (generated by master[m[41m [m
[32m+[m[32m  * device) followed by the peripheral address. The peripheral generates an ACK[m[41m [m
[32m+[m[32m  * condition on the bus (if the acknowledge feature is enabled through function[m[41m [m
[32m+[m[32m  * I2C_AcknowledgeConfig()) and the events listed above are set :[m
[32m+[m[32m  *[m[41m  [m
[32m+[m[32m  * 1) In normal case (only one address managed by the slave), when the address[m[41m [m
[32m+[m[32m  *   sent by the master matches the own address of the peripheral (configured by[m[41m [m
[32m+[m[32m  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set[m[41m [m
[32m+[m[32m  *   (where XXX could be TRANSMITTER or RECEIVER).[m
[32m+[m[32m  *[m[41m    [m
[32m+[m[32m  * 2) In case the address sent by the master matches the second address of the[m[41m [m
[32m+[m[32m  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled[m[41m [m
[32m+[m[32m  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED[m[41m [m
[32m+[m[32m  *   (where XXX could be TRANSMITTER or RECEIVER) are set.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * 3) In case the address sent by the master is General Call (address 0x00) and[m[41m [m
[32m+[m[32m  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd())[m[41m [m
[32m+[m[32m  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.[m[41m   [m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* --EV1  (all the events below are variants of EV1) */[m[41m   [m
[32m+[m[32m/* 1) Case of One Single Address managed by the slave */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */[m
[32m+[m
[32m+[m[32m/* 2) Case of Dual address managed by the slave */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */[m
[32m+[m
[32m+[m[32m/* 3) Case of General Call enabled for the slave */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  Communication events[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * Wait on one of these events when EV1 has already been checked and:[m[41m [m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  * - Slave RECEIVER mode:[m
[32m+[m[32m  *     - EV2: When the application is expecting a data byte to be received.[m[41m [m
[32m+[m[32m  *     - EV4: When the application is expecting the end of the communication: master[m[41m [m
[32m+[m[32m  *       sends a stop condition and data transmission is stopped.[m
[32m+[m[32m  *[m[41m    [m
[32m+[m[32m  * - Slave Transmitter mode:[m
[32m+[m[32m  *    - EV3: When a byte has been transmitted by the slave and the application is expecting[m[41m [m
[32m+[m[32m  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and[m
[32m+[m[32m  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be[m[41m [m
[32m+[m[32m  *      used when the user software doesn't guarantee the EV3 is managed before the[m
[32m+[m[32m  *      current byte end of transfer.[m
[32m+[m[32m  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission[m[41m [m
[32m+[m[32m  *      shall end (before sending the STOP condition). In this case slave has to stop sending[m[41m [m
[32m+[m[32m  *      data bytes and expect a Stop condition on the bus.[m
[32m+[m[32m  *[m[41m      [m
[32m+[m[32m  *  @note In case the  user software does not guarantee that the event EV2 is[m[41m [m
[32m+[m[32m  *  managed before the current byte end of transfer, then user may check on EV2[m[41m [m
[32m+[m[32m  *  and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).[m
[32m+[m[32m  * In this case the communication may be slower.[m
[32m+[m[32m  *[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Slave RECEIVER mode --------------------------*/[m[41m [m
[32m+[m[32m/* --EV2 */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */[m
[32m+[m[32m/* --EV4  */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */[m
[32m+[m
[32m+[m[32m/* Slave TRANSMITTER mode -----------------------*/[m
[32m+[m[32m/* --EV3 */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */[m
[32m+[m[32m/* --EV3_2 */[m
[32m+[m[32m#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */[m
[32m+[m
[32m+[m[32m/*===========================      End of Events Description           ==========================================*/[m
[32m+[m
[32m+[m[32m#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \[m
[32m+[m[32m                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \[m
[32m+[m[32m                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \[m
[32m+[m[32m                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \[m
[32m+[m[32m                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \[m
[32m+[m[32m                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_own_address1[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_clock_speed[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid I2C_DeInit(I2C_TypeDef* I2Cx);[m
[32m+[m[32mvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);[m
[32m+[m[32mvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);[m
[32m+[m[32mvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);[m
[32m+[m[32mvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);[m
[32m+[m[32muint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);[m
[32m+[m[32mvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);[m
[32m+[m[32muint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);[m
[32m+[m[32mvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);[m
[32m+[m[32mvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);[m
[32m+[m[32mvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);[m
[32m+[m[32mvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32muint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);[m
[32m+[m[32mvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);[m
[32m+[m[32mvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief[m
[32m+[m[32m ****************************************************************************************[m
[32m+[m[32m *[m
[32m+[m[32m *                         I2C State Monitoring Functions[m
[32m+[m[32m *[m[41m                       [m
[32m+[m[32m ****************************************************************************************[m[41m   [m
[32m+[m[32m * This I2C driver provides three different ways for I2C state monitoring[m
[32m+[m[32m *  depending on the application requirements and constraints:[m
[32m+[m[32m *[m[41m        [m
[32m+[m[32m *[m[41m  [m
[32m+[m[32m * 1) Basic state monitoring:[m
[32m+[m[32m *    Using I2C_CheckEvent() function:[m
[32m+[m[32m *    It compares the status registers (SR1 and SR2) content to a given event[m
[32m+[m[32m *    (can be the combination of one or more flags).[m
[32m+[m[32m *    It returns SUCCESS if the current status includes the given flags[m[41m [m
[32m+[m[32m *    and returns ERROR if one or more flags are missing in the current status.[m
[32m+[m[32m *    - When to use:[m
[32m+[m[32m *      - This function is suitable for most applications as well as for startup[m[41m [m
[32m+[m[32m *      activity since the events are fully described in the product reference manual[m[41m [m
[32m+[m[32m *      (RM0008).[m
[32m+[m[32m *      - It is also suitable for users who need to define their own events.[m
[32m+[m[32m *    - Limitations:[m
[32m+[m[32m *      - If an error occurs (ie. error flags are set besides to the monitored flags),[m
[32m+[m[32m *        the I2C_CheckEvent() function may return SUCCESS despite the communication[m
[32m+[m[32m *        hold or corrupted real state.[m[41m [m
[32m+[m[32m *        In this case, it is advised to use error interrupts to monitor the error[m
[32m+[m[32m *        events and handle them in the interrupt IRQ handler.[m
[32m+[m[32m *[m[41m        [m
[32m+[m[32m *        @note[m[41m [m
[32m+[m[32m *        For error management, it is advised to use the following functions:[m
[32m+[m[32m *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).[m
[32m+[m[32m *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.[m
[32m+[m[32m *            Where x is the peripheral instance (I2C1, I2C2 ...)[m
[32m+[m[32m *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()[m
[32m+[m[32m *            in order to determine which error occurred.[m
[32m+[m[32m *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()[m
[32m+[m[32m *            and/or I2C_GenerateStop() in order to clear the error flag and source,[m
[32m+[m[32m *            and return to correct communication status.[m
[32m+[m[32m *[m[41m            [m
[32m+[m[32m *[m
[32m+[m[32m *  2) Advanced state monitoring:[m
[32m+[m[32m *     Using the function I2C_GetLastEvent() which returns the image of both status[m[41m [m
[32m+[m[32m *     registers in a single word (uint32_t) (Status Register 2 value is shifted left[m[41m [m
[32m+[m[32m *     by 16 bits and concatenated to Status Register 1).[m
[32m+[m[32m *     - When to use:[m
[32m+[m[32m *       - This function is suitable for the same applications above but it allows to[m
[32m+[m[32m *         overcome the limitations of I2C_GetFlagStatus() function (see below).[m
[32m+[m[32m *         The returned value could be compared to events already defined in the[m[41m [m
[32m+[m[32m *         library (stm32f10x_i2c.h) or to custom values defined by user.[m
[32m+[m[32m *       - This function is suitable when multiple flags are monitored at the same time.[m
[32m+[m[32m *       - At the opposite of I2C_CheckEvent() function, this function allows user to[m
[32m+[m[32m *         choose when an event is accepted (when all events flags are set and no[m[41m [m
[32m+[m[32m *         other flags are set or just when the needed flags are set like[m[41m [m
[32m+[m[32m *         I2C_CheckEvent() function).[m
[32m+[m[32m *     - Limitations:[m
[32m+[m[32m *       - User may need to define his own events.[m
[32m+[m[32m *       - Same remark concerning the error management is applicable for this[m[41m [m
[32m+[m[32m *         function if user decides to check only regular communication flags (and[m[41m [m
[32m+[m[32m *         ignores error flags).[m
[32m+[m[32m *[m[41m     [m
[32m+[m[32m *[m
[32m+[m[32m *  3) Flag-based state monitoring:[m
[32m+[m[32m *     Using the function I2C_GetFlagStatus() which simply returns the status of[m[41m [m
[32m+[m[32m *     one single flag (ie. I2C_FLAG_RXNE ...).[m[41m [m
[32m+[m[32m *     - When to use:[m
[32m+[m[32m *        - This function could be used for specific applications or in debug phase.[m
[32m+[m[32m *        - It is suitable when only one flag checking is needed (most I2C events[m[41m [m
[32m+[m[32m *          are monitored through multiple flags).[m
[32m+[m[32m *     - Limitations:[m[41m [m
[32m+[m[32m *        - When calling this function, the Status register is accessed. Some flags are[m
[32m+[m[32m *          cleared when the status register is accessed. So checking the status[m
[32m+[m[32m *          of one Flag, may clear other ones.[m
[32m+[m[32m *        - Function may need to be called twice or more in order to monitor one[m[41m [m
[32m+[m[32m *          single event.[m
[32m+[m[32m *[m[41m            [m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m *  1) Basic state monitoring[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m[32mErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);[m
[32m+[m[32m/**[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m *  2) Advanced state monitoring[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m[32muint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);[m
[32m+[m[32m/**[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m *  3) Flag-based state monitoring[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m[32mFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);[m
[32m+[m[32m/**[m
[32m+[m[32m *[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32mvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);[m
[32m+[m[32mITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);[m
[32m+[m[32mvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_I2C_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h[m
[1mnew file mode 100644[m
[1mindex 0000000..25b0bb5[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_iwdg.h[m
[36m@@ -0,0 +1,140 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_iwdg.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the IWDG[m[41m [m
[32m+[m[32m  *          firmware library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_IWDG_H[m
[32m+[m[32m#define __STM32F10x_IWDG_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup IWDG[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_WriteAccess[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)[m
[32m+[m[32m#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \[m
[32m+[m[32m                                      ((ACCESS) == IWDG_WriteAccess_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IWDG_Prescaler_4            ((uint8_t)0x00)[m
[32m+[m[32m#define IWDG_Prescaler_8            ((uint8_t)0x01)[m
[32m+[m[32m#define IWDG_Prescaler_16           ((uint8_t)0x02)[m
[32m+[m[32m#define IWDG_Prescaler_32           ((uint8_t)0x03)[m
[32m+[m[32m#define IWDG_Prescaler_64           ((uint8_t)0x04)[m
[32m+[m[32m#define IWDG_Prescaler_128          ((uint8_t)0x05)[m
[32m+[m[32m#define IWDG_Prescaler_256          ((uint8_t)0x06)[m
[32m+[m[32m#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \[m
[32m+[m[32m                                      ((PRESCALER) == IWDG_Prescaler_8)  || \[m
[32m+[m[32m                                      ((PRESCALER) == IWDG_Prescaler_16) || \[m
[32m+[m[32m                                      ((PRESCALER) == IWDG_Prescaler_32) || \[m
[32m+[m[32m                                      ((PRESCALER) == IWDG_Prescaler_64) || \[m
[32m+[m[32m                                      ((PRESCALER) == IWDG_Prescaler_128)|| \[m
[32m+[m[32m                                      ((PRESCALER) == IWDG_Prescaler_256))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Flag[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IWDG_FLAG_PVU               ((uint16_t)0x0001)[m
[32m+[m[32m#define IWDG_FLAG_RVU               ((uint16_t)0x0002)[m
[32m+[m[32m#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))[m
[32m+[m[32m#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);[m
[32m+[m[32mvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler);[m
[32m+[m[32mvoid IWDG_SetReload(uint16_t Reload);[m
[32m+[m[32mvoid IWDG_ReloadCounter(void);[m
[32m+[m[32mvoid IWDG_Enable(void);[m
[32m+[m[32mFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_IWDG_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h[m
[1mnew file mode 100644[m
[1mindex 0000000..1c025e2[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_pwr.h[m
[36m@@ -0,0 +1,156 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_pwr.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the PWR firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_PWR_H[m
[32m+[m[32m#define __STM32F10x_PWR_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup PWR[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup PVD_detection_level[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m#define PWR_PVDLevel_2V2          ((uint32_t)0x00000000)[m
[32m+[m[32m#define PWR_PVDLevel_2V3          ((uint32_t)0x00000020)[m
[32m+[m[32m#define PWR_PVDLevel_2V4          ((uint32_t)0x00000040)[m
[32m+[m[32m#define PWR_PVDLevel_2V5          ((uint32_t)0x00000060)[m
[32m+[m[32m#define PWR_PVDLevel_2V6          ((uint32_t)0x00000080)[m
[32m+[m[32m#define PWR_PVDLevel_2V7          ((uint32_t)0x000000A0)[m
[32m+[m[32m#define PWR_PVDLevel_2V8          ((uint32_t)0x000000C0)[m
[32m+[m[32m#define PWR_PVDLevel_2V9          ((uint32_t)0x000000E0)[m
[32m+[m[32m#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \[m
[32m+[m[32m                                 ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \[m
[32m+[m[32m                                 ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \[m
[32m+[m[32m                                 ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Regulator_state_is_STOP_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define PWR_Regulator_ON          ((uint32_t)0x00000000)[m
[32m+[m[32m#define PWR_Regulator_LowPower    ((uint32_t)0x00000001)[m
[32m+[m[32m#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \[m
[32m+[m[32m                                     ((REGULATOR) == PWR_Regulator_LowPower))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup STOP_mode_entry[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define PWR_STOPEntry_WFI         ((uint8_t)0x01)[m
[32m+[m[32m#define PWR_STOPEntry_WFE         ((uint8_t)0x02)[m
[32m+[m[32m#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))[m
[32m+[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Flag[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define PWR_FLAG_WU               ((uint32_t)0x00000001)[m
[32m+[m[32m#define PWR_FLAG_SB               ((uint32_t)0x00000002)[m
[32m+[m[32m#define PWR_FLAG_PVDO             ((uint32_t)0x00000004)[m
[32m+[m[32m#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \[m
[32m+[m[32m                               ((FLAG) == PWR_FLAG_PVDO))[m
[32m+[m
[32m+[m[32m#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid PWR_DeInit(void);[m
[32m+[m[32mvoid PWR_BackupAccessCmd(FunctionalState NewState);[m
[32m+[m[32mvoid PWR_PVDCmd(FunctionalState NewState);[m
[32m+[m[32mvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);[m
[32m+[m[32mvoid PWR_WakeUpPinCmd(FunctionalState NewState);[m
[32m+[m[32mvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);[m
[32m+[m[32mvoid PWR_EnterSTANDBYMode(void);[m
[32m+[m[32mFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);[m
[32m+[m[32mvoid PWR_ClearFlag(uint32_t PWR_FLAG);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_PWR_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h[m
[1mnew file mode 100644[m
[1mindex 0000000..1149c34[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rcc.h[m
[36m@@ -0,0 +1,727 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_rcc.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the RCC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_RCC_H[m
[32m+[m[32m#define __STM32F10x_RCC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup RCC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t SYSCLK_Frequency;  /*!< returns SYSCLK clock frequency expressed in Hz */[m
[32m+[m[32m  uint32_t HCLK_Frequency;    /*!< returns HCLK clock frequency expressed in Hz */[m
[32m+[m[32m  uint32_t PCLK1_Frequency;   /*!< returns PCLK1 clock frequency expressed in Hz */[m
[32m+[m[32m  uint32_t PCLK2_Frequency;   /*!< returns PCLK2 clock frequency expressed in Hz */[m
[32m+[m[32m  uint32_t ADCCLK_Frequency;  /*!< returns ADCCLK clock frequency expressed in Hz */[m
[32m+[m[32m}RCC_ClocksTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup HSE_configuration[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_HSE_OFF                      ((uint32_t)0x00000000)[m
[32m+[m[32m#define RCC_HSE_ON                       ((uint32_t)0x00010000)[m
[32m+[m[32m#define RCC_HSE_Bypass                   ((uint32_t)0x00040000)[m
[32m+[m[32m#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \[m
[32m+[m[32m                         ((HSE) == RCC_HSE_Bypass))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup PLL_entry_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_PLLSource_HSI_Div2           ((uint32_t)0x00000000)[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_CL)[m
[32m+[m[32m #define RCC_PLLSource_HSE_Div1           ((uint32_t)0x00010000)[m
[32m+[m[32m #define RCC_PLLSource_HSE_Div2           ((uint32_t)0x00030000)[m
[32m+[m[32m #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \[m
[32m+[m[32m                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \[m
[32m+[m[32m                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))[m
[32m+[m[32m#else[m
[32m+[m[32m #define RCC_PLLSource_PREDIV1            ((uint32_t)0x00010000)[m
[32m+[m[32m #define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \[m
[32m+[m[32m                                   ((SOURCE) == RCC_PLLSource_PREDIV1))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup PLL_multiplication_factor[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m #define RCC_PLLMul_2                    ((uint32_t)0x00000000)[m
[32m+[m[32m #define RCC_PLLMul_3                    ((uint32_t)0x00040000)[m
[32m+[m[32m #define RCC_PLLMul_4                    ((uint32_t)0x00080000)[m
[32m+[m[32m #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)[m
[32m+[m[32m #define RCC_PLLMul_6                    ((uint32_t)0x00100000)[m
[32m+[m[32m #define RCC_PLLMul_7                    ((uint32_t)0x00140000)[m
[32m+[m[32m #define RCC_PLLMul_8                    ((uint32_t)0x00180000)[m
[32m+[m[32m #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)[m
[32m+[m[32m #define RCC_PLLMul_10                   ((uint32_t)0x00200000)[m
[32m+[m[32m #define RCC_PLLMul_11                   ((uint32_t)0x00240000)[m
[32m+[m[32m #define RCC_PLLMul_12                   ((uint32_t)0x00280000)[m
[32m+[m[32m #define RCC_PLLMul_13                   ((uint32_t)0x002C0000)[m
[32m+[m[32m #define RCC_PLLMul_14                   ((uint32_t)0x00300000)[m
[32m+[m[32m #define RCC_PLLMul_15                   ((uint32_t)0x00340000)[m
[32m+[m[32m #define RCC_PLLMul_16                   ((uint32_t)0x00380000)[m
[32m+[m[32m #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_16))[m
[32m+[m
[32m+[m[32m#else[m
[32m+[m[32m #define RCC_PLLMul_4                    ((uint32_t)0x00080000)[m
[32m+[m[32m #define RCC_PLLMul_5                    ((uint32_t)0x000C0000)[m
[32m+[m[32m #define RCC_PLLMul_6                    ((uint32_t)0x00100000)[m
[32m+[m[32m #define RCC_PLLMul_7                    ((uint32_t)0x00140000)[m
[32m+[m[32m #define RCC_PLLMul_8                    ((uint32_t)0x00180000)[m
[32m+[m[32m #define RCC_PLLMul_9                    ((uint32_t)0x001C0000)[m
[32m+[m[32m #define RCC_PLLMul_6_5                  ((uint32_t)0x00340000)[m
[32m+[m
[32m+[m[32m #define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5) || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7) || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9) || \[m
[32m+[m[32m                              ((MUL) == RCC_PLLMul_6_5))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m                              [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PREDIV1_division_factor[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)[m
[32m+[m[32m #define  RCC_PREDIV1_Div1               ((uint32_t)0x00000000)[m
[32m+[m[32m #define  RCC_PREDIV1_Div2               ((uint32_t)0x00000001)[m
[32m+[m[32m #define  RCC_PREDIV1_Div3               ((uint32_t)0x00000002)[m
[32m+[m[32m #define  RCC_PREDIV1_Div4               ((uint32_t)0x00000003)[m
[32m+[m[32m #define  RCC_PREDIV1_Div5               ((uint32_t)0x00000004)[m
[32m+[m[32m #define  RCC_PREDIV1_Div6               ((uint32_t)0x00000005)[m
[32m+[m[32m #define  RCC_PREDIV1_Div7               ((uint32_t)0x00000006)[m
[32m+[m[32m #define  RCC_PREDIV1_Div8               ((uint32_t)0x00000007)[m
[32m+[m[32m #define  RCC_PREDIV1_Div9               ((uint32_t)0x00000008)[m
[32m+[m[32m #define  RCC_PREDIV1_Div10              ((uint32_t)0x00000009)[m
[32m+[m[32m #define  RCC_PREDIV1_Div11              ((uint32_t)0x0000000A)[m
[32m+[m[32m #define  RCC_PREDIV1_Div12              ((uint32_t)0x0000000B)[m
[32m+[m[32m #define  RCC_PREDIV1_Div13              ((uint32_t)0x0000000C)[m
[32m+[m[32m #define  RCC_PREDIV1_Div14              ((uint32_t)0x0000000D)[m
[32m+[m[32m #define  RCC_PREDIV1_Div15              ((uint32_t)0x0000000E)[m
[32m+[m[32m #define  RCC_PREDIV1_Div16              ((uint32_t)0x0000000F)[m
[32m+[m
[32m+[m[32m #define IS_RCC_PREDIV1(PREDIV1) (((PREDIV1) == RCC_PREDIV1_Div1) || ((PREDIV1) == RCC_PREDIV1_Div2) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div3) || ((PREDIV1) == RCC_PREDIV1_Div4) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div5) || ((PREDIV1) == RCC_PREDIV1_Div6) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div7) || ((PREDIV1) == RCC_PREDIV1_Div8) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div9) || ((PREDIV1) == RCC_PREDIV1_Div10) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div11) || ((PREDIV1) == RCC_PREDIV1_Div12) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div13) || ((PREDIV1) == RCC_PREDIV1_Div14) || \[m
[32m+[m[32m                                  ((PREDIV1) == RCC_PREDIV1_Div15) || ((PREDIV1) == RCC_PREDIV1_Div16))[m
[32m+[m[32m#endif[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup PREDIV1_clock_source[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/* PREDIV1 clock source (for STM32 connectivity line devices) */[m
[32m+[m[32m #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000)[m[41m [m
[32m+[m[32m #define  RCC_PREDIV1_Source_PLL2        ((uint32_t)0x00010000)[m[41m [m
[32m+[m
[32m+[m[32m #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE) || \[m
[32m+[m[32m                                        ((SOURCE) == RCC_PREDIV1_Source_PLL2))[m[41m [m
[32m+[m[32m#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m/* PREDIV1 clock source (for STM32 Value line devices) */[m
[32m+[m[32m #define  RCC_PREDIV1_Source_HSE         ((uint32_t)0x00000000)[m[41m [m
[32m+[m
[32m+[m[32m #define IS_RCC_PREDIV1_SOURCE(SOURCE) (((SOURCE) == RCC_PREDIV1_Source_HSE))[m[41m [m
[32m+[m[32m#endif[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/** @defgroup PREDIV2_division_factor[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m #define  RCC_PREDIV2_Div1               ((uint32_t)0x00000000)[m
[32m+[m[32m #define  RCC_PREDIV2_Div2               ((uint32_t)0x00000010)[m
[32m+[m[32m #define  RCC_PREDIV2_Div3               ((uint32_t)0x00000020)[m
[32m+[m[32m #define  RCC_PREDIV2_Div4               ((uint32_t)0x00000030)[m
[32m+[m[32m #define  RCC_PREDIV2_Div5               ((uint32_t)0x00000040)[m
[32m+[m[32m #define  RCC_PREDIV2_Div6               ((uint32_t)0x00000050)[m
[32m+[m[32m #define  RCC_PREDIV2_Div7               ((uint32_t)0x00000060)[m
[32m+[m[32m #define  RCC_PREDIV2_Div8               ((uint32_t)0x00000070)[m
[32m+[m[32m #define  RCC_PREDIV2_Div9               ((uint32_t)0x00000080)[m
[32m+[m[32m #define  RCC_PREDIV2_Div10              ((uint32_t)0x00000090)[m
[32m+[m[32m #define  RCC_PREDIV2_Div11              ((uint32_t)0x000000A0)[m
[32m+[m[32m #define  RCC_PREDIV2_Div12              ((uint32_t)0x000000B0)[m
[32m+[m[32m #define  RCC_PREDIV2_Div13              ((uint32_t)0x000000C0)[m
[32m+[m[32m #define  RCC_PREDIV2_Div14              ((uint32_t)0x000000D0)[m
[32m+[m[32m #define  RCC_PREDIV2_Div15              ((uint32_t)0x000000E0)[m
[32m+[m[32m #define  RCC_PREDIV2_Div16              ((uint32_t)0x000000F0)[m
[32m+[m
[32m+[m[32m #define IS_RCC_PREDIV2(PREDIV2) (((PREDIV2) == RCC_PREDIV2_Div1) || ((PREDIV2) == RCC_PREDIV2_Div2) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div3) || ((PREDIV2) == RCC_PREDIV2_Div4) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div5) || ((PREDIV2) == RCC_PREDIV2_Div6) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div7) || ((PREDIV2) == RCC_PREDIV2_Div8) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div9) || ((PREDIV2) == RCC_PREDIV2_Div10) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div11) || ((PREDIV2) == RCC_PREDIV2_Div12) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div13) || ((PREDIV2) == RCC_PREDIV2_Div14) || \[m
[32m+[m[32m                                  ((PREDIV2) == RCC_PREDIV2_Div15) || ((PREDIV2) == RCC_PREDIV2_Div16))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup PLL2_multiplication_factor[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m #define  RCC_PLL2Mul_8                  ((uint32_t)0x00000600)[m
[32m+[m[32m #define  RCC_PLL2Mul_9                  ((uint32_t)0x00000700)[m
[32m+[m[32m #define  RCC_PLL2Mul_10                 ((uint32_t)0x00000800)[m
[32m+[m[32m #define  RCC_PLL2Mul_11                 ((uint32_t)0x00000900)[m
[32m+[m[32m #define  RCC_PLL2Mul_12                 ((uint32_t)0x00000A00)[m
[32m+[m[32m #define  RCC_PLL2Mul_13                 ((uint32_t)0x00000B00)[m
[32m+[m[32m #define  RCC_PLL2Mul_14                 ((uint32_t)0x00000C00)[m
[32m+[m[32m #define  RCC_PLL2Mul_16                 ((uint32_t)0x00000E00)[m
[32m+[m[32m #define  RCC_PLL2Mul_20                 ((uint32_t)0x00000F00)[m
[32m+[m
[32m+[m[32m #define IS_RCC_PLL2_MUL(MUL) (((MUL) == RCC_PLL2Mul_8) || ((MUL) == RCC_PLL2Mul_9)  || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL2Mul_10) || ((MUL) == RCC_PLL2Mul_11) || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL2Mul_12) || ((MUL) == RCC_PLL2Mul_13) || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL2Mul_14) || ((MUL) == RCC_PLL2Mul_16) || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL2Mul_20))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup PLL3_multiplication_factor[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m #define  RCC_PLL3Mul_8                  ((uint32_t)0x00006000)[m
[32m+[m[32m #define  RCC_PLL3Mul_9                  ((uint32_t)0x00007000)[m
[32m+[m[32m #define  RCC_PLL3Mul_10                 ((uint32_t)0x00008000)[m
[32m+[m[32m #define  RCC_PLL3Mul_11                 ((uint32_t)0x00009000)[m
[32m+[m[32m #define  RCC_PLL3Mul_12                 ((uint32_t)0x0000A000)[m
[32m+[m[32m #define  RCC_PLL3Mul_13                 ((uint32_t)0x0000B000)[m
[32m+[m[32m #define  RCC_PLL3Mul_14                 ((uint32_t)0x0000C000)[m
[32m+[m[32m #define  RCC_PLL3Mul_16                 ((uint32_t)0x0000E000)[m
[32m+[m[32m #define  RCC_PLL3Mul_20                 ((uint32_t)0x0000F000)[m
[32m+[m
[32m+[m[32m #define IS_RCC_PLL3_MUL(MUL) (((MUL) == RCC_PLL3Mul_8) || ((MUL) == RCC_PLL3Mul_9)  || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL3Mul_10) || ((MUL) == RCC_PLL3Mul_11) || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL3Mul_12) || ((MUL) == RCC_PLL3Mul_13) || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL3Mul_14) || ((MUL) == RCC_PLL3Mul_16) || \[m
[32m+[m[32m                               ((MUL) == RCC_PLL3Mul_20))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup System_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)[m
[32m+[m[32m#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)[m
[32m+[m[32m#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)[m
[32m+[m[32m#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \[m
[32m+[m[32m                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \[m
[32m+[m[32m                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup AHB_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)[m
[32m+[m[32m#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)[m
[32m+[m[32m#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)[m
[32m+[m[32m#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)[m
[32m+[m[32m#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)[m
[32m+[m[32m#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)[m
[32m+[m[32m#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)[m
[32m+[m[32m#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)[m
[32m+[m[32m#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)[m
[32m+[m[32m#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \[m
[32m+[m[32m                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \[m
[32m+[m[32m                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \[m
[32m+[m[32m                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \[m
[32m+[m[32m                           ((HCLK) == RCC_SYSCLK_Div512))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup APB1_APB2_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define RCC_HCLK_Div2                    ((uint32_t)0x00000400)[m
[32m+[m[32m#define RCC_HCLK_Div4                    ((uint32_t)0x00000500)[m
[32m+[m[32m#define RCC_HCLK_Div8                    ((uint32_t)0x00000600)[m
[32m+[m[32m#define RCC_HCLK_Div16                   ((uint32_t)0x00000700)[m
[32m+[m[32m#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \[m
[32m+[m[32m                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \[m
[32m+[m[32m                           ((PCLK) == RCC_HCLK_Div16))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Interrupt_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_IT_LSIRDY                    ((uint8_t)0x01)[m
[32m+[m[32m#define RCC_IT_LSERDY                    ((uint8_t)0x02)[m
[32m+[m[32m#define RCC_IT_HSIRDY                    ((uint8_t)0x04)[m
[32m+[m[32m#define RCC_IT_HSERDY                    ((uint8_t)0x08)[m
[32m+[m[32m#define RCC_IT_PLLRDY                    ((uint8_t)0x10)[m
[32m+[m[32m#define RCC_IT_CSS                       ((uint8_t)0x80)[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0xE0) == 0x00) && ((IT) != 0x00))[m
[32m+[m[32m #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \[m
[32m+[m[32m                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \[m
[32m+[m[32m                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))[m
[32m+[m[32m #define IS_RCC_CLEAR_IT(IT) ((((IT) & (uint8_t)0x60) == 0x00) && ((IT) != 0x00))[m
[32m+[m[32m#else[m
[32m+[m[32m #define RCC_IT_PLL2RDY                  ((uint8_t)0x20)[m
[32m+[m[32m #define RCC_IT_PLL3RDY                  ((uint8_t)0x40)[m
[32m+[m[32m #define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))[m
[32m+[m[32m #define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \[m
[32m+[m[32m                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \[m
[32m+[m[32m                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \[m
[32m+[m[32m                            ((IT) == RCC_IT_PLL2RDY) || ((IT) == RCC_IT_PLL3RDY))[m
[32m+[m[32m #define IS_RCC_CLEAR_IT(IT) ((IT) != 0x00)[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m/** @defgroup USB_Device_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m #define RCC_USBCLKSource_PLLCLK_1Div5   ((uint8_t)0x00)[m
[32m+[m[32m #define RCC_USBCLKSource_PLLCLK_Div1    ((uint8_t)0x01)[m
[32m+[m
[32m+[m[32m #define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \[m
[32m+[m[32m                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m#else[m
[32m+[m[32m/** @defgroup USB_OTG_FS_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m #define RCC_OTGFSCLKSource_PLLVCO_Div3    ((uint8_t)0x00)[m
[32m+[m[32m #define RCC_OTGFSCLKSource_PLLVCO_Div2    ((uint8_t)0x01)[m
[32m+[m
[32m+[m[32m #define IS_RCC_OTGFSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div3) || \[m
[32m+[m[32m                                         ((SOURCE) == RCC_OTGFSCLKSource_PLLVCO_Div2))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/** @defgroup I2S2_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m #define RCC_I2S2CLKSource_SYSCLK        ((uint8_t)0x00)[m
[32m+[m[32m #define RCC_I2S2CLKSource_PLL3_VCO      ((uint8_t)0x01)[m
[32m+[m
[32m+[m[32m #define IS_RCC_I2S2CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_SYSCLK) || \[m
[32m+[m[32m                                        ((SOURCE) == RCC_I2S2CLKSource_PLL3_VCO))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2S3_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m #define RCC_I2S3CLKSource_SYSCLK        ((uint8_t)0x00)[m
[32m+[m[32m #define RCC_I2S3CLKSource_PLL3_VCO      ((uint8_t)0x01)[m
[32m+[m
[32m+[m[32m #define IS_RCC_I2S3CLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S3CLKSource_SYSCLK) || \[m
[32m+[m[32m                                        ((SOURCE) == RCC_I2S3CLKSource_PLL3_VCO))[m[41m    [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m  [m
[32m+[m[41m  [m
[32m+[m
[32m+[m[32m/** @defgroup ADC_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_PCLK2_Div2                   ((uint32_t)0x00000000)[m
[32m+[m[32m#define RCC_PCLK2_Div4                   ((uint32_t)0x00004000)[m
[32m+[m[32m#define RCC_PCLK2_Div6                   ((uint32_t)0x00008000)[m
[32m+[m[32m#define RCC_PCLK2_Div8                   ((uint32_t)0x0000C000)[m
[32m+[m[32m#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \[m
[32m+[m[32m                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup LSE_configuration[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_LSE_OFF                      ((uint8_t)0x00)[m
[32m+[m[32m#define RCC_LSE_ON                       ((uint8_t)0x01)[m
[32m+[m[32m#define RCC_LSE_Bypass                   ((uint8_t)0x04)[m
[32m+[m[32m#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \[m
[32m+[m[32m                         ((LSE) == RCC_LSE_Bypass))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_clock_source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)[m
[32m+[m[32m#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)[m
[32m+[m[32m#define RCC_RTCCLKSource_HSE_Div128      ((uint32_t)0x00000300)[m
[32m+[m[32m#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \[m
[32m+[m[32m                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \[m
[32m+[m[32m                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup AHB_peripheral[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_AHBPeriph_DMA1               ((uint32_t)0x00000001)[m
[32m+[m[32m#define RCC_AHBPeriph_DMA2               ((uint32_t)0x00000002)[m
[32m+[m[32m#define RCC_AHBPeriph_SRAM               ((uint32_t)0x00000004)[m
[32m+[m[32m#define RCC_AHBPeriph_FLITF              ((uint32_t)0x00000010)[m
[32m+[m[32m#define RCC_AHBPeriph_CRC                ((uint32_t)0x00000040)[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m #define RCC_AHBPeriph_FSMC              ((uint32_t)0x00000100)[m
[32m+[m[32m #define RCC_AHBPeriph_SDIO              ((uint32_t)0x00000400)[m
[32m+[m[32m #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))[m
[32m+[m[32m#else[m
[32m+[m[32m #define RCC_AHBPeriph_OTG_FS            ((uint32_t)0x00001000)[m
[32m+[m[32m #define RCC_AHBPeriph_ETH_MAC           ((uint32_t)0x00004000)[m
[32m+[m[32m #define RCC_AHBPeriph_ETH_MAC_Tx        ((uint32_t)0x00008000)[m
[32m+[m[32m #define RCC_AHBPeriph_ETH_MAC_Rx        ((uint32_t)0x00010000)[m
[32m+[m
[32m+[m[32m #define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFE2FA8) == 0x00) && ((PERIPH) != 0x00))[m
[32m+[m[32m #define IS_RCC_AHB_PERIPH_RESET(PERIPH) ((((PERIPH) & 0xFFFFAFFF) == 0x00) && ((PERIPH) != 0x00))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup APB2_peripheral[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOB             ((uint32_t)0x00000008)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOC             ((uint32_t)0x00000010)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOD             ((uint32_t)0x00000020)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOE             ((uint32_t)0x00000040)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOF             ((uint32_t)0x00000080)[m
[32m+[m[32m#define RCC_APB2Periph_GPIOG             ((uint32_t)0x00000100)[m
[32m+[m[32m#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000200)[m
[32m+[m[32m#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000400)[m
[32m+[m[32m#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000800)[m
[32m+[m[32m#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM8              ((uint32_t)0x00002000)[m
[32m+[m[32m#define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)[m
[32m+[m[32m#define RCC_APB2Periph_ADC3              ((uint32_t)0x00008000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM15             ((uint32_t)0x00010000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM16             ((uint32_t)0x00020000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM17             ((uint32_t)0x00040000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM9              ((uint32_t)0x00080000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM10             ((uint32_t)0x00100000)[m
[32m+[m[32m#define RCC_APB2Periph_TIM11             ((uint32_t)0x00200000)[m
[32m+[m
[32m+[m[32m#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFC00002) == 0x00) && ((PERIPH) != 0x00))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup APB1_peripheral[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)[m
[32m+[m[32m#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)[m
[32m+[m[32m#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)[m
[32m+[m[32m#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)[m
[32m+[m[32m#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)[m
[32m+[m[32m#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)[m
[32m+[m[32m#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)[m
[32m+[m[32m#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)[m
[32m+[m[32m#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)[m
[32m+[m[32m#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)[m
[32m+[m[32m#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)[m
[32m+[m[32m#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)[m
[32m+[m[32m#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)[m
[32m+[m[32m#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)[m
[32m+[m[32m#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)[m
[32m+[m[32m#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)[m
[32m+[m[32m#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)[m
[32m+[m[32m#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)[m
[32m+[m[32m#define RCC_APB1Periph_USB               ((uint32_t)0x00800000)[m
[32m+[m[32m#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)[m
[32m+[m[32m#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)[m
[32m+[m[32m#define RCC_APB1Periph_BKP               ((uint32_t)0x08000000)[m
[32m+[m[32m#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)[m
[32m+[m[32m#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)[m
[32m+[m[32m#define RCC_APB1Periph_CEC               ((uint32_t)0x40000000)[m
[32m+[m[41m [m
[32m+[m[32m#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x81013600) == 0x00) && ((PERIPH) != 0x00))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup Clock_source_to_output_on_MCO_pin[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_MCO_NoClock                  ((uint8_t)0x00)[m
[32m+[m[32m#define RCC_MCO_SYSCLK                   ((uint8_t)0x04)[m
[32m+[m[32m#define RCC_MCO_HSI                      ((uint8_t)0x05)[m
[32m+[m[32m#define RCC_MCO_HSE                      ((uint8_t)0x06)[m
[32m+[m[32m#define RCC_MCO_PLLCLK_Div2              ((uint8_t)0x07)[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \[m
[32m+[m[32m                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \[m
[32m+[m[32m                          ((MCO) == RCC_MCO_PLLCLK_Div2))[m
[32m+[m[32m#else[m
[32m+[m[32m #define RCC_MCO_PLL2CLK                 ((uint8_t)0x08)[m
[32m+[m[32m #define RCC_MCO_PLL3CLK_Div2            ((uint8_t)0x09)[m
[32m+[m[32m #define RCC_MCO_XT1                     ((uint8_t)0x0A)[m
[32m+[m[32m #define RCC_MCO_PLL3CLK                 ((uint8_t)0x0B)[m
[32m+[m
[32m+[m[32m #define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \[m
[32m+[m[32m                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \[m
[32m+[m[32m                          ((MCO) == RCC_MCO_PLLCLK_Div2) || ((MCO) == RCC_MCO_PLL2CLK) || \[m
[32m+[m[32m                          ((MCO) == RCC_MCO_PLL3CLK_Div2) || ((MCO) == RCC_MCO_XT1) || \[m
[32m+[m[32m                          ((MCO) == RCC_MCO_PLL3CLK))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Flag[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)[m
[32m+[m[32m#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)[m
[32m+[m[32m#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)[m
[32m+[m[32m#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)[m
[32m+[m[32m#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)[m
[32m+[m[32m#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)[m
[32m+[m[32m#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)[m
[32m+[m[32m#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)[m
[32m+[m[32m#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)[m
[32m+[m[32m#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)[m
[32m+[m[32m#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_LPWRRST))[m
[32m+[m[32m#else[m
[32m+[m[32m #define RCC_FLAG_PLL2RDY                ((uint8_t)0x3B)[m[41m [m
[32m+[m[32m #define RCC_FLAG_PLL3RDY                ((uint8_t)0x3D)[m[41m [m
[32m+[m[32m #define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_PLL2RDY) || ((FLAG) == RCC_FLAG_PLL3RDY) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \[m
[32m+[m[32m                            ((FLAG) == RCC_FLAG_LPWRRST))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid RCC_DeInit(void);[m
[32m+[m[32mvoid RCC_HSEConfig(uint32_t RCC_HSE);[m
[32m+[m[32mErrorStatus RCC_WaitForHSEStartUp(void);[m
[32m+[m[32mvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);[m
[32m+[m[32mvoid RCC_HSICmd(FunctionalState NewState);[m
[32m+[m[32mvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul);[m
[32m+[m[32mvoid RCC_PLLCmd(FunctionalState NewState);[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)[m
[32m+[m[32m void RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div);[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef  STM32F10X_CL[m
[32m+[m[32m void RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div);[m
[32m+[m[32m void RCC_PLL2Config(uint32_t RCC_PLL2Mul);[m
[32m+[m[32m void RCC_PLL2Cmd(FunctionalState NewState);[m
[32m+[m[32m void RCC_PLL3Config(uint32_t RCC_PLL3Mul);[m
[32m+[m[32m void RCC_PLL3Cmd(FunctionalState NewState);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32mvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);[m
[32m+[m[32muint8_t RCC_GetSYSCLKSource(void);[m
[32m+[m[32mvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK);[m
[32m+[m[32mvoid RCC_PCLK1Config(uint32_t RCC_HCLK);[m
[32m+[m[32mvoid RCC_PCLK2Config(uint32_t RCC_HCLK);[m
[32m+[m[32mvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource);[m
[32m+[m[32m#else[m
[32m+[m[32m void RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32mvoid RCC_ADCCLKConfig(uint32_t RCC_PCLK2);[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m void RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource);[m[41m                                  [m
[32m+[m[32m void RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32mvoid RCC_LSEConfig(uint8_t RCC_LSE);[m
[32m+[m[32mvoid RCC_LSICmd(FunctionalState NewState);[m
[32m+[m[32mvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);[m
[32m+[m[32mvoid RCC_RTCCLKCmd(FunctionalState NewState);[m
[32m+[m[32mvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);[m
[32m+[m[32mvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);[m
[32m+[m[32mvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);[m
[32m+[m[32mvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32mvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState);[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32mvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);[m
[32m+[m[32mvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);[m
[32m+[m[32mvoid RCC_BackupResetCmd(FunctionalState NewState);[m
[32m+[m[32mvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);[m
[32m+[m[32mvoid RCC_MCOConfig(uint8_t RCC_MCO);[m
[32m+[m[32mFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG);[m
[32m+[m[32mvoid RCC_ClearFlag(void);[m
[32m+[m[32mITStatus RCC_GetITStatus(uint8_t RCC_IT);[m
[32m+[m[32mvoid RCC_ClearITPendingBit(uint8_t RCC_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_RCC_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h[m
[1mnew file mode 100644[m
[1mindex 0000000..fd8beb5[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_rtc.h[m
[36m@@ -0,0 +1,135 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_rtc.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the RTC firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_RTC_H[m
[32m+[m[32m#define __STM32F10x_RTC_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup RTC[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_interrupts_define[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RTC_IT_OW            ((uint16_t)0x0004)  /*!< Overflow interrupt */[m
[32m+[m[32m#define RTC_IT_ALR           ((uint16_t)0x0002)  /*!< Alarm interrupt */[m
[32m+[m[32m#define RTC_IT_SEC           ((uint16_t)0x0001)  /*!< Second interrupt */[m
[32m+[m[32m#define IS_RTC_IT(IT) ((((IT) & (uint16_t)0xFFF8) == 0x00) && ((IT) != 0x00))[m
[32m+[m[32m#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \[m
[32m+[m[32m                           ((IT) == RTC_IT_SEC))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup RTC_interrupts_flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define RTC_FLAG_RTOFF       ((uint16_t)0x0020)  /*!< RTC Operation OFF flag */[m
[32m+[m[32m#define RTC_FLAG_RSF         ((uint16_t)0x0008)  /*!< Registers Synchronized flag */[m
[32m+[m[32m#define RTC_FLAG_OW          ((uint16_t)0x0004)  /*!< Overflow flag */[m
[32m+[m[32m#define RTC_FLAG_ALR         ((uint16_t)0x0002)  /*!< Alarm flag */[m
[32m+[m[32m#define RTC_FLAG_SEC         ((uint16_t)0x0001)  /*!< Second flag */[m
[32m+[m[32m#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFF0) == 0x00) && ((FLAG) != 0x00))[m
[32m+[m[32m#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \[m
[32m+[m[32m                               ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \[m
[32m+[m[32m                               ((FLAG) == RTC_FLAG_SEC))[m
[32m+[m[32m#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) <= 0xFFFFF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState);[m
[32m+[m[32mvoid RTC_EnterConfigMode(void);[m
[32m+[m[32mvoid RTC_ExitConfigMode(void);[m
[32m+[m[32muint32_t  RTC_GetCounter(void);[m
[32m+[m[32mvoid RTC_SetCounter(uint32_t CounterValue);[m
[32m+[m[32mvoid RTC_SetPrescaler(uint32_t PrescalerValue);[m
[32m+[m[32mvoid RTC_SetAlarm(uint32_t AlarmValue);[m
[32m+[m[32muint32_t  RTC_GetDivider(void);[m
[32m+[m[32mvoid RTC_WaitForLastTask(void);[m
[32m+[m[32mvoid RTC_WaitForSynchro(void);[m
[32m+[m[32mFlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG);[m
[32m+[m[32mvoid RTC_ClearFlag(uint16_t RTC_FLAG);[m
[32m+[m[32mITStatus RTC_GetITStatus(uint16_t RTC_IT);[m
[32m+[m[32mvoid RTC_ClearITPendingBit(uint16_t RTC_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_RTC_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h[m
[1mnew file mode 100644[m
[1mindex 0000000..81c058a[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_sdio.h[m
[36m@@ -0,0 +1,531 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_sdio.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the SDIO firmware[m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_SDIO_H[m
[32m+[m[32m#define __STM32F10x_SDIO_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup SDIO[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.[m
[32m+[m[32m                                           This parameter can be a value of @ref SDIO_Clock_Edge */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is[m
[32m+[m[32m                                           enabled or disabled.[m
[32m+[m[32m                                           This parameter can be a value of @ref SDIO_Clock_Bypass */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or[m
[32m+[m[32m                                           disabled when the bus is idle.[m
[32m+[m[32m                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.[m
[32m+[m[32m                                           This parameter can be a value of @ref SDIO_Bus_Wide */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.[m
[32m+[m[32m                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */[m
[32m+[m
[32m+[m[32m  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.[m
[32m+[m[32m                                           This parameter can be a value between 0x00 and 0xFF. */[m
[32m+[m[41m                                           [m
[32m+[m[32m} SDIO_InitTypeDef;[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent[m
[32m+[m[32m                                to a card as part of a command message. If a command[m
[32m+[m[32m                                contains an argument, it must be loaded into this register[m
[32m+[m[32m                                before writing the command to the command register */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.[m
[32m+[m[32m                                This parameter can be a value of @ref SDIO_Response_Type */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait-for-interrupt request is enabled or disabled.[m
[32m+[m[32m                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)[m
[32m+[m[32m                                is enabled or disabled.[m
[32m+[m[32m                                This parameter can be a value of @ref SDIO_CPSM_State */[m
[32m+[m[32m} SDIO_CmdInitTypeDef;[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */[m
[32m+[m
[32m+[m[32m  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */[m
[32m+[m[41m [m
[32m+[m[32m  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.[m
[32m+[m[32m                                     This parameter can be a value of @ref SDIO_Data_Block_Size */[m
[32m+[m[41m [m
[32m+[m[32m  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer[m
[32m+[m[32m                                     is a read or write.[m
[32m+[m[32m                                     This parameter can be a value of @ref SDIO_Transfer_Direction */[m
[32m+[m[41m [m
[32m+[m[32m  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.[m
[32m+[m[32m                                     This parameter can be a value of @ref SDIO_Transfer_Type */[m
[32m+[m[41m [m
[32m+[m[32m  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)[m
[32m+[m[32m                                     is enabled or disabled.[m
[32m+[m[32m                                     This parameter can be a value of @ref SDIO_DPSM_State */[m
[32m+[m[32m} SDIO_DataInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Clock_Edge[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)[m
[32m+[m[32m#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \[m
[32m+[m[32m                                  ((EDGE) == SDIO_ClockEdge_Falling))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Clock_Bypass[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)[m[41m    [m
[32m+[m[32m#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \[m
[32m+[m[32m                                     ((BYPASS) == SDIO_ClockBypass_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Clock_Power_Save[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200)[m[41m [m
[32m+[m[32m#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \[m
[32m+[m[32m                                        ((SAVE) == SDIO_ClockPowerSave_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Bus_Wide[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)[m
[32m+[m[32m#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)[m
[32m+[m[32m#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \[m
[32m+[m[32m                                ((WIDE) == SDIO_BusWide_8b))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Hardware_Flow_Control[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)[m
[32m+[m[32m#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \[m
[32m+[m[32m                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Power_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)[m
[32m+[m[32m#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON))[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Interrupt_sources[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)[m
[32m+[m[32m#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)[m
[32m+[m[32m#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)[m
[32m+[m[32m#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)[m
[32m+[m[32m#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)[m
[32m+[m[32m#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)[m
[32m+[m[32m#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)[m
[32m+[m[32m#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)[m
[32m+[m[32m#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)[m
[32m+[m[32m#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)[m
[32m+[m[32m#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)[m
[32m+[m[32m#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)[m
[32m+[m[32m#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)[m
[32m+[m[32m#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)[m
[32m+[m[32m#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)[m
[32m+[m[32m#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)[m
[32m+[m[32m#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)[m
[32m+[m[32m#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)[m
[32m+[m[32m#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)[m
[32m+[m[32m#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)[m
[32m+[m[32m#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)[m
[32m+[m[32m#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)[m
[32m+[m[32m#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)[m
[32m+[m[32m#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)[m
[32m+[m[32m#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Command_Index[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Response_Type[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_Response_No                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_Response_Short                 ((uint32_t)0x00000040)[m
[32m+[m[32m#define SDIO_Response_Long                  ((uint32_t)0x000000C0)[m
[32m+[m[32m#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \[m
[32m+[m[32m                                    ((RESPONSE) == SDIO_Response_Short) || \[m
[32m+[m[32m                                    ((RESPONSE) == SDIO_Response_Long))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Wait_Interrupt_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */[m
[32m+[m[32m#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */[m
[32m+[m[32m#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */[m
[32m+[m[32m#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \[m
[32m+[m[32m                            ((WAIT) == SDIO_Wait_Pend))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_CPSM_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)[m
[32m+[m[32m#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Response_Registers[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_RESP1                          ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_RESP2                          ((uint32_t)0x00000004)[m
[32m+[m[32m#define SDIO_RESP3                          ((uint32_t)0x00000008)[m
[32m+[m[32m#define SDIO_RESP4                          ((uint32_t)0x0000000C)[m
[32m+[m[32m#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \[m
[32m+[m[32m                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Data_Length[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Data_Block_Size[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)[m
[32m+[m[32m#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)[m
[32m+[m[32m#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)[m
[32m+[m[32m#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)[m
[32m+[m[32m#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)[m
[32m+[m[32m#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)[m
[32m+[m[32m#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)[m
[32m+[m[32m#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)[m
[32m+[m[32m#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)[m
[32m+[m[32m#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)[m
[32m+[m[32m#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)[m
[32m+[m[32m#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)[m
[32m+[m[32m#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)[m
[32m+[m[32m#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)[m
[32m+[m[32m#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_2b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_4b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_8b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_16b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_32b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_64b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_128b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_256b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_512b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \[m
[32m+[m[32m                                  ((SIZE) == SDIO_DataBlockSize_16384b))[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Transfer_Direction[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)[m
[32m+[m[32m#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \[m
[32m+[m[32m                                   ((DIR) == SDIO_TransferDir_ToSDIO))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Transfer_Type[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)[m
[32m+[m[32m#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \[m
[32m+[m[32m                                     ((MODE) == SDIO_TransferMode_Block))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_DPSM_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)[m
[32m+[m[32m#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)[m
[32m+[m[32m#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)[m
[32m+[m[32m#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)[m
[32m+[m[32m#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)[m
[32m+[m[32m#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)[m
[32m+[m[32m#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)[m
[32m+[m[32m#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)[m
[32m+[m[32m#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)[m
[32m+[m[32m#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)[m
[32m+[m[32m#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)[m
[32m+[m[32m#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)[m
[32m+[m[32m#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)[m
[32m+[m[32m#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)[m
[32m+[m[32m#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)[m
[32m+[m[32m#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)[m
[32m+[m[32m#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)[m
[32m+[m[32m#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)[m
[32m+[m[32m#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)[m
[32m+[m[32m#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)[m
[32m+[m[32m#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)[m
[32m+[m[32m#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)[m
[32m+[m[32m#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)[m
[32m+[m[32m#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)[m
[32m+[m[32m#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)[m
[32m+[m[32m#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)[m
[32m+[m[32m#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_CMDREND) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_DATAEND) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_STBITERR) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_CMDACT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_TXACT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_RXACT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \[m
[32m+[m[32m                            ((FLAG)  == SDIO_FLAG_CEATAEND))[m
[32m+[m
[32m+[m[32m#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))[m
[32m+[m
[32m+[m[32m#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_DCRCFAIL) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_CTIMEOUT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_DTIMEOUT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_TXUNDERR) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_RXOVERR) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_CMDREND) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_CMDSENT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_DATAEND) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_STBITERR) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_DBCKEND) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_CMDACT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_TXACT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_RXACT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_TXFIFOHE) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_RXFIFOHF) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_TXFIFOF) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_RXFIFOF) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_TXFIFOE) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_RXFIFOE) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_TXDAVL) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_RXDAVL) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_SDIOIT) || \[m
[32m+[m[32m                            ((IT)  == SDIO_IT_CEATAEND))[m
[32m+[m
[32m+[m[32m#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Read_Wait_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)[m
[32m+[m[32m#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)[m
[32m+[m[32m#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \[m
[32m+[m[32m                                     ((MODE) == SDIO_ReadWaitMode_DATA2))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid SDIO_DeInit(void);[m
[32m+[m[32mvoid SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);[m
[32m+[m[32mvoid SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);[m
[32m+[m[32mvoid SDIO_ClockCmd(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_SetPowerState(uint32_t SDIO_PowerState);[m
[32m+[m[32muint32_t SDIO_GetPowerState(void);[m
[32m+[m[32mvoid SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_DMACmd(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);[m
[32m+[m[32mvoid SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);[m
[32m+[m[32muint8_t SDIO_GetCommandResponse(void);[m
[32m+[m[32muint32_t SDIO_GetResponse(uint32_t SDIO_RESP);[m
[32m+[m[32mvoid SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);[m
[32m+[m[32mvoid SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);[m
[32m+[m[32muint32_t SDIO_GetDataCounter(void);[m
[32m+[m[32muint32_t SDIO_ReadData(void);[m
[32m+[m[32mvoid SDIO_WriteData(uint32_t Data);[m
[32m+[m[32muint32_t SDIO_GetFIFOCount(void);[m
[32m+[m[32mvoid SDIO_StartSDIOReadWait(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_StopSDIOReadWait(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);[m
[32m+[m[32mvoid SDIO_SetSDIOOperation(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_SendSDIOSuspendCmd(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_CommandCompletionCmd(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_CEATAITCmd(FunctionalState NewState);[m
[32m+[m[32mvoid SDIO_SendCEATACmd(FunctionalState NewState);[m
[32m+[m[32mFlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);[m
[32m+[m[32mvoid SDIO_ClearFlag(uint32_t SDIO_FLAG);[m
[32m+[m[32mITStatus SDIO_GetITStatus(uint32_t SDIO_IT);[m
[32m+[m[32mvoid SDIO_ClearITPendingBit(uint32_t SDIO_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_SDIO_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h[m
[1mnew file mode 100644[m
[1mindex 0000000..23cc26d[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_spi.h[m
[36m@@ -0,0 +1,487 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_spi.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the SPI firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_SPI_H[m
[32m+[m[32m#define __STM32F10x_SPI_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup SPI[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  SPI Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_data_direction */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_mode */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_data_size */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_Clock_Polarity */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_Clock_Phase */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by[m
[32m+[m[32m                                         hardware (NSS pin) or by software using the SSI bit.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_Slave_Select_management */[m
[32m+[m[41m [m
[32m+[m[32m  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be[m
[32m+[m[32m                                         used to configure the transmit and receive SCK clock.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler.[m
[32m+[m[32m                                         @note The communication clock is derived from the master[m
[32m+[m[32m                                               clock. The slave clock does not need to be set. */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.[m
[32m+[m[32m                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */[m
[32m+[m
[32m+[m[32m  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */[m
[32m+[m[32m}SPI_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  I2S Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.[m
[32m+[m[32m                                  This parameter can be a value of @ref I2S_Mode */[m
[32m+[m
[32m+[m[32m  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.[m
[32m+[m[32m                                  This parameter can be a value of @ref I2S_Standard */[m
[32m+[m
[32m+[m[32m  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.[m
[32m+[m[32m                                  This parameter can be a value of @ref I2S_Data_Format */[m
[32m+[m
[32m+[m[32m  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.[m
[32m+[m[32m                                  This parameter can be a value of @ref I2S_MCLK_Output */[m
[32m+[m
[32m+[m[32m  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.[m
[32m+[m[32m                                  This parameter can be a value of @ref I2S_Audio_Frequency */[m
[32m+[m
[32m+[m[32m  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.[m
[32m+[m[32m                                  This parameter can be a value of @ref I2S_Clock_Polarity */[m
[32m+[m[32m}I2S_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \[m
[32m+[m[32m                                   ((PERIPH) == SPI2) || \[m
[32m+[m[32m                                   ((PERIPH) == SPI3))[m
[32m+[m
[32m+[m[32m#define IS_SPI_23_PERIPH(PERIPH) (((PERIPH) == SPI2) || \[m
[32m+[m[32m                                  ((PERIPH) == SPI3))[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_data_direction[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)[m
[32m+[m[32m#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)[m
[32m+[m[32m#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)[m
[32m+[m[32m#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)[m
[32m+[m[32m#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \[m
[32m+[m[32m                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \[m
[32m+[m[32m                                     ((MODE) == SPI_Direction_1Line_Rx) || \[m
[32m+[m[32m                                     ((MODE) == SPI_Direction_1Line_Tx))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_Mode_Master                 ((uint16_t)0x0104)[m
[32m+[m[32m#define SPI_Mode_Slave                  ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \[m
[32m+[m[32m                           ((MODE) == SPI_Mode_Slave))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_data_size[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_DataSize_16b                ((uint16_t)0x0800)[m
[32m+[m[32m#define SPI_DataSize_8b                 ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \[m
[32m+[m[32m                                   ((DATASIZE) == SPI_DataSize_8b))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Clock_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_CPOL_Low                    ((uint16_t)0x0000)[m
[32m+[m[32m#define SPI_CPOL_High                   ((uint16_t)0x0002)[m
[32m+[m[32m#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \[m
[32m+[m[32m                           ((CPOL) == SPI_CPOL_High))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Clock_Phase[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)[m
[32m+[m[32m#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)[m
[32m+[m[32m#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \[m
[32m+[m[32m                           ((CPHA) == SPI_CPHA_2Edge))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Slave_Select_management[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_NSS_Soft                    ((uint16_t)0x0200)[m
[32m+[m[32m#define SPI_NSS_Hard                    ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \[m
[32m+[m[32m                         ((NSS) == SPI_NSS_Hard))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SPI_BaudRate_Prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)[m
[32m+[m[32m#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)[m
[32m+[m[32m#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \[m
[32m+[m[32m                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SPI_MSB_LSB_transmission[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_FirstBit_MSB                ((uint16_t)0x0000)[m
[32m+[m[32m#define SPI_FirstBit_LSB                ((uint16_t)0x0080)[m
[32m+[m[32m#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \[m
[32m+[m[32m                               ((BIT) == SPI_FirstBit_LSB))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2S_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)[m
[32m+[m[32m#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)[m
[32m+[m[32m#define I2S_Mode_MasterTx               ((uint16_t)0x0200)[m
[32m+[m[32m#define I2S_Mode_MasterRx               ((uint16_t)0x0300)[m
[32m+[m[32m#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \[m
[32m+[m[32m                           ((MODE) == I2S_Mode_SlaveRx) || \[m
[32m+[m[32m                           ((MODE) == I2S_Mode_MasterTx) || \[m
[32m+[m[32m                           ((MODE) == I2S_Mode_MasterRx) )[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2S_Standard[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2S_Standard_Phillips           ((uint16_t)0x0000)[m
[32m+[m[32m#define I2S_Standard_MSB                ((uint16_t)0x0010)[m
[32m+[m[32m#define I2S_Standard_LSB                ((uint16_t)0x0020)[m
[32m+[m[32m#define I2S_Standard_PCMShort           ((uint16_t)0x0030)[m
[32m+[m[32m#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)[m
[32m+[m[32m#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \[m
[32m+[m[32m                                   ((STANDARD) == I2S_Standard_MSB) || \[m
[32m+[m[32m                                   ((STANDARD) == I2S_Standard_LSB) || \[m
[32m+[m[32m                                   ((STANDARD) == I2S_Standard_PCMShort) || \[m
[32m+[m[32m                                   ((STANDARD) == I2S_Standard_PCMLong))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2S_Data_Format[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2S_DataFormat_16b              ((uint16_t)0x0000)[m
[32m+[m[32m#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)[m
[32m+[m[32m#define I2S_DataFormat_24b              ((uint16_t)0x0003)[m
[32m+[m[32m#define I2S_DataFormat_32b              ((uint16_t)0x0005)[m
[32m+[m[32m#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \[m
[32m+[m[32m                                    ((FORMAT) == I2S_DataFormat_16bextended) || \[m
[32m+[m[32m                                    ((FORMAT) == I2S_DataFormat_24b) || \[m
[32m+[m[32m                                    ((FORMAT) == I2S_DataFormat_32b))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2S_MCLK_Output[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)[m
[32m+[m[32m#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \[m
[32m+[m[32m                                    ((OUTPUT) == I2S_MCLKOutput_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2S_Audio_Frequency[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2S_AudioFreq_192k               ((uint32_t)192000)[m
[32m+[m[32m#define I2S_AudioFreq_96k                ((uint32_t)96000)[m
[32m+[m[32m#define I2S_AudioFreq_48k                ((uint32_t)48000)[m
[32m+[m[32m#define I2S_AudioFreq_44k                ((uint32_t)44100)[m
[32m+[m[32m#define I2S_AudioFreq_32k                ((uint32_t)32000)[m
[32m+[m[32m#define I2S_AudioFreq_22k                ((uint32_t)22050)[m
[32m+[m[32m#define I2S_AudioFreq_16k                ((uint32_t)16000)[m
[32m+[m[32m#define I2S_AudioFreq_11k                ((uint32_t)11025)[m
[32m+[m[32m#define I2S_AudioFreq_8k                 ((uint32_t)8000)[m
[32m+[m[32m#define I2S_AudioFreq_Default            ((uint32_t)2)[m
[32m+[m
[32m+[m[32m#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \[m
[32m+[m[32m                                  ((FREQ) <= I2S_AudioFreq_192k)) || \[m
[32m+[m[32m                                 ((FREQ) == I2S_AudioFreq_Default))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2S_Clock_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define I2S_CPOL_Low                    ((uint16_t)0x0000)[m
[32m+[m[32m#define I2S_CPOL_High                   ((uint16_t)0x0008)[m
[32m+[m[32m#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \[m
[32m+[m[32m                           ((CPOL) == I2S_CPOL_High))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_I2S_DMA_transfer_requests[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)[m
[32m+[m[32m#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)[m
[32m+[m[32m#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_NSS_internal_software_management[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)[m
[32m+[m[32m#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)[m
[32m+[m[32m#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \[m
[32m+[m[32m                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_CRC_Transmit_Receive[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_CRC_Tx                      ((uint8_t)0x00)[m
[32m+[m[32m#define SPI_CRC_Rx                      ((uint8_t)0x01)[m
[32m+[m[32m#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_direction_transmit_receive[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_Direction_Rx                ((uint16_t)0xBFFF)[m
[32m+[m[32m#define SPI_Direction_Tx                ((uint16_t)0x4000)[m
[32m+[m[32m#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \[m
[32m+[m[32m                                     ((DIRECTION) == SPI_Direction_Tx))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_I2S_interrupts_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)[m
[32m+[m[32m#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)[m
[32m+[m[32m#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)[m
[32m+[m[32m#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \[m
[32m+[m[32m                                 ((IT) == SPI_I2S_IT_RXNE) || \[m
[32m+[m[32m                                 ((IT) == SPI_I2S_IT_ERR))[m
[32m+[m[32m#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)[m
[32m+[m[32m#define SPI_IT_MODF                     ((uint8_t)0x55)[m
[32m+[m[32m#define SPI_IT_CRCERR                   ((uint8_t)0x54)[m
[32m+[m[32m#define I2S_IT_UDR                      ((uint8_t)0x53)[m
[32m+[m[32m#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))[m
[32m+[m[32m#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \[m
[32m+[m[32m                               ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \[m
[32m+[m[32m                               ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_I2S_flags_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)[m
[32m+[m[32m#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)[m
[32m+[m[32m#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)[m
[32m+[m[32m#define I2S_FLAG_UDR                    ((uint16_t)0x0008)[m
[32m+[m[32m#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)[m
[32m+[m[32m#define SPI_FLAG_MODF                   ((uint16_t)0x0020)[m
[32m+[m[32m#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)[m
[32m+[m[32m#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)[m
[32m+[m[32m#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))[m
[32m+[m[32m#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \[m
[32m+[m[32m                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \[m
[32m+[m[32m                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \[m
[32m+[m[32m                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_CRC_polynomial[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);[m
[32m+[m[32mvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);[m
[32m+[m[32mvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);[m
[32m+[m[32mvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);[m
[32m+[m[32mvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);[m
[32m+[m[32mvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);[m
[32m+[m[32mvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);[m
[32m+[m[32mvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);[m
[32m+[m[32mvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);[m
[32m+[m[32mvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);[m
[32m+[m[32muint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);[m
[32m+[m[32mvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);[m
[32m+[m[32mvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);[m
[32m+[m[32mvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);[m
[32m+[m[32mvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);[m
[32m+[m[32mvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);[m
[32m+[m[32muint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);[m
[32m+[m[32muint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);[m
[32m+[m[32mvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);[m
[32m+[m[32mFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);[m
[32m+[m[32mvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);[m
[32m+[m[32mITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);[m
[32m+[m[32mvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_SPI_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h[m
[1mnew file mode 100644[m
[1mindex 0000000..65bf76a[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_tim.h[m
[36m@@ -0,0 +1,1164 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_tim.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the TIM firmware[m[41m [m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_TIM_H[m
[32m+[m[32m#define __STM32F10x_TIM_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup TIM[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  TIM Time Base Init structure definition[m
[32m+[m[32m  * @note   This structure is used with all TIMx except for TIM6 and TIM7.[m[41m    [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t TIM_Prescaler;         /*!< Specifies the prescaler value used to divide the TIM clock.[m
[32m+[m[32m                                       This parameter can be a number between 0x0000 and 0xFFFF */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_CounterMode;       /*!< Specifies the counter mode.[m
[32m+[m[32m                                       This parameter can be a value of @ref TIM_Counter_Mode */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_Period;            /*!< Specifies the period value to be loaded into the active[m
[32m+[m[32m                                       Auto-Reload Register at the next update event.[m
[32m+[m[32m                                       This parameter must be a number between 0x0000 and 0xFFFF.  */[m[41m [m
[32m+[m
[32m+[m[32m  uint16_t TIM_ClockDivision;     /*!< Specifies the clock division.[m
[32m+[m[32m                                      This parameter can be a value of @ref TIM_Clock_Division_CKD */[m
[32m+[m
[32m+[m[32m  uint8_t TIM_RepetitionCounter;  /*!< Specifies the repetition counter value. Each time the RCR downcounter[m
[32m+[m[32m                                       reaches zero, an update event is generated and counting restarts[m
[32m+[m[32m                                       from the RCR value (N).[m
[32m+[m[32m                                       This means in PWM mode that (N+1) corresponds to:[m
[32m+[m[32m                                          - the number of PWM periods in edge-aligned mode[m
[32m+[m[32m                                          - the number of half PWM period in center-aligned mode[m
[32m+[m[32m                                       This parameter must be a number between 0x00 and 0xFF.[m[41m [m
[32m+[m[32m                                       @note This parameter is valid only for TIM1 and TIM8. */[m
[32m+[m[32m} TIM_TimeBaseInitTypeDef;[m[41m       [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  TIM Output Compare Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t TIM_OCMode;        /*!< Specifies the TIM mode.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OutputState;   /*!< Specifies the TIM Output Compare state.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_state */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OutputNState;  /*!< Specifies the TIM complementary Output Compare state.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_N_state[m
[32m+[m[32m                                   @note This parameter is valid only for TIM1 and TIM8. */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_Pulse;         /*!< Specifies the pulse value to be loaded into the Capture Compare Register.[m[41m [m
[32m+[m[32m                                   This parameter can be a number between 0x0000 and 0xFFFF */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OCPolarity;    /*!< Specifies the output polarity.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_Polarity */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OCNPolarity;   /*!< Specifies the complementary output polarity.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_N_Polarity[m
[32m+[m[32m                                   @note This parameter is valid only for TIM1 and TIM8. */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OCIdleState;   /*!< Specifies the TIM Output Compare pin state during Idle state.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_Idle_State[m
[32m+[m[32m                                   @note This parameter is valid only for TIM1 and TIM8. */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OCNIdleState;  /*!< Specifies the TIM Output Compare pin state during Idle state.[m
[32m+[m[32m                                   This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State[m
[32m+[m[32m                                   @note This parameter is valid only for TIM1 and TIM8. */[m
[32m+[m[32m} TIM_OCInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  TIM Input Capture Init structure definition[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m  uint16_t TIM_Channel;      /*!< Specifies the TIM channel.[m
[32m+[m[32m                                  This parameter can be a value of @ref TIM_Channel */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_ICPolarity;   /*!< Specifies the active edge of the input signal.[m
[32m+[m[32m                                  This parameter can be a value of @ref TIM_Input_Capture_Polarity */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_ICSelection;  /*!< Specifies the input.[m
[32m+[m[32m                                  This parameter can be a value of @ref TIM_Input_Capture_Selection */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_ICPrescaler;  /*!< Specifies the Input Capture Prescaler.[m
[32m+[m[32m                                  This parameter can be a value of @ref TIM_Input_Capture_Prescaler */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_ICFilter;     /*!< Specifies the input capture filter.[m
[32m+[m[32m                                  This parameter can be a number between 0x0 and 0xF */[m
[32m+[m[32m} TIM_ICInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  BDTR structure definition[m[41m [m
[32m+[m[32m  * @note   This structure is used only with TIM1 and TIM8.[m[41m    [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OSSRState;        /*!< Specifies the Off-State selection used in Run mode.[m
[32m+[m[32m                                      This parameter can be a value of @ref OSSR_Off_State_Selection_for_Run_mode_state */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_OSSIState;        /*!< Specifies the Off-State used in Idle state.[m
[32m+[m[32m                                      This parameter can be a value of @ref OSSI_Off_State_Selection_for_Idle_mode_state */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_LOCKLevel;        /*!< Specifies the LOCK level parameters.[m
[32m+[m[32m                                      This parameter can be a value of @ref Lock_level */[m[41m [m
[32m+[m
[32m+[m[32m  uint16_t TIM_DeadTime;         /*!< Specifies the delay time between the switching-off and the[m
[32m+[m[32m                                      switching-on of the outputs.[m
[32m+[m[32m                                      This parameter can be a number between 0x00 and 0xFF  */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_Break;            /*!< Specifies whether the TIM Break input is enabled or not.[m[41m [m
[32m+[m[32m                                      This parameter can be a value of @ref Break_Input_enable_disable */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_BreakPolarity;    /*!< Specifies the TIM Break Input pin polarity.[m
[32m+[m[32m                                      This parameter can be a value of @ref Break_Polarity */[m
[32m+[m
[32m+[m[32m  uint16_t TIM_AutomaticOutput;  /*!< Specifies whether the TIM Automatic Output feature is enabled or not.[m[41m [m
[32m+[m[32m                                      This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset */[m
[32m+[m[32m} TIM_BDTRInitTypeDef;[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Exported_constants[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_TIM_ALL_PERIPH(PERIPH) (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM6) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM7) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM9) || \[m
[32m+[m[32m                                   ((PERIPH) == TIM10)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM11)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM12)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM13)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM14)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM15)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM16)|| \[m
[32m+[m[32m                                   ((PERIPH) == TIM17))[m
[32m+[m
[32m+[m[32m/* LIST1: TIM 1 and 8 */[m
[32m+[m[32m#define IS_TIM_LIST1_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM8))[m
[32m+[m
[32m+[m[32m/* LIST2: TIM 1, 8, 15 16 and 17 */[m
[32m+[m[32m#define IS_TIM_LIST2_PERIPH(PERIPH) (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM15)|| \[m
[32m+[m[32m                                     ((PERIPH) == TIM16)|| \[m
[32m+[m[32m                                     ((PERIPH) == TIM17))[m[41m [m
[32m+[m
[32m+[m[32m/* LIST3: TIM 1, 2, 3, 4, 5 and 8 */[m
[32m+[m[32m#define IS_TIM_LIST3_PERIPH(PERIPH) (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM8))[m[41m [m
[32m+[m[41m									                                 [m
[32m+[m[32m/* LIST4: TIM 1, 2, 3, 4, 5, 8, 15, 16 and 17 */[m
[32m+[m[32m#define IS_TIM_LIST4_PERIPH(PERIPH) (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM15)|| \[m
[32m+[m[32m                                     ((PERIPH) == TIM16)|| \[m
[32m+[m[32m                                     ((PERIPH) == TIM17))[m
[32m+[m
[32m+[m[32m/* LIST5: TIM 1, 2, 3, 4, 5, 8 and 15 */[m[41m                                            [m
[32m+[m[32m#define IS_TIM_LIST5_PERIPH(PERIPH) (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                     ((PERIPH) == TIM15))[m[41m [m
[32m+[m
[32m+[m[32m/* LIST6: TIM 1, 2, 3, 4, 5, 8, 9, 12 and 15 */[m
[32m+[m[32m#define IS_TIM_LIST6_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM9) || \[m
[32m+[m									[32m  ((PERIPH) == TIM12)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM15))[m
[32m+[m
[32m+[m[32m/* LIST7: TIM 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 and 15 */[m
[32m+[m[32m#define IS_TIM_LIST7_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM6) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM7) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM9) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM12)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM15))[m[41m                                    [m
[32m+[m
[32m+[m[32m/* LIST8: TIM 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16 and 17 */[m[41m                                        [m
[32m+[m[32m#define IS_TIM_LIST8_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM9) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM10)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM11)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM12)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM13)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM14)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM15)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM16)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM17))[m
[32m+[m
[32m+[m[32m/* LIST9: TIM 1, 2, 3, 4, 5, 6, 7, 8, 15, 16, and 17 */[m
[32m+[m[32m#define IS_TIM_LIST9_PERIPH(PERIPH)  (((PERIPH) == TIM1) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM2) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM3) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM4) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM5) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM6) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM7) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM8) || \[m
[32m+[m[32m                                      ((PERIPH) == TIM15)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM16)|| \[m
[32m+[m[32m                                      ((PERIPH) == TIM17))[m[41m  [m
[32m+[m[41m                                                                                                                                                                                                                          [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_and_PWM_modes[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCMode_Timing                  ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_OCMode_Active                  ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_OCMode_Inactive                ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_OCMode_Toggle                  ((uint16_t)0x0030)[m
[32m+[m[32m#define TIM_OCMode_PWM1                    ((uint16_t)0x0060)[m
[32m+[m[32m#define TIM_OCMode_PWM2                    ((uint16_t)0x0070)[m
[32m+[m[32m#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \[m
[32m+[m[32m                              ((MODE) == TIM_OCMode_Active) || \[m
[32m+[m[32m                              ((MODE) == TIM_OCMode_Inactive) || \[m
[32m+[m[32m                              ((MODE) == TIM_OCMode_Toggle)|| \[m
[32m+[m[32m                              ((MODE) == TIM_OCMode_PWM1) || \[m
[32m+[m[32m                              ((MODE) == TIM_OCMode_PWM2))[m
[32m+[m[32m#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \[m
[32m+[m[32m                          ((MODE) == TIM_OCMode_Active) || \[m
[32m+[m[32m                          ((MODE) == TIM_OCMode_Inactive) || \[m
[32m+[m[32m                          ((MODE) == TIM_OCMode_Toggle)|| \[m
[32m+[m[32m                          ((MODE) == TIM_OCMode_PWM1) || \[m
[32m+[m[32m                          ((MODE) == TIM_OCMode_PWM2) ||	\[m
[32m+[m[32m                          ((MODE) == TIM_ForcedAction_Active) || \[m
[32m+[m[32m                          ((MODE) == TIM_ForcedAction_InActive))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_One_Pulse_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OPMode_Single                  ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_OPMode_Repetitive              ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \[m
[32m+[m[32m                               ((MODE) == TIM_OPMode_Repetitive))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Channel[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_Channel_1                      ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_Channel_2                      ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_Channel_3                      ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_Channel_4                      ((uint16_t)0x000C)[m
[32m+[m[32m#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \[m
[32m+[m[32m                                 ((CHANNEL) == TIM_Channel_2) || \[m
[32m+[m[32m                                 ((CHANNEL) == TIM_Channel_3) || \[m
[32m+[m[32m                                 ((CHANNEL) == TIM_Channel_4))[m
[32m+[m[32m#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \[m
[32m+[m[32m                                      ((CHANNEL) == TIM_Channel_2))[m
[32m+[m[32m#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \[m
[32m+[m[32m                                               ((CHANNEL) == TIM_Channel_2) || \[m
[32m+[m[32m                                               ((CHANNEL) == TIM_Channel_3))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Clock_Division_CKD[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_CKD_DIV1                       ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_CKD_DIV2                       ((uint16_t)0x0100)[m
[32m+[m[32m#define TIM_CKD_DIV4                       ((uint16_t)0x0200)[m
[32m+[m[32m#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \[m
[32m+[m[32m                             ((DIV) == TIM_CKD_DIV2) || \[m
[32m+[m[32m                             ((DIV) == TIM_CKD_DIV4))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Counter_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_CounterMode_Up                 ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_CounterMode_Down               ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_CounterMode_CenterAligned1     ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_CounterMode_CenterAligned2     ((uint16_t)0x0040)[m
[32m+[m[32m#define TIM_CounterMode_CenterAligned3     ((uint16_t)0x0060)[m
[32m+[m[32m#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \[m
[32m+[m[32m                                   ((MODE) == TIM_CounterMode_Down) || \[m
[32m+[m[32m                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \[m
[32m+[m[32m                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \[m
[32m+[m[32m                                   ((MODE) == TIM_CounterMode_CenterAligned3))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCPolarity_High                ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_OCPolarity_Low                 ((uint16_t)0x0002)[m
[32m+[m[32m#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \[m
[32m+[m[32m                                      ((POLARITY) == TIM_OCPolarity_Low))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_N_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m#define TIM_OCNPolarity_High               ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_OCNPolarity_Low                ((uint16_t)0x0008)[m
[32m+[m[32m#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \[m
[32m+[m[32m                                       ((POLARITY) == TIM_OCNPolarity_Low))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_state[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OutputState_Disable            ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_OutputState_Enable             ((uint16_t)0x0001)[m
[32m+[m[32m#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \[m
[32m+[m[32m                                    ((STATE) == TIM_OutputState_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_N_state[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OutputNState_Disable           ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_OutputNState_Enable            ((uint16_t)0x0004)[m
[32m+[m[32m#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \[m
[32m+[m[32m                                     ((STATE) == TIM_OutputNState_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Capture_Compare_state[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_CCx_Enable                      ((uint16_t)0x0001)[m
[32m+[m[32m#define TIM_CCx_Disable                     ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \[m
[32m+[m[32m                         ((CCX) == TIM_CCx_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Capture_Compare_N_state[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_CCxN_Enable                     ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_CCxN_Disable                    ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \[m
[32m+[m[32m                           ((CCXN) == TIM_CCxN_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup Break_Input_enable_disable[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_Break_Enable                   ((uint16_t)0x1000)[m
[32m+[m[32m#define TIM_Break_Disable                  ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \[m
[32m+[m[32m                                   ((STATE) == TIM_Break_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup Break_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_BreakPolarity_Low              ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_BreakPolarity_High             ((uint16_t)0x2000)[m
[32m+[m[32m#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \[m
[32m+[m[32m                                         ((POLARITY) == TIM_BreakPolarity_High))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_AOE_Bit_Set_Reset[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_AutomaticOutput_Enable         ((uint16_t)0x4000)[m
[32m+[m[32m#define TIM_AutomaticOutput_Disable        ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \[m
[32m+[m[32m                                              ((STATE) == TIM_AutomaticOutput_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup Lock_level[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_LOCKLevel_OFF                  ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_LOCKLevel_1                    ((uint16_t)0x0100)[m
[32m+[m[32m#define TIM_LOCKLevel_2                    ((uint16_t)0x0200)[m
[32m+[m[32m#define TIM_LOCKLevel_3                    ((uint16_t)0x0300)[m
[32m+[m[32m#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \[m
[32m+[m[32m                                  ((LEVEL) == TIM_LOCKLevel_1) || \[m
[32m+[m[32m                                  ((LEVEL) == TIM_LOCKLevel_2) || \[m
[32m+[m[32m                                  ((LEVEL) == TIM_LOCKLevel_3))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup OSSI_Off_State_Selection_for_Idle_mode_state[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OSSIState_Enable               ((uint16_t)0x0400)[m
[32m+[m[32m#define TIM_OSSIState_Disable              ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \[m
[32m+[m[32m                                  ((STATE) == TIM_OSSIState_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup OSSR_Off_State_Selection_for_Run_mode_state[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OSSRState_Enable               ((uint16_t)0x0800)[m
[32m+[m[32m#define TIM_OSSRState_Disable              ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \[m
[32m+[m[32m                                  ((STATE) == TIM_OSSRState_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_Idle_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCIdleState_Set                ((uint16_t)0x0100)[m
[32m+[m[32m#define TIM_OCIdleState_Reset              ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \[m
[32m+[m[32m                                    ((STATE) == TIM_OCIdleState_Reset))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_N_Idle_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCNIdleState_Set               ((uint16_t)0x0200)[m
[32m+[m[32m#define TIM_OCNIdleState_Reset             ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \[m
[32m+[m[32m                                     ((STATE) == TIM_OCNIdleState_Reset))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Input_Capture_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define  TIM_ICPolarity_Rising             ((uint16_t)0x0000)[m
[32m+[m[32m#define  TIM_ICPolarity_Falling            ((uint16_t)0x0002)[m
[32m+[m[32m#define  TIM_ICPolarity_BothEdge           ((uint16_t)0x000A)[m
[32m+[m[32m#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \[m
[32m+[m[32m                                      ((POLARITY) == TIM_ICPolarity_Falling))[m
[32m+[m[32m#define IS_TIM_IC_POLARITY_LITE(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \[m
[32m+[m[32m                                           ((POLARITY) == TIM_ICPolarity_Falling)|| \[m
[32m+[m[32m                                           ((POLARITY) == TIM_ICPolarity_BothEdge))[m[41m                                      [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Input_Capture_Selection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_ICSelection_DirectTI           ((uint16_t)0x0001) /*!< TIM Input 1, 2, 3 or 4 is selected to be[m[41m [m
[32m+[m[32m                                                                   connected to IC1, IC2, IC3 or IC4, respectively */[m
[32m+[m[32m#define TIM_ICSelection_IndirectTI         ((uint16_t)0x0002) /*!< TIM Input 1, 2, 3 or 4 is selected to be[m
[32m+[m[32m                                                                   connected to IC2, IC1, IC4 or IC3, respectively. */[m
[32m+[m[32m#define TIM_ICSelection_TRC                ((uint16_t)0x0003) /*!< TIM Input 1, 2, 3 or 4 is selected to be connected to TRC. */[m
[32m+[m[32m#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \[m
[32m+[m[32m                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \[m
[32m+[m[32m                                        ((SELECTION) == TIM_ICSelection_TRC))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Input_Capture_Prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_ICPSC_DIV1                     ((uint16_t)0x0000) /*!< Capture performed each time an edge is detected on the capture input. */[m
[32m+[m[32m#define TIM_ICPSC_DIV2                     ((uint16_t)0x0004) /*!< Capture performed once every 2 events. */[m
[32m+[m[32m#define TIM_ICPSC_DIV4                     ((uint16_t)0x0008) /*!< Capture performed once every 4 events. */[m
[32m+[m[32m#define TIM_ICPSC_DIV8                     ((uint16_t)0x000C) /*!< Capture performed once every 8 events. */[m
[32m+[m[32m#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \[m
[32m+[m[32m                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \[m
[32m+[m[32m                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \[m
[32m+[m[32m                                        ((PRESCALER) == TIM_ICPSC_DIV8))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_interrupt_sources[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_IT_Update                      ((uint16_t)0x0001)[m
[32m+[m[32m#define TIM_IT_CC1                         ((uint16_t)0x0002)[m
[32m+[m[32m#define TIM_IT_CC2                         ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_IT_CC3                         ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_IT_CC4                         ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_IT_COM                         ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_IT_Trigger                     ((uint16_t)0x0040)[m
[32m+[m[32m#define TIM_IT_Break                       ((uint16_t)0x0080)[m
[32m+[m[32m#define IS_TIM_IT(IT) ((((IT) & (uint16_t)0xFF00) == 0x0000) && ((IT) != 0x0000))[m
[32m+[m
[32m+[m[32m#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_CC1) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_CC2) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_CC3) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_CC4) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_COM) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_Trigger) || \[m
[32m+[m[32m                           ((IT) == TIM_IT_Break))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_DMA_Base_address[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_DMABase_CR1                    ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_DMABase_CR2                    ((uint16_t)0x0001)[m
[32m+[m[32m#define TIM_DMABase_SMCR                   ((uint16_t)0x0002)[m
[32m+[m[32m#define TIM_DMABase_DIER                   ((uint16_t)0x0003)[m
[32m+[m[32m#define TIM_DMABase_SR                     ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_DMABase_EGR                    ((uint16_t)0x0005)[m
[32m+[m[32m#define TIM_DMABase_CCMR1                  ((uint16_t)0x0006)[m
[32m+[m[32m#define TIM_DMABase_CCMR2                  ((uint16_t)0x0007)[m
[32m+[m[32m#define TIM_DMABase_CCER                   ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_DMABase_CNT                    ((uint16_t)0x0009)[m
[32m+[m[32m#define TIM_DMABase_PSC                    ((uint16_t)0x000A)[m
[32m+[m[32m#define TIM_DMABase_ARR                    ((uint16_t)0x000B)[m
[32m+[m[32m#define TIM_DMABase_RCR                    ((uint16_t)0x000C)[m
[32m+[m[32m#define TIM_DMABase_CCR1                   ((uint16_t)0x000D)[m
[32m+[m[32m#define TIM_DMABase_CCR2                   ((uint16_t)0x000E)[m
[32m+[m[32m#define TIM_DMABase_CCR3                   ((uint16_t)0x000F)[m
[32m+[m[32m#define TIM_DMABase_CCR4                   ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_DMABase_BDTR                   ((uint16_t)0x0011)[m
[32m+[m[32m#define TIM_DMABase_DCR                    ((uint16_t)0x0012)[m
[32m+[m[32m#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CR2) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_SMCR) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_DIER) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_SR) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_EGR) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCMR1) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCMR2) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCER) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CNT) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_PSC) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_ARR) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_RCR) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCR1) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCR2) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCR3) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_CCR4) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_BDTR) || \[m
[32m+[m[32m                               ((BASE) == TIM_DMABase_DCR))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_DMA_Burst_Length[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_DMABurstLength_1Transfer           ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_DMABurstLength_2Transfers          ((uint16_t)0x0100)[m
[32m+[m[32m#define TIM_DMABurstLength_3Transfers          ((uint16_t)0x0200)[m
[32m+[m[32m#define TIM_DMABurstLength_4Transfers          ((uint16_t)0x0300)[m
[32m+[m[32m#define TIM_DMABurstLength_5Transfers          ((uint16_t)0x0400)[m
[32m+[m[32m#define TIM_DMABurstLength_6Transfers          ((uint16_t)0x0500)[m
[32m+[m[32m#define TIM_DMABurstLength_7Transfers          ((uint16_t)0x0600)[m
[32m+[m[32m#define TIM_DMABurstLength_8Transfers          ((uint16_t)0x0700)[m
[32m+[m[32m#define TIM_DMABurstLength_9Transfers          ((uint16_t)0x0800)[m
[32m+[m[32m#define TIM_DMABurstLength_10Transfers         ((uint16_t)0x0900)[m
[32m+[m[32m#define TIM_DMABurstLength_11Transfers         ((uint16_t)0x0A00)[m
[32m+[m[32m#define TIM_DMABurstLength_12Transfers         ((uint16_t)0x0B00)[m
[32m+[m[32m#define TIM_DMABurstLength_13Transfers         ((uint16_t)0x0C00)[m
[32m+[m[32m#define TIM_DMABurstLength_14Transfers         ((uint16_t)0x0D00)[m
[32m+[m[32m#define TIM_DMABurstLength_15Transfers         ((uint16_t)0x0E00)[m
[32m+[m[32m#define TIM_DMABurstLength_16Transfers         ((uint16_t)0x0F00)[m
[32m+[m[32m#define TIM_DMABurstLength_17Transfers         ((uint16_t)0x1000)[m
[32m+[m[32m#define TIM_DMABurstLength_18Transfers         ((uint16_t)0x1100)[m
[32m+[m[32m#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Transfer) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_2Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_3Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_4Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_5Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_6Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_7Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_8Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_9Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_10Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_11Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_12Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_13Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_14Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_15Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_16Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_17Transfers) || \[m
[32m+[m[32m                                   ((LENGTH) == TIM_DMABurstLength_18Transfers))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_DMA_sources[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_DMA_Update                     ((uint16_t)0x0100)[m
[32m+[m[32m#define TIM_DMA_CC1                        ((uint16_t)0x0200)[m
[32m+[m[32m#define TIM_DMA_CC2                        ((uint16_t)0x0400)[m
[32m+[m[32m#define TIM_DMA_CC3                        ((uint16_t)0x0800)[m
[32m+[m[32m#define TIM_DMA_CC4                        ((uint16_t)0x1000)[m
[32m+[m[32m#define TIM_DMA_COM                        ((uint16_t)0x2000)[m
[32m+[m[32m#define TIM_DMA_Trigger                    ((uint16_t)0x4000)[m
[32m+[m[32m#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_External_Trigger_Prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_ExtTRGPSC_OFF                  ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_ExtTRGPSC_DIV2                 ((uint16_t)0x1000)[m
[32m+[m[32m#define TIM_ExtTRGPSC_DIV4                 ((uint16_t)0x2000)[m
[32m+[m[32m#define TIM_ExtTRGPSC_DIV8                 ((uint16_t)0x3000)[m
[32m+[m[32m#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \[m
[32m+[m[32m                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \[m
[32m+[m[32m                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \[m
[32m+[m[32m                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Internal_Trigger_Selection[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_TS_ITR0                        ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_TS_ITR1                        ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_TS_ITR2                        ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_TS_ITR3                        ((uint16_t)0x0030)[m
[32m+[m[32m#define TIM_TS_TI1F_ED                     ((uint16_t)0x0040)[m
[32m+[m[32m#define TIM_TS_TI1FP1                      ((uint16_t)0x0050)[m
[32m+[m[32m#define TIM_TS_TI2FP2                      ((uint16_t)0x0060)[m
[32m+[m[32m#define TIM_TS_ETRF                        ((uint16_t)0x0070)[m
[32m+[m[32m#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_ITR1) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_ITR2) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_ITR3) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_TI1F_ED) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_TI1FP1) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_TI2FP2) || \[m
[32m+[m[32m                                             ((SELECTION) == TIM_TS_ETRF))[m
[32m+[m[32m#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \[m
[32m+[m[32m                                                      ((SELECTION) == TIM_TS_ITR1) || \[m
[32m+[m[32m                                                      ((SELECTION) == TIM_TS_ITR2) || \[m
[32m+[m[32m                                                      ((SELECTION) == TIM_TS_ITR3))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_TIx_External_Clock_Source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_TIxExternalCLK1Source_TI1      ((uint16_t)0x0050)[m
[32m+[m[32m#define TIM_TIxExternalCLK1Source_TI2      ((uint16_t)0x0060)[m
[32m+[m[32m#define TIM_TIxExternalCLK1Source_TI1ED    ((uint16_t)0x0040)[m
[32m+[m[32m#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \[m
[32m+[m[32m                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \[m
[32m+[m[32m                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_External_Trigger_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define TIM_ExtTRGPolarity_Inverted        ((uint16_t)0x8000)[m
[32m+[m[32m#define TIM_ExtTRGPolarity_NonInverted     ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \[m
[32m+[m[32m                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Prescaler_Reload_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_PSCReloadMode_Update           ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_PSCReloadMode_Immediate        ((uint16_t)0x0001)[m
[32m+[m[32m#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \[m
[32m+[m[32m                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Forced_Action[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_ForcedAction_Active            ((uint16_t)0x0050)[m
[32m+[m[32m#define TIM_ForcedAction_InActive          ((uint16_t)0x0040)[m
[32m+[m[32m#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \[m
[32m+[m[32m                                      ((ACTION) == TIM_ForcedAction_InActive))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Encoder_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_EncoderMode_TI1                ((uint16_t)0x0001)[m
[32m+[m[32m#define TIM_EncoderMode_TI2                ((uint16_t)0x0002)[m
[32m+[m[32m#define TIM_EncoderMode_TI12               ((uint16_t)0x0003)[m
[32m+[m[32m#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \[m
[32m+[m[32m                                   ((MODE) == TIM_EncoderMode_TI2) || \[m
[32m+[m[32m                                   ((MODE) == TIM_EncoderMode_TI12))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Event_Source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_EventSource_Update             ((uint16_t)0x0001)[m
[32m+[m[32m#define TIM_EventSource_CC1                ((uint16_t)0x0002)[m
[32m+[m[32m#define TIM_EventSource_CC2                ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_EventSource_CC3                ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_EventSource_CC4                ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_EventSource_COM                ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_EventSource_Trigger            ((uint16_t)0x0040)[m
[32m+[m[32m#define TIM_EventSource_Break              ((uint16_t)0x0080)[m
[32m+[m[32m#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (uint16_t)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Update_Source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_UpdateSource_Global            ((uint16_t)0x0000) /*!< Source of update is the counter overflow/underflow[m
[32m+[m[32m                                                                   or the setting of UG bit, or an update generation[m
[32m+[m[32m                                                                   through the slave mode controller. */[m
[32m+[m[32m#define TIM_UpdateSource_Regular           ((uint16_t)0x0001) /*!< Source of update is counter overflow/underflow. */[m
[32m+[m[32m#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \[m
[32m+[m[32m                                      ((SOURCE) == TIM_UpdateSource_Regular))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_Preload_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCPreload_Enable               ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_OCPreload_Disable              ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \[m
[32m+[m[32m                                       ((STATE) == TIM_OCPreload_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_Fast_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCFast_Enable                  ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_OCFast_Disable                 ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \[m
[32m+[m[32m                                    ((STATE) == TIM_OCFast_Disable))[m
[32m+[m[41m                                     [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Output_Compare_Clear_State[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_OCClear_Enable                 ((uint16_t)0x0080)[m
[32m+[m[32m#define TIM_OCClear_Disable                ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \[m
[32m+[m[32m                                     ((STATE) == TIM_OCClear_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Trigger_Output_Source[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_TRGOSource_Reset               ((uint16_t)0x0000)[m
[32m+[m[32m#define TIM_TRGOSource_Enable              ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_TRGOSource_Update              ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_TRGOSource_OC1                 ((uint16_t)0x0030)[m
[32m+[m[32m#define TIM_TRGOSource_OC1Ref              ((uint16_t)0x0040)[m
[32m+[m[32m#define TIM_TRGOSource_OC2Ref              ((uint16_t)0x0050)[m
[32m+[m[32m#define TIM_TRGOSource_OC3Ref              ((uint16_t)0x0060)[m
[32m+[m[32m#define TIM_TRGOSource_OC4Ref              ((uint16_t)0x0070)[m
[32m+[m[32m#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_Enable) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_Update) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_OC1) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \[m
[32m+[m[32m                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Slave_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_SlaveMode_Reset                ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_SlaveMode_Gated                ((uint16_t)0x0005)[m
[32m+[m[32m#define TIM_SlaveMode_Trigger              ((uint16_t)0x0006)[m
[32m+[m[32m#define TIM_SlaveMode_External1            ((uint16_t)0x0007)[m
[32m+[m[32m#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \[m
[32m+[m[32m                                 ((MODE) == TIM_SlaveMode_Gated) || \[m
[32m+[m[32m                                 ((MODE) == TIM_SlaveMode_Trigger) || \[m
[32m+[m[32m                                 ((MODE) == TIM_SlaveMode_External1))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Master_Slave_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_MasterSlaveMode_Enable         ((uint16_t)0x0080)[m
[32m+[m[32m#define TIM_MasterSlaveMode_Disable        ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \[m
[32m+[m[32m                                 ((STATE) == TIM_MasterSlaveMode_Disable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_FLAG_Update                    ((uint16_t)0x0001)[m
[32m+[m[32m#define TIM_FLAG_CC1                       ((uint16_t)0x0002)[m
[32m+[m[32m#define TIM_FLAG_CC2                       ((uint16_t)0x0004)[m
[32m+[m[32m#define TIM_FLAG_CC3                       ((uint16_t)0x0008)[m
[32m+[m[32m#define TIM_FLAG_CC4                       ((uint16_t)0x0010)[m
[32m+[m[32m#define TIM_FLAG_COM                       ((uint16_t)0x0020)[m
[32m+[m[32m#define TIM_FLAG_Trigger                   ((uint16_t)0x0040)[m
[32m+[m[32m#define TIM_FLAG_Break                     ((uint16_t)0x0080)[m
[32m+[m[32m#define TIM_FLAG_CC1OF                     ((uint16_t)0x0200)[m
[32m+[m[32m#define TIM_FLAG_CC2OF                     ((uint16_t)0x0400)[m
[32m+[m[32m#define TIM_FLAG_CC3OF                     ((uint16_t)0x0800)[m
[32m+[m[32m#define TIM_FLAG_CC4OF                     ((uint16_t)0x1000)[m
[32m+[m[32m#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC1) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC2) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC3) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC4) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_COM) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_Trigger) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_Break) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC1OF) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC2OF) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC3OF) || \[m
[32m+[m[32m                               ((FLAG) == TIM_FLAG_CC4OF))[m
[32m+[m[41m                               [m
[32m+[m[41m                               [m
[32m+[m[32m#define IS_TIM_CLEAR_FLAG(TIM_FLAG) ((((TIM_FLAG) & (uint16_t)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Input_Capture_Filer_Value[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF)[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_External_Trigger_Filter[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Legacy[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define TIM_DMABurstLength_1Byte           TIM_DMABurstLength_1Transfer[m
[32m+[m[32m#define TIM_DMABurstLength_2Bytes          TIM_DMABurstLength_2Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_3Bytes          TIM_DMABurstLength_3Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_4Bytes          TIM_DMABurstLength_4Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_5Bytes          TIM_DMABurstLength_5Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_6Bytes          TIM_DMABurstLength_6Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_7Bytes          TIM_DMABurstLength_7Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_8Bytes          TIM_DMABurstLength_8Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_9Bytes          TIM_DMABurstLength_9Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_10Bytes         TIM_DMABurstLength_10Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_11Bytes         TIM_DMABurstLength_11Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_12Bytes         TIM_DMABurstLength_12Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_13Bytes         TIM_DMABurstLength_13Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_14Bytes         TIM_DMABurstLength_14Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_15Bytes         TIM_DMABurstLength_15Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_16Bytes         TIM_DMABurstLength_16Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_17Bytes         TIM_DMABurstLength_17Transfers[m
[32m+[m[32m#define TIM_DMABurstLength_18Bytes         TIM_DMABurstLength_18Transfers[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid TIM_DeInit(TIM_TypeDef* TIMx);[m
[32m+[m[32mvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);[m
[32m+[m[32mvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);[m
[32m+[m[32mvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);[m
[32m+[m[32mvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);[m
[32m+[m[32mvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);[m
[32m+[m[32mvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);[m
[32m+[m[32mvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);[m
[32m+[m[32mvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);[m
[32m+[m[32mvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);[m
[32m+[m[32mvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);[m
[32m+[m[32mvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);[m
[32m+[m[32mvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);[m
[32m+[m[32mvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource);[m
[32m+[m[32mvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength);[m
[32m+[m[32mvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);[m
[32m+[m[32mvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);[m
[32m+[m[32mvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,[m
[32m+[m[32m                                uint16_t TIM_ICPolarity, uint16_t ICFilter);[m
[32m+[m[32mvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,[m
[32m+[m[32m                             uint16_t ExtTRGFilter);[m
[32m+[m[32mvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,[m[41m [m
[32m+[m[32m                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter);[m
[32m+[m[32mvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,[m
[32m+[m[32m                   uint16_t ExtTRGFilter);[m
[32m+[m[32mvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode);[m
[32m+[m[32mvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode);[m
[32m+[m[32mvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource);[m
[32m+[m[32mvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,[m
[32m+[m[32m                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity);[m
[32m+[m[32mvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);[m
[32m+[m[32mvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);[m
[32m+[m[32mvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);[m
[32m+[m[32mvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction);[m
[32m+[m[32mvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);[m
[32m+[m[32mvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);[m
[32m+[m[32mvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);[m
[32m+[m[32mvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload);[m
[32m+[m[32mvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);[m
[32m+[m[32mvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);[m
[32m+[m[32mvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);[m
[32m+[m[32mvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast);[m
[32m+[m[32mvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);[m
[32m+[m[32mvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);[m
[32m+[m[32mvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);[m
[32m+[m[32mvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear);[m
[32m+[m[32mvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);[m
[32m+[m[32mvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);[m
[32m+[m[32mvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);[m
[32m+[m[32mvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);[m
[32m+[m[32mvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);[m
[32m+[m[32mvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity);[m
[32m+[m[32mvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity);[m
[32m+[m[32mvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx);[m
[32m+[m[32mvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN);[m
[32m+[m[32mvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode);[m
[32m+[m[32mvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource);[m
[32m+[m[32mvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);[m
[32m+[m[32mvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode);[m
[32m+[m[32mvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource);[m
[32m+[m[32mvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode);[m
[32m+[m[32mvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode);[m
[32m+[m[32mvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter);[m
[32m+[m[32mvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload);[m
[32m+[m[32mvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1);[m
[32m+[m[32mvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2);[m
[32m+[m[32mvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3);[m
[32m+[m[32mvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4);[m
[32m+[m[32mvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);[m
[32m+[m[32mvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);[m
[32m+[m[32mvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);[m
[32m+[m[32mvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC);[m
[32m+[m[32mvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD);[m
[32m+[m[32muint16_t TIM_GetCapture1(TIM_TypeDef* TIMx);[m
[32m+[m[32muint16_t TIM_GetCapture2(TIM_TypeDef* TIMx);[m
[32m+[m[32muint16_t TIM_GetCapture3(TIM_TypeDef* TIMx);[m
[32m+[m[32muint16_t TIM_GetCapture4(TIM_TypeDef* TIMx);[m
[32m+[m[32muint16_t TIM_GetCounter(TIM_TypeDef* TIMx);[m
[32m+[m[32muint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx);[m
[32m+[m[32mFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);[m
[32m+[m[32mvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG);[m
[32m+[m[32mITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT);[m
[32m+[m[32mvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /*__STM32F10x_TIM_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h[m
[1mnew file mode 100644[m
[1mindex 0000000..162fa87[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_usart.h[m
[36m@@ -0,0 +1,412 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_usart.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the USART[m[41m [m
[32m+[m[32m  *          firmware library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_USART_H[m
[32m+[m[32m#define __STM32F10x_USART_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup USART[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  USART Init Structure definition[m[41m  [m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.[m
[32m+[m[32m                                           The baud rate is computed using the following formula:[m
[32m+[m[32m                                            - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->USART_BaudRate)))[m
[32m+[m[32m                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 16) + 0.5 */[m
[32m+[m
[32m+[m[32m  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.[m
[32m+[m[32m                                           This parameter can be a value of @ref USART_Word_Length */[m
[32m+[m
[32m+[m[32m  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.[m
[32m+[m[32m                                           This parameter can be a value of @ref USART_Stop_Bits */[m
[32m+[m
[32m+[m[32m  uint16_t USART_Parity;              /*!< Specifies the parity mode.[m
[32m+[m[32m                                           This parameter can be a value of @ref USART_Parity[m
[32m+[m[32m                                           @note When parity is enabled, the computed parity is inserted[m
[32m+[m[32m                                                 at the MSB position of the transmitted data (9th bit when[m
[32m+[m[32m                                                 the word length is set to 9 data bits; 8th bit when the[m
[32m+[m[32m                                                 word length is set to 8 data bits). */[m
[32m+[m[41m [m
[32m+[m[32m  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.[m
[32m+[m[32m                                           This parameter can be a value of @ref USART_Mode */[m
[32m+[m
[32m+[m[32m  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled[m
[32m+[m[32m                                           or disabled.[m
[32m+[m[32m                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */[m
[32m+[m[32m} USART_InitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief  USART Clock Init Structure definition[m[41m  [m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m
[32m+[m[32m  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.[m
[32m+[m[32m                               This parameter can be a value of @ref USART_Clock */[m
[32m+[m
[32m+[m[32m  uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.[m
[32m+[m[32m                               This parameter can be a value of @ref USART_Clock_Polarity */[m
[32m+[m
[32m+[m[32m  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.[m
[32m+[m[32m                               This parameter can be a value of @ref USART_Clock_Phase */[m
[32m+[m
[32m+[m[32m  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted[m
[32m+[m[32m                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.[m
[32m+[m[32m                               This parameter can be a value of @ref USART_Last_Bit */[m
[32m+[m[32m} USART_ClockInitTypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \[m
[32m+[m[32m                                     ((PERIPH) == USART2) || \[m
[32m+[m[32m                                     ((PERIPH) == USART3) || \[m
[32m+[m[32m                                     ((PERIPH) == UART4) || \[m
[32m+[m[32m                                     ((PERIPH) == UART5))[m
[32m+[m
[32m+[m[32m#define IS_USART_123_PERIPH(PERIPH) (((PERIPH) == USART1) || \[m
[32m+[m[32m                                     ((PERIPH) == USART2) || \[m
[32m+[m[32m                                     ((PERIPH) == USART3))[m
[32m+[m
[32m+[m[32m#define IS_USART_1234_PERIPH(PERIPH) (((PERIPH) == USART1) || \[m
[32m+[m[32m                                      ((PERIPH) == USART2) || \[m
[32m+[m[32m                                      ((PERIPH) == USART3) || \[m
[32m+[m[32m                                      ((PERIPH) == UART4))[m
[32m+[m[32m/** @defgroup USART_Word_Length[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define USART_WordLength_8b                  ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_WordLength_9b                  ((uint16_t)0x1000)[m
[32m+[m[41m                                    [m
[32m+[m[32m#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \[m
[32m+[m[32m                                      ((LENGTH) == USART_WordLength_9b))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Stop_Bits[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define USART_StopBits_1                     ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_StopBits_0_5                   ((uint16_t)0x1000)[m
[32m+[m[32m#define USART_StopBits_2                     ((uint16_t)0x2000)[m
[32m+[m[32m#define USART_StopBits_1_5                   ((uint16_t)0x3000)[m
[32m+[m[32m#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \[m
[32m+[m[32m                                     ((STOPBITS) == USART_StopBits_0_5) || \[m
[32m+[m[32m                                     ((STOPBITS) == USART_StopBits_2) || \[m
[32m+[m[32m                                     ((STOPBITS) == USART_StopBits_1_5))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Parity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define USART_Parity_No                      ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_Parity_Even                    ((uint16_t)0x0400)[m
[32m+[m[32m#define USART_Parity_Odd                     ((uint16_t)0x0600)[m[41m [m
[32m+[m[32m#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \[m
[32m+[m[32m                                 ((PARITY) == USART_Parity_Even) || \[m
[32m+[m[32m                                 ((PARITY) == USART_Parity_Odd))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Mode[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define USART_Mode_Rx                        ((uint16_t)0x0004)[m
[32m+[m[32m#define USART_Mode_Tx                        ((uint16_t)0x0008)[m
[32m+[m[32m#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Hardware_Flow_Control[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)[m
[32m+[m[32m#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)[m
[32m+[m[32m#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)[m
[32m+[m[32m#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\[m
[32m+[m[32m                              (((CONTROL) == USART_HardwareFlowControl_None) || \[m
[32m+[m[32m                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \[m
[32m+[m[32m                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \[m
[32m+[m[32m                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Clock[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m#define USART_Clock_Disable                  ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_Clock_Enable                   ((uint16_t)0x0800)[m
[32m+[m[32m#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \[m
[32m+[m[32m                               ((CLOCK) == USART_Clock_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Clock_Polarity[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m#define USART_CPOL_Low                       ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_CPOL_High                      ((uint16_t)0x0400)[m
[32m+[m[32m#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Clock_Phase[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define USART_CPHA_1Edge                     ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_CPHA_2Edge                     ((uint16_t)0x0200)[m
[32m+[m[32m#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Last_Bit[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define USART_LastBit_Disable                ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_LastBit_Enable                 ((uint16_t)0x0100)[m
[32m+[m[32m#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \[m
[32m+[m[32m                                   ((LASTBIT) == USART_LastBit_Enable))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Interrupt_definition[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m#define USART_IT_PE                          ((uint16_t)0x0028)[m
[32m+[m[32m#define USART_IT_TXE                         ((uint16_t)0x0727)[m
[32m+[m[32m#define USART_IT_TC                          ((uint16_t)0x0626)[m
[32m+[m[32m#define USART_IT_RXNE                        ((uint16_t)0x0525)[m
[32m+[m[32m#define USART_IT_IDLE                        ((uint16_t)0x0424)[m
[32m+[m[32m#define USART_IT_LBD                         ((uint16_t)0x0846)[m
[32m+[m[32m#define USART_IT_CTS                         ((uint16_t)0x096A)[m
[32m+[m[32m#define USART_IT_ERR                         ((uint16_t)0x0060)[m
[32m+[m[32m#define USART_IT_ORE                         ((uint16_t)0x0360)[m
[32m+[m[32m#define USART_IT_NE                          ((uint16_t)0x0260)[m
[32m+[m[32m#define USART_IT_FE                          ((uint16_t)0x0160)[m
[32m+[m[32m#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \[m
[32m+[m[32m                               ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \[m
[32m+[m[32m                               ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \[m
[32m+[m[32m                               ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))[m
[32m+[m[32m#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \[m
[32m+[m[32m                            ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \[m
[32m+[m[32m                            ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \[m
[32m+[m[32m                            ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \[m
[32m+[m[32m                            ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))[m
[32m+[m[32m#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \[m
[32m+[m[32m                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_DMA_Requests[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define USART_DMAReq_Tx                      ((uint16_t)0x0080)[m
[32m+[m[32m#define USART_DMAReq_Rx                      ((uint16_t)0x0040)[m
[32m+[m[32m#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_WakeUp_methods[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)[m
[32m+[m[32m#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \[m
[32m+[m[32m                                 ((WAKEUP) == USART_WakeUp_AddressMark))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_LIN_Break_Detection_Length[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)[m
[32m+[m[32m#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)[m
[32m+[m[32m#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \[m
[32m+[m[32m                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \[m
[32m+[m[32m                                ((LENGTH) == USART_LINBreakDetectLength_11b))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_IrDA_Low_Power[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)[m
[32m+[m[32m#define USART_IrDAMode_Normal                ((uint16_t)0x0000)[m
[32m+[m[32m#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \[m
[32m+[m[32m                                  ((MODE) == USART_IrDAMode_Normal))[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Flags[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define USART_FLAG_CTS                       ((uint16_t)0x0200)[m
[32m+[m[32m#define USART_FLAG_LBD                       ((uint16_t)0x0100)[m
[32m+[m[32m#define USART_FLAG_TXE                       ((uint16_t)0x0080)[m
[32m+[m[32m#define USART_FLAG_TC                        ((uint16_t)0x0040)[m
[32m+[m[32m#define USART_FLAG_RXNE                      ((uint16_t)0x0020)[m
[32m+[m[32m#define USART_FLAG_IDLE                      ((uint16_t)0x0010)[m
[32m+[m[32m#define USART_FLAG_ORE                       ((uint16_t)0x0008)[m
[32m+[m[32m#define USART_FLAG_NE                        ((uint16_t)0x0004)[m
[32m+[m[32m#define USART_FLAG_FE                        ((uint16_t)0x0002)[m
[32m+[m[32m#define USART_FLAG_PE                        ((uint16_t)0x0001)[m
[32m+[m[32m#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \[m
[32m+[m[32m                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \[m
[32m+[m[32m                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \[m
[32m+[m[32m                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \[m
[32m+[m[32m                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))[m
[32m+[m[41m                              [m
[32m+[m[32m#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))[m
[32m+[m[32m#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(uint32_t*)&(PERIPH)) != UART4_BASE) &&\[m
[32m+[m[32m                                                  ((*(uint32_t*)&(PERIPH)) != UART5_BASE)) \[m
[32m+[m[32m                                                  || ((USART_FLAG) != USART_FLAG_CTS))[m[41m [m
[32m+[m[32m#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x0044AA21))[m
[32m+[m[32m#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)[m
[32m+[m[32m#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup USART_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mvoid USART_DeInit(USART_TypeDef* USARTx);[m
[32m+[m[32mvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);[m
[32m+[m[32mvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);[m
[32m+[m[32mvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);[m
[32m+[m[32mvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);[m
[32m+[m[32mvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);[m
[32m+[m[32mvoid USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);[m
[32m+[m[32mvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);[m
[32m+[m[32mvoid USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);[m
[32m+[m[32mvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);[m
[32m+[m[32mvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);[m
[32m+[m[32muint16_t USART_ReceiveData(USART_TypeDef* USARTx);[m
[32m+[m[32mvoid USART_SendBreak(USART_TypeDef* USARTx);[m
[32m+[m[32mvoid USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);[m
[32m+[m[32mvoid USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);[m
[32m+[m[32mvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mvoid USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);[m
[32m+[m[32mvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);[m
[32m+[m[32mFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);[m
[32m+[m[32mvoid USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);[m
[32m+[m[32mITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);[m
[32m+[m[32mvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_USART_H */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h[m
[1mnew file mode 100644[m
[1mindex 0000000..bdfa177[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/inc/stm32f10x_wwdg.h[m
[36m@@ -0,0 +1,115 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_wwdg.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file contains all the functions prototypes for the WWDG firmware[m
[32m+[m[32m  *          library.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_WWDG_H[m
[32m+[m[32m#define __STM32F10x_WWDG_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup WWDG[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Exported_Types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Exported_Constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m/** @defgroup WWDG_Prescaler[m[41m [m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m#define WWDG_Prescaler_1    ((uint32_t)0x00000000)[m
[32m+[m[32m#define WWDG_Prescaler_2    ((uint32_t)0x00000080)[m
[32m+[m[32m#define WWDG_Prescaler_4    ((uint32_t)0x00000100)[m
[32m+[m[32m#define WWDG_Prescaler_8    ((uint32_t)0x00000180)[m
[32m+[m[32m#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \[m
[32m+[m[32m                                      ((PRESCALER) == WWDG_Prescaler_2) || \[m
[32m+[m[32m                                      ((PRESCALER) == WWDG_Prescaler_4) || \[m
[32m+[m[32m                                      ((PRESCALER) == WWDG_Prescaler_8))[m
[32m+[m[32m#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)[m
[32m+[m[32m#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Exported_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Exported_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32mvoid WWDG_DeInit(void);[m
[32m+[m[32mvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler);[m
[32m+[m[32mvoid WWDG_SetWindowValue(uint8_t WindowValue);[m
[32m+[m[32mvoid WWDG_EnableIT(void);[m
[32m+[m[32mvoid WWDG_SetCounter(uint8_t Counter);[m
[32m+[m[32mvoid WWDG_Enable(uint8_t Counter);[m
[32m+[m[32mFlagStatus WWDG_GetFlagStatus(void);[m
[32m+[m[32mvoid WWDG_ClearFlag(void);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_WWDG_H */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c b/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c[m
[1mnew file mode 100644[m
[1mindex 0000000..c0a5e11[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/misc.c[m
[36m@@ -0,0 +1,225 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    misc.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the miscellaneous firmware functions (add-on[m
[32m+[m[32m  *          to CMSIS functions).[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "misc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC[m[41m [m
[32m+[m[32m  * @brief MISC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define AIRCR_VECTKEY_MASK    ((uint32_t)0x05FA0000)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup MISC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the priority grouping: pre-emption priority and subpriority.[m
[32m+[m[32m  * @param  NVIC_PriorityGroup: specifies the priority grouping bits length.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg NVIC_PriorityGroup_0: 0 bits for pre-emption priority[m
[32m+[m[32m  *                                4 bits for subpriority[m
[32m+[m[32m  *     @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority[m
[32m+[m[32m  *                                3 bits for subpriority[m
[32m+[m[32m  *     @arg NVIC_PriorityGroup_2: 2 bits for pre-emption priority[m
[32m+[m[32m  *                                2 bits for subpriority[m
[32m+[m[32m  *     @arg NVIC_PriorityGroup_3: 3 bits for pre-emption priority[m
[32m+[m[32m  *                                1 bits for subpriority[m
[32m+[m[32m  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority[m
[32m+[m[32m  *                                0 bits for subpriority[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */[m
[32m+[m[32m  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the NVIC peripheral according to the specified[m
[32m+[m[32m  *         parameters in the NVIC_InitStruct.[m
[32m+[m[32m  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains[m
[32m+[m[32m  *         the configuration information for the specified NVIC peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));[m
[32m+[m[32m  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));[m[41m  [m
[32m+[m[32m  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));[m
[32m+[m[41m    [m
[32m+[m[32m  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Compute the Corresponding IRQ Priority --------------------------------*/[m[41m    [m
[32m+[m[32m    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;[m
[32m+[m[32m    tmppre = (0x4 - tmppriority);[m
[32m+[m[32m    tmpsub = tmpsub >> tmppriority;[m
[32m+[m
[32m+[m[32m    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;[m
[32m+[m[32m    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;[m
[32m+[m[32m    tmppriority = tmppriority << 0x04;[m
[32m+[m[41m        [m
[32m+[m[32m    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Enable the Selected IRQ Channels --------------------------------------*/[m
[32m+[m[32m    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =[m
[32m+[m[32m      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the Selected IRQ Channels -------------------------------------*/[m
[32m+[m[32m    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =[m
[32m+[m[32m      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the vector table location and Offset.[m
[32m+[m[32m  * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg NVIC_VectTab_RAM[m
[32m+[m[32m  *     @arg NVIC_VectTab_FLASH[m
[32m+[m[32m  * @param  Offset: Vector Table base offset field. This value must be a multiple[m[41m [m
[32m+[m[32m  *         of 0x200.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));[m
[32m+[m[32m  assert_param(IS_NVIC_OFFSET(Offset));[m[41m  [m
[32m+[m[41m   [m
[32m+[m[32m  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the condition for the system to enter low power mode.[m
[32m+[m[32m  * @param  LowPowerMode: Specifies the new mode for the system to enter low power mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg NVIC_LP_SEVONPEND[m
[32m+[m[32m  *     @arg NVIC_LP_SLEEPDEEP[m
[32m+[m[32m  *     @arg NVIC_LP_SLEEPONEXIT[m
[32m+[m[32m  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_NVIC_LP(LowPowerMode));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    SCB->SCR |= LowPowerMode;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the SysTick clock source.[m
[32m+[m[32m  * @param  SysTick_CLKSource: specifies the SysTick clock source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.[m
[32m+[m[32m  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));[m
[32m+[m[32m  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)[m
[32m+[m[32m  {[m
[32m+[m[32m    SysTick->CTRL |= SysTick_CLKSource_HCLK;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c[m
[1mnew file mode 100644[m
[1mindex 0000000..8155dc9[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_adc.c[m
[36m@@ -0,0 +1,1307 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_adc.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the ADC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_adc.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC[m[41m [m
[32m+[m[32m  * @brief ADC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* ADC DISCNUM mask */[m
[32m+[m[32m#define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)[m
[32m+[m
[32m+[m[32m/* ADC DISCEN mask */[m
[32m+[m[32m#define CR1_DISCEN_Set              ((uint32_t)0x00000800)[m
[32m+[m[32m#define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)[m
[32m+[m
[32m+[m[32m/* ADC JAUTO mask */[m
[32m+[m[32m#define CR1_JAUTO_Set               ((uint32_t)0x00000400)[m
[32m+[m[32m#define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)[m
[32m+[m
[32m+[m[32m/* ADC JDISCEN mask */[m
[32m+[m[32m#define CR1_JDISCEN_Set             ((uint32_t)0x00001000)[m
[32m+[m[32m#define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)[m
[32m+[m
[32m+[m[32m/* ADC AWDCH mask */[m
[32m+[m[32m#define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)[m
[32m+[m
[32m+[m[32m/* ADC Analog watchdog enable mode mask */[m
[32m+[m[32m#define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)[m
[32m+[m
[32m+[m[32m/* CR1 register Mask */[m
[32m+[m[32m#define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)[m
[32m+[m
[32m+[m[32m/* ADC ADON mask */[m
[32m+[m[32m#define CR2_ADON_Set                ((uint32_t)0x00000001)[m
[32m+[m[32m#define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)[m
[32m+[m
[32m+[m[32m/* ADC DMA mask */[m
[32m+[m[32m#define CR2_DMA_Set                 ((uint32_t)0x00000100)[m
[32m+[m[32m#define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)[m
[32m+[m
[32m+[m[32m/* ADC RSTCAL mask */[m
[32m+[m[32m#define CR2_RSTCAL_Set              ((uint32_t)0x00000008)[m
[32m+[m
[32m+[m[32m/* ADC CAL mask */[m
[32m+[m[32m#define CR2_CAL_Set                 ((uint32_t)0x00000004)[m
[32m+[m
[32m+[m[32m/* ADC SWSTART mask */[m
[32m+[m[32m#define CR2_SWSTART_Set             ((uint32_t)0x00400000)[m
[32m+[m
[32m+[m[32m/* ADC EXTTRIG mask */[m
[32m+[m[32m#define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)[m
[32m+[m[32m#define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)[m
[32m+[m
[32m+[m[32m/* ADC Software start mask */[m
[32m+[m[32m#define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)[m
[32m+[m[32m#define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)[m
[32m+[m
[32m+[m[32m/* ADC JEXTSEL mask */[m
[32m+[m[32m#define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)[m
[32m+[m
[32m+[m[32m/* ADC JEXTTRIG mask */[m
[32m+[m[32m#define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)[m
[32m+[m[32m#define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)[m
[32m+[m
[32m+[m[32m/* ADC JSWSTART mask */[m
[32m+[m[32m#define CR2_JSWSTART_Set            ((uint32_t)0x00200000)[m
[32m+[m
[32m+[m[32m/* ADC injected software start mask */[m
[32m+[m[32m#define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)[m
[32m+[m[32m#define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)[m
[32m+[m
[32m+[m[32m/* ADC TSPD mask */[m
[32m+[m[32m#define CR2_TSVREFE_Set             ((uint32_t)0x00800000)[m
[32m+[m[32m#define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)[m
[32m+[m
[32m+[m[32m/* CR2 register Mask */[m
[32m+[m[32m#define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)[m
[32m+[m
[32m+[m[32m/* ADC SQx mask */[m
[32m+[m[32m#define SQR3_SQ_Set                 ((uint32_t)0x0000001F)[m
[32m+[m[32m#define SQR2_SQ_Set                 ((uint32_t)0x0000001F)[m
[32m+[m[32m#define SQR1_SQ_Set                 ((uint32_t)0x0000001F)[m
[32m+[m
[32m+[m[32m/* SQR1 register Mask */[m
[32m+[m[32m#define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)[m
[32m+[m
[32m+[m[32m/* ADC JSQx mask */[m
[32m+[m[32m#define JSQR_JSQ_Set                ((uint32_t)0x0000001F)[m
[32m+[m
[32m+[m[32m/* ADC JL mask */[m
[32m+[m[32m#define JSQR_JL_Set                 ((uint32_t)0x00300000)[m
[32m+[m[32m#define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)[m
[32m+[m
[32m+[m[32m/* ADC SMPx mask */[m
[32m+[m[32m#define SMPR1_SMP_Set               ((uint32_t)0x00000007)[m
[32m+[m[32m#define SMPR2_SMP_Set               ((uint32_t)0x00000007)[m
[32m+[m
[32m+[m[32m/* ADC JDRx registers offset */[m
[32m+[m[32m#define JDR_Offset                  ((uint8_t)0x28)[m
[32m+[m
[32m+[m[32m/* ADC1 DR register base address */[m
[32m+[m[32m#define DR_ADDRESS                  ((uint32_t)0x4001244C)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup ADC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_DeInit(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[41m  [m
[32m+[m[32m  if (ADCx == ADC1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable ADC1 reset state */[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);[m
[32m+[m[32m    /* Release ADC1 from reset state */[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (ADCx == ADC2)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable ADC2 reset state */[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);[m
[32m+[m[32m    /* Release ADC2 from reset state */[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if (ADCx == ADC3)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Enable ADC3 reset state */[m
[32m+[m[32m      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);[m
[32m+[m[32m      /* Release ADC3 from reset state */[m
[32m+[m[32m      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the ADCx peripheral according to the specified parameters[m
[32m+[m[32m  *         in the ADC_InitStruct.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains[m
[32m+[m[32m  *         the configuration information for the specified ADC peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg1 = 0;[m
[32m+[m[32m  uint8_t tmpreg2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));[m
[32m+[m[32m  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));[m[41m   [m
[32m+[m[32m  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign));[m[41m [m
[32m+[m[32m  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));[m
[32m+[m
[32m+[m[32m  /*---------------------------- ADCx CR1 Configuration -----------------*/[m
[32m+[m[32m  /* Get the ADCx CR1 value */[m
[32m+[m[32m  tmpreg1 = ADCx->CR1;[m
[32m+[m[32m  /* Clear DUALMOD and SCAN bits */[m
[32m+[m[32m  tmpreg1 &= CR1_CLEAR_Mask;[m
[32m+[m[32m  /* Configure ADCx: Dual mode and scan conversion mode */[m
[32m+[m[32m  /* Set DUALMOD bits according to ADC_Mode value */[m
[32m+[m[32m  /* Set SCAN bit according to ADC_ScanConvMode value */[m
[32m+[m[32m  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));[m
[32m+[m[32m  /* Write to ADCx CR1 */[m
[32m+[m[32m  ADCx->CR1 = tmpreg1;[m
[32m+[m
[32m+[m[32m  /*---------------------------- ADCx CR2 Configuration -----------------*/[m
[32m+[m[32m  /* Get the ADCx CR2 value */[m
[32m+[m[32m  tmpreg1 = ADCx->CR2;[m
[32m+[m[32m  /* Clear CONT, ALIGN and EXTSEL bits */[m
[32m+[m[32m  tmpreg1 &= CR2_CLEAR_Mask;[m
[32m+[m[32m  /* Configure ADCx: external trigger event and continuous conversion mode */[m
[32m+[m[32m  /* Set ALIGN bit according to ADC_DataAlign value */[m
[32m+[m[32m  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */[m
[32m+[m[32m  /* Set CONT bit according to ADC_ContinuousConvMode value */[m
[32m+[m[32m  tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |[m
[32m+[m[32m            ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));[m
[32m+[m[32m  /* Write to ADCx CR2 */[m
[32m+[m[32m  ADCx->CR2 = tmpreg1;[m
[32m+[m
[32m+[m[32m  /*---------------------------- ADCx SQR1 Configuration -----------------*/[m
[32m+[m[32m  /* Get the ADCx SQR1 value */[m
[32m+[m[32m  tmpreg1 = ADCx->SQR1;[m
[32m+[m[32m  /* Clear L bits */[m
[32m+[m[32m  tmpreg1 &= SQR1_CLEAR_Mask;[m
[32m+[m[32m  /* Configure ADCx: regular channel sequence length */[m
[32m+[m[32m  /* Set L bits according to ADC_NbrOfChannel value */[m
[32m+[m[32m  tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);[m
[32m+[m[32m  tmpreg1 |= (uint32_t)tmpreg2 << 20;[m
[32m+[m[32m  /* Write to ADCx SQR1 */[m
[32m+[m[32m  ADCx->SQR1 = tmpreg1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each ADC_InitStruct member with its default value.[m
[32m+[m[32m  * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset ADC init structure parameters values */[m
[32m+[m[32m  /* Initialize the ADC_Mode member */[m
[32m+[m[32m  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;[m
[32m+[m[32m  /* initialize the ADC_ScanConvMode member */[m
[32m+[m[32m  ADC_InitStruct->ADC_ScanConvMode = DISABLE;[m
[32m+[m[32m  /* Initialize the ADC_ContinuousConvMode member */[m
[32m+[m[32m  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;[m
[32m+[m[32m  /* Initialize the ADC_ExternalTrigConv member */[m
[32m+[m[32m  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;[m
[32m+[m[32m  /* Initialize the ADC_DataAlign member */[m
[32m+[m[32m  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;[m
[32m+[m[32m  /* Initialize the ADC_NbrOfChannel member */[m
[32m+[m[32m  ADC_InitStruct->ADC_NbrOfChannel = 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified ADC peripheral.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the ADCx peripheral.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the ADON bit to wake up the ADC from power down mode */[m
[32m+[m[32m    ADCx->CR2 |= CR2_ADON_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC peripheral */[m
[32m+[m[32m    ADCx->CR2 &= CR2_ADON_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified ADC DMA request.[m
[32m+[m[32m  * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.[m
[32m+[m[32m  *   Note: ADC2 hasn't a DMA capability.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC DMA transfer.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_DMA_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC DMA request */[m
[32m+[m[32m    ADCx->CR2 |= CR2_DMA_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC DMA request */[m
[32m+[m[32m    ADCx->CR2 &= CR2_DMA_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified ADC interrupts.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg ADC_IT_EOC: End of conversion interrupt mask[m
[32m+[m[32m  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask[m
[32m+[m[32m  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask[m
[32m+[m[32m  * @param  NewState: new state of the specified ADC interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t itmask = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  assert_param(IS_ADC_IT(ADC_IT));[m
[32m+[m[32m  /* Get the ADC IT index */[m
[32m+[m[32m  itmask = (uint8_t)ADC_IT;[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC interrupts */[m
[32m+[m[32m    ADCx->CR1 |= itmask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC interrupts */[m
[32m+[m[32m    ADCx->CR1 &= (~(uint32_t)itmask);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Resets the selected ADC calibration registers.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ResetCalibration(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Resets the selected ADC calibration registers */[m[41m  [m
[32m+[m[32m  ADCx->CR2 |= CR2_RSTCAL_Set;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the selected ADC reset calibration registers status.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval The new state of ADC reset calibration registers (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Check the status of RSTCAL bit */[m
[32m+[m[32m  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* RSTCAL bit is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* RSTCAL bit is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the RSTCAL bit status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Starts the selected ADC calibration process.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_StartCalibration(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Enable the selected ADC calibration process */[m[41m  [m
[32m+[m[32m  ADCx->CR2 |= CR2_CAL_Set;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the selected ADC calibration status.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval The new state of ADC calibration (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Check the status of CAL bit */[m
[32m+[m[32m  if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CAL bit is set: calibration on going */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CAL bit is reset: end of calibration */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the CAL bit status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the selected ADC software start conversion .[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC software start conversion.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC conversion on external event and start the selected[m
[32m+[m[32m       ADC conversion */[m
[32m+[m[32m    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC conversion on external event and stop the selected[m
[32m+[m[32m       ADC conversion */[m
[32m+[m[32m    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the selected ADC Software start conversion Status.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval The new state of ADC software start conversion (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Check the status of SWSTART bit */[m
[32m+[m[32m  if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SWSTART bit is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SWSTART bit is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the SWSTART bit status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the discontinuous mode for the selected ADC regular[m
[32m+[m[32m  *         group channel.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  Number: specifies the discontinuous mode regular channel[m
[32m+[m[32m  *         count value. This number must be between 1 and 8.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg1 = 0;[m
[32m+[m[32m  uint32_t tmpreg2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));[m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg1 = ADCx->CR1;[m
[32m+[m[32m  /* Clear the old discontinuous mode channel count */[m
[32m+[m[32m  tmpreg1 &= CR1_DISCNUM_Reset;[m
[32m+[m[32m  /* Set the discontinuous mode channel count */[m
[32m+[m[32m  tmpreg2 = Number - 1;[m
[32m+[m[32m  tmpreg1 |= tmpreg2 << 13;[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  ADCx->CR1 = tmpreg1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the discontinuous mode on regular group[m
[32m+[m[32m  *         channel for the specified ADC[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC discontinuous mode[m
[32m+[m[32m  *         on regular group channel.[m
[32m+[m[32m  *         This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC regular discontinuous mode */[m
[32m+[m[32m    ADCx->CR1 |= CR1_DISCEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC regular discontinuous mode */[m
[32m+[m[32m    ADCx->CR1 &= CR1_DISCEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures for the selected ADC regular channel its corresponding[m
[32m+[m[32m  *         rank in the sequencer and its sample time.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_Channel: the ADC channel to configure.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_Channel_0: ADC Channel0 selected[m
[32m+[m[32m  *     @arg ADC_Channel_1: ADC Channel1 selected[m
[32m+[m[32m  *     @arg ADC_Channel_2: ADC Channel2 selected[m
[32m+[m[32m  *     @arg ADC_Channel_3: ADC Channel3 selected[m
[32m+[m[32m  *     @arg ADC_Channel_4: ADC Channel4 selected[m
[32m+[m[32m  *     @arg ADC_Channel_5: ADC Channel5 selected[m
[32m+[m[32m  *     @arg ADC_Channel_6: ADC Channel6 selected[m
[32m+[m[32m  *     @arg ADC_Channel_7: ADC Channel7 selected[m
[32m+[m[32m  *     @arg ADC_Channel_8: ADC Channel8 selected[m
[32m+[m[32m  *     @arg ADC_Channel_9: ADC Channel9 selected[m
[32m+[m[32m  *     @arg ADC_Channel_10: ADC Channel10 selected[m
[32m+[m[32m  *     @arg ADC_Channel_11: ADC Channel11 selected[m
[32m+[m[32m  *     @arg ADC_Channel_12: ADC Channel12 selected[m
[32m+[m[32m  *     @arg ADC_Channel_13: ADC Channel13 selected[m
[32m+[m[32m  *     @arg ADC_Channel_14: ADC Channel14 selected[m
[32m+[m[32m  *     @arg ADC_Channel_15: ADC Channel15 selected[m
[32m+[m[32m  *     @arg ADC_Channel_16: ADC Channel16 selected[m
[32m+[m[32m  *     @arg ADC_Channel_17: ADC Channel17 selected[m
[32m+[m[32m  * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.[m
[32m+[m[32m  * @param  ADC_SampleTime: The sample time value to be set for the selected channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles[m
[32m+[m[32m  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles[m
[32m+[m[32m  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles[m
[32m+[m[32m  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles[m[41m	[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg1 = 0, tmpreg2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_CHANNEL(ADC_Channel));[m
[32m+[m[32m  assert_param(IS_ADC_REGULAR_RANK(Rank));[m
[32m+[m[32m  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));[m
[32m+[m[32m  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */[m
[32m+[m[32m  if (ADC_Channel > ADC_Channel_9)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SMPR1;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));[m
[32m+[m[32m    /* Clear the old channel sample time */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));[m
[32m+[m[32m    /* Set the new channel sample time */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SMPR1 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* ADC_Channel include in ADC_Channel_[0..9] */[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SMPR2;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);[m
[32m+[m[32m    /* Clear the old channel sample time */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);[m
[32m+[m[32m    /* Set the new channel sample time */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SMPR2 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* For Rank 1 to 6 */[m
[32m+[m[32m  if (Rank < 7)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SQR3;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));[m
[32m+[m[32m    /* Clear the old SQx bits for the selected rank */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));[m
[32m+[m[32m    /* Set the SQx bits for the selected rank */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SQR3 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* For Rank 7 to 12 */[m
[32m+[m[32m  else if (Rank < 13)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SQR2;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));[m
[32m+[m[32m    /* Clear the old SQx bits for the selected rank */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));[m
[32m+[m[32m    /* Set the SQx bits for the selected rank */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SQR2 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* For Rank 13 to 16 */[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SQR1;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));[m
[32m+[m[32m    /* Clear the old SQx bits for the selected rank */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));[m
[32m+[m[32m    /* Set the SQx bits for the selected rank */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SQR1 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the ADCx conversion through external trigger.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC external trigger start of conversion.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC conversion on external event */[m
[32m+[m[32m    ADCx->CR2 |= CR2_EXTTRIG_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC conversion on external event */[m
[32m+[m[32m    ADCx->CR2 &= CR2_EXTTRIG_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the last ADCx conversion result data for regular channel.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval The Data conversion value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Return the selected ADC conversion value */[m
[32m+[m[32m  return (uint16_t) ADCx->DR;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.[m
[32m+[m[32m  * @retval The Data conversion value.[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t ADC_GetDualModeConversionValue(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Return the dual mode conversion value */[m
[32m+[m[32m  return (*(__IO uint32_t *) DR_ADDRESS);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the selected ADC automatic injected group[m
[32m+[m[32m  *         conversion after regular one.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC auto injected conversion[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC automatic injected group conversion */[m
[32m+[m[32m    ADCx->CR1 |= CR1_JAUTO_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC automatic injected group conversion */[m
[32m+[m[32m    ADCx->CR1 &= CR1_JAUTO_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the discontinuous mode for injected group[m
[32m+[m[32m  *         channel for the specified ADC[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC discontinuous mode[m
[32m+[m[32m  *         on injected group channel.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC injected discontinuous mode */[m
[32m+[m[32m    ADCx->CR1 |= CR1_JDISCEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC injected discontinuous mode */[m
[32m+[m[32m    ADCx->CR1 &= CR1_JDISCEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the ADCx external trigger for injected channels conversion.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and ADC3)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8[m
[32m+[m[32m  *                                                       capture compare4 event selected (for ADC1 and ADC2)[m[41m                       [m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)[m[41m                         [m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)[m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)[m[41m                         [m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)[m[41m                        [m
[32m+[m[32m  *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not[m
[32m+[m[32m  *                                          by external trigger (for ADC1, ADC2 and ADC3)[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));[m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg = ADCx->CR2;[m
[32m+[m[32m  /* Clear the old external event selection for injected group */[m
[32m+[m[32m  tmpreg &= CR2_JEXTSEL_Reset;[m
[32m+[m[32m  /* Set the external event selection for injected group */[m
[32m+[m[32m  tmpreg |= ADC_ExternalTrigInjecConv;[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  ADCx->CR2 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the ADCx injected channels conversion through[m
[32m+[m[32m  *         external trigger[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC external trigger start of[m
[32m+[m[32m  *         injected conversion.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC external event selection for injected group */[m
[32m+[m[32m    ADCx->CR2 |= CR2_JEXTTRIG_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC external event selection for injected group */[m
[32m+[m[32m    ADCx->CR2 &= CR2_JEXTTRIG_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the selected ADC start of the injected[m[41m [m
[32m+[m[32m  *         channels conversion.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the selected ADC software start injected conversion.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected ADC conversion for injected group on external event and start the selected[m
[32m+[m[32m       ADC injected conversion */[m
[32m+[m[32m    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected ADC conversion on external event for injected group and stop the selected[m
[32m+[m[32m       ADC injected conversion */[m
[32m+[m[32m    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the selected ADC Software start injected conversion Status.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @retval The new state of ADC software start injected conversion (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  /* Check the status of JSWSTART bit */[m
[32m+[m[32m  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* JSWSTART bit is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* JSWSTART bit is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the JSWSTART bit status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures for the selected ADC injected channel its corresponding[m
[32m+[m[32m  *         rank in the sequencer and its sample time.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_Channel: the ADC channel to configure.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_Channel_0: ADC Channel0 selected[m
[32m+[m[32m  *     @arg ADC_Channel_1: ADC Channel1 selected[m
[32m+[m[32m  *     @arg ADC_Channel_2: ADC Channel2 selected[m
[32m+[m[32m  *     @arg ADC_Channel_3: ADC Channel3 selected[m
[32m+[m[32m  *     @arg ADC_Channel_4: ADC Channel4 selected[m
[32m+[m[32m  *     @arg ADC_Channel_5: ADC Channel5 selected[m
[32m+[m[32m  *     @arg ADC_Channel_6: ADC Channel6 selected[m
[32m+[m[32m  *     @arg ADC_Channel_7: ADC Channel7 selected[m
[32m+[m[32m  *     @arg ADC_Channel_8: ADC Channel8 selected[m
[32m+[m[32m  *     @arg ADC_Channel_9: ADC Channel9 selected[m
[32m+[m[32m  *     @arg ADC_Channel_10: ADC Channel10 selected[m
[32m+[m[32m  *     @arg ADC_Channel_11: ADC Channel11 selected[m
[32m+[m[32m  *     @arg ADC_Channel_12: ADC Channel12 selected[m
[32m+[m[32m  *     @arg ADC_Channel_13: ADC Channel13 selected[m
[32m+[m[32m  *     @arg ADC_Channel_14: ADC Channel14 selected[m
[32m+[m[32m  *     @arg ADC_Channel_15: ADC Channel15 selected[m
[32m+[m[32m  *     @arg ADC_Channel_16: ADC Channel16 selected[m
[32m+[m[32m  *     @arg ADC_Channel_17: ADC Channel17 selected[m
[32m+[m[32m  * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.[m
[32m+[m[32m  * @param  ADC_SampleTime: The sample time value to be set for the selected channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles[m
[32m+[m[32m  *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles[m
[32m+[m[32m  *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles[m
[32m+[m[32m  *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles[m[41m	[m
[32m+[m[32m  *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles[m[41m	[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_CHANNEL(ADC_Channel));[m
[32m+[m[32m  assert_param(IS_ADC_INJECTED_RANK(Rank));[m
[32m+[m[32m  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));[m
[32m+[m[32m  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */[m
[32m+[m[32m  if (ADC_Channel > ADC_Channel_9)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SMPR1;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));[m
[32m+[m[32m    /* Clear the old channel sample time */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));[m
[32m+[m[32m    /* Set the new channel sample time */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SMPR1 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* ADC_Channel include in ADC_Channel_[0..9] */[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the old register value */[m
[32m+[m[32m    tmpreg1 = ADCx->SMPR2;[m
[32m+[m[32m    /* Calculate the mask to clear */[m
[32m+[m[32m    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);[m
[32m+[m[32m    /* Clear the old channel sample time */[m
[32m+[m[32m    tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m    /* Calculate the mask to set */[m
[32m+[m[32m    tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);[m
[32m+[m[32m    /* Set the new channel sample time */[m
[32m+[m[32m    tmpreg1 |= tmpreg2;[m
[32m+[m[32m    /* Store the new register value */[m
[32m+[m[32m    ADCx->SMPR2 = tmpreg1;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Rank configuration */[m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg1 = ADCx->JSQR;[m
[32m+[m[32m  /* Get JL value: Number = JL+1 */[m
[32m+[m[32m  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;[m
[32m+[m[32m  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */[m
[32m+[m[32m  tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));[m
[32m+[m[32m  /* Clear the old JSQx bits for the selected rank */[m
[32m+[m[32m  tmpreg1 &= ~tmpreg2;[m
[32m+[m[32m  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */[m
[32m+[m[32m  tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));[m
[32m+[m[32m  /* Set the JSQx bits for the selected rank */[m
[32m+[m[32m  tmpreg1 |= tmpreg2;[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  ADCx->JSQR = tmpreg1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the sequencer length for injected channels[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  Length: The sequencer length.[m[41m [m
[32m+[m[32m  *   This parameter must be a number between 1 to 4.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg1 = 0;[m
[32m+[m[32m  uint32_t tmpreg2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_INJECTED_LENGTH(Length));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg1 = ADCx->JSQR;[m
[32m+[m[32m  /* Clear the old injected sequnence lenght JL bits */[m
[32m+[m[32m  tmpreg1 &= JSQR_JL_Reset;[m
[32m+[m[32m  /* Set the injected sequnence lenght JL bits */[m
[32m+[m[32m  tmpreg2 = Length - 1;[m[41m [m
[32m+[m[32m  tmpreg1 |= tmpreg2 << 20;[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  ADCx->JSQR = tmpreg1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Set the injected channels conversion value offset[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_InjectedChannel: the ADC injected channel to set its offset.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected[m
[32m+[m[32m  * @param  Offset: the offset value for the selected ADC injected channel[m
[32m+[m[32m  *   This parameter must be a 12bit value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));[m
[32m+[m[32m  assert_param(IS_ADC_OFFSET(Offset));[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m  tmp = (uint32_t)ADCx;[m
[32m+[m[32m  tmp += ADC_InjectedChannel;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the selected injected channel data offset */[m
[32m+[m[32m  *(__IO uint32_t *) tmp = (uint32_t)Offset;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the ADC injected channel conversion result[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_InjectedChannel: the converted ADC injected channel.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_1: Injected Channel1 selected[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_2: Injected Channel2 selected[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_3: Injected Channel3 selected[m
[32m+[m[32m  *     @arg ADC_InjectedChannel_4: Injected Channel4 selected[m
[32m+[m[32m  * @retval The Data conversion value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));[m
[32m+[m
[32m+[m[32m  tmp = (uint32_t)ADCx;[m
[32m+[m[32m  tmp += ADC_InjectedChannel + JDR_Offset;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Returns the selected injected channel conversion data value */[m
[32m+[m[32m  return (uint16_t) (*(__IO uint32_t*)  tmp);[m[41m   [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the analog watchdog on single/all regular[m
[32m+[m[32m  *         or injected channels[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or injected channel[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected channels[m
[32m+[m[32m  *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog[m
[32m+[m[32m  * @retval None[m[41m	  [m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));[m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg = ADCx->CR1;[m
[32m+[m[32m  /* Clear AWDEN, AWDENJ and AWDSGL bits */[m
[32m+[m[32m  tmpreg &= CR1_AWDMode_Reset;[m
[32m+[m[32m  /* Set the analog watchdog enable mode */[m
[32m+[m[32m  tmpreg |= ADC_AnalogWatchdog;[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  ADCx->CR1 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the high and low thresholds of the analog watchdog.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  HighThreshold: the ADC analog watchdog High threshold value.[m
[32m+[m[32m  *   This parameter must be a 12bit value.[m
[32m+[m[32m  * @param  LowThreshold: the ADC analog watchdog Low threshold value.[m
[32m+[m[32m  *   This parameter must be a 12bit value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,[m
[32m+[m[32m                                        uint16_t LowThreshold)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_THRESHOLD(HighThreshold));[m
[32m+[m[32m  assert_param(IS_ADC_THRESHOLD(LowThreshold));[m
[32m+[m[32m  /* Set the ADCx high threshold */[m
[32m+[m[32m  ADCx->HTR = HighThreshold;[m
[32m+[m[32m  /* Set the ADCx low threshold */[m
[32m+[m[32m  ADCx->LTR = LowThreshold;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the analog watchdog guarded single channel[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_Channel: the ADC channel to configure for the analog watchdog.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_Channel_0: ADC Channel0 selected[m
[32m+[m[32m  *     @arg ADC_Channel_1: ADC Channel1 selected[m
[32m+[m[32m  *     @arg ADC_Channel_2: ADC Channel2 selected[m
[32m+[m[32m  *     @arg ADC_Channel_3: ADC Channel3 selected[m
[32m+[m[32m  *     @arg ADC_Channel_4: ADC Channel4 selected[m
[32m+[m[32m  *     @arg ADC_Channel_5: ADC Channel5 selected[m
[32m+[m[32m  *     @arg ADC_Channel_6: ADC Channel6 selected[m
[32m+[m[32m  *     @arg ADC_Channel_7: ADC Channel7 selected[m
[32m+[m[32m  *     @arg ADC_Channel_8: ADC Channel8 selected[m
[32m+[m[32m  *     @arg ADC_Channel_9: ADC Channel9 selected[m
[32m+[m[32m  *     @arg ADC_Channel_10: ADC Channel10 selected[m
[32m+[m[32m  *     @arg ADC_Channel_11: ADC Channel11 selected[m
[32m+[m[32m  *     @arg ADC_Channel_12: ADC Channel12 selected[m
[32m+[m[32m  *     @arg ADC_Channel_13: ADC Channel13 selected[m
[32m+[m[32m  *     @arg ADC_Channel_14: ADC Channel14 selected[m
[32m+[m[32m  *     @arg ADC_Channel_15: ADC Channel15 selected[m
[32m+[m[32m  *     @arg ADC_Channel_16: ADC Channel16 selected[m
[32m+[m[32m  *     @arg ADC_Channel_17: ADC Channel17 selected[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_CHANNEL(ADC_Channel));[m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg = ADCx->CR1;[m
[32m+[m[32m  /* Clear the Analog watchdog channel select bits */[m
[32m+[m[32m  tmpreg &= CR1_AWDCH_Reset;[m
[32m+[m[32m  /* Set the Analog watchdog channel */[m
[32m+[m[32m  tmpreg |= ADC_Channel;[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  ADCx->CR1 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the temperature sensor and Vrefint channel.[m
[32m+[m[32m  * @param  NewState: new state of the temperature sensor.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_TempSensorVrefintCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the temperature sensor and Vrefint channel*/[m
[32m+[m[32m    ADC1->CR2 |= CR2_TSVREFE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the temperature sensor and Vrefint channel*/[m
[32m+[m[32m    ADC1->CR2 &= CR2_TSVREFE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified ADC flag is set or not.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_FLAG: specifies the flag to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_FLAG_AWD: Analog watchdog flag[m
[32m+[m[32m  *     @arg ADC_FLAG_EOC: End of conversion flag[m
[32m+[m[32m  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag[m
[32m+[m[32m  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag[m
[32m+[m[32m  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag[m
[32m+[m[32m  * @retval The new state of ADC_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));[m
[32m+[m[32m  /* Check the status of the specified ADC flag */[m
[32m+[m[32m  if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* ADC_FLAG is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* ADC_FLAG is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the ADC_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the ADCx's pending flags.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_FLAG: specifies the flag to clear.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg ADC_FLAG_AWD: Analog watchdog flag[m
[32m+[m[32m  *     @arg ADC_FLAG_EOC: End of conversion flag[m
[32m+[m[32m  *     @arg ADC_FLAG_JEOC: End of injected group conversion flag[m
[32m+[m[32m  *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag[m
[32m+[m[32m  *     @arg ADC_FLAG_STRT: Start of regular group conversion flag[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));[m
[32m+[m[32m  /* Clear the selected ADC flags */[m
[32m+[m[32m  ADCx->SR = ~(uint32_t)ADC_FLAG;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified ADC interrupt has occurred or not.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_IT: specifies the ADC interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg ADC_IT_EOC: End of conversion interrupt mask[m
[32m+[m[32m  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask[m
[32m+[m[32m  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask[m
[32m+[m[32m  * @retval The new state of ADC_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t itmask = 0, enablestatus = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_GET_IT(ADC_IT));[m
[32m+[m[32m  /* Get the ADC IT index */[m
[32m+[m[32m  itmask = ADC_IT >> 8;[m
[32m+[m[32m  /* Get the ADC_IT enable bit status */[m
[32m+[m[32m  enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;[m
[32m+[m[32m  /* Check the status of the specified ADC interrupt */[m
[32m+[m[32m  if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* ADC_IT is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* ADC_IT is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the ADC_IT status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the ADCx's interrupt pending bits.[m
[32m+[m[32m  * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.[m
[32m+[m[32m  * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg ADC_IT_EOC: End of conversion interrupt mask[m
[32m+[m[32m  *     @arg ADC_IT_AWD: Analog watchdog interrupt mask[m
[32m+[m[32m  *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t itmask = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_ADC_ALL_PERIPH(ADCx));[m
[32m+[m[32m  assert_param(IS_ADC_IT(ADC_IT));[m
[32m+[m[32m  /* Get the ADC IT index */[m
[32m+[m[32m  itmask = (uint8_t)(ADC_IT >> 8);[m
[32m+[m[32m  /* Clear the selected ADC interrupt pending bits */[m
[32m+[m[32m  ADCx->SR = ~(uint32_t)itmask;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c[m
[1mnew file mode 100644[m
[1mindex 0000000..997eecc[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_bkp.c[m
[36m@@ -0,0 +1,308 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_bkp.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the BKP firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_bkp.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP[m[41m [m
[32m+[m[32m  * @brief BKP driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* ------------ BKP registers bit address in the alias region --------------- */[m
[32m+[m[32m#define BKP_OFFSET        (BKP_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* --- CR Register ----*/[m
[32m+[m
[32m+[m[32m/* Alias word address of TPAL bit */[m
[32m+[m[32m#define CR_OFFSET         (BKP_OFFSET + 0x30)[m
[32m+[m[32m#define TPAL_BitNumber    0x01[m
[32m+[m[32m#define CR_TPAL_BB        (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPAL_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of TPE bit */[m
[32m+[m[32m#define TPE_BitNumber     0x00[m
[32m+[m[32m#define CR_TPE_BB         (PERIPH_BB_BASE + (CR_OFFSET * 32) + (TPE_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- CSR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of TPIE bit */[m
[32m+[m[32m#define CSR_OFFSET        (BKP_OFFSET + 0x34)[m
[32m+[m[32m#define TPIE_BitNumber    0x02[m
[32m+[m[32m#define CSR_TPIE_BB       (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TPIE_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of TIF bit */[m
[32m+[m[32m#define TIF_BitNumber     0x09[m
[32m+[m[32m#define CSR_TIF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TIF_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of TEF bit */[m
[32m+[m[32m#define TEF_BitNumber     0x08[m
[32m+[m[32m#define CSR_TEF_BB        (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEF_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* ---------------------- BKP registers bit mask ------------------------ */[m
[32m+[m
[32m+[m[32m/* RTCCR register bit mask */[m
[32m+[m[32m#define RTCCR_CAL_MASK    ((uint16_t)0xFF80)[m
[32m+[m[32m#define RTCCR_MASK        ((uint16_t)0xFC7F)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup BKP_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the BKP peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  RCC_BackupResetCmd(ENABLE);[m
[32m+[m[32m  RCC_BackupResetCmd(DISABLE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the Tamper Pin active level.[m
[32m+[m[32m  * @param  BKP_TamperPinLevel: specifies the Tamper Pin active level.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg BKP_TamperPinLevel_High: Tamper pin active on high level[m
[32m+[m[32m  *     @arg BKP_TamperPinLevel_Low: Tamper pin active on low level[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_TamperPinLevelConfig(uint16_t BKP_TamperPinLevel)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_BKP_TAMPER_PIN_LEVEL(BKP_TamperPinLevel));[m
[32m+[m[32m  *(__IO uint32_t *) CR_TPAL_BB = BKP_TamperPinLevel;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Tamper Pin activation.[m
[32m+[m[32m  * @param  NewState: new state of the Tamper Pin activation.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_TamperPinCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CR_TPE_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Tamper Pin Interrupt.[m
[32m+[m[32m  * @param  NewState: new state of the Tamper Pin Interrupt.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_ITConfig(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CSR_TPIE_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Select the RTC output source to output on the Tamper pin.[m
[32m+[m[32m  * @param  BKP_RTCOutputSource: specifies the RTC output source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg BKP_RTCOutputSource_None: no RTC output on the Tamper pin.[m
[32m+[m[32m  *     @arg BKP_RTCOutputSource_CalibClock: output the RTC clock with frequency[m
[32m+[m[32m  *                                          divided by 64 on the Tamper pin.[m
[32m+[m[32m  *     @arg BKP_RTCOutputSource_Alarm: output the RTC Alarm pulse signal on[m
[32m+[m[32m  *                                     the Tamper pin.[m
[32m+[m[32m  *     @arg BKP_RTCOutputSource_Second: output the RTC Second pulse signal on[m
[32m+[m[32m  *                                      the Tamper pin.[m[41m  [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_RTCOutputConfig(uint16_t BKP_RTCOutputSource)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_BKP_RTC_OUTPUT_SOURCE(BKP_RTCOutputSource));[m
[32m+[m[32m  tmpreg = BKP->RTCCR;[m
[32m+[m[32m  /* Clear CCO, ASOE and ASOS bits */[m
[32m+[m[32m  tmpreg &= RTCCR_MASK;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set CCO, ASOE and ASOS bits according to BKP_RTCOutputSource value */[m
[32m+[m[32m  tmpreg |= BKP_RTCOutputSource;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  BKP->RTCCR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets RTC Clock Calibration value.[m
[32m+[m[32m  * @param  CalibrationValue: specifies the RTC Clock Calibration value.[m
[32m+[m[32m  *   This parameter must be a number between 0 and 0x7F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_SetRTCCalibrationValue(uint8_t CalibrationValue)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_BKP_CALIBRATION_VALUE(CalibrationValue));[m
[32m+[m[32m  tmpreg = BKP->RTCCR;[m
[32m+[m[32m  /* Clear CAL[6:0] bits */[m
[32m+[m[32m  tmpreg &= RTCCR_CAL_MASK;[m
[32m+[m[32m  /* Set CAL[6:0] bits according to CalibrationValue value */[m
[32m+[m[32m  tmpreg |= CalibrationValue;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  BKP->RTCCR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Writes user data to the specified Data Backup Register.[m
[32m+[m[32m  * @param  BKP_DR: specifies the Data Backup Register.[m
[32m+[m[32m  *   This parameter can be BKP_DRx where x:[1, 42][m
[32m+[m[32m  * @param  Data: data to write[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_BKP_DR(BKP_DR));[m
[32m+[m
[32m+[m[32m  tmp = (uint32_t)BKP_BASE;[m[41m [m
[32m+[m[32m  tmp += BKP_DR;[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) tmp = Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reads data from the specified Data Backup Register.[m
[32m+[m[32m  * @param  BKP_DR: specifies the Data Backup Register.[m
[32m+[m[32m  *   This parameter can be BKP_DRx where x:[1, 42][m
[32m+[m[32m  * @retval The content of the specified Data Backup Register[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_BKP_DR(BKP_DR));[m
[32m+[m
[32m+[m[32m  tmp = (uint32_t)BKP_BASE;[m[41m [m
[32m+[m[32m  tmp += BKP_DR;[m
[32m+[m
[32m+[m[32m  return (*(__IO uint16_t *) tmp);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the Tamper Pin Event flag is set or not.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The new state of the Tamper Pin Event flag (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus BKP_GetFlagStatus(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (FlagStatus)(*(__IO uint32_t *) CSR_TEF_BB);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears Tamper Pin Event pending flag.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_ClearFlag(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set CTE bit to clear Tamper Pin Event flag */[m
[32m+[m[32m  BKP->CSR |= BKP_CSR_CTE;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the Tamper Pin Interrupt has occurred or not.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The new state of the Tamper Pin Interrupt (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus BKP_GetITStatus(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (ITStatus)(*(__IO uint32_t *) CSR_TIF_BB);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears Tamper Pin Interrupt pending bit.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BKP_ClearITPendingBit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set CTI bit to clear Tamper Pin Interrupt pending bit */[m
[32m+[m[32m  BKP->CSR |= BKP_CSR_CTI;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c[m
[1mnew file mode 100644[m
[1mindex 0000000..ec8e049[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_can.c[m
[36m@@ -0,0 +1,1415 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_can.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the CAN firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_can.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN[m[41m [m
[32m+[m[32m  * @brief CAN driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* CAN Master Control Register bits */[m
[32m+[m
[32m+[m[32m#define MCR_DBF      ((uint32_t)0x00010000) /* software master reset */[m
[32m+[m
[32m+[m[32m/* CAN Mailbox Transmit Request */[m
[32m+[m[32m#define TMIDxR_TXRQ  ((uint32_t)0x00000001) /* Transmit mailbox request */[m
[32m+[m
[32m+[m[32m/* CAN Filter Master Register bits */[m
[32m+[m[32m#define FMR_FINIT    ((uint32_t)0x00000001) /* Filter init mode */[m
[32m+[m
[32m+[m[32m/* Time out for INAK bit */[m
[32m+[m[32m#define INAK_TIMEOUT        ((uint32_t)0x0000FFFF)[m
[32m+[m[32m/* Time out for SLAK bit */[m
[32m+[m[32m#define SLAK_TIMEOUT        ((uint32_t)0x0000FFFF)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/* Flags in TSR register */[m
[32m+[m[32m#define CAN_FLAGS_TSR              ((uint32_t)0x08000000)[m[41m [m
[32m+[m[32m/* Flags in RF1R register */[m
[32m+[m[32m#define CAN_FLAGS_RF1R             ((uint32_t)0x04000000)[m[41m [m
[32m+[m[32m/* Flags in RF0R register */[m
[32m+[m[32m#define CAN_FLAGS_RF0R             ((uint32_t)0x02000000)[m[41m [m
[32m+[m[32m/* Flags in MSR register */[m
[32m+[m[32m#define CAN_FLAGS_MSR              ((uint32_t)0x01000000)[m[41m [m
[32m+[m[32m/* Flags in ESR register */[m
[32m+[m[32m#define CAN_FLAGS_ESR              ((uint32_t)0x00F00000)[m[41m [m
[32m+[m
[32m+[m[32m/* Mailboxes definition */[m
[32m+[m[32m#define CAN_TXMAILBOX_0                   ((uint8_t)0x00)[m
[32m+[m[32m#define CAN_TXMAILBOX_1                   ((uint8_t)0x01)[m
[32m+[m[32m#define CAN_TXMAILBOX_2                   ((uint8_t)0x02)[m[41m [m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m#define CAN_MODE_MASK              ((uint32_t) 0x00000003)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mstatic ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CAN_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the CAN peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  CANx: where x can be 1 or 2 to select the CAN peripheral.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_DeInit(CAN_TypeDef* CANx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[41m [m
[32m+[m[32m  if (CANx == CAN1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable CAN1 reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);[m
[32m+[m[32m    /* Release CAN1 from reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m[41m  [m
[32m+[m[32m    /* Enable CAN2 reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);[m
[32m+[m[32m    /* Release CAN2 from reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the CAN peripheral according to the specified[m
[32m+[m[32m  *         parameters in the CAN_InitStruct.[m
[32m+[m[32m  * @param  CANx:           where x can be 1 or 2 to to select the CAN[m[41m [m
[32m+[m[32m  *                         peripheral.[m
[32m+[m[32m  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that[m
[32m+[m[32m  *                         contains the configuration information for the[m[41m [m
[32m+[m[32m  *                         CAN peripheral.[m
[32m+[m[32m  * @retval Constant indicates initialization succeed which will be[m[41m [m
[32m+[m[32m  *         CAN_InitStatus_Failed or CAN_InitStatus_Success.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t InitStatus = CAN_InitStatus_Failed;[m
[32m+[m[32m  uint32_t wait_ack = 0x00000000;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));[m
[32m+[m[32m  assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));[m
[32m+[m[32m  assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));[m
[32m+[m[32m  assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));[m
[32m+[m[32m  assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));[m
[32m+[m[32m  assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));[m
[32m+[m
[32m+[m[32m  /* Exit from sleep mode */[m
[32m+[m[32m  CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);[m
[32m+[m
[32m+[m[32m  /* Request initialisation */[m
[32m+[m[32m  CANx->MCR |= CAN_MCR_INRQ ;[m
[32m+[m
[32m+[m[32m  /* Wait the acknowledge */[m
[32m+[m[32m  while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))[m
[32m+[m[32m  {[m
[32m+[m[32m    wait_ack++;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Check acknowledge */[m
[32m+[m[32m  if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)[m
[32m+[m[32m  {[m
[32m+[m[32m    InitStatus = CAN_InitStatus_Failed;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the time triggered communication mode */[m
[32m+[m[32m    if (CAN_InitStruct->CAN_TTCM == ENABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR |= CAN_MCR_TTCM;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Set the automatic bus-off management */[m
[32m+[m[32m    if (CAN_InitStruct->CAN_ABOM == ENABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR |= CAN_MCR_ABOM;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Set the automatic wake-up mode */[m
[32m+[m[32m    if (CAN_InitStruct->CAN_AWUM == ENABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR |= CAN_MCR_AWUM;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Set the no automatic retransmission */[m
[32m+[m[32m    if (CAN_InitStruct->CAN_NART == ENABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR |= CAN_MCR_NART;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR &= ~(uint32_t)CAN_MCR_NART;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Set the receive FIFO locked mode */[m
[32m+[m[32m    if (CAN_InitStruct->CAN_RFLM == ENABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR |= CAN_MCR_RFLM;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Set the transmit FIFO priority */[m
[32m+[m[32m    if (CAN_InitStruct->CAN_TXFP == ENABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR |= CAN_MCR_TXFP;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Set the bit timing register */[m
[32m+[m[32m    CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \[m
[32m+[m[32m                ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \[m
[32m+[m[32m                ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \[m
[32m+[m[32m                ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \[m
[32m+[m[32m               ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);[m
[32m+[m
[32m+[m[32m    /* Request leave initialisation */[m
[32m+[m[32m    CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;[m
[32m+[m
[32m+[m[32m   /* Wait the acknowledge */[m
[32m+[m[32m   wait_ack = 0;[m
[32m+[m
[32m+[m[32m   while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))[m
[32m+[m[32m   {[m
[32m+[m[32m     wait_ack++;[m
[32m+[m[32m   }[m
[32m+[m
[32m+[m[32m    /* ...and check acknowledged */[m
[32m+[m[32m    if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)[m
[32m+[m[32m    {[m
[32m+[m[32m      InitStatus = CAN_InitStatus_Failed;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      InitStatus = CAN_InitStatus_Success ;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* At this step, return the status of initialization */[m
[32m+[m[32m  return InitStatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the CAN peripheral according to the specified[m
[32m+[m[32m  *         parameters in the CAN_FilterInitStruct.[m
[32m+[m[32m  * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef[m
[32m+[m[32m  *                               structure that contains the configuration[m[41m [m
[32m+[m[32m  *                               information.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t filter_number_bit_pos = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));[m
[32m+[m[32m  assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));[m
[32m+[m[32m  assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));[m
[32m+[m[32m  assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));[m
[32m+[m
[32m+[m[32m  filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;[m
[32m+[m
[32m+[m[32m  /* Initialisation mode for the filter */[m
[32m+[m[32m  CAN1->FMR |= FMR_FINIT;[m
[32m+[m
[32m+[m[32m  /* Filter Deactivation */[m
[32m+[m[32m  CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;[m
[32m+[m
[32m+[m[32m  /* Filter Scale */[m
[32m+[m[32m  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* 16-bit scale for the filter */[m
[32m+[m[32m    CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;[m
[32m+[m
[32m+[m[32m    /* First 16-bit identifier and First 16-bit mask */[m
[32m+[m[32m    /* Or First 16-bit identifier and Second 16-bit identifier */[m
[32m+[m[32m    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 =[m[41m [m
[32m+[m[32m    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |[m
[32m+[m[32m        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);[m
[32m+[m
[32m+[m[32m    /* Second 16-bit identifier and Second 16-bit mask */[m
[32m+[m[32m    /* Or Third 16-bit identifier and Fourth 16-bit identifier */[m
[32m+[m[32m    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 =[m[41m [m
[32m+[m[32m    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |[m
[32m+[m[32m        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* 32-bit scale for the filter */[m
[32m+[m[32m    CAN1->FS1R |= filter_number_bit_pos;[m
[32m+[m[32m    /* 32-bit identifier or First 32-bit identifier */[m
[32m+[m[32m    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 =[m[41m [m
[32m+[m[32m    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |[m
[32m+[m[32m        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);[m
[32m+[m[32m    /* 32-bit mask or Second 32-bit identifier */[m
[32m+[m[32m    CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 =[m[41m [m
[32m+[m[32m    ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |[m
[32m+[m[32m        (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Filter Mode */[m
[32m+[m[32m  if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)[m
[32m+[m[32m  {[m
[32m+[m[32m    /*Id/Mask mode for the filter*/[m
[32m+[m[32m    CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */[m
[32m+[m[32m  {[m
[32m+[m[32m    /*Identifier list mode for the filter*/[m
[32m+[m[32m    CAN1->FM1R |= (uint32_t)filter_number_bit_pos;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Filter FIFO assignment */[m
[32m+[m[32m  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* FIFO 0 assignation for the filter */[m
[32m+[m[32m    CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* FIFO 1 assignation for the filter */[m
[32m+[m[32m    CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Filter activation */[m
[32m+[m[32m  if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    CAN1->FA1R |= filter_number_bit_pos;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Leave the initialisation mode for the filter */[m
[32m+[m[32m  CAN1->FMR &= ~FMR_FINIT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each CAN_InitStruct member with its default value.[m
[32m+[m[32m  * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which[m
[32m+[m[32m  *                         will be initialized.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset CAN init structure parameters values */[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the time triggered communication mode */[m
[32m+[m[32m  CAN_InitStruct->CAN_TTCM = DISABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the automatic bus-off management */[m
[32m+[m[32m  CAN_InitStruct->CAN_ABOM = DISABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the automatic wake-up mode */[m
[32m+[m[32m  CAN_InitStruct->CAN_AWUM = DISABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the no automatic retransmission */[m
[32m+[m[32m  CAN_InitStruct->CAN_NART = DISABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the receive FIFO locked mode */[m
[32m+[m[32m  CAN_InitStruct->CAN_RFLM = DISABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the transmit FIFO priority */[m
[32m+[m[32m  CAN_InitStruct->CAN_TXFP = DISABLE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the CAN_Mode member */[m
[32m+[m[32m  CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the CAN_SJW member */[m
[32m+[m[32m  CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the CAN_BS1 member */[m
[32m+[m[32m  CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the CAN_BS2 member */[m
[32m+[m[32m  CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the CAN_Prescaler member */[m
[32m+[m[32m  CAN_InitStruct->CAN_Prescaler = 1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Select the start bank filter for slave CAN.[m
[32m+[m[32m  * @note   This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_SlaveStartBank(uint8_t CAN_BankNumber)[m[41m [m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Enter Initialisation mode for the filter */[m
[32m+[m[32m  CAN1->FMR |= FMR_FINIT;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Select the start slave bank */[m
[32m+[m[32m  CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;[m
[32m+[m[32m  CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Leave Initialisation mode for the filter */[m
[32m+[m[32m  CAN1->FMR &= ~FMR_FINIT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the DBG Freeze for CAN.[m
[32m+[m[32m  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the CAN peripheral. This parameter can[m[41m [m
[32m+[m[32m  *                   be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable Debug Freeze  */[m
[32m+[m[32m    CANx->MCR |= MCR_DBF;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable Debug Freeze */[m
[32m+[m[32m    CANx->MCR &= ~MCR_DBF;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disabes the CAN Time TriggerOperation communication mode.[m
[32m+[m[32m  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  NewState : Mode new state , can be one of @ref FunctionalState.[m
[32m+[m[32m  * @note   when enabled, Time stamp (TIME[15:0]) value is sent in the last[m[41m [m
[32m+[m[32m  *         two data bytes of the 8-byte message: TIME[7:0] in data byte 6[m[41m [m
[32m+[m[32m  *         and TIME[15:8] in data byte 7[m[41m [m
[32m+[m[32m  * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be[m[41m [m
[32m+[m[32m  *         sent over the CAN bus.[m[41m  [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the TTCM mode */[m
[32m+[m[32m    CANx->MCR |= CAN_MCR_TTCM;[m
[32m+[m
[32m+[m[32m    /* Set TGT bits */[m
[32m+[m[32m    CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);[m
[32m+[m[32m    CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);[m
[32m+[m[32m    CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the TTCM mode */[m
[32m+[m[32m    CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);[m
[32m+[m
[32m+[m[32m    /* Reset TGT bits */[m
[32m+[m[32m    CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);[m
[32m+[m[32m    CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);[m
[32m+[m[32m    CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initiates the transmission of a message.[m
[32m+[m[32m  * @param  CANx:      where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  TxMessage: pointer to a structure which contains CAN Id, CAN[m
[32m+[m[32m  *                    DLC and CAN data.[m
[32m+[m[32m  * @retval The number of the mailbox that is used for transmission[m
[32m+[m[32m  *                    or CAN_TxStatus_NoMailBox if there is no empty mailbox.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t transmit_mailbox = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_IDTYPE(TxMessage->IDE));[m
[32m+[m[32m  assert_param(IS_CAN_RTR(TxMessage->RTR));[m
[32m+[m[32m  assert_param(IS_CAN_DLC(TxMessage->DLC));[m
[32m+[m
[32m+[m[32m  /* Select one empty transmit mailbox */[m
[32m+[m[32m  if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)[m
[32m+[m[32m  {[m
[32m+[m[32m    transmit_mailbox = 0;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)[m
[32m+[m[32m  {[m
[32m+[m[32m    transmit_mailbox = 1;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)[m
[32m+[m[32m  {[m
[32m+[m[32m    transmit_mailbox = 2;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    transmit_mailbox = CAN_TxStatus_NoMailBox;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if (transmit_mailbox != CAN_TxStatus_NoMailBox)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set up the Id */[m
[32m+[m[32m    CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;[m
[32m+[m[32m    if (TxMessage->IDE == CAN_Id_Standard)[m
[32m+[m[32m    {[m
[32m+[m[32m      assert_param(IS_CAN_STDID(TxMessage->StdId));[m[41m  [m
[32m+[m[32m      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \[m
[32m+[m[32m                                                  TxMessage->RTR);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      assert_param(IS_CAN_EXTID(TxMessage->ExtId));[m
[32m+[m[32m      CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \[m
[32m+[m[32m                                                  TxMessage->IDE | \[m
[32m+[m[32m                                                  TxMessage->RTR);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    /* Set up the DLC */[m
[32m+[m[32m    TxMessage->DLC &= (uint8_t)0x0000000F;[m
[32m+[m[32m    CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;[m
[32m+[m[32m    CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;[m
[32m+[m
[32m+[m[32m    /* Set up the data field */[m
[32m+[m[32m    CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) |[m[41m [m
[32m+[m[32m                                             ((uint32_t)TxMessage->Data[2] << 16) |[m
[32m+[m[32m                                             ((uint32_t)TxMessage->Data[1] << 8) |[m[41m [m
[32m+[m[32m                                             ((uint32_t)TxMessage->Data[0]));[m
[32m+[m[32m    CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) |[m[41m [m
[32m+[m[32m                                             ((uint32_t)TxMessage->Data[6] << 16) |[m
[32m+[m[32m                                             ((uint32_t)TxMessage->Data[5] << 8) |[m
[32m+[m[32m                                             ((uint32_t)TxMessage->Data[4]));[m
[32m+[m[32m    /* Request transmission */[m
[32m+[m[32m    CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;[m
[32m+[m[32m  }[m
[32m+[m[32m  return transmit_mailbox;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks the transmission of a message.[m
[32m+[m[32m  * @param  CANx:            where x can be 1 or 2 to to select the[m[41m [m
[32m+[m[32m  *                          CAN peripheral.[m
[32m+[m[32m  * @param  TransmitMailbox: the number of the mailbox that is used for[m[41m [m
[32m+[m[32m  *                          transmission.[m
[32m+[m[32m  * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, CAN_TxStatus_Failed[m[41m [m
[32m+[m[32m  *         in an other case.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t state = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));[m
[32m+[m[41m [m
[32m+[m[32m  switch (TransmitMailbox)[m
[32m+[m[32m  {[m
[32m+[m[32m    case (CAN_TXMAILBOX_0):[m[41m [m
[32m+[m[32m      state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);[m
[32m+[m[32m      break;[m
[32m+[m[32m    case (CAN_TXMAILBOX_1):[m[41m [m
[32m+[m[32m      state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);[m
[32m+[m[32m      break;[m
[32m+[m[32m    case (CAN_TXMAILBOX_2):[m[41m [m
[32m+[m[32m      state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);[m
[32m+[m[32m      break;[m
[32m+[m[32m    default:[m
[32m+[m[32m      state = CAN_TxStatus_Failed;[m
[32m+[m[32m      break;[m
[32m+[m[32m  }[m
[32m+[m[32m  switch (state)[m
[32m+[m[32m  {[m
[32m+[m[32m      /* transmit pending  */[m
[32m+[m[32m    case (0x0): state = CAN_TxStatus_Pending;[m
[32m+[m[32m      break;[m
[32m+[m[32m      /* transmit failed  */[m
[32m+[m[32m     case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;[m
[32m+[m[32m      break;[m
[32m+[m[32m     case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;[m
[32m+[m[32m      break;[m
[32m+[m[32m     case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;[m
[32m+[m[32m      break;[m
[32m+[m[32m      /* transmit succeeded  */[m
[32m+[m[32m    case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;[m
[32m+[m[32m      break;[m
[32m+[m[32m    default: state = CAN_TxStatus_Failed;[m
[32m+[m[32m      break;[m
[32m+[m[32m  }[m
[32m+[m[32m  return (uint8_t) state;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Cancels a transmit request.[m
[32m+[m[32m  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.[m[41m [m
[32m+[m[32m  * @param  Mailbox:  Mailbox number.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));[m
[32m+[m[32m  /* abort transmission */[m
[32m+[m[32m  switch (Mailbox)[m
[32m+[m[32m  {[m
[32m+[m[32m    case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;[m
[32m+[m[32m      break;[m
[32m+[m[32m    default:[m
[32m+[m[32m      break;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Receives a message.[m
[32m+[m[32m  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.[m
[32m+[m[32m  * @param  RxMessage:  pointer to a structure receive message which contains[m[41m [m
[32m+[m[32m  *                     CAN Id, CAN DLC, CAN datas and FMI number.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_FIFO(FIFONumber));[m
[32m+[m[32m  /* Get the Id */[m
[32m+[m[32m  RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;[m
[32m+[m[32m  if (RxMessage->IDE == CAN_Id_Standard)[m
[32m+[m[32m  {[m
[32m+[m[32m    RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;[m
[32m+[m[32m  /* Get the DLC */[m
[32m+[m[32m  RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;[m
[32m+[m[32m  /* Get the FMI */[m
[32m+[m[32m  RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);[m
[32m+[m[32m  /* Get the data field */[m
[32m+[m[32m  RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;[m
[32m+[m[32m  RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);[m
[32m+[m[32m  RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);[m
[32m+[m[32m  RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);[m
[32m+[m[32m  RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;[m
[32m+[m[32m  RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);[m
[32m+[m[32m  RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);[m
[32m+[m[32m  RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);[m
[32m+[m[32m  /* Release the FIFO */[m
[32m+[m[32m  /* Release FIFO0 */[m
[32m+[m[32m  if (FIFONumber == CAN_FIFO0)[m
[32m+[m[32m  {[m
[32m+[m[32m    CANx->RF0R |= CAN_RF0R_RFOM0;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Release FIFO1 */[m
[32m+[m[32m  else /* FIFONumber == CAN_FIFO1 */[m
[32m+[m[32m  {[m
[32m+[m[32m    CANx->RF1R |= CAN_RF1R_RFOM1;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Releases the specified FIFO.[m
[32m+[m[32m  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.[m[41m [m
[32m+[m[32m  * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_FIFO(FIFONumber));[m
[32m+[m[32m  /* Release FIFO0 */[m
[32m+[m[32m  if (FIFONumber == CAN_FIFO0)[m
[32m+[m[32m  {[m
[32m+[m[32m    CANx->RF0R |= CAN_RF0R_RFOM0;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Release FIFO1 */[m
[32m+[m[32m  else /* FIFONumber == CAN_FIFO1 */[m
[32m+[m[32m  {[m
[32m+[m[32m    CANx->RF1R |= CAN_RF1R_RFOM1;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the number of pending messages.[m
[32m+[m[32m  * @param  CANx:       where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.[m
[32m+[m[32m  * @retval NbMessage : which is the number of pending message.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t message_pending=0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_FIFO(FIFONumber));[m
[32m+[m[32m  if (FIFONumber == CAN_FIFO0)[m
[32m+[m[32m  {[m
[32m+[m[32m    message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (FIFONumber == CAN_FIFO1)[m
[32m+[m[32m  {[m
[32m+[m[32m    message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    message_pending = 0;[m
[32m+[m[32m  }[m
[32m+[m[32m  return message_pending;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief   Select the CAN Operation mode.[m
[32m+[m[32m  * @param CAN_OperatingMode : CAN Operating Mode. This parameter can be one[m[41m [m
[32m+[m[32m  *                            of @ref CAN_OperatingMode_TypeDef enumeration.[m
[32m+[m[32m  * @retval status of the requested mode which can be[m[41m [m
[32m+[m[32m  *         - CAN_ModeStatus_Failed    CAN failed entering the specific mode[m[41m [m
[32m+[m[32m  *         - CAN_ModeStatus_Success   CAN Succeed entering the specific mode[m[41m [m
[32m+[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t status = CAN_ModeStatus_Failed;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Timeout for INAK or also for SLAK bits*/[m
[32m+[m[32m  uint32_t timeout = INAK_TIMEOUT;[m[41m [m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));[m
[32m+[m
[32m+[m[32m  if (CAN_OperatingMode == CAN_OperatingMode_Initialization)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Request initialisation */[m
[32m+[m[32m    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);[m
[32m+[m
[32m+[m[32m    /* Wait the acknowledge */[m
[32m+[m[32m    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))[m
[32m+[m[32m    {[m
[32m+[m[32m      timeout--;[m
[32m+[m[32m    }[m
[32m+[m[32m    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)[m
[32m+[m[32m    {[m
[32m+[m[32m      status = CAN_ModeStatus_Failed;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      status = CAN_ModeStatus_Success;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Request leave initialisation and sleep mode  and enter Normal mode */[m
[32m+[m[32m    CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));[m
[32m+[m
[32m+[m[32m    /* Wait the acknowledge */[m
[32m+[m[32m    while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))[m
[32m+[m[32m    {[m
[32m+[m[32m      timeout--;[m
[32m+[m[32m    }[m
[32m+[m[32m    if ((CANx->MSR & CAN_MODE_MASK) != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m      status = CAN_ModeStatus_Failed;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      status = CAN_ModeStatus_Success;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Request Sleep mode */[m
[32m+[m[32m    CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);[m
[32m+[m
[32m+[m[32m    /* Wait the acknowledge */[m
[32m+[m[32m    while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))[m
[32m+[m[32m    {[m
[32m+[m[32m      timeout--;[m
[32m+[m[32m    }[m
[32m+[m[32m    if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)[m
[32m+[m[32m    {[m
[32m+[m[32m      status = CAN_ModeStatus_Failed;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      status = CAN_ModeStatus_Success;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    status = CAN_ModeStatus_Failed;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  return  (uint8_t) status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enters the low power mode.[m
[32m+[m[32m  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @retval status: CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed in an[m[41m [m
[32m+[m[32m  *                 other case.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_Sleep(CAN_TypeDef* CANx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t sleepstatus = CAN_Sleep_Failed;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[41m    [m
[32m+[m[32m  /* Request Sleep mode */[m
[32m+[m[32m   CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);[m
[32m+[m[41m   [m
[32m+[m[32m  /* Sleep mode status */[m
[32m+[m[32m  if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Sleep mode not entered */[m
[32m+[m[32m    sleepstatus =  CAN_Sleep_Ok;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* return sleep mode status */[m
[32m+[m[32m   return (uint8_t)sleepstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Wakes the CAN up.[m
[32m+[m[32m  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @retval status:  CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed in an[m[41m [m
[32m+[m[32m  *                  other case.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_WakeUp(CAN_TypeDef* CANx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t wait_slak = SLAK_TIMEOUT;[m
[32m+[m[32m  uint8_t wakeupstatus = CAN_WakeUp_Failed;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[41m    [m
[32m+[m[32m  /* Wake up request */[m
[32m+[m[32m  CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Sleep mode status */[m
[32m+[m[32m  while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))[m
[32m+[m[32m  {[m
[32m+[m[32m   wait_slak--;[m
[32m+[m[32m  }[m
[32m+[m[32m  if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)[m
[32m+[m[32m  {[m
[32m+[m[32m   /* wake up done : Sleep mode exited */[m
[32m+[m[32m    wakeupstatus = CAN_WakeUp_Ok;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* return wakeup status */[m
[32m+[m[32m  return (uint8_t)wakeupstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the CANx's last error code (LEC).[m
[32m+[m[32m  * @param  CANx:          where x can be 1 or 2 to to select the CAN peripheral.[m[41m  [m
[32m+[m[32m  * @retval CAN_ErrorCode: specifies the Error code :[m[41m [m
[32m+[m[32m  *                        - CAN_ERRORCODE_NoErr            No Error[m[41m  [m
[32m+[m[32m  *                        - CAN_ERRORCODE_StuffErr         Stuff Error[m
[32m+[m[32m  *                        - CAN_ERRORCODE_FormErr          Form Error[m
[32m+[m[32m  *                        - CAN_ERRORCODE_ACKErr           Acknowledgment Error[m
[32m+[m[32m  *                        - CAN_ERRORCODE_BitRecessiveErr  Bit Recessive Error[m
[32m+[m[32m  *                        - CAN_ERRORCODE_BitDominantErr   Bit Dominant Error[m
[32m+[m[32m  *                        - CAN_ERRORCODE_CRCErr           CRC Error[m
[32m+[m[32m  *                        - CAN_ERRORCODE_SoftwareSetErr   Software Set Error[m[41m  [m
[32m+[m[32m  */[m
[32m+[m[41m [m
[32m+[m[32muint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t errorcode=0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the error code*/[m
[32m+[m[32m  errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the error code*/[m
[32m+[m[32m  return errorcode;[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the CANx Receive Error Counter (REC).[m
[32m+[m[32m  * @note   In case of an error during reception, this counter is incremented[m[41m [m
[32m+[m[32m  *         by 1 or by 8 depending on the error condition as defined by the CAN[m[41m [m
[32m+[m[32m  *         standard. After every successful reception, the counter is[m[41m [m
[32m+[m[32m  *         decremented by 1 or reset to 120 if its value was higher than 128.[m[41m [m
[32m+[m[32m  *         When the counter value exceeds 127, the CAN controller enters the[m[41m [m
[32m+[m[32m  *         error passive state.[m[41m  [m
[32m+[m[32m  * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.[m[41m  [m
[32m+[m[32m  * @retval CAN Receive Error Counter.[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t counter=0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the Receive Error Counter*/[m
[32m+[m[32m  counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the Receive Error Counter*/[m
[32m+[m[32m  return counter;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).[m
[32m+[m[32m  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.[m[41m  [m
[32m+[m[32m  * @retval LSB of the 9-bit CAN Transmit Error Counter.[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t counter=0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */[m
[32m+[m[32m  counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */[m
[32m+[m[32m  return counter;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified CANx interrupts.[m
[32m+[m[32m  * @param  CANx:   where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.[m
[32m+[m[32m  *                 This parameter can be:[m[41m [m
[32m+[m[32m  *                 - CAN_IT_TME,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_FMP0,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_FF0,[m
[32m+[m[32m  *                 - CAN_IT_FOV0,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_FMP1,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_FF1,[m
[32m+[m[32m  *                 - CAN_IT_FOV1,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_EWG,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_EPV,[m
[32m+[m[32m  *                 - CAN_IT_LEC,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_ERR,[m[41m [m
[32m+[m[32m  *                 - CAN_IT_WKU or[m[41m [m
[32m+[m[32m  *                 - CAN_IT_SLK.[m
[32m+[m[32m  * @param  NewState: new state of the CAN interrupts.[m
[32m+[m[32m  *                   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_IT(CAN_IT));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected CANx interrupt */[m
[32m+[m[32m    CANx->IER |= CAN_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected CANx interrupt */[m
[32m+[m[32m    CANx->IER &= ~CAN_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified CAN flag is set or not.[m
[32m+[m[32m  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  CAN_FLAG: specifies the flag to check.[m
[32m+[m[32m  *                   This parameter can be one of the following flags:[m[41m [m
[32m+[m[32m  *                  - CAN_FLAG_EWG[m
[32m+[m[32m  *                  - CAN_FLAG_EPV[m[41m [m
[32m+[m[32m  *                  - CAN_FLAG_BOF[m
[32m+[m[32m  *                  - CAN_FLAG_RQCP0[m
[32m+[m[32m  *                  - CAN_FLAG_RQCP1[m
[32m+[m[32m  *                  - CAN_FLAG_RQCP2[m
[32m+[m[32m  *                  - CAN_FLAG_FMP1[m[41m   [m
[32m+[m[32m  *                  - CAN_FLAG_FF1[m[41m       [m
[32m+[m[32m  *                  - CAN_FLAG_FOV1[m[41m   [m
[32m+[m[32m  *                  - CAN_FLAG_FMP0[m[41m   [m
[32m+[m[32m  *                  - CAN_FLAG_FF0[m[41m       [m
[32m+[m[32m  *                  - CAN_FLAG_FOV0[m[41m   [m
[32m+[m[32m  *                  - CAN_FLAG_WKU[m[41m [m
[32m+[m[32m  *                  - CAN_FLAG_SLAK[m[41m  [m
[32m+[m[32m  *                  - CAN_FLAG_LEC[m[41m       [m
[32m+[m[32m  * @retval The new state of CAN_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_GET_FLAG(CAN_FLAG));[m
[32m+[m[41m  [m
[32m+[m
[32m+[m[32m  if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Check the status of the specified CAN flag */[m
[32m+[m[32m    if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is set */[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is reset */[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Check the status of the specified CAN flag */[m
[32m+[m[32m    if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is set */[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is reset */[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Check the status of the specified CAN flag */[m
[32m+[m[32m    if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is set */[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is reset */[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Check the status of the specified CAN flag */[m
[32m+[m[32m    if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is set */[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is reset */[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Check the status of the specified CAN flag */[m
[32m+[m[32m    if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is set */[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* CAN_FLAG is reset */[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the CAN_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the CAN's pending flags.[m
[32m+[m[32m  * @param  CANx:     where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  CAN_FLAG: specifies the flag to clear.[m
[32m+[m[32m  *                   This parameter can be one of the following flags:[m[41m [m
[32m+[m[32m  *                    - CAN_FLAG_RQCP0[m
[32m+[m[32m  *                    - CAN_FLAG_RQCP1[m
[32m+[m[32m  *                    - CAN_FLAG_RQCP2[m
[32m+[m[32m  *                    - CAN_FLAG_FF1[m[41m       [m
[32m+[m[32m  *                    - CAN_FLAG_FOV1[m[41m   [m
[32m+[m[32m  *                    - CAN_FLAG_FF0[m[41m       [m
[32m+[m[32m  *                    - CAN_FLAG_FOV0[m[41m   [m
[32m+[m[32m  *                    - CAN_FLAG_WKU[m[41m   [m
[32m+[m[32m  *                    - CAN_FLAG_SLAK[m[41m    [m
[32m+[m[32m  *                    - CAN_FLAG_LEC[m[41m       [m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t flagtmp=0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));[m
[32m+[m[41m  [m
[32m+[m[32m  if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the selected CAN flags */[m
[32m+[m[32m    CANx->ESR = (uint32_t)RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* MSR or TSR or RF0R or RF1R */[m
[32m+[m[32m  {[m
[32m+[m[32m    flagtmp = CAN_FLAG & 0x000FFFFF;[m
[32m+[m
[32m+[m[32m    if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Receive Flags */[m
[32m+[m[32m      CANx->RF0R = (uint32_t)(flagtmp);[m
[32m+[m[32m    }[m
[32m+[m[32m    else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Receive Flags */[m
[32m+[m[32m      CANx->RF1R = (uint32_t)(flagtmp);[m
[32m+[m[32m    }[m
[32m+[m[32m    else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Transmit Flags */[m
[32m+[m[32m      CANx->TSR = (uint32_t)(flagtmp);[m
[32m+[m[32m    }[m
[32m+[m[32m    else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Operating mode Flags */[m
[32m+[m[32m      CANx->MSR = (uint32_t)(flagtmp);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified CANx interrupt has occurred or not.[m
[32m+[m[32m  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  CAN_IT:  specifies the CAN interrupt source to check.[m
[32m+[m[32m  *                  This parameter can be one of the following flags:[m[41m [m
[32m+[m[32m  *                 -  CAN_IT_TME[m[41m               [m
[32m+[m[32m  *                 -  CAN_IT_FMP0[m[41m              [m
[32m+[m[32m  *                 -  CAN_IT_FF0[m[41m               [m
[32m+[m[32m  *                 -  CAN_IT_FOV0[m[41m              [m
[32m+[m[32m  *                 -  CAN_IT_FMP1[m[41m              [m
[32m+[m[32m  *                 -  CAN_IT_FF1[m[41m               [m
[32m+[m[32m  *                 -  CAN_IT_FOV1[m[41m              [m
[32m+[m[32m  *                 -  CAN_IT_WKU[m[41m  [m
[32m+[m[32m  *                 -  CAN_IT_SLK[m[41m  [m
[32m+[m[32m  *                 -  CAN_IT_EWG[m[41m    [m
[32m+[m[32m  *                 -  CAN_IT_EPV[m[41m    [m
[32m+[m[32m  *                 -  CAN_IT_BOF[m[41m    [m
[32m+[m[32m  *                 -  CAN_IT_LEC[m[41m    [m
[32m+[m[32m  *                 -  CAN_IT_ERR[m[41m [m
[32m+[m[32m  * @retval The current state of CAN_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus itstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_IT(CAN_IT));[m
[32m+[m[41m  [m
[32m+[m[32m  /* check the enable interrupt bit */[m
[32m+[m[32m if((CANx->IER & CAN_IT) != RESET)[m
[32m+[m[32m {[m
[32m+[m[32m   /* in case the Interrupt is enabled, .... */[m
[32m+[m[32m    switch (CAN_IT)[m
[32m+[m[32m    {[m
[32m+[m[32m      case CAN_IT_TME:[m
[32m+[m[32m               /* Check CAN_TSR_RQCPx bits */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FMP0:[m
[32m+[m[32m               /* Check CAN_RF0R_FMP0 bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FF0:[m
[32m+[m[32m               /* Check CAN_RF0R_FULL0 bit */[m
[32m+[m[32m               itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FOV0:[m
[32m+[m[32m               /* Check CAN_RF0R_FOVR0 bit */[m
[32m+[m[32m               itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FMP1:[m
[32m+[m[32m               /* Check CAN_RF1R_FMP1 bit */[m
[32m+[m[32m               itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FF1:[m
[32m+[m[32m               /* Check CAN_RF1R_FULL1 bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FOV1:[m
[32m+[m[32m               /* Check CAN_RF1R_FOVR1 bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_WKU:[m
[32m+[m[32m               /* Check CAN_MSR_WKUI bit */[m
[32m+[m[32m               itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_SLK:[m
[32m+[m[32m               /* Check CAN_MSR_SLAKI bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_EWG:[m
[32m+[m[32m               /* Check CAN_ESR_EWGF bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_EPV:[m
[32m+[m[32m               /* Check CAN_ESR_EPVF bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_BOF:[m
[32m+[m[32m               /* Check CAN_ESR_BOFF bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_LEC:[m
[32m+[m[32m               /* Check CAN_ESR_LEC bit */[m
[32m+[m	[32m             itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_ERR:[m
[32m+[m[32m               /* Check CAN_MSR_ERRI bit */[m[41m [m
[32m+[m[32m               itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI);[m[41m [m
[32m+[m	[32m      break;[m
[32m+[m[32m      default :[m
[32m+[m[32m               /* in case of error, return RESET */[m
[32m+[m[32m              itstatus = RESET;[m
[32m+[m[32m              break;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m   /* in case the Interrupt is not enabled, return RESET */[m
[32m+[m[32m    itstatus  = RESET;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the CAN_IT status */[m
[32m+[m[32m  return  itstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the CANx's interrupt pending bits.[m
[32m+[m[32m  * @param  CANx:    where x can be 1 or 2 to to select the CAN peripheral.[m
[32m+[m[32m  * @param  CAN_IT: specifies the interrupt pending bit to clear.[m
[32m+[m[32m  *                  -  CAN_IT_TME[m[41m                     [m
[32m+[m[32m  *                  -  CAN_IT_FF0[m[41m               [m
[32m+[m[32m  *                  -  CAN_IT_FOV0[m[41m                     [m
[32m+[m[32m  *                  -  CAN_IT_FF1[m[41m               [m
[32m+[m[32m  *                  -  CAN_IT_FOV1[m[41m              [m
[32m+[m[32m  *                  -  CAN_IT_WKU[m[41m  [m
[32m+[m[32m  *                  -  CAN_IT_SLK[m[41m  [m
[32m+[m[32m  *                  -  CAN_IT_EWG[m[41m    [m
[32m+[m[32m  *                  -  CAN_IT_EPV[m[41m    [m
[32m+[m[32m  *                  -  CAN_IT_BOF[m[41m    [m
[32m+[m[32m  *                  -  CAN_IT_LEC[m[41m    [m
[32m+[m[32m  *                  -  CAN_IT_ERR[m[41m [m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CAN_ALL_PERIPH(CANx));[m
[32m+[m[32m  assert_param(IS_CAN_CLEAR_IT(CAN_IT));[m
[32m+[m
[32m+[m[32m  switch (CAN_IT)[m
[32m+[m[32m  {[m
[32m+[m[32m      case CAN_IT_TME:[m
[32m+[m[32m              /* Clear CAN_TSR_RQCPx (rc_w1)*/[m
[32m+[m	[32m      CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FF0:[m
[32m+[m[32m              /* Clear CAN_RF0R_FULL0 (rc_w1)*/[m
[32m+[m	[32m      CANx->RF0R = CAN_RF0R_FULL0;[m[41m [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FOV0:[m
[32m+[m[32m              /* Clear CAN_RF0R_FOVR0 (rc_w1)*/[m
[32m+[m	[32m      CANx->RF0R = CAN_RF0R_FOVR0;[m[41m [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FF1:[m
[32m+[m[32m              /* Clear CAN_RF1R_FULL1 (rc_w1)*/[m
[32m+[m	[32m      CANx->RF1R = CAN_RF1R_FULL1;[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_FOV1:[m
[32m+[m[32m              /* Clear CAN_RF1R_FOVR1 (rc_w1)*/[m
[32m+[m	[32m      CANx->RF1R = CAN_RF1R_FOVR1;[m[41m [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_WKU:[m
[32m+[m[32m              /* Clear CAN_MSR_WKUI (rc_w1)*/[m
[32m+[m	[32m      CANx->MSR = CAN_MSR_WKUI;[m[41m  [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_SLK:[m
[32m+[m[32m              /* Clear CAN_MSR_SLAKI (rc_w1)*/[m[41m [m
[32m+[m	[32m      CANx->MSR = CAN_MSR_SLAKI;[m[41m   [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_EWG:[m
[32m+[m[32m              /* Clear CAN_MSR_ERRI (rc_w1) */[m
[32m+[m	[32m      CANx->MSR = CAN_MSR_ERRI;[m
[32m+[m[32m              /* Note : the corresponding Flag is cleared by hardware depending[m[41m [m
[32m+[m[32m                        of the CAN Bus status*/[m[41m [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_EPV:[m
[32m+[m[32m              /* Clear CAN_MSR_ERRI (rc_w1) */[m
[32m+[m	[32m      CANx->MSR = CAN_MSR_ERRI;[m[41m [m
[32m+[m[32m              /* Note : the corresponding Flag is cleared by hardware depending[m[41m [m
[32m+[m[32m                        of the CAN Bus status*/[m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_BOF:[m
[32m+[m[32m              /* Clear CAN_MSR_ERRI (rc_w1) */[m[41m [m
[32m+[m	[32m      CANx->MSR = CAN_MSR_ERRI;[m[41m [m
[32m+[m[32m              /* Note : the corresponding Flag is cleared by hardware depending[m[41m [m
[32m+[m[32m                        of the CAN Bus status*/[m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_LEC:[m
[32m+[m[32m              /*  Clear LEC bits */[m
[32m+[m	[32m      CANx->ESR = RESET;[m[41m [m
[32m+[m[32m              /* Clear CAN_MSR_ERRI (rc_w1) */[m
[32m+[m	[32m      CANx->MSR = CAN_MSR_ERRI;[m[41m [m
[32m+[m	[32m      break;[m
[32m+[m[32m      case CAN_IT_ERR:[m
[32m+[m[32m              /*Clear LEC bits */[m
[32m+[m	[32m      CANx->ESR = RESET;[m[41m [m
[32m+[m[32m              /* Clear CAN_MSR_ERRI (rc_w1) */[m
[32m+[m	[32m      CANx->MSR = CAN_MSR_ERRI;[m[41m [m
[32m+[m	[32m      /* Note : BOFF, EPVF and EWGF Flags are cleared by hardware depending[m[41m [m
[32m+[m[32m                  of the CAN Bus status*/[m
[32m+[m	[32m      break;[m
[32m+[m[32m      default :[m
[32m+[m	[32m      break;[m
[32m+[m[32m   }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the CAN interrupt has occurred or not.[m
[32m+[m[32m  * @param  CAN_Reg: specifies the CAN interrupt register to check.[m
[32m+[m[32m  * @param  It_Bit:  specifies the interrupt source bit to check.[m
[32m+[m[32m  * @retval The new state of the CAN Interrupt (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mstatic ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus pendingbitstatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  if ((CAN_Reg & It_Bit) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CAN_IT is set */[m
[32m+[m[32m    pendingbitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CAN_IT is reset */[m
[32m+[m[32m    pendingbitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return pendingbitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c[m
[1mnew file mode 100644[m
[1mindex 0000000..4dc615f[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_cec.c[m
[36m@@ -0,0 +1,433 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_cec.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the CEC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_cec.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CEC[m[41m [m
[32m+[m[32m  * @brief CEC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/* ------------ CEC registers bit address in the alias region ----------- */[m
[32m+[m[32m#define CEC_OFFSET                (CEC_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* --- CFGR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of PE bit */[m
[32m+[m[32m#define CFGR_OFFSET                 (CEC_OFFSET + 0x00)[m
[32m+[m[32m#define PE_BitNumber                0x00[m
[32m+[m[32m#define CFGR_PE_BB                  (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (PE_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of IE bit */[m
[32m+[m[32m#define IE_BitNumber                0x01[m
[32m+[m[32m#define CFGR_IE_BB                  (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (IE_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- CSR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of TSOM bit */[m
[32m+[m[32m#define CSR_OFFSET                  (CEC_OFFSET + 0x10)[m
[32m+[m[32m#define TSOM_BitNumber              0x00[m
[32m+[m[32m#define CSR_TSOM_BB                 (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TSOM_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of TEOM bit */[m
[32m+[m[32m#define TEOM_BitNumber              0x01[m
[32m+[m[32m#define CSR_TEOM_BB                 (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (TEOM_BitNumber * 4))[m
[32m+[m[41m  [m
[32m+[m[32m#define CFGR_CLEAR_Mask            (uint8_t)(0xF3)        /* CFGR register Mask */[m
[32m+[m[32m#define FLAG_Mask                  ((uint32_t)0x00FFFFFF) /* CEC FLAG mask */[m
[32m+[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup CEC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the CEC peripheral registers to their default reset[m[41m [m
[32m+[m[32m  *         values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Enable CEC reset state */[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);[m[41m  [m
[32m+[m[32m  /* Release CEC from reset state */[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE);[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the CEC peripheral according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the CEC_InitStruct.[m
[32m+[m[32m  * @param  CEC_InitStruct: pointer to an CEC_InitTypeDef structure that[m
[32m+[m[32m  *         contains the configuration information for the specified[m
[32m+[m[32m  *         CEC peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_Init(CEC_InitTypeDef* CEC_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0;[m
[32m+[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode));[m[41m [m
[32m+[m[32m  assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));[m
[32m+[m[41m     [m
[32m+[m[32m  /*---------------------------- CEC CFGR Configuration -----------------*/[m
[32m+[m[32m  /* Get the CEC CFGR value */[m
[32m+[m[32m  tmpreg = CEC->CFGR;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear BTEM and BPEM bits */[m
[32m+[m[32m  tmpreg &= CFGR_CLEAR_Mask;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Configure CEC: Bit Timing Error and Bit Period Error */[m
[32m+[m[32m  tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);[m
[32m+[m
[32m+[m[32m  /* Write to CEC CFGR  register*/[m
[32m+[m[32m  CEC->CFGR = tmpreg;[m
[32m+[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified CEC peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the CEC peripheral.[m[41m [m
[32m+[m[32m  *     This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_Cmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;[m
[32m+[m
[32m+[m[32m  if(NewState == DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Wait until the PE bit is cleared by hardware (Idle Line detected) */[m
[32m+[m[32m    while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m    }[m[41m  [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the CEC interrupt.[m
[32m+[m[32m  * @param  NewState: new state of the CEC interrupt.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_ITConfig(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Defines the Own Address of the CEC device.[m
[32m+[m[32m  * @param  CEC_OwnAddress: The CEC own address[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));[m
[32m+[m
[32m+[m[32m  /* Set the CEC own address */[m
[32m+[m[32m  CEC->OAR = CEC_OwnAddress;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the CEC prescaler value.[m
[32m+[m[32m  * @param  CEC_Prescaler: CEC prescaler new value[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_SetPrescaler(uint16_t CEC_Prescaler)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CEC_PRESCALER(CEC_Prescaler));[m
[32m+[m
[32m+[m[32m  /* Set the  Prescaler value*/[m
[32m+[m[32m  CEC->PRES = CEC_Prescaler;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmits single data through the CEC peripheral.[m
[32m+[m[32m  * @param  Data: the data to transmit.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_SendDataByte(uint8_t Data)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  /* Transmit Data */[m
[32m+[m[32m  CEC->TXD = Data ;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the most recent received data by the CEC peripheral.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The received data.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CEC_ReceiveDataByte(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Receive Data */[m
[32m+[m[32m  return (uint8_t)(CEC->RXD);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Starts a new message.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_StartOfMessage(void)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  /* Starts of new message */[m
[32m+[m[32m  *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmits message with or without an EOM bit.[m
[32m+[m[32m  * @param  NewState: new state of the CEC Tx End Of Message.[m[41m [m
[32m+[m[32m  *     This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_EndOfMessageCmd(FunctionalState NewState)[m
[32m+[m[32m{[m[41m   [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  /* The data byte will be transmitted with or without an EOM bit*/[m
[32m+[m[32m  *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the CEC flag status[m
[32m+[m[32m  * @param  CEC_FLAG: specifies the CEC flag to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg CEC_FLAG_BTE: Bit Timing Error[m
[32m+[m[32m  *     @arg CEC_FLAG_BPE: Bit Period Error[m
[32m+[m[32m  *     @arg CEC_FLAG_RBTFE: Rx Block Transfer Finished Error[m
[32m+[m[32m  *     @arg CEC_FLAG_SBE: Start Bit Error[m
[32m+[m[32m  *     @arg CEC_FLAG_ACKE: Block Acknowledge Error[m
[32m+[m[32m  *     @arg CEC_FLAG_LINE: Line Error[m
[32m+[m[32m  *     @arg CEC_FLAG_TBTFE: Tx Block Transfer Finished Error[m
[32m+[m[32m  *     @arg CEC_FLAG_TEOM: Tx End Of Message[m[41m [m
[32m+[m[32m  *     @arg CEC_FLAG_TERR: Tx Error[m
[32m+[m[32m  *     @arg CEC_FLAG_TBTRF: Tx Byte Transfer Request or Block Transfer Finished[m
[32m+[m[32m  *     @arg CEC_FLAG_RSOM: Rx Start Of Message[m
[32m+[m[32m  *     @arg CEC_FLAG_REOM: Rx End Of Message[m
[32m+[m[32m  *     @arg CEC_FLAG_RERR: Rx Error[m
[32m+[m[32m  *     @arg CEC_FLAG_RBTF: Rx Byte/Block Transfer Finished[m
[32m+[m[32m  * @retval The new state of CEC_FLAG (SET or RESET)[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG)[m[41m [m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t cecreg = 0, cecbase = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CEC_GET_FLAG(CEC_FLAG));[m
[32m+[m[41m [m
[32m+[m[32m  /* Get the CEC peripheral base address */[m
[32m+[m[32m  cecbase = (uint32_t)(CEC_BASE);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Read flag register index */[m
[32m+[m[32m  cecreg = CEC_FLAG >> 28;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get bit[23:0] of the flag */[m
[32m+[m[32m  CEC_FLAG &= FLAG_Mask;[m
[32m+[m[41m  [m
[32m+[m[32m  if(cecreg != 0)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Flag in CEC ESR Register */[m
[32m+[m[32m    CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Get the CEC ESR register address */[m
[32m+[m[32m    cecbase += 0xC;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the CEC CSR register address */[m
[32m+[m[32m    cecbase += 0x10;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CEC_FLAG is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CEC_FLAG is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the CEC_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the CEC's pending flags.[m
[32m+[m[32m  * @param  CEC_FLAG: specifies the flag to clear.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg CEC_FLAG_TERR: Tx Error[m
[32m+[m[32m  *     @arg CEC_FLAG_TBTRF: Tx Byte Transfer Request or Block Transfer Finished[m
[32m+[m[32m  *     @arg CEC_FLAG_RSOM: Rx Start Of Message[m
[32m+[m[32m  *     @arg CEC_FLAG_REOM: Rx End Of Message[m
[32m+[m[32m  *     @arg CEC_FLAG_RERR: Rx Error[m
[32m+[m[32m  *     @arg CEC_FLAG_RBTF: Rx Byte/Block Transfer Finished[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_ClearFlag(uint32_t CEC_FLAG)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  uint32_t tmp = 0x0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));[m
[32m+[m
[32m+[m[32m  tmp = CEC->CSR & 0x2;[m
[32m+[m[41m       [m
[32m+[m[32m  /* Clear the selected CEC flags */[m
[32m+[m[32m  CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified CEC interrupt has occurred or not.[m
[32m+[m[32m  * @param  CEC_IT: specifies the CEC interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg CEC_IT_TERR: Tx Error[m
[32m+[m[32m  *     @arg CEC_IT_TBTF: Tx Block Transfer Finished[m
[32m+[m[32m  *     @arg CEC_IT_RERR: Rx Error[m
[32m+[m[32m  *     @arg CEC_IT_RBTF: Rx Block Transfer Finished[m
[32m+[m[32m  * @retval The new state of CEC_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus CEC_GetITStatus(uint8_t CEC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t enablestatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m   assert_param(IS_CEC_GET_IT(CEC_IT));[m
[32m+[m[41m   [m
[32m+[m[32m  /* Get the CEC IT enable bit status */[m
[32m+[m[32m  enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the status of the specified CEC interrupt */[m
[32m+[m[32m  if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CEC_IT is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* CEC_IT is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the CEC_IT status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the CEC's interrupt pending bits.[m
[32m+[m[32m  * @param  CEC_IT: specifies the CEC interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg CEC_IT_TERR: Tx Error[m
[32m+[m[32m  *     @arg CEC_IT_TBTF: Tx Block Transfer Finished[m
[32m+[m[32m  *     @arg CEC_IT_RERR: Rx Error[m
[32m+[m[32m  *     @arg CEC_IT_RBTF: Rx Block Transfer Finished[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CEC_ClearITPendingBit(uint16_t CEC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0x0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_CEC_GET_IT(CEC_IT));[m
[32m+[m[41m  [m
[32m+[m[32m  tmp = CEC->CSR & 0x2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear the selected CEC interrupt pending bits */[m
[32m+[m[32m  CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c[m
[1mnew file mode 100644[m
[1mindex 0000000..6501728[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_crc.c[m
[36m@@ -0,0 +1,160 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_crc.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the CRC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_crc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC[m[41m [m
[32m+[m[32m  * @brief CRC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup CRC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Resets the CRC Data register (DR).[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CRC_ResetDR(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset CRC generator */[m
[32m+[m[32m  CRC->CR = CRC_CR_RESET;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Computes the 32-bit CRC of a given data word(32-bit).[m
[32m+[m[32m  * @param  Data: data word(32-bit) to compute its CRC[m
[32m+[m[32m  * @retval 32-bit CRC[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t CRC_CalcCRC(uint32_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  CRC->DR = Data;[m
[32m+[m[41m  [m
[32m+[m[32m  return (CRC->DR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Computes the 32-bit CRC of a given buffer of data word(32-bit).[m
[32m+[m[32m  * @param  pBuffer: pointer to the buffer containing the data to be computed[m
[32m+[m[32m  * @param  BufferLength: length of the buffer to be computed[m[41m					[m
[32m+[m[32m  * @retval 32-bit CRC[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t index = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  for(index = 0; index < BufferLength; index++)[m
[32m+[m[32m  {[m
[32m+[m[32m    CRC->DR = pBuffer[index];[m
[32m+[m[32m  }[m
[32m+[m[32m  return (CRC->DR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the current CRC value.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval 32-bit CRC[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t CRC_GetCRC(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (CRC->DR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Stores a 8-bit data in the Independent Data(ID) register.[m
[32m+[m[32m  * @param  IDValue: 8-bit value to be stored in the ID register[m[41m 					[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid CRC_SetIDRegister(uint8_t IDValue)[m
[32m+[m[32m{[m
[32m+[m[32m  CRC->IDR = IDValue;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the 8-bit data stored in the Independent Data(ID) register[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval 8-bit value of the ID register[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32muint8_t CRC_GetIDRegister(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (CRC->IDR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c[m
[1mnew file mode 100644[m
[1mindex 0000000..1cfc71d[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dac.c[m
[36m@@ -0,0 +1,571 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_dac.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the DAC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_dac.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC[m[41m [m
[32m+[m[32m  * @brief DAC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* CR register Mask */[m
[32m+[m[32m#define CR_CLEAR_MASK              ((uint32_t)0x00000FFE)[m
[32m+[m
[32m+[m[32m/* DAC Dual Channels SWTRIG masks */[m
[32m+[m[32m#define DUAL_SWTRIG_SET            ((uint32_t)0x00000003)[m
[32m+[m[32m#define DUAL_SWTRIG_RESET          ((uint32_t)0xFFFFFFFC)[m
[32m+[m
[32m+[m[32m/* DHR registers offsets */[m
[32m+[m[32m#define DHR12R1_OFFSET             ((uint32_t)0x00000008)[m
[32m+[m[32m#define DHR12R2_OFFSET             ((uint32_t)0x00000014)[m
[32m+[m[32m#define DHR12RD_OFFSET             ((uint32_t)0x00000020)[m
[32m+[m
[32m+[m[32m/* DOR register offset */[m
[32m+[m[32m#define DOR_OFFSET                 ((uint32_t)0x0000002C)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DAC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the DAC peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Enable DAC reset state */[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);[m
[32m+[m[32m  /* Release DAC from reset state */[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the DAC peripheral according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the DAC_InitStruct.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_InitStruct: pointer to a DAC_InitTypeDef structure that[m
[32m+[m[32m  *        contains the configuration information for the specified DAC channel.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg1 = 0, tmpreg2 = 0;[m
[32m+[m[32m  /* Check the DAC parameters */[m
[32m+[m[32m  assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));[m
[32m+[m[32m  assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));[m
[32m+[m[32m  assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));[m
[32m+[m[32m  assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));[m
[32m+[m[32m/*---------------------------- DAC CR Configuration --------------------------*/[m
[32m+[m[32m  /* Get the DAC CR value */[m
[32m+[m[32m  tmpreg1 = DAC->CR;[m
[32m+[m[32m  /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */[m
[32m+[m[32m  tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);[m
[32m+[m[32m  /* Configure for the selected DAC channel: buffer output, trigger, wave generation,[m
[32m+[m[32m     mask/amplitude for wave generation */[m
[32m+[m[32m  /* Set TSELx and TENx bits according to DAC_Trigger value */[m
[32m+[m[32m  /* Set WAVEx bits according to DAC_WaveGeneration value */[m
[32m+[m[32m  /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */[m[41m [m
[32m+[m[32m  /* Set BOFFx bit according to DAC_OutputBuffer value */[m[41m   [m
[32m+[m[32m  tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |[m
[32m+[m[32m             DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);[m
[32m+[m[32m  /* Calculate CR register value depending on DAC_Channel */[m
[32m+[m[32m  tmpreg1 |= tmpreg2 << DAC_Channel;[m
[32m+[m[32m  /* Write to DAC CR */[m
[32m+[m[32m  DAC->CR = tmpreg1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each DAC_InitStruct member with its default value.[m
[32m+[m[32m  * @param  DAC_InitStruct : pointer to a DAC_InitTypeDef structure which will[m
[32m+[m[32m  *         be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m/*--------------- Reset DAC init structure parameters values -----------------*/[m
[32m+[m[32m  /* Initialize the DAC_Trigger member */[m
[32m+[m[32m  DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;[m
[32m+[m[32m  /* Initialize the DAC_WaveGeneration member */[m
[32m+[m[32m  DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;[m
[32m+[m[32m  /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */[m
[32m+[m[32m  DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;[m
[32m+[m[32m  /* Initialize the DAC_OutputBuffer member */[m
[32m+[m[32m  DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified DAC channel.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  NewState: new state of the DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected DAC channel */[m
[32m+[m[32m    DAC->CR |= (DAC_CR_EN1 << DAC_Channel);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected DAC channel */[m
[32m+[m[32m    DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified DAC interrupts.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_IT: specifies the DAC interrupt sources to be enabled or disabled.[m[41m [m
[32m+[m[32m  *   This parameter can be the following values:[m
[32m+[m[32m  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask[m[41m                      [m
[32m+[m[32m  * @param  NewState: new state of the specified DAC interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32mvoid DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState)[m[41m  [m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  assert_param(IS_DAC_IT(DAC_IT));[m[41m [m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected DAC interrupts */[m
[32m+[m[32m    DAC->CR |=  (DAC_IT << DAC_Channel);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected DAC interrupts */[m
[32m+[m[32m    DAC->CR &= (~(uint32_t)(DAC_IT << DAC_Channel));[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified DAC channel DMA request.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  NewState: new state of the selected DAC channel DMA request.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected DAC channel DMA request */[m
[32m+[m[32m    DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected DAC channel DMA request */[m
[32m+[m[32m    DAC->CR &= ~(DAC_CR_DMAEN1 << DAC_Channel);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the selected DAC channel software trigger.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  NewState: new state of the selected DAC channel software trigger.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable software trigger for the selected DAC channel */[m
[32m+[m[32m    DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable software trigger for the selected DAC channel */[m
[32m+[m[32m    DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables simultaneously the two DAC channels software[m
[32m+[m[32m  *   triggers.[m
[32m+[m[32m  * @param  NewState: new state of the DAC channels software triggers.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_DualSoftwareTriggerCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable software trigger for both DAC channels */[m
[32m+[m[32m    DAC->SWTRIGR |= DUAL_SWTRIG_SET ;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable software trigger for both DAC channels */[m
[32m+[m[32m    DAC->SWTRIGR &= DUAL_SWTRIG_RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the selected DAC channel wave generation.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_Wave: Specifies the wave type to enable or disable.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Wave_Noise: noise wave generation[m
[32m+[m[32m  *     @arg DAC_Wave_Triangle: triangle wave generation[m
[32m+[m[32m  * @param  NewState: new state of the selected DAC channel wave generation.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_DAC_WAVE(DAC_Wave));[m[41m [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected wave generation for the selected DAC channel */[m
[32m+[m[32m    DAC->CR |= DAC_Wave << DAC_Channel;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected wave generation for the selected DAC channel */[m
[32m+[m[32m    DAC->CR &= ~(DAC_Wave << DAC_Channel);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Set the specified data holding register value for DAC channel1.[m
[32m+[m[32m  * @param  DAC_Align: Specifies the data alignment for DAC channel1.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Align_8b_R: 8bit right data alignment selected[m
[32m+[m[32m  *     @arg DAC_Align_12b_L: 12bit left data alignment selected[m
[32m+[m[32m  *     @arg DAC_Align_12b_R: 12bit right data alignment selected[m
[32m+[m[32m  * @param  Data : Data to be loaded in the selected data holding register.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_ALIGN(DAC_Align));[m
[32m+[m[32m  assert_param(IS_DAC_DATA(Data));[m
[32m+[m[41m  [m
[32m+[m[32m  tmp = (uint32_t)DAC_BASE;[m[41m [m
[32m+[m[32m  tmp += DHR12R1_OFFSET + DAC_Align;[m
[32m+[m
[32m+[m[32m  /* Set the DAC channel1 selected data holding register */[m
[32m+[m[32m  *(__IO uint32_t *) tmp = Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Set the specified data holding register value for DAC channel2.[m
[32m+[m[32m  * @param  DAC_Align: Specifies the data alignment for DAC channel2.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Align_8b_R: 8bit right data alignment selected[m
[32m+[m[32m  *     @arg DAC_Align_12b_L: 12bit left data alignment selected[m
[32m+[m[32m  *     @arg DAC_Align_12b_R: 12bit right data alignment selected[m
[32m+[m[32m  * @param  Data : Data to be loaded in the selected data holding register.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_ALIGN(DAC_Align));[m
[32m+[m[32m  assert_param(IS_DAC_DATA(Data));[m
[32m+[m[41m  [m
[32m+[m[32m  tmp = (uint32_t)DAC_BASE;[m
[32m+[m[32m  tmp += DHR12R2_OFFSET + DAC_Align;[m
[32m+[m
[32m+[m[32m  /* Set the DAC channel2 selected data holding register */[m
[32m+[m[32m  *(__IO uint32_t *)tmp = Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Set the specified data holding register value for dual channel[m
[32m+[m[32m  *   DAC.[m
[32m+[m[32m  * @param  DAC_Align: Specifies the data alignment for dual channel DAC.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Align_8b_R: 8bit right data alignment selected[m
[32m+[m[32m  *     @arg DAC_Align_12b_L: 12bit left data alignment selected[m
[32m+[m[32m  *     @arg DAC_Align_12b_R: 12bit right data alignment selected[m
[32m+[m[32m  * @param  Data2: Data for DAC Channel2 to be loaded in the selected data[m[41m [m
[32m+[m[32m  *   holding register.[m
[32m+[m[32m  * @param  Data1: Data for DAC Channel1 to be loaded in the selected data[m[41m [m
[32m+[m[32m  *   holding register.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t data = 0, tmp = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_ALIGN(DAC_Align));[m
[32m+[m[32m  assert_param(IS_DAC_DATA(Data1));[m
[32m+[m[32m  assert_param(IS_DAC_DATA(Data2));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Calculate and set dual DAC data holding register value */[m
[32m+[m[32m  if (DAC_Align == DAC_Align_8b_R)[m
[32m+[m[32m  {[m
[32m+[m[32m    data = ((uint32_t)Data2 << 8) | Data1;[m[41m [m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    data = ((uint32_t)Data2 << 16) | Data1;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  tmp = (uint32_t)DAC_BASE;[m
[32m+[m[32m  tmp += DHR12RD_OFFSET + DAC_Align;[m
[32m+[m
[32m+[m[32m  /* Set the dual DAC selected data holding register */[m
[32m+[m[32m  *(__IO uint32_t *)tmp = data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the last data output value of the selected DAC channel.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @retval The selected DAC channel data output value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[41m  [m
[32m+[m[32m  tmp = (uint32_t) DAC_BASE ;[m
[32m+[m[32m  tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Returns the DAC channel data output register value */[m
[32m+[m[32m  return (uint16_t) (*(__IO uint32_t*) tmp);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified DAC flag is set or not.[m
[32m+[m[32m  * @param  DAC_Channel: thee selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_FLAG: specifies the flag to check.[m[41m [m
[32m+[m[32m  *   This parameter can be only of the following value:[m
[32m+[m[32m  *     @arg DAC_FLAG_DMAUDR: DMA underrun flag[m[41m                                                 [m
[32m+[m[32m  * @retval The new state of DAC_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_DAC_FLAG(DAC_FLAG));[m
[32m+[m
[32m+[m[32m  /* Check the status of the specified DAC flag */[m
[32m+[m[32m  if ((DAC->SR & (DAC_FLAG << DAC_Channel)) != (uint8_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DAC_FLAG is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DAC_FLAG is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the DAC_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the DAC channelx's pending flags.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_FLAG: specifies the flag to clear.[m[41m [m
[32m+[m[32m  *   This parameter can be of the following value:[m
[32m+[m[32m  *     @arg DAC_FLAG_DMAUDR: DMA underrun flag[m[41m                           [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_DAC_FLAG(DAC_FLAG));[m
[32m+[m
[32m+[m[32m  /* Clear the selected DAC flags */[m
[32m+[m[32m  DAC->SR = (DAC_FLAG << DAC_Channel);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified DAC interrupt has occurred or not.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_IT: specifies the DAC interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be the following values:[m
[32m+[m[32m  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask[m[41m                       [m
[32m+[m[32m  * @retval The new state of DAC_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t enablestatus = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_DAC_IT(DAC_IT));[m
[32m+[m
[32m+[m[32m  /* Get the DAC_IT enable bit status */[m
[32m+[m[32m  enablestatus = (DAC->CR & (DAC_IT << DAC_Channel)) ;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the status of the specified DAC interrupt */[m
[32m+[m[32m  if (((DAC->SR & (DAC_IT << DAC_Channel)) != (uint32_t)RESET) && enablestatus)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DAC_IT is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DAC_IT is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the DAC_IT status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the DAC channelx's interrupt pending bits.[m
[32m+[m[32m  * @param  DAC_Channel: the selected DAC channel.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DAC_Channel_1: DAC Channel1 selected[m
[32m+[m[32m  *     @arg DAC_Channel_2: DAC Channel2 selected[m
[32m+[m[32m  * @param  DAC_IT: specifies the DAC interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be the following values:[m
[32m+[m[32m  *     @arg DAC_IT_DMAUDR: DMA underrun interrupt mask[m[41m                         [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DAC_CHANNEL(DAC_Channel));[m
[32m+[m[32m  assert_param(IS_DAC_IT(DAC_IT));[m[41m [m
[32m+[m
[32m+[m[32m  /* Clear the selected DAC interrupt pending bits */[m
[32m+[m[32m  DAC->SR = (DAC_IT << DAC_Channel);[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c[m
[1mnew file mode 100644[m
[1mindex 0000000..96a8fde[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dbgmcu.c[m
[36m@@ -0,0 +1,162 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_dbgmcu.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the DBGMCU firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_dbgmcu.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU[m[41m [m
[32m+[m[32m  * @brief DBGMCU driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define IDCODE_DEVID_MASK    ((uint32_t)0x00000FFF)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DBGMCU_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the device revision identifier.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Device revision identifier[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t DBGMCU_GetREVID(void)[m
[32m+[m[32m{[m
[32m+[m[32m   return(DBGMCU->IDCODE >> 16);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the device identifier.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Device identifier[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t DBGMCU_GetDEVID(void)[m
[32m+[m[32m{[m
[32m+[m[32m   return(DBGMCU->IDCODE & IDCODE_DEVID_MASK);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the specified peripheral and low power mode behavior[m
[32m+[m[32m  *   when the MCU under Debug mode.[m
[32m+[m[32m  * @param  DBGMCU_Periph: specifies the peripheral and low power mode.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg DBGMCU_SLEEP: Keep debugger connection during SLEEP mode[m[41m              [m
[32m+[m[32m  *     @arg DBGMCU_STOP: Keep debugger connection during STOP mode[m[41m               [m
[32m+[m[32m  *     @arg DBGMCU_STANDBY: Keep debugger connection during STANDBY mode[m[41m            [m
[32m+[m[32m  *     @arg DBGMCU_IWDG_STOP: Debug IWDG stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_WWDG_STOP: Debug WWDG stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM1_STOP: TIM1 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM2_STOP: TIM2 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM3_STOP: TIM3 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM4_STOP: TIM4 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_CAN1_STOP: Debug CAN2 stopped when Core is halted[m[41m           [m
[32m+[m[32m  *     @arg DBGMCU_I2C1_SMBUS_TIMEOUT: I2C1 SMBUS timeout mode stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_I2C2_SMBUS_TIMEOUT: I2C2 SMBUS timeout mode stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM5_STOP: TIM5 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM6_STOP: TIM6 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM7_STOP: TIM7 counter stopped when Core is halted[m[41m          [m
[32m+[m[32m  *     @arg DBGMCU_TIM8_STOP: TIM8 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_CAN2_STOP: Debug CAN2 stopped when Core is halted[m[41m [m
[32m+[m[32m  *     @arg DBGMCU_TIM15_STOP: TIM15 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM16_STOP: TIM16 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM17_STOP: TIM17 counter stopped when Core is halted[m[41m                [m
[32m+[m[32m  *     @arg DBGMCU_TIM9_STOP: TIM9 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM10_STOP: TIM10 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM11_STOP: TIM11 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM12_STOP: TIM12 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM13_STOP: TIM13 counter stopped when Core is halted[m
[32m+[m[32m  *     @arg DBGMCU_TIM14_STOP: TIM14 counter stopped when Core is halted[m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral in Debug mode.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DBGMCU_PERIPH(DBGMCU_Periph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    DBGMCU->CR |= DBGMCU_Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    DBGMCU->CR &= ~DBGMCU_Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c[m
[1mnew file mode 100644[m
[1mindex 0000000..bf072df[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_dma.c[m
[36m@@ -0,0 +1,714 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_dma.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the DMA firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_dma.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA[m[41m [m
[32m+[m[32m  * @brief DMA driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m/* DMA1 Channelx interrupt pending bit masks */[m
[32m+[m[32m#define DMA1_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))[m
[32m+[m[32m#define DMA1_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))[m
[32m+[m[32m#define DMA1_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))[m
[32m+[m[32m#define DMA1_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))[m
[32m+[m[32m#define DMA1_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))[m
[32m+[m[32m#define DMA1_Channel6_IT_Mask    ((uint32_t)(DMA_ISR_GIF6 | DMA_ISR_TCIF6 | DMA_ISR_HTIF6 | DMA_ISR_TEIF6))[m
[32m+[m[32m#define DMA1_Channel7_IT_Mask    ((uint32_t)(DMA_ISR_GIF7 | DMA_ISR_TCIF7 | DMA_ISR_HTIF7 | DMA_ISR_TEIF7))[m
[32m+[m
[32m+[m[32m/* DMA2 Channelx interrupt pending bit masks */[m
[32m+[m[32m#define DMA2_Channel1_IT_Mask    ((uint32_t)(DMA_ISR_GIF1 | DMA_ISR_TCIF1 | DMA_ISR_HTIF1 | DMA_ISR_TEIF1))[m
[32m+[m[32m#define DMA2_Channel2_IT_Mask    ((uint32_t)(DMA_ISR_GIF2 | DMA_ISR_TCIF2 | DMA_ISR_HTIF2 | DMA_ISR_TEIF2))[m
[32m+[m[32m#define DMA2_Channel3_IT_Mask    ((uint32_t)(DMA_ISR_GIF3 | DMA_ISR_TCIF3 | DMA_ISR_HTIF3 | DMA_ISR_TEIF3))[m
[32m+[m[32m#define DMA2_Channel4_IT_Mask    ((uint32_t)(DMA_ISR_GIF4 | DMA_ISR_TCIF4 | DMA_ISR_HTIF4 | DMA_ISR_TEIF4))[m
[32m+[m[32m#define DMA2_Channel5_IT_Mask    ((uint32_t)(DMA_ISR_GIF5 | DMA_ISR_TCIF5 | DMA_ISR_HTIF5 | DMA_ISR_TEIF5))[m
[32m+[m
[32m+[m[32m/* DMA2 FLAG mask */[m
[32m+[m[32m#define FLAG_Mask                ((uint32_t)0x10000000)[m
[32m+[m
[32m+[m[32m/* DMA registers Masks */[m
[32m+[m[32m#define CCR_CLEAR_Mask           ((uint32_t)0xFFFF800F)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup DMA_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the DMAy Channelx registers to their default reset[m
[32m+[m[32m  *         values.[m
[32m+[m[32m  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and[m
[32m+[m[32m  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Disable the selected DMAy Channelx */[m
[32m+[m[32m  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset DMAy Channelx control register */[m
[32m+[m[32m  DMAy_Channelx->CCR  = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset DMAy Channelx remaining bytes register */[m
[32m+[m[32m  DMAy_Channelx->CNDTR = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset DMAy Channelx peripheral address register */[m
[32m+[m[32m  DMAy_Channelx->CPAR  = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset DMAy Channelx memory address register */[m
[32m+[m[32m  DMAy_Channelx->CMAR = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  if (DMAy_Channelx == DMA1_Channel1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel1 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel1_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA1_Channel2)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel2 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel2_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA1_Channel3)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel3 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel3_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA1_Channel4)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel4 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel4_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA1_Channel5)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel5 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel5_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA1_Channel6)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel6 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel6_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA1_Channel7)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA1 Channel7 */[m
[32m+[m[32m    DMA1->IFCR |= DMA1_Channel7_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA2_Channel1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA2 Channel1 */[m
[32m+[m[32m    DMA2->IFCR |= DMA2_Channel1_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA2_Channel2)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA2 Channel2 */[m
[32m+[m[32m    DMA2->IFCR |= DMA2_Channel2_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA2_Channel3)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA2 Channel3 */[m
[32m+[m[32m    DMA2->IFCR |= DMA2_Channel3_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (DMAy_Channelx == DMA2_Channel4)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset interrupt pending bits for DMA2 Channel4 */[m
[32m+[m[32m    DMA2->IFCR |= DMA2_Channel4_IT_Mask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    if (DMAy_Channelx == DMA2_Channel5)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Reset interrupt pending bits for DMA2 Channel5 */[m
[32m+[m[32m      DMA2->IFCR |= DMA2_Channel5_IT_Mask;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the DMAy Channelx according to the specified[m
[32m+[m[32m  *         parameters in the DMA_InitStruct.[m
[32m+[m[32m  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and[m[41m [m
[32m+[m[32m  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.[m
[32m+[m[32m  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that[m
[32m+[m[32m  *         contains the configuration information for the specified DMA Channel.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));[m
[32m+[m[32m  assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));[m
[32m+[m[32m  assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));[m
[32m+[m[32m  assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));[m
[32m+[m[32m  assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));[m[41m   [m
[32m+[m[32m  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));[m
[32m+[m[32m  assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));[m
[32m+[m[32m  assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));[m
[32m+[m[32m  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));[m
[32m+[m[32m  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));[m
[32m+[m
[32m+[m[32m/*--------------------------- DMAy Channelx CCR Configuration -----------------*/[m
[32m+[m[32m  /* Get the DMAy_Channelx CCR value */[m
[32m+[m[32m  tmpreg = DMAy_Channelx->CCR;[m
[32m+[m[32m  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */[m
[32m+[m[32m  tmpreg &= CCR_CLEAR_Mask;[m
[32m+[m[32m  /* Configure DMAy Channelx: data transfer, data size, priority level and mode */[m
[32m+[m[32m  /* Set DIR bit according to DMA_DIR value */[m
[32m+[m[32m  /* Set CIRC bit according to DMA_Mode value */[m
[32m+[m[32m  /* Set PINC bit according to DMA_PeripheralInc value */[m
[32m+[m[32m  /* Set MINC bit according to DMA_MemoryInc value */[m
[32m+[m[32m  /* Set PSIZE bits according to DMA_PeripheralDataSize value */[m
[32m+[m[32m  /* Set MSIZE bits according to DMA_MemoryDataSize value */[m
[32m+[m[32m  /* Set PL bits according to DMA_Priority value */[m
[32m+[m[32m  /* Set the MEM2MEM bit according to DMA_M2M value */[m
[32m+[m[32m  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |[m
[32m+[m[32m            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |[m
[32m+[m[32m            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |[m
[32m+[m[32m            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;[m
[32m+[m
[32m+[m[32m  /* Write to DMAy Channelx CCR */[m
[32m+[m[32m  DMAy_Channelx->CCR = tmpreg;[m
[32m+[m
[32m+[m[32m/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/[m
[32m+[m[32m  /* Write to DMAy Channelx CNDTR */[m
[32m+[m[32m  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;[m
[32m+[m
[32m+[m[32m/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/[m
[32m+[m[32m  /* Write to DMAy Channelx CPAR */[m
[32m+[m[32m  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;[m
[32m+[m
[32m+[m[32m/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/[m
[32m+[m[32m  /* Write to DMAy Channelx CMAR */[m
[32m+[m[32m  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each DMA_InitStruct member with its default value.[m
[32m+[m[32m  * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will[m
[32m+[m[32m  *         be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m/*-------------- Reset DMA init structure parameters values ------------------*/[m
[32m+[m[32m  /* Initialize the DMA_PeripheralBaseAddr member */[m
[32m+[m[32m  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;[m
[32m+[m[32m  /* Initialize the DMA_MemoryBaseAddr member */[m
[32m+[m[32m  DMA_InitStruct->DMA_MemoryBaseAddr = 0;[m
[32m+[m[32m  /* Initialize the DMA_DIR member */[m
[32m+[m[32m  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;[m
[32m+[m[32m  /* Initialize the DMA_BufferSize member */[m
[32m+[m[32m  DMA_InitStruct->DMA_BufferSize = 0;[m
[32m+[m[32m  /* Initialize the DMA_PeripheralInc member */[m
[32m+[m[32m  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;[m
[32m+[m[32m  /* Initialize the DMA_MemoryInc member */[m
[32m+[m[32m  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;[m
[32m+[m[32m  /* Initialize the DMA_PeripheralDataSize member */[m
[32m+[m[32m  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;[m
[32m+[m[32m  /* Initialize the DMA_MemoryDataSize member */[m
[32m+[m[32m  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;[m
[32m+[m[32m  /* Initialize the DMA_Mode member */[m
[32m+[m[32m  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;[m
[32m+[m[32m  /* Initialize the DMA_Priority member */[m
[32m+[m[32m  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;[m
[32m+[m[32m  /* Initialize the DMA_M2M member */[m
[32m+[m[32m  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified DMAy Channelx.[m
[32m+[m[32m  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and[m[41m [m
[32m+[m[32m  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.[m
[32m+[m[32m  * @param  NewState: new state of the DMAy Channelx.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected DMAy Channelx */[m
[32m+[m[32m    DMAy_Channelx->CCR |= DMA_CCR1_EN;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected DMAy Channelx */[m
[32m+[m[32m    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified DMAy Channelx interrupts.[m
[32m+[m[32m  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and[m[41m [m
[32m+[m[32m  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.[m
[32m+[m[32m  * @param  DMA_IT: specifies the DMA interrupts sources to be enabled[m
[32m+[m[32m  *   or disabled.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg DMA_IT_TC:  Transfer complete interrupt mask[m
[32m+[m[32m  *     @arg DMA_IT_HT:  Half transfer interrupt mask[m
[32m+[m[32m  *     @arg DMA_IT_TE:  Transfer error interrupt mask[m
[32m+[m[32m  * @param  NewState: new state of the specified DMA interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));[m
[32m+[m[32m  assert_param(IS_DMA_CONFIG_IT(DMA_IT));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected DMA interrupts */[m
[32m+[m[32m    DMAy_Channelx->CCR |= DMA_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected DMA interrupts */[m
[32m+[m[32m    DMAy_Channelx->CCR &= ~DMA_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the number of data units in the current DMAy Channelx transfer.[m
[32m+[m[32m  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and[m[41m [m
[32m+[m[32m  *         x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.[m
[32m+[m[32m  * @param  DataNumber: The number of data units in the current DMAy Channelx[m
[32m+[m[32m  *         transfer.[m[41m   [m
[32m+[m[32m  * @note   This function can only be used when the DMAy_Channelx is disabled.[m[41m                 [m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));[m
[32m+[m[41m  [m
[32m+[m[32m/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/[m
[32m+[m[32m  /* Write to DMAy Channelx CNDTR */[m
[32m+[m[32m  DMAy_Channelx->CNDTR = DataNumber;[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the number of remaining data units in the current[m
[32m+[m[32m  *         DMAy Channelx transfer.[m
[32m+[m[32m  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and[m[41m [m
[32m+[m[32m  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.[m
[32m+[m[32m  * @retval The number of remaining data units in the current DMAy Channelx[m
[32m+[m[32m  *         transfer.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));[m
[32m+[m[32m  /* Return the number of remaining data units for DMAy Channelx */[m
[32m+[m[32m  return ((uint16_t)(DMAy_Channelx->CNDTR));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified DMAy Channelx flag is set or not.[m
[32m+[m[32m  * @param  DMAy_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.[m
[32m+[m[32m  * @retval The new state of DMAy_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus DMA_GetFlagStatus(uint32_t DMAy_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));[m
[32m+[m
[32m+[m[32m  /* Calculate the used DMAy */[m
[32m+[m[32m  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get DMA2 ISR register value */[m
[32m+[m[32m    tmpreg = DMA2->ISR ;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get DMA1 ISR register value */[m
[32m+[m[32m    tmpreg = DMA1->ISR ;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Check the status of the specified DMAy flag */[m
[32m+[m[32m  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DMAy_FLAG is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DMAy_FLAG is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the DMAy_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the DMAy Channelx's pending flags.[m
[32m+[m[32m  * @param  DMAy_FLAG: specifies the flag to clear.[m
[32m+[m[32m  *   This parameter can be any combination (for the same DMA) of the following values:[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL1: DMA1 Channel1 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC1: DMA1 Channel1 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT1: DMA1 Channel1 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE1: DMA1 Channel1 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL2: DMA1 Channel2 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC2: DMA1 Channel2 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT2: DMA1 Channel2 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE2: DMA1 Channel2 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL3: DMA1 Channel3 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC3: DMA1 Channel3 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT3: DMA1 Channel3 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE3: DMA1 Channel3 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL4: DMA1 Channel4 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC4: DMA1 Channel4 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT4: DMA1 Channel4 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE4: DMA1 Channel4 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL5: DMA1 Channel5 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC5: DMA1 Channel5 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT5: DMA1 Channel5 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE5: DMA1 Channel5 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL6: DMA1 Channel6 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC6: DMA1 Channel6 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT6: DMA1 Channel6 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE6: DMA1 Channel6 transfer error flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_GL7: DMA1 Channel7 global flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TC7: DMA1 Channel7 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_HT7: DMA1 Channel7 half transfer flag.[m
[32m+[m[32m  *     @arg DMA1_FLAG_TE7: DMA1 Channel7 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL1: DMA2 Channel1 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC1: DMA2 Channel1 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT1: DMA2 Channel1 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE1: DMA2 Channel1 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL2: DMA2 Channel2 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC2: DMA2 Channel2 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT2: DMA2 Channel2 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE2: DMA2 Channel2 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL3: DMA2 Channel3 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC3: DMA2 Channel3 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT3: DMA2 Channel3 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE3: DMA2 Channel3 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL4: DMA2 Channel4 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC4: DMA2 Channel4 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT4: DMA2 Channel4 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE4: DMA2 Channel4 transfer error flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_GL5: DMA2 Channel5 global flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TC5: DMA2 Channel5 transfer complete flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.[m
[32m+[m[32m  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_ClearFlag(uint32_t DMAy_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));[m
[32m+[m
[32m+[m[32m  /* Calculate the used DMAy */[m
[32m+[m[32m  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the selected DMAy flags */[m
[32m+[m[32m    DMA2->IFCR = DMAy_FLAG;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the selected DMAy flags */[m
[32m+[m[32m    DMA1->IFCR = DMAy_FLAG;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified DMAy Channelx interrupt has occurred or not.[m
[32m+[m[32m  * @param  DMAy_IT: specifies the DMAy interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.[m
[32m+[m[32m  * @retval The new state of DMAy_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus DMA_GetITStatus(uint32_t DMAy_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_GET_IT(DMAy_IT));[m
[32m+[m
[32m+[m[32m  /* Calculate the used DMA */[m
[32m+[m[32m  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get DMA2 ISR register value */[m
[32m+[m[32m    tmpreg = DMA2->ISR;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get DMA1 ISR register value */[m
[32m+[m[32m    tmpreg = DMA1->ISR;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Check the status of the specified DMAy interrupt */[m
[32m+[m[32m  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DMAy_IT is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* DMAy_IT is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the DMA_IT status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the DMAy Channelx's interrupt pending bits.[m
[32m+[m[32m  * @param  DMAy_IT: specifies the DMAy interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination (for the same DMA) of the following values:[m
[32m+[m[32m  *     @arg DMA1_IT_GL1: DMA1 Channel1 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC1: DMA1 Channel1 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT1: DMA1 Channel1 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE1: DMA1 Channel1 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL2: DMA1 Channel2 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC2: DMA1 Channel2 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT2: DMA1 Channel2 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE2: DMA1 Channel2 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL3: DMA1 Channel3 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC3: DMA1 Channel3 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT3: DMA1 Channel3 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE3: DMA1 Channel3 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL4: DMA1 Channel4 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC4: DMA1 Channel4 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT4: DMA1 Channel4 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE4: DMA1 Channel4 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL5: DMA1 Channel5 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC5: DMA1 Channel5 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT5: DMA1 Channel5 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE5: DMA1 Channel5 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL6: DMA1 Channel6 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC6: DMA1 Channel6 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT6: DMA1 Channel6 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE6: DMA1 Channel6 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_GL7: DMA1 Channel7 global interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TC7: DMA1 Channel7 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_HT7: DMA1 Channel7 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA1_IT_TE7: DMA1 Channel7 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL1: DMA2 Channel1 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC1: DMA2 Channel1 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT1: DMA2 Channel1 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE1: DMA2 Channel1 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL2: DMA2 Channel2 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC2: DMA2 Channel2 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT2: DMA2 Channel2 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE2: DMA2 Channel2 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL3: DMA2 Channel3 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC3: DMA2 Channel3 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT3: DMA2 Channel3 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE3: DMA2 Channel3 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL4: DMA2 Channel4 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC4: DMA2 Channel4 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT4: DMA2 Channel4 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE4: DMA2 Channel4 transfer error interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_GL5: DMA2 Channel5 global interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TC5: DMA2 Channel5 transfer complete interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.[m
[32m+[m[32m  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DMA_ClearITPendingBit(uint32_t DMAy_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));[m
[32m+[m
[32m+[m[32m  /* Calculate the used DMAy */[m
[32m+[m[32m  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the selected DMAy interrupt pending bits */[m
[32m+[m[32m    DMA2->IFCR = DMAy_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the selected DMAy interrupt pending bits */[m
[32m+[m[32m    DMA1->IFCR = DMAy_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c[m
[1mnew file mode 100644[m
[1mindex 0000000..b6290d5[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_exti.c[m
[36m@@ -0,0 +1,269 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_exti.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the EXTI firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_exti.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI[m[41m [m
[32m+[m[32m  * @brief EXTI driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define EXTI_LINENONE    ((uint32_t)0x00000)  /* No interrupt selected */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup EXTI_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the EXTI peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid EXTI_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  EXTI->IMR = 0x00000000;[m
[32m+[m[32m  EXTI->EMR = 0x00000000;[m
[32m+[m[32m  EXTI->RTSR = 0x00000000;[m[41m [m
[32m+[m[32m  EXTI->FTSR = 0x00000000;[m[41m [m
[32m+[m[32m  EXTI->PR = 0x000FFFFF;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the EXTI peripheral according to the specified[m
[32m+[m[32m  *         parameters in the EXTI_InitStruct.[m
[32m+[m[32m  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the EXTI peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_EXTI_MODE(EXTI_InitStruct->EXTI_Mode));[m
[32m+[m[32m  assert_param(IS_EXTI_TRIGGER(EXTI_InitStruct->EXTI_Trigger));[m
[32m+[m[32m  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));[m[41m  [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));[m
[32m+[m
[32m+[m[32m  tmp = (uint32_t)EXTI_BASE;[m
[32m+[m[41m     [m
[32m+[m[32m  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear EXTI line configuration */[m
[32m+[m[32m    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;[m
[32m+[m[32m    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;[m
[32m+[m[41m    [m
[32m+[m[32m    tmp += EXTI_InitStruct->EXTI_Mode;[m
[32m+[m
[32m+[m[32m    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;[m
[32m+[m
[32m+[m[32m    /* Clear Rising Falling edge configuration */[m
[32m+[m[32m    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;[m
[32m+[m[32m    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Select the trigger for the selected external interrupts */[m
[32m+[m[32m    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Rising Falling edge */[m
[32m+[m[32m      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;[m
[32m+[m[32m      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      tmp = (uint32_t)EXTI_BASE;[m
[32m+[m[32m      tmp += EXTI_InitStruct->EXTI_Trigger;[m
[32m+[m
[32m+[m[32m      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    tmp += EXTI_InitStruct->EXTI_Mode;[m
[32m+[m
[32m+[m[32m    /* Disable the selected external lines */[m
[32m+[m[32m    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each EXTI_InitStruct member with its reset value.[m
[32m+[m[32m  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure which will[m
[32m+[m[32m  *         be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;[m
[32m+[m[32m  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;[m
[32m+[m[32m  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;[m
[32m+[m[32m  EXTI_InitStruct->EXTI_LineCmd = DISABLE;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Generates a Software interrupt.[m
[32m+[m[32m  * @param  EXTI_Line: specifies the EXTI lines to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_EXTI_LINE(EXTI_Line));[m
[32m+[m[41m  [m
[32m+[m[32m  EXTI->SWIER |= EXTI_Line;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified EXTI line flag is set or not.[m
[32m+[m[32m  * @param  EXTI_Line: specifies the EXTI line flag to check.[m
[32m+[m[32m  *   This parameter can be:[m
[32m+[m[32m  *     @arg EXTI_Linex: External interrupt line x where x(0..19)[m
[32m+[m[32m  * @retval The new state of EXTI_Line (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GET_EXTI_LINE(EXTI_Line));[m
[32m+[m[41m  [m
[32m+[m[32m  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the EXTI's line pending flags.[m
[32m+[m[32m  * @param  EXTI_Line: specifies the EXTI lines flags to clear.[m
[32m+[m[32m  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid EXTI_ClearFlag(uint32_t EXTI_Line)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_EXTI_LINE(EXTI_Line));[m
[32m+[m[41m  [m
[32m+[m[32m  EXTI->PR = EXTI_Line;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified EXTI line is asserted or not.[m
[32m+[m[32m  * @param  EXTI_Line: specifies the EXTI line to check.[m
[32m+[m[32m  *   This parameter can be:[m
[32m+[m[32m  *     @arg EXTI_Linex: External interrupt line x where x(0..19)[m
[32m+[m[32m  * @retval The new state of EXTI_Line (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus EXTI_GetITStatus(uint32_t EXTI_Line)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t enablestatus = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GET_EXTI_LINE(EXTI_Line));[m
[32m+[m[41m  [m
[32m+[m[32m  enablestatus =  EXTI->IMR & EXTI_Line;[m
[32m+[m[32m  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the EXTI's line pending bits.[m
[32m+[m[32m  * @param  EXTI_Line: specifies the EXTI lines to clear.[m
[32m+[m[32m  *   This parameter can be any combination of EXTI_Linex where x can be (0..19).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid EXTI_ClearITPendingBit(uint32_t EXTI_Line)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_EXTI_LINE(EXTI_Line));[m
[32m+[m[41m  [m
[32m+[m[32m  EXTI->PR = EXTI_Line;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c[m
[1mnew file mode 100644[m
[1mindex 0000000..cdff9e9[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_flash.c[m
[36m@@ -0,0 +1,1684 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_flash.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the FLASH firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_flash.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH[m[41m [m
[32m+[m[32m  * @brief FLASH driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/* Flash Access Control Register bits */[m
[32m+[m[32m#define ACR_LATENCY_Mask         ((uint32_t)0x00000038)[m
[32m+[m[32m#define ACR_HLFCYA_Mask          ((uint32_t)0xFFFFFFF7)[m
[32m+[m[32m#define ACR_PRFTBE_Mask          ((uint32_t)0xFFFFFFEF)[m
[32m+[m
[32m+[m[32m/* Flash Access Control Register bits */[m
[32m+[m[32m#define ACR_PRFTBS_Mask          ((uint32_t)0x00000020)[m[41m [m
[32m+[m
[32m+[m[32m/* Flash Control Register bits */[m
[32m+[m[32m#define CR_PG_Set                ((uint32_t)0x00000001)[m
[32m+[m[32m#define CR_PG_Reset              ((uint32_t)0x00001FFE)[m[41m [m
[32m+[m[32m#define CR_PER_Set               ((uint32_t)0x00000002)[m
[32m+[m[32m#define CR_PER_Reset             ((uint32_t)0x00001FFD)[m
[32m+[m[32m#define CR_MER_Set               ((uint32_t)0x00000004)[m
[32m+[m[32m#define CR_MER_Reset             ((uint32_t)0x00001FFB)[m
[32m+[m[32m#define CR_OPTPG_Set             ((uint32_t)0x00000010)[m
[32m+[m[32m#define CR_OPTPG_Reset           ((uint32_t)0x00001FEF)[m
[32m+[m[32m#define CR_OPTER_Set             ((uint32_t)0x00000020)[m
[32m+[m[32m#define CR_OPTER_Reset           ((uint32_t)0x00001FDF)[m
[32m+[m[32m#define CR_STRT_Set              ((uint32_t)0x00000040)[m
[32m+[m[32m#define CR_LOCK_Set              ((uint32_t)0x00000080)[m
[32m+[m
[32m+[m[32m/* FLASH Mask */[m
[32m+[m[32m#define RDPRT_Mask               ((uint32_t)0x00000002)[m
[32m+[m[32m#define WRP0_Mask                ((uint32_t)0x000000FF)[m
[32m+[m[32m#define WRP1_Mask                ((uint32_t)0x0000FF00)[m
[32m+[m[32m#define WRP2_Mask                ((uint32_t)0x00FF0000)[m
[32m+[m[32m#define WRP3_Mask                ((uint32_t)0xFF000000)[m
[32m+[m[32m#define OB_USER_BFB2             ((uint16_t)0x0008)[m
[32m+[m
[32m+[m[32m/* FLASH Keys */[m
[32m+[m[32m#define RDP_Key                  ((uint16_t)0x00A5)[m
[32m+[m[32m#define FLASH_KEY1               ((uint32_t)0x45670123)[m
[32m+[m[32m#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)[m
[32m+[m
[32m+[m[32m/* FLASH BANK address */[m
[32m+[m[32m#define FLASH_BANK1_END_ADDRESS   ((uint32_t)0x807FFFF)[m
[32m+[m
[32m+[m[32m/* Delay definition */[m[41m   [m
[32m+[m[32m#define EraseTimeout          ((uint32_t)0x000B0000)[m
[32m+[m[32m#define ProgramTimeout        ((uint32_t)0x00002000)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FLASH_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m@code[m[41m  [m
[32m+[m[41m [m
[32m+[m[32m This driver provides functions to configure and program the Flash memory of all STM32F10x devices,[m
[32m+[m[32m including the latest STM32F10x_XL density devices.[m[41m [m
[32m+[m
[32m+[m[32m STM32F10x_XL devices feature up to 1 Mbyte with dual bank architecture for read-while-write (RWW) capability:[m
[32m+[m[32m    - bank1: fixed size of 512 Kbytes (256 pages of 2Kbytes each)[m
[32m+[m[32m    - bank2: up to 512 Kbytes (up to 256 pages of 2Kbytes each)[m
[32m+[m[32m While other STM32F10x devices features only one bank with memory up to 512 Kbytes.[m
[32m+[m
[32m+[m[32m In version V3.3.0, some functions were updated and new ones were added to support[m
[32m+[m[32m STM32F10x_XL devices. Thus some functions manages all devices, while other are[m[41m [m
[32m+[m[32m dedicated for XL devices only.[m
[32m+[m[41m [m
[32m+[m[32m The table below presents the list of available functions depending on the used STM32F10x devices.[m[41m  [m
[32m+[m[41m      [m
[32m+[m[32m   ***************************************************[m
[32m+[m[32m   * Legacy functions used for all STM32F10x devices *[m
[32m+[m[32m   ***************************************************[m
[32m+[m[32m   +----------------------------------------------------------------------------------------------------------------------------------+[m
[32m+[m[32m   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |[m
[32m+[m[32m   |                                    |   devices  |  devices      |                                                                |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_SetLatency                    |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_HalfCycleAccessCmd            |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_PrefetchBufferCmd             |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_Unlock                        |    Yes     |      Yes      | - For STM32F10X_XL devices: unlock Bank1 and Bank2.            |[m
[32m+[m[32m   |                                    |            |               | - For other devices: unlock Bank1 and it is equivalent         |[m
[32m+[m[32m   |                                    |            |               |   to FLASH_UnlockBank1 function.                               |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_Lock                          |    Yes     |      Yes      | - For STM32F10X_XL devices: lock Bank1 and Bank2.              |[m
[32m+[m[32m   |                                    |            |               | - For other devices: lock Bank1 and it is equivalent           |[m
[32m+[m[32m   |                                    |            |               |   to FLASH_LockBank1 function.                                 |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ErasePage                     |    Yes     |      Yes      | - For STM32F10x_XL devices: erase a page in Bank1 and Bank2    |[m
[32m+[m[32m   |                                    |            |               | - For other devices: erase a page in Bank1                     |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_EraseAllPages                 |    Yes     |      Yes      | - For STM32F10x_XL devices: erase all pages in Bank1 and Bank2 |[m
[32m+[m[32m   |                                    |            |               | - For other devices: erase all pages in Bank1                  |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_EraseOptionBytes              |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ProgramWord                   |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ProgramHalfWord               |    Yes     |      Yes      | Updated to program up to 1MByte (depending on the used device) |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ProgramOptionByteData         |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_EnableWriteProtection         |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ReadOutProtection             |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_UserOptionByteConfig          |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_GetUserOptionByte             |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_GetWriteProtectionOptionByte  |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_GetReadOutProtectionStatus    |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_GetPrefetchBufferStatus       |    Yes     |      Yes      | No change                                                      |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ITConfig                      |    Yes     |      Yes      | - For STM32F10x_XL devices: enable Bank1 and Bank2's interrupts|[m
[32m+[m[32m   |                                    |            |               | - For other devices: enable Bank1's interrupts                 |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_GetFlagStatus                 |    Yes     |      Yes      | - For STM32F10x_XL devices: return Bank1 and Bank2's flag status|[m
[32m+[m[32m   |                                    |            |               | - For other devices: return Bank1's flag status                |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_ClearFlag                     |    Yes     |      Yes      | - For STM32F10x_XL devices: clear Bank1 and Bank2's flag       |[m
[32m+[m[32m   |                                    |            |               | - For other devices: clear Bank1's flag                        |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_GetStatus                     |    Yes     |      Yes      | - Return the status of Bank1 (for all devices)                 |[m
[32m+[m[32m   |                                    |            |               |   equivalent to FLASH_GetBank1Status function                  |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_WaitForLastOperation          |    Yes     |      Yes      | - Wait for Bank1 last operation (for all devices)              |[m
[32m+[m[32m   |                                    |            |               |   equivalent to: FLASH_WaitForLastBank1Operation function      |[m
[32m+[m[32m   +----------------------------------------------------------------------------------------------------------------------------------+[m
[32m+[m
[32m+[m[32m   ************************************************************************************************************************[m
[32m+[m[32m   * New functions used for all STM32F10x devices to manage Bank1:                                                        *[m
[32m+[m[32m   *   - These functions are mainly useful for STM32F10x_XL density devices, to have separate control for Bank1 and bank2 *[m
[32m+[m[32m   *   - For other devices, these functions are optional (covered by functions listed above)                              *[m
[32m+[m[32m   ************************************************************************************************************************[m
[32m+[m[32m   +----------------------------------------------------------------------------------------------------------------------------------+[m
[32m+[m[32m   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |[m
[32m+[m[32m   |                                    |   devices  |  devices      |                                                                |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_UnlockBank1                  |    Yes     |      Yes      | - Unlock Bank1                                                 |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_LockBank1                     |    Yes     |      Yes      | - Lock Bank1                                                   |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_EraseAllBank1Pages           |    Yes     |      Yes      | - Erase all pages in Bank1                                     |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_GetBank1Status               |    Yes     |      Yes      | - Return the status of Bank1                                   |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_WaitForLastBank1Operation    |    Yes     |      Yes      | - Wait for Bank1 last operation                                |[m
[32m+[m[32m   +----------------------------------------------------------------------------------------------------------------------------------+[m
[32m+[m
[32m+[m[32m   *****************************************************************************[m
[32m+[m[32m   * New Functions used only with STM32F10x_XL density devices to manage Bank2 *[m
[32m+[m[32m   *****************************************************************************[m
[32m+[m[32m   +----------------------------------------------------------------------------------------------------------------------------------+[m
[32m+[m[32m   |       Functions prototypes         |STM32F10x_XL|Other STM32F10x|    Comments                                                    |[m
[32m+[m[32m   |                                    |   devices  |  devices      |                                                                |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_UnlockBank2                  |    Yes     |      No       | - Unlock Bank2                                                 |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   |FLASH_LockBank2                     |    Yes     |      No       | - Lock Bank2                                                   |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_EraseAllBank2Pages           |    Yes     |      No       | - Erase all pages in Bank2                                     |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_GetBank2Status               |    Yes     |      No       | - Return the status of Bank2                                   |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_WaitForLastBank2Operation    |    Yes     |      No       | - Wait for Bank2 last operation                                |[m
[32m+[m[32m   |----------------------------------------------------------------------------------------------------------------------------------|[m
[32m+[m[32m   | FLASH_BootConfig                   |    Yes     |      No       | - Configure to boot from Bank1 or Bank2                        |[m
[32m+[m[32m   +----------------------------------------------------------------------------------------------------------------------------------+[m
[32m+[m[32m@endcode[m
[32m+[m[32m*/[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the code latency value.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  FLASH_Latency: specifies the FLASH Latency value.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FLASH_Latency_0: FLASH Zero Latency cycle[m
[32m+[m[32m  *     @arg FLASH_Latency_1: FLASH One Latency cycle[m
[32m+[m[32m  *     @arg FLASH_Latency_2: FLASH Two Latency cycles[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_SetLatency(uint32_t FLASH_Latency)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_LATENCY(FLASH_Latency));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Read the ACR register */[m
[32m+[m[32m  tmpreg = FLASH->ACR;[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m  /* Sets the Latency value */[m
[32m+[m[32m  tmpreg &= ACR_LATENCY_Mask;[m
[32m+[m[32m  tmpreg |= FLASH_Latency;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write the ACR register */[m
[32m+[m[32m  FLASH->ACR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Half cycle flash access.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  FLASH_HalfCycleAccess: specifies the FLASH Half cycle Access mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable[m
[32m+[m[32m  *     @arg FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Enable or disable the Half cycle access */[m
[32m+[m[32m  FLASH->ACR &= ACR_HLFCYA_Mask;[m
[32m+[m[32m  FLASH->ACR |= FLASH_HalfCycleAccess;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Prefetch Buffer.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  FLASH_PrefetchBuffer: specifies the Prefetch buffer status.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable[m
[32m+[m[32m  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Enable or disable the Prefetch Buffer */[m
[32m+[m[32m  FLASH->ACR &= ACR_PRFTBE_Mask;[m
[32m+[m[32m  FLASH->ACR |= FLASH_PrefetchBuffer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Unlocks the FLASH Program Erase Controller.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices this function unlocks Bank1 and Bank2.[m
[32m+[m[32m  *         - For all other devices it unlocks Bank1 and it is equivalent[m[41m [m
[32m+[m[32m  *           to FLASH_UnlockBank1 function..[m[41m [m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_Unlock(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Authorize the FPEC of Bank1 Access */[m
[32m+[m[32m  FLASH->KEYR = FLASH_KEY1;[m
[32m+[m[32m  FLASH->KEYR = FLASH_KEY2;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Authorize the FPEC of Bank2 Access */[m
[32m+[m[32m  FLASH->KEYR2 = FLASH_KEY1;[m
[32m+[m[32m  FLASH->KEYR2 = FLASH_KEY2;[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Unlocks the FLASH Bank1 Program Erase Controller.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices this function unlocks Bank1.[m
[32m+[m[32m  *         - For all other devices it unlocks Bank1 and it is[m[41m [m
[32m+[m[32m  *           equivalent to FLASH_Unlock function.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_UnlockBank1(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Authorize the FPEC of Bank1 Access */[m
[32m+[m[32m  FLASH->KEYR = FLASH_KEY1;[m
[32m+[m[32m  FLASH->KEYR = FLASH_KEY2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Unlocks the FLASH Bank2 Program Erase Controller.[m
[32m+[m[32m  * @note   This function can be used only for STM32F10X_XL density devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_UnlockBank2(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Authorize the FPEC of Bank2 Access */[m
[32m+[m[32m  FLASH->KEYR2 = FLASH_KEY1;[m
[32m+[m[32m  FLASH->KEYR2 = FLASH_KEY2;[m
[32m+[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Locks the FLASH Program Erase Controller.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices this function Locks Bank1 and Bank2.[m
[32m+[m[32m  *         - For all other devices it Locks Bank1 and it is equivalent[m[41m [m
[32m+[m[32m  *           to FLASH_LockBank1 function.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_Lock(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */[m
[32m+[m[32m  FLASH->CR |= CR_LOCK_Set;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */[m
[32m+[m[32m  FLASH->CR2 |= CR_LOCK_Set;[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Locks the FLASH Bank1 Program Erase Controller.[m
[32m+[m[32m  * @note   this function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices this function Locks Bank1.[m
[32m+[m[32m  *         - For all other devices it Locks Bank1 and it is equivalent[m[41m [m
[32m+[m[32m  *           to FLASH_Lock function.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_LockBank1(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */[m
[32m+[m[32m  FLASH->CR |= CR_LOCK_Set;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Locks the FLASH Bank2 Program Erase Controller.[m
[32m+[m[32m  * @note   This function can be used only for STM32F10X_XL density devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_LockBank2(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */[m
[32m+[m[32m  FLASH->CR2 |= CR_LOCK_Set;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Erases a specified FLASH page.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  Page_Address: The page address to be erased.[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_ErasePage(uint32_t Page_Address)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_ADDRESS(Page_Address));[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  if(Page_Address < FLASH_BANK1_END_ADDRESS)[m[41m  [m
[32m+[m[32m  {[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank1Operation(EraseTimeout);[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* if the previous operation is completed, proceed to erase the page */[m
[32m+[m[32m      FLASH->CR|= CR_PER_Set;[m
[32m+[m[32m      FLASH->AR = Page_Address;[m[41m [m
[32m+[m[32m      FLASH->CR|= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank1Operation(EraseTimeout);[m
[32m+[m
[32m+[m[32m      /* Disable the PER Bit */[m
[32m+[m[32m      FLASH->CR &= CR_PER_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank2Operation(EraseTimeout);[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      /* if the previous operation is completed, proceed to erase the page */[m
[32m+[m[32m      FLASH->CR2|= CR_PER_Set;[m
[32m+[m[32m      FLASH->AR2 = Page_Address;[m[41m [m
[32m+[m[32m      FLASH->CR2|= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank2Operation(EraseTimeout);[m
[32m+[m[41m      [m
[32m+[m[32m      /* Disable the PER Bit */[m
[32m+[m[32m      FLASH->CR2 &= CR_PER_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase the page */[m
[32m+[m[32m    FLASH->CR|= CR_PER_Set;[m
[32m+[m[32m    FLASH->AR = Page_Address;[m[41m [m
[32m+[m[32m    FLASH->CR|= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Disable the PER Bit */[m
[32m+[m[32m    FLASH->CR &= CR_PER_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m  /* Return the Erase Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Erases all FLASH pages.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_EraseAllPages(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastBank1Operation(EraseTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase all pages */[m
[32m+[m[32m     FLASH->CR |= CR_MER_Set;[m
[32m+[m[32m     FLASH->CR |= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank1Operation(EraseTimeout);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Disable the MER Bit */[m
[32m+[m[32m    FLASH->CR &= CR_MER_Reset;[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase all pages */[m
[32m+[m[32m     FLASH->CR2 |= CR_MER_Set;[m
[32m+[m[32m     FLASH->CR2 |= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank2Operation(EraseTimeout);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Disable the MER Bit */[m
[32m+[m[32m    FLASH->CR2 &= CR_MER_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase all pages */[m
[32m+[m[32m     FLASH->CR |= CR_MER_Set;[m
[32m+[m[32m     FLASH->CR |= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m
[32m+[m[32m    /* Disable the MER Bit */[m
[32m+[m[32m    FLASH->CR &= CR_MER_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m  /* Return the Erase Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Erases all Bank1 FLASH pages.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices this function erases all Bank1 pages.[m
[32m+[m[32m  *         - For all other devices it erases all Bank1 pages and it is equivalent[m[41m [m
[32m+[m[32m  *           to FLASH_EraseAllPages function.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_EraseAllBank1Pages(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastBank1Operation(EraseTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase all pages */[m
[32m+[m[32m     FLASH->CR |= CR_MER_Set;[m
[32m+[m[32m     FLASH->CR |= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank1Operation(EraseTimeout);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Disable the MER Bit */[m
[32m+[m[32m    FLASH->CR &= CR_MER_Reset;[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  /* Return the Erase Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Erases all Bank2 FLASH pages.[m
[32m+[m[32m  * @note   This function can be used only for STM32F10x_XL density devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_EraseAllBank2Pages(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastBank2Operation(EraseTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase all pages */[m
[32m+[m[32m     FLASH->CR2 |= CR_MER_Set;[m
[32m+[m[32m     FLASH->CR2 |= CR_STRT_Set;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank2Operation(EraseTimeout);[m
[32m+[m
[32m+[m[32m    /* Disable the MER Bit */[m
[32m+[m[32m    FLASH->CR2 &= CR_MER_Reset;[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  /* Return the Erase Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Erases the FLASH option bytes.[m
[32m+[m[32m  * @note   This functions erases all option bytes except the Read protection (RDP).[m[41m [m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_EraseOptionBytes(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t rdptmp = RDP_Key;[m
[32m+[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m
[32m+[m[32m  /* Get the actual read protection Option Byte value */[m[41m [m
[32m+[m[32m  if(FLASH_GetReadOutProtectionStatus() != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    rdptmp = 0x00;[m[41m  [m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Authorize the small information block programming */[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY1;[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY2;[m
[32m+[m[41m    [m
[32m+[m[32m    /* if the previous operation is completed, proceed to erase the option bytes */[m
[32m+[m[32m    FLASH->CR |= CR_OPTER_Set;[m
[32m+[m[32m    FLASH->CR |= CR_STRT_Set;[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[41m    [m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the erase operation is completed, disable the OPTER Bit */[m
[32m+[m[32m      FLASH->CR &= CR_OPTER_Reset;[m
[32m+[m[41m       [m
[32m+[m[32m      /* Enable the Option Bytes Programming operation */[m
[32m+[m[32m      FLASH->CR |= CR_OPTPG_Set;[m
[32m+[m[32m      /* Restore the last read protection Option Byte value */[m
[32m+[m[32m      OB->RDP = (uint16_t)rdptmp;[m[41m [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m [m
[32m+[m[32m      if(status != FLASH_TIMEOUT)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* if the program operation is completed, disable the OPTPG Bit */[m
[32m+[m[32m        FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      if (status != FLASH_TIMEOUT)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* Disable the OPTPG Bit */[m
[32m+[m[32m        FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m[41m  [m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the erase status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Programs a word at a specified address.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  Address: specifies the address to be programmed.[m
[32m+[m[32m  * @param  Data: specifies the data to be programmed.[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_ADDRESS(Address));[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  if(Address < FLASH_BANK1_END_ADDRESS - 2)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank1Operation(ProgramTimeout);[m[41m [m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new first[m[41m [m
[32m+[m[32m        half word */[m
[32m+[m[32m      FLASH->CR |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m      *(__IO uint16_t*)Address = (uint16_t)Data;[m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m [m
[32m+[m[32m      if(status == FLASH_COMPLETE)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* if the previous operation is completed, proceed to program the new second[m[41m [m
[32m+[m[32m        half word */[m
[32m+[m[32m        tmp = Address + 2;[m
[32m+[m
[32m+[m[32m        *(__IO uint16_t*) tmp = Data >> 16;[m
[32m+[m[41m    [m
[32m+[m[32m        /* Wait for last operation to be completed */[m
[32m+[m[32m        status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m        [m
[32m+[m[32m        /* Disable the PG Bit */[m
[32m+[m[32m        FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        /* Disable the PG Bit */[m
[32m+[m[32m        FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m       }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else if(Address == (FLASH_BANK1_END_ADDRESS - 1))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank1Operation(ProgramTimeout);[m
[32m+[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new first[m[41m [m
[32m+[m[32m        half word */[m
[32m+[m[32m      FLASH->CR |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m      *(__IO uint16_t*)Address = (uint16_t)Data;[m
[32m+[m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank1Operation(ProgramTimeout);[m
[32m+[m[41m      [m
[32m+[m	[32m  /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank2Operation(ProgramTimeout);[m
[32m+[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new second[m[41m [m
[32m+[m[32m      half word */[m
[32m+[m[32m      FLASH->CR2 |= CR_PG_Set;[m
[32m+[m[32m      tmp = Address + 2;[m
[32m+[m
[32m+[m[32m      *(__IO uint16_t*) tmp = Data >> 16;[m
[32m+[m[41m    [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);[m
[32m+[m[41m        [m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR2 &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR2 &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastBank2Operation(ProgramTimeout);[m
[32m+[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new first[m[41m [m
[32m+[m[32m        half word */[m
[32m+[m[32m      FLASH->CR2 |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m      *(__IO uint16_t*)Address = (uint16_t)Data;[m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);[m
[32m+[m[41m [m
[32m+[m[32m      if(status == FLASH_COMPLETE)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* if the previous operation is completed, proceed to program the new second[m[41m [m
[32m+[m[32m        half word */[m
[32m+[m[32m        tmp = Address + 2;[m
[32m+[m
[32m+[m[32m        *(__IO uint16_t*) tmp = Data >> 16;[m
[32m+[m[41m    [m
[32m+[m[32m        /* Wait for last operation to be completed */[m
[32m+[m[32m        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);[m
[32m+[m[41m        [m
[32m+[m[32m        /* Disable the PG Bit */[m
[32m+[m[32m        FLASH->CR2 &= CR_PG_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        /* Disable the PG Bit */[m
[32m+[m[32m        FLASH->CR2 &= CR_PG_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to program the new first[m[41m [m
[32m+[m[32m    half word */[m
[32m+[m[32m    FLASH->CR |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m    *(__IO uint16_t*)Address = (uint16_t)Data;[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m [m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new second[m[41m [m
[32m+[m[32m      half word */[m
[32m+[m[32m      tmp = Address + 2;[m
[32m+[m
[32m+[m[32m      *(__IO uint16_t*) tmp = Data >> 16;[m
[32m+[m[41m    [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m        [m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m[41m         [m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[41m   [m
[32m+[m[32m  /* Return the Program Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Programs a half word at a specified address.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  Address: specifies the address to be programmed.[m
[32m+[m[32m  * @param  Data: specifies the data to be programmed.[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_ADDRESS(Address));[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(Address < FLASH_BANK1_END_ADDRESS)[m
[32m+[m[32m  {[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new data */[m
[32m+[m[32m      FLASH->CR |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m      *(__IO uint16_t*)Address = Data;[m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank1Operation(ProgramTimeout);[m
[32m+[m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the previous operation is completed, proceed to program the new data */[m
[32m+[m[32m      FLASH->CR2 |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m      *(__IO uint16_t*)Address = Data;[m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastBank2Operation(ProgramTimeout);[m
[32m+[m
[32m+[m[32m      /* Disable the PG Bit */[m
[32m+[m[32m      FLASH->CR2 &= CR_PG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* if the previous operation is completed, proceed to program the new data */[m
[32m+[m[32m    FLASH->CR |= CR_PG_Set;[m
[32m+[m[41m  [m
[32m+[m[32m    *(__IO uint16_t*)Address = Data;[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Disable the PG Bit */[m
[32m+[m[32m    FLASH->CR &= CR_PG_Reset;[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m#endif  /* STM32F10X_XL */[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the Program Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Programs a half word at a specified Option Byte Data address.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  Address: specifies the address to be programmed.[m
[32m+[m[32m  *   This parameter can be 0x1FFFF804 or 0x1FFFF806.[m[41m [m
[32m+[m[32m  * @param  Data: specifies the data to be programmed.[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_OB_DATA_ADDRESS(Address));[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Authorize the small information block programming */[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY1;[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY2;[m
[32m+[m[32m    /* Enables the Option Bytes Programming operation */[m
[32m+[m[32m    FLASH->CR |= CR_OPTPG_Set;[m[41m [m
[32m+[m[32m    *(__IO uint16_t*)Address = Data;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    if(status != FLASH_TIMEOUT)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the program operation is completed, disable the OPTPG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the Option Byte Data Program Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Write protects the desired pages[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  FLASH_Pages: specifies the address of the pages to be write protected.[m
[32m+[m[32m  *   This parameter can be:[m
[32m+[m[32m  *     @arg For @b STM32_Low-density_devices: value between FLASH_WRProt_Pages0to3 and FLASH_WRProt_Pages28to31[m[41m  [m
[32m+[m[32m  *     @arg For @b STM32_Medium-density_devices: value between FLASH_WRProt_Pages0to3[m
[32m+[m[32m  *       and FLASH_WRProt_Pages124to127[m
[32m+[m[32m  *     @arg For @b STM32_High-density_devices: value between FLASH_WRProt_Pages0to1 and[m
[32m+[m[32m  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to255[m
[32m+[m[32m  *     @arg For @b STM32_Connectivity_line_devices: value between FLASH_WRProt_Pages0to1 and[m
[32m+[m[32m  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to127[m[41m    [m
[32m+[m[32m  *     @arg For @b STM32_XL-density_devices: value between FLASH_WRProt_Pages0to1 and[m
[32m+[m[32m  *       FLASH_WRProt_Pages60to61 or FLASH_WRProt_Pages62to511[m
[32m+[m[32m  *     @arg FLASH_WRProt_AllPages[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;[m
[32m+[m[41m  [m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));[m
[32m+[m[41m  [m
[32m+[m[32m  FLASH_Pages = (uint32_t)(~FLASH_Pages);[m
[32m+[m[32m  WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);[m
[32m+[m[32m  WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);[m
[32m+[m[32m  WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);[m
[32m+[m[32m  WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Authorizes the small information block programming */[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY1;[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY2;[m
[32m+[m[32m    FLASH->CR |= CR_OPTPG_Set;[m
[32m+[m[32m    if(WRP0_Data != 0xFF)[m
[32m+[m[32m    {[m
[32m+[m[32m      OB->WRP0 = WRP0_Data;[m
[32m+[m[41m      [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    }[m
[32m+[m[32m    if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))[m
[32m+[m[32m    {[m
[32m+[m[32m      OB->WRP1 = WRP1_Data;[m
[32m+[m[41m      [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    }[m
[32m+[m[32m    if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))[m
[32m+[m[32m    {[m
[32m+[m[32m      OB->WRP2 = WRP2_Data;[m
[32m+[m[41m      [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))[m
[32m+[m[32m    {[m
[32m+[m[32m      OB->WRP3 = WRP3_Data;[m
[32m+[m[41m     [m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    }[m
[32m+[m[41m          [m
[32m+[m[32m    if(status != FLASH_TIMEOUT)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the program operation is completed, disable the OPTPG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  /* Return the write protection operation Status */[m
[32m+[m[32m  return status;[m[41m       [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the read out protection.[m
[32m+[m[32m  * @note   If the user has already programmed the other option bytes before calling[m[41m [m
[32m+[m[32m  *   this function, he must re-program them since this function erases all option bytes.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  Newstate: new state of the ReadOut Protection.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Authorizes the small information block programming */[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY1;[m
[32m+[m[32m    FLASH->OPTKEYR = FLASH_KEY2;[m
[32m+[m[32m    FLASH->CR |= CR_OPTER_Set;[m
[32m+[m[32m    FLASH->CR |= CR_STRT_Set;[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(EraseTimeout);[m
[32m+[m[32m    if(status == FLASH_COMPLETE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the erase operation is completed, disable the OPTER Bit */[m
[32m+[m[32m      FLASH->CR &= CR_OPTER_Reset;[m
[32m+[m[32m      /* Enable the Option Bytes Programming operation */[m
[32m+[m[32m      FLASH->CR |= CR_OPTPG_Set;[m[41m [m
[32m+[m[32m      if(NewState != DISABLE)[m
[32m+[m[32m      {[m
[32m+[m[32m        OB->RDP = 0x00;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        OB->RDP = RDP_Key;[m[41m  [m
[32m+[m[32m      }[m
[32m+[m[32m      /* Wait for last operation to be completed */[m
[32m+[m[32m      status = FLASH_WaitForLastOperation(EraseTimeout);[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m      if(status != FLASH_TIMEOUT)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* if the program operation is completed, disable the OPTPG Bit */[m
[32m+[m[32m        FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m[41m [m
[32m+[m[32m    {[m
[32m+[m[32m      if(status != FLASH_TIMEOUT)[m
[32m+[m[32m      {[m
[32m+[m[32m        /* Disable the OPTER Bit */[m
[32m+[m[32m        FLASH->CR &= CR_OPTER_Reset;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the protection operation Status */[m
[32m+[m[32m  return status;[m[41m       [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  OB_IWDG: Selects the IWDG mode[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg OB_IWDG_SW: Software IWDG selected[m
[32m+[m[32m  *     @arg OB_IWDG_HW: Hardware IWDG selected[m
[32m+[m[32m  * @param  OB_STOP: Reset event when entering STOP mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg OB_STOP_NoRST: No reset generated when entering in STOP[m
[32m+[m[32m  *     @arg OB_STOP_RST: Reset generated when entering in STOP[m
[32m+[m[32m  * @param  OB_STDBY: Reset event when entering Standby mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY[m
[32m+[m[32m  *     @arg OB_STDBY_RST: Reset generated when entering in STANDBY[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m[41m [m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m[41m [m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));[m
[32m+[m[32m  assert_param(IS_OB_STOP_SOURCE(OB_STOP));[m
[32m+[m[32m  assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));[m
[32m+[m
[32m+[m[32m  /* Authorize the small information block programming */[m
[32m+[m[32m  FLASH->OPTKEYR = FLASH_KEY1;[m
[32m+[m[32m  FLASH->OPTKEYR = FLASH_KEY2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m[41m  [m
[32m+[m[32m    /* Enable the Option Bytes Programming operation */[m
[32m+[m[32m    FLASH->CR |= CR_OPTPG_Set;[m[41m [m
[32m+[m[41m           [m
[32m+[m[32m    OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8)));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    if(status != FLASH_TIMEOUT)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the program operation is completed, disable the OPTPG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  /* Return the Option Byte program Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures to boot from Bank1 or Bank2.[m[41m  [m
[32m+[m[32m  * @note   This function can be used only for STM32F10x_XL density devices.[m
[32m+[m[32m  * @param  FLASH_BOOT: select the FLASH Bank to boot from.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FLASH_BOOT_Bank1: At startup, if boot pins are set in boot from user Flash[m
[32m+[m[32m  *        position and this parameter is selected the device will boot from Bank1(Default).[m
[32m+[m[32m  *     @arg FLASH_BOOT_Bank2: At startup, if boot pins are set in boot from user Flash[m
[32m+[m[32m  *        position and this parameter is selected the device will boot from Bank2 or Bank1,[m
[32m+[m[32m  *        depending on the activation of the bank. The active banks are checked in[m
[32m+[m[32m  *        the following order: Bank2, followed by Bank1.[m
[32m+[m[32m  *        The active bank is recognized by the value programmed at the base address[m
[32m+[m[32m  *        of the respective bank (corresponding to the initial stack pointer value[m
[32m+[m[32m  *        in the interrupt vector table).[m
[32m+[m[32m  *        For more information, please refer to AN2606 from www.st.com.[m[41m    [m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m[41m [m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m[41m [m
[32m+[m[32m  assert_param(IS_FLASH_BOOT(FLASH_BOOT));[m
[32m+[m[32m  /* Authorize the small information block programming */[m
[32m+[m[32m  FLASH->OPTKEYR = FLASH_KEY1;[m
[32m+[m[32m  FLASH->OPTKEYR = FLASH_KEY2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Wait for last operation to be completed */[m
[32m+[m[32m  status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[41m  [m
[32m+[m[32m  if(status == FLASH_COMPLETE)[m
[32m+[m[32m  {[m[41m  [m
[32m+[m[32m    /* Enable the Option Bytes Programming operation */[m
[32m+[m[32m    FLASH->CR |= CR_OPTPG_Set;[m[41m [m
[32m+[m
[32m+[m[32m    if(FLASH_BOOT == FLASH_BOOT_Bank1)[m
[32m+[m[32m    {[m
[32m+[m[32m      OB->USER |= OB_USER_BFB2;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));[m
[32m+[m[32m    }[m
[32m+[m[32m    /* Wait for last operation to be completed */[m
[32m+[m[32m    status = FLASH_WaitForLastOperation(ProgramTimeout);[m
[32m+[m[32m    if(status != FLASH_TIMEOUT)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* if the program operation is completed, disable the OPTPG Bit */[m
[32m+[m[32m      FLASH->CR &= CR_OPTPG_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  /* Return the Option Byte program Status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the FLASH User Option Bytes values.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)[m
[32m+[m[32m  *         and RST_STDBY(Bit2).[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t FLASH_GetUserOptionByte(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Return the User Option Byte */[m
[32m+[m[32m  return (uint32_t)(FLASH->OBR >> 2);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the FLASH Write Protection Option Bytes Register value.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The FLASH Write Protection  Option Bytes Register value[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t FLASH_GetWriteProtectionOptionByte(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Return the Flash write protection Register value */[m
[32m+[m[32m  return (uint32_t)(FLASH->WRPR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the FLASH Read Out Protection Status is set or not.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH ReadOut Protection Status(SET or RESET)[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus FLASH_GetReadOutProtectionStatus(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus readoutstatus = RESET;[m
[32m+[m[32m  if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    readoutstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    readoutstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return readoutstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the FLASH Prefetch Buffer status is set or not.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Prefetch Buffer Status (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus FLASH_GetPrefetchBufferStatus(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */[m
[32m+[m[32m  return bitstatus;[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified FLASH interrupts.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices, enables or disables the specified FLASH interrupts[m
[32m+[m[32m              for Bank1 and Bank2.[m
[32m+[m[32m  *         - For other devices it enables or disables the specified FLASH interrupts for Bank1.[m
[32m+[m[32m  * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg FLASH_IT_ERROR: FLASH Error Interrupt[m
[32m+[m[32m  *     @arg FLASH_IT_EOP: FLASH end of operation Interrupt[m
[32m+[m[32m  * @param  NewState: new state of the specified Flash interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m[41m      [m
[32m+[m[32m  * @retval None[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_IT(FLASH_IT));[m[41m [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if((FLASH_IT & 0x80000000) != 0x0)[m
[32m+[m[32m  {[m
[32m+[m[32m    if(NewState != DISABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Enable the interrupt sources */[m
[32m+[m[32m      FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Disable the interrupt sources */[m
[32m+[m[32m      FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if(NewState != DISABLE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Enable the interrupt sources */[m
[32m+[m[32m      FLASH->CR |= FLASH_IT;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Disable the interrupt sources */[m
[32m+[m[32m      FLASH->CR &= ~(uint32_t)FLASH_IT;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_IT(FLASH_IT));[m[41m [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if(NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the interrupt sources */[m
[32m+[m[32m    FLASH->CR |= FLASH_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the interrupt sources */[m
[32m+[m[32m    FLASH->CR &= ~(uint32_t)FLASH_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified FLASH flag is set or not.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices, this function checks whether the specified[m[41m [m
[32m+[m[32m  *           Bank1 or Bank2 flag is set or not.[m
[32m+[m[32m  *         - For other devices, it checks whether the specified Bank1 flag is[m[41m [m
[32m+[m[32m  *           set or not.[m
[32m+[m[32m  * @param  FLASH_FLAG: specifies the FLASH flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FLASH_FLAG_BSY: FLASH Busy flag[m[41m           [m
[32m+[m[32m  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag[m[41m       [m
[32m+[m[32m  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag[m[41m      [m
[32m+[m[32m  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag[m[41m           [m
[32m+[m[32m  *     @arg FLASH_FLAG_OPTERR:  FLASH Option Byte error flag[m[41m     [m
[32m+[m[32m  * @retval The new state of FLASH_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;[m
[32m+[m[32m  if(FLASH_FLAG == FLASH_FLAG_OPTERR)[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if((FLASH_FLAG & 0x80000000) != 0x0)[m
[32m+[m[32m    {[m
[32m+[m[32m      if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m      {[m
[32m+[m[32m        bitstatus = SET;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        bitstatus = RESET;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m      {[m
[32m+[m[32m        bitstatus = SET;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        bitstatus = RESET;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;[m
[32m+[m[32m  if(FLASH_FLAG == FLASH_FLAG_OPTERR)[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m   if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m    {[m
[32m+[m[32m      bitstatus = SET;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      bitstatus = RESET;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m  /* Return the new state of FLASH_FLAG (SET or RESET) */[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the FLASH's pending flags.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices.[m
[32m+[m[32m  *         - For STM32F10X_XL devices, this function clears Bank1 or Bank2ís pending flags[m
[32m+[m[32m  *         - For other devices, it clears Bank1ís pending flags.[m
[32m+[m[32m  * @param  FLASH_FLAG: specifies the FLASH flags to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m[41m         [m
[32m+[m[32m  *     @arg FLASH_FLAG_PGERR: FLASH Program error flag[m[41m       [m
[32m+[m[32m  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag[m[41m      [m
[32m+[m[32m  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag[m[41m           [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FLASH_ClearFlag(uint32_t FLASH_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;[m
[32m+[m
[32m+[m[32m  if((FLASH_FLAG & 0x80000000) != 0x0)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the flags */[m
[32m+[m[32m    FLASH->SR2 = FLASH_FLAG;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Clear the flags */[m
[32m+[m[32m    FLASH->SR = FLASH_FLAG;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m
[32m+[m[32m#else[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear the flags */[m
[32m+[m[32m  FLASH->SR = FLASH_FLAG;[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the FLASH Status.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices, it is equivalent[m
[32m+[m[32m  *         to FLASH_GetBank1Status function.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP or FLASH_COMPLETE[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_GetStatus(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status flashstatus = FLASH_COMPLETE;[m
[32m+[m[41m  [m
[32m+[m[32m  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY)[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    flashstatus = FLASH_BUSY;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m[41m [m
[32m+[m[32m  {[m[41m  [m
[32m+[m[32m    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      flashstatus = FLASH_ERROR_PG;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m[41m [m
[32m+[m[32m    {[m
[32m+[m[32m      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )[m
[32m+[m[32m      {[m
[32m+[m[32m        flashstatus = FLASH_ERROR_WRP;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        flashstatus = FLASH_COMPLETE;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the Flash Status */[m
[32m+[m[32m  return flashstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the FLASH Bank1 Status.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices, it is equivalent[m
[32m+[m[32m  *         to FLASH_GetStatus function.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP or FLASH_COMPLETE[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_GetBank1Status(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status flashstatus = FLASH_COMPLETE;[m
[32m+[m[41m  [m
[32m+[m[32m  if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY)[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    flashstatus = FLASH_BUSY;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m[41m [m
[32m+[m[32m  {[m[41m  [m
[32m+[m[32m    if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      flashstatus = FLASH_ERROR_PG;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m[41m [m
[32m+[m[32m    {[m
[32m+[m[32m      if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )[m
[32m+[m[32m      {[m
[32m+[m[32m        flashstatus = FLASH_ERROR_WRP;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        flashstatus = FLASH_COMPLETE;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the Flash Status */[m
[32m+[m[32m  return flashstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the FLASH Bank2 Status.[m
[32m+[m[32m  * @note   This function can be used for STM32F10x_XL density devices.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,[m
[32m+[m[32m  *        FLASH_ERROR_WRP or FLASH_COMPLETE[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_GetBank2Status(void)[m
[32m+[m[32m{[m
[32m+[m[32m  FLASH_Status flashstatus = FLASH_COMPLETE;[m
[32m+[m[41m  [m
[32m+[m[32m  if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF))[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    flashstatus = FLASH_BUSY;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m[41m [m
[32m+[m[32m  {[m[41m  [m
[32m+[m[32m    if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      flashstatus = FLASH_ERROR_PG;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m[41m [m
[32m+[m[32m    {[m
[32m+[m[32m      if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )[m
[32m+[m[32m      {[m
[32m+[m[32m        flashstatus = FLASH_ERROR_WRP;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        flashstatus = FLASH_COMPLETE;[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the Flash Status */[m
[32m+[m[32m  return flashstatus;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Waits for a Flash operation to complete or a TIMEOUT to occur.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices,[m[41m [m
[32m+[m[32m  *         it is equivalent to FLASH_WaitForLastBank1Operation.[m
[32m+[m[32m  *         - For STM32F10X_XL devices this function waits for a Bank1 Flash operation[m
[32m+[m[32m  *           to complete or a TIMEOUT to occur.[m
[32m+[m[32m  *         - For all other devices it waits for a Flash operation to complete[m[41m [m
[32m+[m[32m  *           or a TIMEOUT to occur.[m
[32m+[m[32m  * @param  Timeout: FLASH programming Timeout[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check for the Flash Status */[m
[32m+[m[32m  status = FLASH_GetBank1Status();[m
[32m+[m[32m  /* Wait for a Flash operation to complete or a TIMEOUT to occur */[m
[32m+[m[32m  while((status == FLASH_BUSY) && (Timeout != 0x00))[m
[32m+[m[32m  {[m
[32m+[m[32m    status = FLASH_GetBank1Status();[m
[32m+[m[32m    Timeout--;[m
[32m+[m[32m  }[m
[32m+[m[32m  if(Timeout == 0x00 )[m
[32m+[m[32m  {[m
[32m+[m[32m    status = FLASH_TIMEOUT;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the operation status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Waits for a Flash operation on Bank1 to complete or a TIMEOUT to occur.[m
[32m+[m[32m  * @note   This function can be used for all STM32F10x devices,[m[41m [m
[32m+[m[32m  *         it is equivalent to FLASH_WaitForLastOperation.[m
[32m+[m[32m  * @param  Timeout: FLASH programming Timeout[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check for the Flash Status */[m
[32m+[m[32m  status = FLASH_GetBank1Status();[m
[32m+[m[32m  /* Wait for a Flash operation to complete or a TIMEOUT to occur */[m
[32m+[m[32m  while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))[m
[32m+[m[32m  {[m
[32m+[m[32m    status = FLASH_GetBank1Status();[m
[32m+[m[32m    Timeout--;[m
[32m+[m[32m  }[m
[32m+[m[32m  if(Timeout == 0x00 )[m
[32m+[m[32m  {[m
[32m+[m[32m    status = FLASH_TIMEOUT;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the operation status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Waits for a Flash operation on Bank2 to complete or a TIMEOUT to occur.[m
[32m+[m[32m  * @note   This function can be used only for STM32F10x_XL density devices.[m
[32m+[m[32m  * @param  Timeout: FLASH programming Timeout[m
[32m+[m[32m  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,[m
[32m+[m[32m  *         FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.[m
[32m+[m[32m  */[m
[32m+[m[32mFLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  FLASH_Status status = FLASH_COMPLETE;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check for the Flash Status */[m
[32m+[m[32m  status = FLASH_GetBank2Status();[m
[32m+[m[32m  /* Wait for a Flash operation to complete or a TIMEOUT to occur */[m
[32m+[m[32m  while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))[m
[32m+[m[32m  {[m
[32m+[m[32m    status = FLASH_GetBank2Status();[m
[32m+[m[32m    Timeout--;[m
[32m+[m[32m  }[m
[32m+[m[32m  if(Timeout == 0x00 )[m
[32m+[m[32m  {[m
[32m+[m[32m    status = FLASH_TIMEOUT;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the operation status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c[m
[1mnew file mode 100644[m
[1mindex 0000000..51669ee[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_fsmc.c[m
[36m@@ -0,0 +1,866 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_fsmc.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the FSMC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_fsmc.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC[m[41m [m
[32m+[m[32m  * @brief FSMC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* --------------------- FSMC registers bit mask ---------------------------- */[m
[32m+[m
[32m+[m[32m/* FSMC BCRx Mask */[m
[32m+[m[32m#define BCR_MBKEN_Set                       ((uint32_t)0x00000001)[m
[32m+[m[32m#define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)[m
[32m+[m[32m#define BCR_FACCEN_Set                      ((uint32_t)0x00000040)[m
[32m+[m
[32m+[m[32m/* FSMC PCRx Mask */[m
[32m+[m[32m#define PCR_PBKEN_Set                       ((uint32_t)0x00000004)[m
[32m+[m[32m#define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)[m
[32m+[m[32m#define PCR_ECCEN_Set                       ((uint32_t)0x00000040)[m
[32m+[m[32m#define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)[m
[32m+[m[32m#define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup FSMC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default[m[41m [m
[32m+[m[32m  *         reset values.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1[m[41m  [m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4[m[41m [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameter */[m
[32m+[m[32m  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));[m
[32m+[m[41m  [m
[32m+[m[32m  /* FSMC_Bank1_NORSRAM1 */[m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;[m[41m    [m
[32m+[m[32m  }[m
[32m+[m[32m  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m[41m   [m
[32m+[m[32m    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2;[m[41m [m
[32m+[m[32m  }[m
[32m+[m[32m  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;[m
[32m+[m[32m  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m[41m [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NANDDeInit(uint32_t FSMC_Bank)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameter */[m
[32m+[m[32m  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));[m
[32m+[m[41m  [m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the FSMC_Bank2 registers to their reset values */[m
[32m+[m[32m    FSMC_Bank2->PCR2 = 0x00000018;[m
[32m+[m[32m    FSMC_Bank2->SR2 = 0x00000040;[m
[32m+[m[32m    FSMC_Bank2->PMEM2 = 0xFCFCFCFC;[m
[32m+[m[32m    FSMC_Bank2->PATT2 = 0xFCFCFCFC;[m[41m  [m
[32m+[m[32m  }[m
[32m+[m[32m  /* FSMC_Bank3_NAND */[m[41m  [m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the FSMC_Bank3 registers to their reset values */[m
[32m+[m[32m    FSMC_Bank3->PCR3 = 0x00000018;[m
[32m+[m[32m    FSMC_Bank3->SR3 = 0x00000040;[m
[32m+[m[32m    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;[m
[32m+[m[32m    FSMC_Bank3->PATT3 = 0xFCFCFCFC;[m[41m [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.[m
[32m+[m[32m  * @param  None[m[41m                       [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_PCCARDDeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the FSMC_Bank4 registers to their reset values */[m
[32m+[m[32m  FSMC_Bank4->PCR4 = 0x00000018;[m[41m [m
[32m+[m[32m  FSMC_Bank4->SR4 = 0x00000000;[m[41m	[m
[32m+[m[32m  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;[m
[32m+[m[32m  FSMC_Bank4->PATT4 = 0xFCFCFCFC;[m
[32m+[m[32m  FSMC_Bank4->PIO4 = 0xFCFCFCFC;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified[m
[32m+[m[32m  *         parameters in the FSMC_NORSRAMInitStruct.[m
[32m+[m[32m  * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef[m
[32m+[m[32m  *         structure that contains the configuration information for[m[41m [m
[32m+[m[32m  *        the FSMC NOR/SRAM specified Banks.[m[41m                       [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));[m
[32m+[m[32m  assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));[m
[32m+[m[32m  assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));[m
[32m+[m[32m  assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));[m
[32m+[m[32m  assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));[m
[32m+[m[32m  assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));[m
[32m+[m[32m  assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));[m
[32m+[m[32m  assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));[m
[32m+[m[32m  assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));[m
[32m+[m[32m  assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));[m[41m  [m
[32m+[m[32m  assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));[m
[32m+[m[32m  assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));[m
[32m+[m[32m  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));[m
[32m+[m[32m  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));[m
[32m+[m[32m  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  /* Bank1 NOR/SRAM control register configuration */[m[41m [m
[32m+[m[32m  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] =[m[41m [m
[32m+[m[32m            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_MemoryType |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_WrapMode |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |[m
[32m+[m[32m            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;[m
[32m+[m
[32m+[m[32m  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Bank1 NOR/SRAM timing register configuration */[m
[32m+[m[32m  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] =[m[41m [m
[32m+[m[32m            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |[m
[32m+[m[32m            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |[m
[32m+[m[32m            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |[m
[32m+[m[32m            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |[m
[32m+[m[32m            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |[m
[32m+[m[32m            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |[m
[32m+[m[32m             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;[m
[32m+[m[41m            [m
[32m+[m[41m    [m
[32m+[m[32m  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */[m
[32m+[m[32m  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));[m
[32m+[m[32m    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));[m
[32m+[m[32m    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));[m
[32m+[m[32m    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));[m
[32m+[m[32m    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));[m
[32m+[m[32m    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));[m
[32m+[m[32m    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] =[m[41m [m
[32m+[m[32m              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |[m
[32m+[m[32m              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|[m
[32m+[m[32m              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |[m
[32m+[m[32m              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |[m
[32m+[m[32m              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |[m
[32m+[m[32m               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the FSMC NAND Banks according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the FSMC_NANDInitStruct.[m
[32m+[m[32m  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef[m[41m [m
[32m+[m[32m  *         structure that contains the configuration information for the FSMC[m[41m [m
[32m+[m[32m  *         NAND specified Banks.[m[41m                       [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000;[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));[m
[32m+[m[32m  assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));[m
[32m+[m[32m  assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));[m
[32m+[m[32m  assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));[m
[32m+[m[32m  assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));[m
[32m+[m[32m  assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));[m
[32m+[m[32m  assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */[m
[32m+[m[32m  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |[m
[32m+[m[32m            PCR_MemoryType_NAND |[m
[32m+[m[32m            FSMC_NANDInitStruct->FSMC_MemoryDataWidth |[m
[32m+[m[32m            FSMC_NANDInitStruct->FSMC_ECC |[m
[32m+[m[32m            FSMC_NANDInitStruct->FSMC_ECCPageSize |[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);[m
[32m+[m[41m            [m
[32m+[m[32m  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */[m
[32m+[m[32m  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24);[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */[m
[32m+[m[32m  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|[m
[32m+[m[32m            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);[m
[32m+[m[41m  [m
[32m+[m[32m  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* FSMC_Bank2_NAND registers configuration */[m
[32m+[m[32m    FSMC_Bank2->PCR2 = tmppcr;[m
[32m+[m[32m    FSMC_Bank2->PMEM2 = tmppmem;[m
[32m+[m[32m    FSMC_Bank2->PATT2 = tmppatt;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* FSMC_Bank3_NAND registers configuration */[m
[32m+[m[32m    FSMC_Bank3->PCR3 = tmppcr;[m
[32m+[m[32m    FSMC_Bank3->PMEM3 = tmppmem;[m
[32m+[m[32m    FSMC_Bank3->PATT3 = tmppatt;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the FSMC PCCARD Bank according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the FSMC_PCCARDInitStruct.[m
[32m+[m[32m  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef[m
[32m+[m[32m  *         structure that contains the configuration information for the FSMC[m[41m [m
[32m+[m[32m  *         PCCARD Bank.[m[41m                       [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));[m
[32m+[m[32m  assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));[m
[32m+[m[41m [m
[32m+[m[32m  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));[m
[32m+[m[41m  [m
[32m+[m[32m  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));[m
[32m+[m[32m  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */[m
[32m+[m[32m  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |[m
[32m+[m[32m                     FSMC_MemoryDataWidth_16b |[m[41m  [m
[32m+[m[32m                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |[m
[32m+[m[32m                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);[m
[32m+[m[41m            [m
[32m+[m[32m  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */[m
[32m+[m[32m  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |[m
[32m+[m[32m                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |[m
[32m+[m[32m                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|[m
[32m+[m[32m                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24);[m[41m [m
[32m+[m[41m            [m
[32m+[m[32m  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */[m
[32m+[m[32m  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |[m
[32m+[m[32m                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |[m
[32m+[m[32m                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|[m
[32m+[m[32m                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);[m[41m	[m
[32m+[m[41m            [m
[32m+[m[32m  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */[m
[32m+[m[32m  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |[m
[32m+[m[32m                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |[m
[32m+[m[32m                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|[m
[32m+[m[32m                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);[m[41m             [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.[m
[32m+[m[32m  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef[m[41m [m
[32m+[m[32m  *         structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  /* Reset NOR/SRAM Init structure parameters values */[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;[m[41m [m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;[m
[32m+[m[32m  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each FSMC_NANDInitStruct member with its default value.[m
[32m+[m[32m  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef[m[41m [m
[32m+[m[32m  *         structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Reset NAND Init structure parameters values */[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;[m[41m	  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.[m
[32m+[m[32m  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef[m[41m [m
[32m+[m[32m  *         structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset PCCARD Init structure parameters values */[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;[m[41m	[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;[m
[32m+[m[32m  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified NOR/SRAM Memory Bank.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1[m[41m  [m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4[m[41m [m
[32m+[m[32m  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */[m
[32m+[m[32m    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */[m
[32m+[m[32m    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified NAND Memory Bank.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */[m
[32m+[m[32m    if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */[m
[32m+[m[32m    if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the PCCARD Memory Bank.[m
[32m+[m[32m  * @param  NewState: new state of the PCCARD Memory Bank.[m[41m  [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_PCCARDCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */[m
[32m+[m[32m    FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */[m
[32m+[m[32m    FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the FSMC NAND ECC feature.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  * @param  NewState: new state of the FSMC NAND ECC feature.[m[41m  [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */[m
[32m+[m[32m    if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */[m
[32m+[m[32m    if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the error correction code register value.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  * @retval The Error Correction Code (ECC) value.[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t FSMC_GetECC(uint32_t FSMC_Bank)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t eccval = 0x00000000;[m
[32m+[m[41m  [m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the ECCR2 register value */[m
[32m+[m[32m    eccval = FSMC_Bank2->ECCR2;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the ECCR3 register value */[m
[32m+[m[32m    eccval = FSMC_Bank3->ECCR3;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the error correction code value */[m
[32m+[m[32m  return(eccval);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified FSMC interrupts.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD[m
[32m+[m[32m  * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt.[m[41m [m
[32m+[m[32m  *     @arg FSMC_IT_Level: Level edge detection interrupt.[m
[32m+[m[32m  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.[m
[32m+[m[32m  * @param  NewState: new state of the specified FSMC interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FSMC_IT(FSMC_IT));[m[41m	[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected FSMC_Bank2 interrupts */[m
[32m+[m[32m    if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank2->SR2 |= FSMC_IT;[m
[32m+[m[32m    }[m
[32m+[m[32m    /* Enable the selected FSMC_Bank3 interrupts */[m
[32m+[m[32m    else if (FSMC_Bank == FSMC_Bank3_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank3->SR3 |= FSMC_IT;[m
[32m+[m[32m    }[m
[32m+[m[32m    /* Enable the selected FSMC_Bank4 interrupts */[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank4->SR4 |= FSMC_IT;[m[41m    [m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected FSMC_Bank2 interrupts */[m
[32m+[m[32m    if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m    {[m
[32m+[m[41m      [m
[32m+[m[32m      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;[m
[32m+[m[32m    }[m
[32m+[m[32m    /* Disable the selected FSMC_Bank3 interrupts */[m
[32m+[m[32m    else if (FSMC_Bank == FSMC_Bank3_NAND)[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;[m
[32m+[m[32m    }[m
[32m+[m[32m    /* Disable the selected FSMC_Bank4 interrupts */[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;[m[41m    [m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified FSMC flag is set or not.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD[m
[32m+[m[32m  * @param  FSMC_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.[m
[32m+[m[32m  *     @arg FSMC_FLAG_Level: Level detection Flag.[m
[32m+[m[32m  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.[m
[32m+[m[32m  *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag.[m[41m [m
[32m+[m[32m  * @retval The new state of FSMC_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t tmpsr = 0x00000000;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));[m
[32m+[m[41m  [m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpsr = FSMC_Bank2->SR2;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if(FSMC_Bank == FSMC_Bank3_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpsr = FSMC_Bank3->SR3;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* FSMC_Bank4_PCCARD*/[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpsr = FSMC_Bank4->SR4;[m
[32m+[m[32m  }[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the flag status */[m
[32m+[m[32m  if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the flag status */[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the FSMC's pending flags.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD[m
[32m+[m[32m  * @param  FSMC_FLAG: specifies the flag to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.[m
[32m+[m[32m  *     @arg FSMC_FLAG_Level: Level detection Flag.[m
[32m+[m[32m  *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;[m
[32m+[m[41m    [m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank2->SR2 &= ~FSMC_FLAG;[m[41m [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if(FSMC_Bank == FSMC_Bank3_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank3->SR3 &= ~FSMC_FLAG;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* FSMC_Bank4_PCCARD*/[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank4->SR4 &= ~FSMC_FLAG;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified FSMC interrupt has occurred or not.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD[m
[32m+[m[32m  * @param  FSMC_IT: specifies the FSMC interrupt source to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt.[m[41m [m
[32m+[m[32m  *     @arg FSMC_IT_Level: Level edge detection interrupt.[m
[32m+[m[32m  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.[m[41m [m
[32m+[m[32m  * @retval The new state of FSMC_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0;[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FSMC_GET_IT(FSMC_IT));[m
[32m+[m[41m  [m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpsr = FSMC_Bank2->SR2;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if(FSMC_Bank == FSMC_Bank3_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpsr = FSMC_Bank3->SR3;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* FSMC_Bank4_PCCARD*/[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpsr = FSMC_Bank4->SR4;[m
[32m+[m[32m  }[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  itstatus = tmpsr & FSMC_IT;[m
[32m+[m[41m  [m
[32m+[m[32m  itenable = tmpsr & (FSMC_IT >> 3);[m
[32m+[m[32m  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the FSMC's interrupt pending bits.[m
[32m+[m[32m  * @param  FSMC_Bank: specifies the FSMC Bank to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND[m[41m [m
[32m+[m[32m  *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND[m
[32m+[m[32m  *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD[m
[32m+[m[32m  * @param  FSMC_IT: specifies the interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt.[m[41m [m
[32m+[m[32m  *     @arg FSMC_IT_Level: Level edge detection interrupt.[m
[32m+[m[32m  *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));[m
[32m+[m[32m  assert_param(IS_FSMC_IT(FSMC_IT));[m
[32m+[m[41m    [m
[32m+[m[32m  if(FSMC_Bank == FSMC_Bank2_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3);[m[41m [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if(FSMC_Bank == FSMC_Bank3_NAND)[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);[m
[32m+[m[32m  }[m
[32m+[m[32m  /* FSMC_Bank4_PCCARD*/[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c[m
[1mnew file mode 100644[m
[1mindex 0000000..457ff11[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_gpio.c[m
[36m@@ -0,0 +1,650 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_gpio.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the GPIO firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_gpio.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO[m[41m [m
[32m+[m[32m  * @brief GPIO driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* ------------ RCC registers bit address in the alias region ----------------*/[m
[32m+[m[32m#define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* --- EVENTCR Register -----*/[m
[32m+[m
[32m+[m[32m/* Alias word address of EVOE bit */[m
[32m+[m[32m#define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)[m
[32m+[m[32m#define EVOE_BitNumber              ((uint8_t)0x07)[m
[32m+[m[32m#define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))[m
[32m+[m
[32m+[m
[32m+[m[32m/* ---  MAPR Register ---*/[m[41m [m
[32m+[m[32m/* Alias word address of MII_RMII_SEL bit */[m[41m [m
[32m+[m[32m#define MAPR_OFFSET                 (AFIO_OFFSET + 0x04)[m[41m [m
[32m+[m[32m#define MII_RMII_SEL_BitNumber      ((u8)0x17)[m[41m [m
[32m+[m[32m#define MAPR_MII_RMII_SEL_BB        (PERIPH_BB_BASE + (MAPR_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4))[m
[32m+[m
[32m+[m
[32m+[m[32m#define EVCR_PORTPINCONFIG_MASK     ((uint16_t)0xFF80)[m
[32m+[m[32m#define LSB_MASK                    ((uint16_t)0xFFFF)[m
[32m+[m[32m#define DBGAFR_POSITION_MASK        ((uint32_t)0x000F0000)[m
[32m+[m[32m#define DBGAFR_SWJCFG_MASK          ((uint32_t)0xF0FFFFFF)[m
[32m+[m[32m#define DBGAFR_LOCATION_MASK        ((uint32_t)0x00200000)[m
[32m+[m[32m#define DBGAFR_NUMBITS_MASK         ((uint32_t)0x00100000)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup GPIO_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_DeInit(GPIO_TypeDef* GPIOx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[41m  [m
[32m+[m[32m  if (GPIOx == GPIOA)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (GPIOx == GPIOB)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (GPIOx == GPIOC)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (GPIOx == GPIOD)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  else if (GPIOx == GPIOE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else if (GPIOx == GPIOF)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if (GPIOx == GPIOG)[m
[32m+[m[32m    {[m
[32m+[m[32m      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);[m
[32m+[m[32m      RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the Alternate Functions (remap, event control[m
[32m+[m[32m  *   and EXTI configuration) registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_AFIODeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);[m
[32m+[m[32m  RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the GPIOx peripheral according to the specified[m
[32m+[m[32m  *         parameters in the GPIO_InitStruct.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that[m
[32m+[m[32m  *         contains the configuration information for the specified GPIO peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;[m
[32m+[m[32m  uint32_t tmpreg = 0x00, pinmask = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));[m
[32m+[m[32m  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m/*---------------------------- GPIO Mode Configuration -----------------------*/[m
[32m+[m[32m  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);[m
[32m+[m[32m  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* Check the parameters */[m
[32m+[m[32m    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));[m
[32m+[m[32m    /* Output mode */[m
[32m+[m[32m    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;[m
[32m+[m[32m  }[m
[32m+[m[32m/*---------------------------- GPIO CRL Configuration ------------------------*/[m
[32m+[m[32m  /* Configure the eight low port pins */[m
[32m+[m[32m  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg = GPIOx->CRL;[m
[32m+[m[32m    for (pinpos = 0x00; pinpos < 0x08; pinpos++)[m
[32m+[m[32m    {[m
[32m+[m[32m      pos = ((uint32_t)0x01) << pinpos;[m
[32m+[m[32m      /* Get the port pins position */[m
[32m+[m[32m      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;[m
[32m+[m[32m      if (currentpin == pos)[m
[32m+[m[32m      {[m
[32m+[m[32m        pos = pinpos << 2;[m
[32m+[m[32m        /* Clear the corresponding low control register bits */[m
[32m+[m[32m        pinmask = ((uint32_t)0x0F) << pos;[m
[32m+[m[32m        tmpreg &= ~pinmask;[m
[32m+[m[32m        /* Write the mode configuration in the corresponding bits */[m
[32m+[m[32m        tmpreg |= (currentmode << pos);[m
[32m+[m[32m        /* Reset the corresponding ODR bit */[m
[32m+[m[32m        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)[m
[32m+[m[32m        {[m
[32m+[m[32m          GPIOx->BRR = (((uint32_t)0x01) << pinpos);[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m          /* Set the corresponding ODR bit */[m
[32m+[m[32m          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)[m
[32m+[m[32m          {[m
[32m+[m[32m            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);[m
[32m+[m[32m          }[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    GPIOx->CRL = tmpreg;[m
[32m+[m[32m  }[m
[32m+[m[32m/*---------------------------- GPIO CRH Configuration ------------------------*/[m
[32m+[m[32m  /* Configure the eight high port pins */[m
[32m+[m[32m  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg = GPIOx->CRH;[m
[32m+[m[32m    for (pinpos = 0x00; pinpos < 0x08; pinpos++)[m
[32m+[m[32m    {[m
[32m+[m[32m      pos = (((uint32_t)0x01) << (pinpos + 0x08));[m
[32m+[m[32m      /* Get the port pins position */[m
[32m+[m[32m      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);[m
[32m+[m[32m      if (currentpin == pos)[m
[32m+[m[32m      {[m
[32m+[m[32m        pos = pinpos << 2;[m
[32m+[m[32m        /* Clear the corresponding high control register bits */[m
[32m+[m[32m        pinmask = ((uint32_t)0x0F) << pos;[m
[32m+[m[32m        tmpreg &= ~pinmask;[m
[32m+[m[32m        /* Write the mode configuration in the corresponding bits */[m
[32m+[m[32m        tmpreg |= (currentmode << pos);[m
[32m+[m[32m        /* Reset the corresponding ODR bit */[m
[32m+[m[32m        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)[m
[32m+[m[32m        {[m
[32m+[m[32m          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));[m
[32m+[m[32m        }[m
[32m+[m[32m        /* Set the corresponding ODR bit */[m
[32m+[m[32m        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)[m
[32m+[m[32m        {[m
[32m+[m[32m          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m    }[m
[32m+[m[32m    GPIOx->CRH = tmpreg;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each GPIO_InitStruct member with its default value.[m
[32m+[m[32m  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will[m
[32m+[m[32m  *         be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset GPIO init structure parameters values */[m
[32m+[m[32m  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;[m
[32m+[m[32m  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;[m
[32m+[m[32m  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reads the specified input port pin.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_Pin:  specifies the port bit to read.[m
[32m+[m[32m  *   This parameter can be GPIO_Pin_x where x can be (0..15).[m
[32m+[m[32m  * @retval The input port pin value.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t bitstatus = 0x00;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = (uint8_t)Bit_SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = (uint8_t)Bit_RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reads the specified GPIO input data port.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @retval GPIO input data port value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[41m  [m
[32m+[m[32m  return ((uint16_t)GPIOx->IDR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reads the specified output data port bit.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_Pin:  specifies the port bit to read.[m
[32m+[m[32m  *   This parameter can be GPIO_Pin_x where x can be (0..15).[m
[32m+[m[32m  * @retval The output port pin value.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)[m
[32m+[m[32m{[m
[32m+[m[32m  uint8_t bitstatus = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = (uint8_t)Bit_SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = (uint8_t)Bit_RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reads the specified GPIO output data port.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @retval GPIO output data port value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[41m    [m
[32m+[m[32m  return ((uint16_t)GPIOx->ODR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the selected data port bits.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_Pin: specifies the port bits to be written.[m
[32m+[m[32m  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GPIO_PIN(GPIO_Pin));[m
[32m+[m[41m  [m
[32m+[m[32m  GPIOx->BSRR = GPIO_Pin;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the selected data port bits.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_Pin: specifies the port bits to be written.[m
[32m+[m[32m  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GPIO_PIN(GPIO_Pin));[m
[32m+[m[41m  [m
[32m+[m[32m  GPIOx->BRR = GPIO_Pin;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets or clears the selected data port bit.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_Pin: specifies the port bit to be written.[m
[32m+[m[32m  *   This parameter can be one of GPIO_Pin_x where x can be (0..15).[m
[32m+[m[32m  * @param  BitVal: specifies the value to be written to the selected bit.[m
[32m+[m[32m  *   This parameter can be one of the BitAction enum values:[m
[32m+[m[32m  *     @arg Bit_RESET: to clear the port pin[m
[32m+[m[32m  *     @arg Bit_SET: to set the port pin[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));[m
[32m+[m[32m  assert_param(IS_GPIO_BIT_ACTION(BitVal));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  if (BitVal != Bit_RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    GPIOx->BSRR = GPIO_Pin;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    GPIOx->BRR = GPIO_Pin;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Writes data to the specified GPIO data port.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  PortVal: specifies the value to be written to the port output data register.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[41m  [m
[32m+[m[32m  GPIOx->ODR = PortVal;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Locks GPIO Pins configuration registers.[m
[32m+[m[32m  * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.[m
[32m+[m[32m  * @param  GPIO_Pin: specifies the port bit to be written.[m
[32m+[m[32m  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0x00010000;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));[m
[32m+[m[32m  assert_param(IS_GPIO_PIN(GPIO_Pin));[m
[32m+[m[41m  [m
[32m+[m[32m  tmp |= GPIO_Pin;[m
[32m+[m[32m  /* Set LCKK bit */[m
[32m+[m[32m  GPIOx->LCKR = tmp;[m
[32m+[m[32m  /* Reset LCKK bit */[m
[32m+[m[32m  GPIOx->LCKR =  GPIO_Pin;[m
[32m+[m[32m  /* Set LCKK bit */[m
[32m+[m[32m  GPIOx->LCKR = tmp;[m
[32m+[m[32m  /* Read LCKK bit*/[m
[32m+[m[32m  tmp = GPIOx->LCKR;[m
[32m+[m[32m  /* Read LCKK bit*/[m
[32m+[m[32m  tmp = GPIOx->LCKR;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the GPIO pin used as Event output.[m
[32m+[m[32m  * @param  GPIO_PortSource: selects the GPIO port to be used as source[m
[32m+[m[32m  *   for Event output.[m
[32m+[m[32m  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..E).[m
[32m+[m[32m  * @param  GPIO_PinSource: specifies the pin for the Event output.[m
[32m+[m[32m  *   This parameter can be GPIO_PinSourcex where x can be (0..15).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));[m
[32m+[m[32m  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));[m
[32m+[m[41m    [m
[32m+[m[32m  tmpreg = AFIO->EVCR;[m
[32m+[m[32m  /* Clear the PORT[6:4] and PIN[3:0] bits */[m
[32m+[m[32m  tmpreg &= EVCR_PORTPINCONFIG_MASK;[m
[32m+[m[32m  tmpreg |= (uint32_t)GPIO_PortSource << 0x04;[m
[32m+[m[32m  tmpreg |= GPIO_PinSource;[m
[32m+[m[32m  AFIO->EVCR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Event Output.[m
[32m+[m[32m  * @param  NewState: new state of the Event output.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_EventOutputCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Changes the mapping of the specified pin.[m
[32m+[m[32m  * @param  GPIO_Remap: selects the pin to remap.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg GPIO_Remap_SPI1             : SPI1 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap_I2C1             : I2C1 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap_USART1           : USART1 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap_USART2           : USART2 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_PartialRemap_USART3    : USART3 Partial Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_FullRemap_USART3       : USART3 Full Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_PartialRemap_TIM1      : TIM1 Partial Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_FullRemap_TIM1         : TIM1 Full Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_PartialRemap1_TIM2     : TIM2 Partial1 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_PartialRemap2_TIM2     : TIM2 Partial2 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_FullRemap_TIM2         : TIM2 Full Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_PartialRemap_TIM3      : TIM3 Partial Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_FullRemap_TIM3         : TIM3 Full Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM4             : TIM4 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap1_CAN1            : CAN1 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap2_CAN1            : CAN1 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap_PD01             : PD01 Alternate Function mapping[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM5CH4_LSI      : LSI connected to TIM5 Channel4 input capture for calibration[m
[32m+[m[32m  *     @arg GPIO_Remap_ADC1_ETRGINJ     : ADC1 External Trigger Injected Conversion remapping[m
[32m+[m[32m  *     @arg GPIO_Remap_ADC1_ETRGREG     : ADC1 External Trigger Regular Conversion remapping[m
[32m+[m[32m  *     @arg GPIO_Remap_ADC2_ETRGINJ     : ADC2 External Trigger Injected Conversion remapping[m
[32m+[m[32m  *     @arg GPIO_Remap_ADC2_ETRGREG     : ADC2 External Trigger Regular Conversion remapping[m
[32m+[m[32m  *     @arg GPIO_Remap_ETH              : Ethernet remapping (only for Connectivity line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_CAN2             : CAN2 remapping (only for Connectivity line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_SWJ_NoJTRST      : Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST[m
[32m+[m[32m  *     @arg GPIO_Remap_SWJ_JTAGDisable  : JTAG-DP Disabled and SW-DP Enabled[m
[32m+[m[32m  *     @arg GPIO_Remap_SWJ_Disable      : Full SWJ Disabled (JTAG-DP + SW-DP)[m
[32m+[m[32m  *     @arg GPIO_Remap_SPI3             : SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices)[m
[32m+[m[32m  *                                        When the SPI3/I2S3 is remapped using this function, the SWJ is configured[m
[32m+[m[32m  *                                        to Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST.[m[41m   [m
[32m+[m[32m  *     @arg GPIO_Remap_TIM2ITR1_PTP_SOF : Ethernet PTP output or USB OTG SOF (Start of Frame) connected[m
[32m+[m[32m  *                                        to TIM2 Internal Trigger 1 for calibration (only for Connectivity line devices)[m
[32m+[m[32m  *                                        If the GPIO_Remap_TIM2ITR1_PTP_SOF is enabled the TIM2 ITR1 is connected to[m[41m [m
[32m+[m[32m  *                                        Ethernet PTP output. When Reset TIM2 ITR1 is connected to USB OTG SOF output.[m[41m    [m
[32m+[m[32m  *     @arg GPIO_Remap_PTP_PPS          : Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM15            : TIM15 Alternate Function mapping (only for Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM16            : TIM16 Alternate Function mapping (only for Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM17            : TIM17 Alternate Function mapping (only for Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_CEC              : CEC Alternate Function mapping (only for Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM1_DMA         : TIM1 DMA requests mapping (only for Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM9             : TIM9 Alternate Function mapping (only for XL-density devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM10            : TIM10 Alternate Function mapping (only for XL-density devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM11            : TIM11 Alternate Function mapping (only for XL-density devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM13            : TIM13 Alternate Function mapping (only for High density Value line and XL-density devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM14            : TIM14 Alternate Function mapping (only for High density Value line and XL-density devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_FSMC_NADV        : FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM67_DAC_DMA    : TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_TIM12            : TIM12 Alternate Function mapping (only for High density Value line devices)[m
[32m+[m[32m  *     @arg GPIO_Remap_MISC             : Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping,[m[41m [m
[32m+[m[32m  *                                        only for High density Value line devices)[m[41m     [m
[32m+[m[32m  * @param  NewState: new state of the port pin remapping.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_REMAP(GPIO_Remap));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m  if((GPIO_Remap & 0x80000000) == 0x80000000)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg = AFIO->MAPR2;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg = AFIO->MAPR;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;[m
[32m+[m[32m  tmp = GPIO_Remap & LSB_MASK;[m
[32m+[m
[32m+[m[32m  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg &= DBGAFR_SWJCFG_MASK;[m
[32m+[m[32m    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmp1 = ((uint32_t)0x03) << tmpmask;[m
[32m+[m[32m    tmpreg &= ~tmp1;[m
[32m+[m[32m    tmpreg |= ~DBGAFR_SWJCFG_MASK;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));[m
[32m+[m[32m    tmpreg |= ~DBGAFR_SWJCFG_MASK;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  if((GPIO_Remap & 0x80000000) == 0x80000000)[m
[32m+[m[32m  {[m
[32m+[m[32m    AFIO->MAPR2 = tmpreg;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    AFIO->MAPR = tmpreg;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the GPIO pin used as EXTI Line.[m
[32m+[m[32m  * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.[m
[32m+[m[32m  *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).[m
[32m+[m[32m  * @param  GPIO_PinSource: specifies the EXTI line to be configured.[m
[32m+[m[32m  *   This parameter can be GPIO_PinSourcex where x can be (0..15).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));[m
[32m+[m[32m  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));[m
[32m+[m[41m  [m
[32m+[m[32m  tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));[m
[32m+[m[32m  AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;[m
[32m+[m[32m  AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the Ethernet media interface.[m
[32m+[m[32m  * @note   This function applies only to STM32 Connectivity line devices.[m[41m  [m
[32m+[m[32m  * @param  GPIO_ETH_MediaInterface: specifies the Media Interface mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg GPIO_ETH_MediaInterface_MII: MII mode[m
[32m+[m[32m  *     @arg GPIO_ETH_MediaInterface_RMII: RMII mode[m[41m    [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface)[m[41m [m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface));[m[41m [m
[32m+[m
[32m+[m[32m  /* Configure MII_RMII selection bit */[m[41m [m
[32m+[m[32m  *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface;[m[41m [m
[32m+[m[32m}[m
[32m+[m[41m  [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c[m
[1mnew file mode 100644[m
[1mindex 0000000..4ea321c[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_i2c.c[m
[36m@@ -0,0 +1,1331 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_i2c.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the I2C firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_i2c.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C[m[41m [m
[32m+[m[32m  * @brief I2C driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* I2C SPE mask */[m
[32m+[m[32m#define CR1_PE_Set              ((uint16_t)0x0001)[m
[32m+[m[32m#define CR1_PE_Reset            ((uint16_t)0xFFFE)[m
[32m+[m
[32m+[m[32m/* I2C START mask */[m
[32m+[m[32m#define CR1_START_Set           ((uint16_t)0x0100)[m
[32m+[m[32m#define CR1_START_Reset         ((uint16_t)0xFEFF)[m
[32m+[m
[32m+[m[32m/* I2C STOP mask */[m
[32m+[m[32m#define CR1_STOP_Set            ((uint16_t)0x0200)[m
[32m+[m[32m#define CR1_STOP_Reset          ((uint16_t)0xFDFF)[m
[32m+[m
[32m+[m[32m/* I2C ACK mask */[m
[32m+[m[32m#define CR1_ACK_Set             ((uint16_t)0x0400)[m
[32m+[m[32m#define CR1_ACK_Reset           ((uint16_t)0xFBFF)[m
[32m+[m
[32m+[m[32m/* I2C ENGC mask */[m
[32m+[m[32m#define CR1_ENGC_Set            ((uint16_t)0x0040)[m
[32m+[m[32m#define CR1_ENGC_Reset          ((uint16_t)0xFFBF)[m
[32m+[m
[32m+[m[32m/* I2C SWRST mask */[m
[32m+[m[32m#define CR1_SWRST_Set           ((uint16_t)0x8000)[m
[32m+[m[32m#define CR1_SWRST_Reset         ((uint16_t)0x7FFF)[m
[32m+[m
[32m+[m[32m/* I2C PEC mask */[m
[32m+[m[32m#define CR1_PEC_Set             ((uint16_t)0x1000)[m
[32m+[m[32m#define CR1_PEC_Reset           ((uint16_t)0xEFFF)[m
[32m+[m
[32m+[m[32m/* I2C ENPEC mask */[m
[32m+[m[32m#define CR1_ENPEC_Set           ((uint16_t)0x0020)[m
[32m+[m[32m#define CR1_ENPEC_Reset         ((uint16_t)0xFFDF)[m
[32m+[m
[32m+[m[32m/* I2C ENARP mask */[m
[32m+[m[32m#define CR1_ENARP_Set           ((uint16_t)0x0010)[m
[32m+[m[32m#define CR1_ENARP_Reset         ((uint16_t)0xFFEF)[m
[32m+[m
[32m+[m[32m/* I2C NOSTRETCH mask */[m
[32m+[m[32m#define CR1_NOSTRETCH_Set       ((uint16_t)0x0080)[m
[32m+[m[32m#define CR1_NOSTRETCH_Reset     ((uint16_t)0xFF7F)[m
[32m+[m
[32m+[m[32m/* I2C registers Masks */[m
[32m+[m[32m#define CR1_CLEAR_Mask          ((uint16_t)0xFBF5)[m
[32m+[m
[32m+[m[32m/* I2C DMAEN mask */[m
[32m+[m[32m#define CR2_DMAEN_Set           ((uint16_t)0x0800)[m
[32m+[m[32m#define CR2_DMAEN_Reset         ((uint16_t)0xF7FF)[m
[32m+[m
[32m+[m[32m/* I2C LAST mask */[m
[32m+[m[32m#define CR2_LAST_Set            ((uint16_t)0x1000)[m
[32m+[m[32m#define CR2_LAST_Reset          ((uint16_t)0xEFFF)[m
[32m+[m
[32m+[m[32m/* I2C FREQ mask */[m
[32m+[m[32m#define CR2_FREQ_Reset          ((uint16_t)0xFFC0)[m
[32m+[m
[32m+[m[32m/* I2C ADD0 mask */[m
[32m+[m[32m#define OAR1_ADD0_Set           ((uint16_t)0x0001)[m
[32m+[m[32m#define OAR1_ADD0_Reset         ((uint16_t)0xFFFE)[m
[32m+[m
[32m+[m[32m/* I2C ENDUAL mask */[m
[32m+[m[32m#define OAR2_ENDUAL_Set         ((uint16_t)0x0001)[m
[32m+[m[32m#define OAR2_ENDUAL_Reset       ((uint16_t)0xFFFE)[m
[32m+[m
[32m+[m[32m/* I2C ADD2 mask */[m
[32m+[m[32m#define OAR2_ADD2_Reset         ((uint16_t)0xFF01)[m
[32m+[m
[32m+[m[32m/* I2C F/S mask */[m
[32m+[m[32m#define CCR_FS_Set              ((uint16_t)0x8000)[m
[32m+[m
[32m+[m[32m/* I2C CCR mask */[m
[32m+[m[32m#define CCR_CCR_Set             ((uint16_t)0x0FFF)[m
[32m+[m
[32m+[m[32m/* I2C FLAG mask */[m
[32m+[m[32m#define FLAG_Mask               ((uint32_t)0x00FFFFFF)[m
[32m+[m
[32m+[m[32m/* I2C Interrupt Enable mask */[m
[32m+[m[32m#define ITEN_Mask               ((uint32_t)0x07000000)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup I2C_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_DeInit(I2C_TypeDef* I2Cx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m
[32m+[m[32m  if (I2Cx == I2C1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable I2C1 reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);[m
[32m+[m[32m    /* Release I2C1 from reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable I2C2 reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);[m
[32m+[m[32m    /* Release I2C2 from reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the I2Cx peripheral according to the specified[m[41m [m
[32m+[m[32m  *   parameters in the I2C_InitStruct.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that[m
[32m+[m[32m  *   contains the configuration information for the specified I2C peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0, freqrange = 0;[m
[32m+[m[32m  uint16_t result = 0x04;[m
[32m+[m[32m  uint32_t pclk1 = 8000000;[m
[32m+[m[32m  RCC_ClocksTypeDef  rcc_clocks;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_CLOCK_SPEED(I2C_InitStruct->I2C_ClockSpeed));[m
[32m+[m[32m  assert_param(IS_I2C_MODE(I2C_InitStruct->I2C_Mode));[m
[32m+[m[32m  assert_param(IS_I2C_DUTY_CYCLE(I2C_InitStruct->I2C_DutyCycle));[m
[32m+[m[32m  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));[m
[32m+[m[32m  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));[m
[32m+[m[32m  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));[m
[32m+[m
[32m+[m[32m/*---------------------------- I2Cx CR2 Configuration ------------------------*/[m
[32m+[m[32m  /* Get the I2Cx CR2 value */[m
[32m+[m[32m  tmpreg = I2Cx->CR2;[m
[32m+[m[32m  /* Clear frequency FREQ[5:0] bits */[m
[32m+[m[32m  tmpreg &= CR2_FREQ_Reset;[m
[32m+[m[32m  /* Get pclk1 frequency value */[m
[32m+[m[32m  RCC_GetClocksFreq(&rcc_clocks);[m
[32m+[m[32m  pclk1 = rcc_clocks.PCLK1_Frequency;[m
[32m+[m[32m  /* Set frequency bits depending on pclk1 value */[m
[32m+[m[32m  freqrange = (uint16_t)(pclk1 / 1000000);[m
[32m+[m[32m  tmpreg |= freqrange;[m
[32m+[m[32m  /* Write to I2Cx CR2 */[m
[32m+[m[32m  I2Cx->CR2 = tmpreg;[m
[32m+[m
[32m+[m[32m/*---------------------------- I2Cx CCR Configuration ------------------------*/[m
[32m+[m[32m  /* Disable the selected I2C peripheral to configure TRISE */[m
[32m+[m[32m  I2Cx->CR1 &= CR1_PE_Reset;[m
[32m+[m[32m  /* Reset tmpreg value */[m
[32m+[m[32m  /* Clear F/S, DUTY and CCR[11:0] bits */[m
[32m+[m[32m  tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Configure speed in standard mode */[m
[32m+[m[32m  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Standard mode speed calculate */[m
[32m+[m[32m    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));[m
[32m+[m[32m    /* Test if CCR value is under 0x4*/[m
[32m+[m[32m    if (result < 0x04)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Set minimum allowed value */[m
[32m+[m[32m      result = 0x04;[m[41m  [m
[32m+[m[32m    }[m
[32m+[m[32m    /* Set speed value for standard mode */[m
[32m+[m[32m    tmpreg |= result;[m[41m	  [m
[32m+[m[32m    /* Set Maximum Rise Time for standard mode */[m
[32m+[m[32m    I2Cx->TRISE = freqrange + 1;[m[41m [m
[32m+[m[32m  }[m
[32m+[m[32m  /* Configure speed in fast mode */[m
[32m+[m[32m  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/[m
[32m+[m[32m  {[m
[32m+[m[32m    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Fast mode speed calculate: Tlow/Thigh = 2 */[m
[32m+[m[32m      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));[m
[32m+[m[32m    }[m
[32m+[m[32m    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */[m
[32m+[m[32m      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));[m
[32m+[m[32m      /* Set DUTY bit */[m
[32m+[m[32m      result |= I2C_DutyCycle_16_9;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Test if CCR value is under 0x1*/[m
[32m+[m[32m    if ((result & CCR_CCR_Set) == 0)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Set minimum allowed value */[m
[32m+[m[32m      result |= (uint16_t)0x0001;[m[41m  [m
[32m+[m[32m    }[m
[32m+[m[32m    /* Set speed value and set F/S bit for fast mode */[m
[32m+[m[32m    tmpreg |= (uint16_t)(result | CCR_FS_Set);[m
[32m+[m[32m    /* Set Maximum Rise Time for fast mode */[m
[32m+[m[32m    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);[m[41m  [m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Write to I2Cx CCR */[m
[32m+[m[32m  I2Cx->CCR = tmpreg;[m
[32m+[m[32m  /* Enable the selected I2C peripheral */[m
[32m+[m[32m  I2Cx->CR1 |= CR1_PE_Set;[m
[32m+[m
[32m+[m[32m/*---------------------------- I2Cx CR1 Configuration ------------------------*/[m
[32m+[m[32m  /* Get the I2Cx CR1 value */[m
[32m+[m[32m  tmpreg = I2Cx->CR1;[m
[32m+[m[32m  /* Clear ACK, SMBTYPE and  SMBUS bits */[m
[32m+[m[32m  tmpreg &= CR1_CLEAR_Mask;[m
[32m+[m[32m  /* Configure I2Cx: mode and acknowledgement */[m
[32m+[m[32m  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */[m
[32m+[m[32m  /* Set ACK bit according to I2C_Ack value */[m
[32m+[m[32m  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);[m
[32m+[m[32m  /* Write to I2Cx CR1 */[m
[32m+[m[32m  I2Cx->CR1 = tmpreg;[m
[32m+[m
[32m+[m[32m/*---------------------------- I2Cx OAR1 Configuration -----------------------*/[m
[32m+[m[32m  /* Set I2Cx Own Address1 and acknowledged address */[m
[32m+[m[32m  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each I2C_InitStruct member with its default value.[m
[32m+[m[32m  * @param  I2C_InitStruct: pointer to an I2C_InitTypeDef structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m/*---------------- Reset I2C init structure parameters values ----------------*/[m
[32m+[m[32m  /* initialize the I2C_ClockSpeed member */[m
[32m+[m[32m  I2C_InitStruct->I2C_ClockSpeed = 5000;[m
[32m+[m[32m  /* Initialize the I2C_Mode member */[m
[32m+[m[32m  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;[m
[32m+[m[32m  /* Initialize the I2C_DutyCycle member */[m
[32m+[m[32m  I2C_InitStruct->I2C_DutyCycle = I2C_DutyCycle_2;[m
[32m+[m[32m  /* Initialize the I2C_OwnAddress1 member */[m
[32m+[m[32m  I2C_InitStruct->I2C_OwnAddress1 = 0;[m
[32m+[m[32m  /* Initialize the I2C_Ack member */[m
[32m+[m[32m  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;[m
[32m+[m[32m  /* Initialize the I2C_AcknowledgedAddress member */[m
[32m+[m[32m  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C peripheral.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2Cx peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C peripheral */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_PE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C peripheral */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_PE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C DMA requests.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C DMA transfer.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C DMA requests */[m
[32m+[m[32m    I2Cx->CR2 |= CR2_DMAEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C DMA requests */[m
[32m+[m[32m    I2Cx->CR2 &= CR2_DMAEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Specifies if the next DMA transfer will be the last one.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C DMA last transfer.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Next DMA transfer is the last transfer */[m
[32m+[m[32m    I2Cx->CR2 |= CR2_LAST_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Next DMA transfer is not the last transfer */[m
[32m+[m[32m    I2Cx->CR2 &= CR2_LAST_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Generates I2Cx communication START condition.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C START condition generation.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Generate a START condition */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_START_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the START condition generation */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_START_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Generates I2Cx communication STOP condition.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C STOP condition generation.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Generate a STOP condition */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_STOP_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the STOP condition generation */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_STOP_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C acknowledge feature.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C Acknowledgement.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the acknowledgement */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_ACK_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the acknowledgement */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_ACK_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the specified I2C own address2.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  Address: specifies the 7bit I2C own address2.[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m
[32m+[m[32m  /* Get the old register value */[m
[32m+[m[32m  tmpreg = I2Cx->OAR2;[m
[32m+[m
[32m+[m[32m  /* Reset I2Cx Own address2 bit [7:1] */[m
[32m+[m[32m  tmpreg &= OAR2_ADD2_Reset;[m
[32m+[m
[32m+[m[32m  /* Set I2Cx Own address2 */[m
[32m+[m[32m  tmpreg |= (uint16_t)((uint16_t)Address & (uint16_t)0x00FE);[m
[32m+[m
[32m+[m[32m  /* Store the new register value */[m
[32m+[m[32m  I2Cx->OAR2 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C dual addressing mode.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C dual addressing mode.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable dual addressing mode */[m
[32m+[m[32m    I2Cx->OAR2 |= OAR2_ENDUAL_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable dual addressing mode */[m
[32m+[m[32m    I2Cx->OAR2 &= OAR2_ENDUAL_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C general call feature.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C General call.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable generall call */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_ENGC_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable generall call */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_ENGC_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C interrupts.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_IT: specifies the I2C interrupts sources to be enabled or disabled.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg I2C_IT_BUF: Buffer interrupt mask[m
[32m+[m[32m  *     @arg I2C_IT_EVT: Event interrupt mask[m
[32m+[m[32m  *     @arg I2C_IT_ERR: Error interrupt mask[m
[32m+[m[32m  * @param  NewState: new state of the specified I2C interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  assert_param(IS_I2C_CONFIG_IT(I2C_IT));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C interrupts */[m
[32m+[m[32m    I2Cx->CR2 |= I2C_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C interrupts */[m
[32m+[m[32m    I2Cx->CR2 &= (uint16_t)~I2C_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sends a data byte through the I2Cx peripheral.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  Data: Byte to be transmitted..[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  /* Write in the DR register the data to be sent */[m
[32m+[m[32m  I2Cx->DR = Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the most recent received data by the I2Cx peripheral.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @retval The value of the received data.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  /* Return the data in the DR register */[m
[32m+[m[32m  return (uint8_t)I2Cx->DR;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmits the address byte to select the slave device.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  Address: specifies the slave address which will be transmitted[m
[32m+[m[32m  * @param  I2C_Direction: specifies whether the I2C device will be a[m
[32m+[m[32m  *   Transmitter or a Receiver. This parameter can be one of the following values[m
[32m+[m[32m  *     @arg I2C_Direction_Transmitter: Transmitter mode[m
[32m+[m[32m  *     @arg I2C_Direction_Receiver: Receiver mode[m
[32m+[m[32m  * @retval None.[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_DIRECTION(I2C_Direction));[m
[32m+[m[32m  /* Test on the direction to set/reset the read/write bit */[m
[32m+[m[32m  if (I2C_Direction != I2C_Direction_Transmitter)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the address bit0 for read */[m
[32m+[m[32m    Address |= OAR1_ADD0_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the address bit0 for write */[m
[32m+[m[32m    Address &= OAR1_ADD0_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Send the address */[m
[32m+[m[32m  I2Cx->DR = Address;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reads the specified I2C register and returns its value.[m
[32m+[m[32m  * @param  I2C_Register: specifies the register to read.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_Register_CR1:  CR1 register.[m
[32m+[m[32m  *     @arg I2C_Register_CR2:   CR2 register.[m
[32m+[m[32m  *     @arg I2C_Register_OAR1:  OAR1 register.[m
[32m+[m[32m  *     @arg I2C_Register_OAR2:  OAR2 register.[m
[32m+[m[32m  *     @arg I2C_Register_DR:    DR register.[m
[32m+[m[32m  *     @arg I2C_Register_SR1:   SR1 register.[m
[32m+[m[32m  *     @arg I2C_Register_SR2:   SR2 register.[m
[32m+[m[32m  *     @arg I2C_Register_CCR:   CCR register.[m
[32m+[m[32m  *     @arg I2C_Register_TRISE: TRISE register.[m
[32m+[m[32m  * @retval The value of the read register.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_REGISTER(I2C_Register));[m
[32m+[m
[32m+[m[32m  tmp = (uint32_t) I2Cx;[m
[32m+[m[32m  tmp += I2C_Register;[m
[32m+[m
[32m+[m[32m  /* Return the selected register value */[m
[32m+[m[32m  return (*(__IO uint16_t *) tmp);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C software reset.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C software reset.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Peripheral under reset */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_SWRST_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Peripheral not under reset */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_SWRST_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the specified I2C NACK position in master receiver mode.[m
[32m+[m[32m  *         This function is useful in I2C Master Receiver mode when the number[m
[32m+[m[32m  *         of data to be received is equal to 2. In this case, this function[m[41m [m
[32m+[m[32m  *         should be called (with parameter I2C_NACKPosition_Next) before data[m[41m [m
[32m+[m[32m  *         reception starts,as described in the 2-byte reception procedure[m[41m [m
[32m+[m[32m  *         recommended in Reference Manual in Section: Master receiver.[m[41m                [m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_NACKPosition: specifies the NACK position.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_NACKPosition_Next: indicates that the next byte will be the last[m
[32m+[m[32m  *          received byte.[m[41m  [m
[32m+[m[32m  *     @arg I2C_NACKPosition_Current: indicates that current byte is the last[m[41m [m
[32m+[m[32m  *          received byte.[m
[32m+[m[32m  *[m[41m            [m
[32m+[m[32m  * @note    This function configures the same bit (POS) as I2C_PECPositionConfig()[m[41m [m
[32m+[m[32m  *          but is intended to be used in I2C mode while I2C_PECPositionConfig()[m[41m [m
[32m+[m[32m  *          is intended to used in SMBUS mode.[m[41m [m
[32m+[m[32m  *[m[41m            [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_NACK_POSITION(I2C_NACKPosition));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the input parameter */[m
[32m+[m[32m  if (I2C_NACKPosition == I2C_NACKPosition_Next)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Next byte in shift register is the last received byte */[m
[32m+[m[32m    I2Cx->CR1 |= I2C_NACKPosition_Next;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Current byte in shift register is the last received byte */[m
[32m+[m[32m    I2Cx->CR1 &= I2C_NACKPosition_Current;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Drives the SMBusAlert pin high or low for the specified I2C.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_SMBusAlert: specifies SMBAlert pin level.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_SMBusAlert_Low: SMBAlert pin driven low[m
[32m+[m[32m  *     @arg I2C_SMBusAlert_High: SMBAlert pin driven high[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_SMBUS_ALERT(I2C_SMBusAlert));[m
[32m+[m[32m  if (I2C_SMBusAlert == I2C_SMBusAlert_Low)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Drive the SMBusAlert pin Low */[m
[32m+[m[32m    I2Cx->CR1 |= I2C_SMBusAlert_Low;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Drive the SMBusAlert pin High  */[m
[32m+[m[32m    I2Cx->CR1 &= I2C_SMBusAlert_High;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C PEC transfer.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2C PEC transmission.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C PEC transmission */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_PEC_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C PEC transmission */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_PEC_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the specified I2C PEC position.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_PECPosition: specifies the PEC position.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_PECPosition_Next: indicates that the next byte is PEC[m
[32m+[m[32m  *     @arg I2C_PECPosition_Current: indicates that current byte is PEC[m
[32m+[m[32m  *[m[41m       [m
[32m+[m[32m  * @note    This function configures the same bit (POS) as I2C_NACKPositionConfig()[m
[32m+[m[32m  *          but is intended to be used in SMBUS mode while I2C_NACKPositionConfig()[m[41m [m
[32m+[m[32m  *          is intended to used in I2C mode.[m
[32m+[m[32m  *[m[41m               [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_PEC_POSITION(I2C_PECPosition));[m
[32m+[m[32m  if (I2C_PECPosition == I2C_PECPosition_Next)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Next byte in shift register is PEC */[m
[32m+[m[32m    I2Cx->CR1 |= I2C_PECPosition_Next;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Current byte in shift register is PEC */[m
[32m+[m[32m    I2Cx->CR1 &= I2C_PECPosition_Current;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the PEC value calculation of the transferred bytes.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2Cx PEC value calculation.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C PEC calculation */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_ENPEC_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C PEC calculation */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_ENPEC_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the PEC value for the specified I2C.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @retval The PEC value.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t I2C_GetPEC(I2C_TypeDef* I2Cx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  /* Return the selected I2C PEC value */[m
[32m+[m[32m  return ((I2Cx->SR2) >> 8);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C ARP.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2Cx ARP.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C ARP */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_ENARP_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C ARP */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_ENARP_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified I2C Clock stretching.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the I2Cx Clock stretching.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState == DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected I2C Clock stretching */[m
[32m+[m[32m    I2Cx->CR1 |= CR1_NOSTRETCH_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected I2C Clock stretching */[m
[32m+[m[32m    I2Cx->CR1 &= CR1_NOSTRETCH_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the specified I2C fast mode duty cycle.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_DutyCycle: specifies the fast mode duty cycle.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2[m
[32m+[m[32m  *     @arg I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_DUTY_CYCLE(I2C_DutyCycle));[m
[32m+[m[32m  if (I2C_DutyCycle != I2C_DutyCycle_16_9)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* I2C fast mode Tlow/Thigh=2 */[m
[32m+[m[32m    I2Cx->CCR &= I2C_DutyCycle_2;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* I2C fast mode Tlow/Thigh=16/9 */[m
[32m+[m[32m    I2Cx->CCR |= I2C_DutyCycle_16_9;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief[m
[32m+[m[32m ****************************************************************************************[m
[32m+[m[32m *[m
[32m+[m[32m *                         I2C State Monitoring Functions[m
[32m+[m[32m *[m[41m                       [m
[32m+[m[32m ****************************************************************************************[m[41m   [m
[32m+[m[32m * This I2C driver provides three different ways for I2C state monitoring[m
[32m+[m[32m *  depending on the application requirements and constraints:[m
[32m+[m[32m *[m[41m        [m
[32m+[m[32m *[m[41m  [m
[32m+[m[32m * 1) Basic state monitoring:[m
[32m+[m[32m *    Using I2C_CheckEvent() function:[m
[32m+[m[32m *    It compares the status registers (SR1 and SR2) content to a given event[m
[32m+[m[32m *    (can be the combination of one or more flags).[m
[32m+[m[32m *    It returns SUCCESS if the current status includes the given flags[m[41m [m
[32m+[m[32m *    and returns ERROR if one or more flags are missing in the current status.[m
[32m+[m[32m *    - When to use:[m
[32m+[m[32m *      - This function is suitable for most applications as well as for startup[m[41m [m
[32m+[m[32m *      activity since the events are fully described in the product reference manual[m[41m [m
[32m+[m[32m *      (RM0008).[m
[32m+[m[32m *      - It is also suitable for users who need to define their own events.[m
[32m+[m[32m *    - Limitations:[m
[32m+[m[32m *      - If an error occurs (ie. error flags are set besides to the monitored flags),[m
[32m+[m[32m *        the I2C_CheckEvent() function may return SUCCESS despite the communication[m
[32m+[m[32m *        hold or corrupted real state.[m[41m [m
[32m+[m[32m *        In this case, it is advised to use error interrupts to monitor the error[m
[32m+[m[32m *        events and handle them in the interrupt IRQ handler.[m
[32m+[m[32m *[m[41m        [m
[32m+[m[32m *        @note[m[41m [m
[32m+[m[32m *        For error management, it is advised to use the following functions:[m
[32m+[m[32m *          - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).[m
[32m+[m[32m *          - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.[m
[32m+[m[32m *            Where x is the peripheral instance (I2C1, I2C2 ...)[m
[32m+[m[32m *          - I2C_GetFlagStatus() or I2C_GetITStatus() to be called into I2Cx_ER_IRQHandler()[m[41m [m
[32m+[m[32m *            in order to determine which error occured.[m
[32m+[m[32m *          - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd()[m
[32m+[m[32m *            and/or I2C_GenerateStop() in order to clear the error flag and source,[m
[32m+[m[32m *            and return to correct communication status.[m
[32m+[m[32m *[m[41m            [m
[32m+[m[32m *[m
[32m+[m[32m *  2) Advanced state monitoring:[m
[32m+[m[32m *     Using the function I2C_GetLastEvent() which returns the image of both status[m[41m [m
[32m+[m[32m *     registers in a single word (uint32_t) (Status Register 2 value is shifted left[m[41m [m
[32m+[m[32m *     by 16 bits and concatenated to Status Register 1).[m
[32m+[m[32m *     - When to use:[m
[32m+[m[32m *       - This function is suitable for the same applications above but it allows to[m
[32m+[m[32m *         overcome the mentioned limitation of I2C_GetFlagStatus() function.[m
[32m+[m[32m *         The returned value could be compared to events already defined in the[m[41m [m
[32m+[m[32m *         library (stm32f10x_i2c.h) or to custom values defined by user.[m
[32m+[m[32m *       - This function is suitable when multiple flags are monitored at the same time.[m
[32m+[m[32m *       - At the opposite of I2C_CheckEvent() function, this function allows user to[m
[32m+[m[32m *         choose when an event is accepted (when all events flags are set and no[m[41m [m
[32m+[m[32m *         other flags are set or just when the needed flags are set like[m[41m [m
[32m+[m[32m *         I2C_CheckEvent() function).[m
[32m+[m[32m *     - Limitations:[m
[32m+[m[32m *       - User may need to define his own events.[m
[32m+[m[32m *       - Same remark concerning the error management is applicable for this[m[41m [m
[32m+[m[32m *         function if user decides to check only regular communication flags (and[m[41m [m
[32m+[m[32m *         ignores error flags).[m
[32m+[m[32m *[m[41m     [m
[32m+[m[32m *[m
[32m+[m[32m *  3) Flag-based state monitoring:[m
[32m+[m[32m *     Using the function I2C_GetFlagStatus() which simply returns the status of[m[41m [m
[32m+[m[32m *     one single flag (ie. I2C_FLAG_RXNE ...).[m[41m [m
[32m+[m[32m *     - When to use:[m
[32m+[m[32m *        - This function could be used for specific applications or in debug phase.[m
[32m+[m[32m *        - It is suitable when only one flag checking is needed (most I2C events[m[41m [m
[32m+[m[32m *          are monitored through multiple flags).[m
[32m+[m[32m *     - Limitations:[m[41m [m
[32m+[m[32m *        - When calling this function, the Status register is accessed. Some flags are[m
[32m+[m[32m *          cleared when the status register is accessed. So checking the status[m
[32m+[m[32m *          of one Flag, may clear other ones.[m
[32m+[m[32m *        - Function may need to be called twice or more in order to monitor one[m[41m [m
[32m+[m[32m *          single event.[m
[32m+[m[32m *[m
[32m+[m[32m *  For detailed description of Events, please refer to section I2C_Events in[m[41m [m
[32m+[m[32m *  stm32f10x_i2c.h file.[m
[32m+[m[32m *[m[41m  [m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m *  1) Basic state monitoring[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the last I2Cx Event is equal to the one passed[m
[32m+[m[32m  *   as parameter.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_EVENT: specifies the event to be checked.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED           : EV1[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED              : EV1[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED     : EV1[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED        : EV1[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED            : EV1[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_BYTE_RECEIVED                         : EV2[m
[32m+[m[32m  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)      : EV2[m
[32m+[m[32m  *     @arg (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)    : EV2[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_BYTE_TRANSMITTED                      : EV3[m
[32m+[m[32m  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)   : EV3[m
[32m+[m[32m  *     @arg (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL) : EV3[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_ACK_FAILURE                           : EV3_2[m
[32m+[m[32m  *     @arg I2C_EVENT_SLAVE_STOP_DETECTED                         : EV4[m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_MODE_SELECT                          : EV5[m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED            : EV6[m[41m     [m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED               : EV6[m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_BYTE_RECEIVED                        : EV7[m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTING                    : EV8[m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_BYTE_TRANSMITTED                     : EV8_2[m
[32m+[m[32m  *     @arg I2C_EVENT_MASTER_MODE_ADDRESS10                       : EV9[m
[32m+[m[32m  *[m[41m     [m
[32m+[m[32m  * @note: For detailed description of Events, please refer to section[m[41m [m
[32m+[m[32m  *    I2C_Events in stm32f10x_i2c.h file.[m
[32m+[m[32m  *[m[41m    [m
[32m+[m[32m  * @retval An ErrorStatus enumeration value:[m
[32m+[m[32m  * - SUCCESS: Last event is equal to the I2C_EVENT[m
[32m+[m[32m  * - ERROR: Last event is different from the I2C_EVENT[m
[32m+[m[32m  */[m
[32m+[m[32mErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t lastevent = 0;[m
[32m+[m[32m  uint32_t flag1 = 0, flag2 = 0;[m
[32m+[m[32m  ErrorStatus status = ERROR;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_EVENT(I2C_EVENT));[m
[32m+[m
[32m+[m[32m  /* Read the I2Cx status register */[m
[32m+[m[32m  flag1 = I2Cx->SR1;[m
[32m+[m[32m  flag2 = I2Cx->SR2;[m
[32m+[m[32m  flag2 = flag2 << 16;[m
[32m+[m
[32m+[m[32m  /* Get the last event value from I2C status register */[m
[32m+[m[32m  lastevent = (flag1 | flag2) & FLAG_Mask;[m
[32m+[m
[32m+[m[32m  /* Check whether the last event contains the I2C_EVENT */[m
[32m+[m[32m  if ((lastevent & I2C_EVENT) == I2C_EVENT)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SUCCESS: last event is equal to I2C_EVENT */[m
[32m+[m[32m    status = SUCCESS;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* ERROR: last event is different from I2C_EVENT */[m
[32m+[m[32m    status = ERROR;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return status */[m
[32m+[m[32m  return status;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m *  2) Advanced state monitoring[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the last I2Cx Event.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  *[m[41m     [m
[32m+[m[32m  * @note: For detailed description of Events, please refer to section[m[41m [m
[32m+[m[32m  *    I2C_Events in stm32f10x_i2c.h file.[m
[32m+[m[32m  *[m[41m    [m
[32m+[m[32m  * @retval The last event[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t lastevent = 0;[m
[32m+[m[32m  uint32_t flag1 = 0, flag2 = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m
[32m+[m[32m  /* Read the I2Cx status register */[m
[32m+[m[32m  flag1 = I2Cx->SR1;[m
[32m+[m[32m  flag2 = I2Cx->SR2;[m
[32m+[m[32m  flag2 = flag2 << 16;[m
[32m+[m
[32m+[m[32m  /* Get the last event value from I2C status register */[m
[32m+[m[32m  lastevent = (flag1 | flag2) & FLAG_Mask;[m
[32m+[m
[32m+[m[32m  /* Return status */[m
[32m+[m[32m  return lastevent;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m *[m[41m [m
[32m+[m[32m *  3) Flag-based state monitoring[m
[32m+[m[32m *******************************************************************************[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified I2C flag is set or not.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_FLAG: specifies the flag to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_FLAG_DUALF: Dual flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_SMBHOST: SMBus host header (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_GENCALL: General call header flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_TRA: Transmitter/Receiver flag[m
[32m+[m[32m  *     @arg I2C_FLAG_BUSY: Bus busy flag[m
[32m+[m[32m  *     @arg I2C_FLAG_MSL: Master/Slave flag[m
[32m+[m[32m  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag[m
[32m+[m[32m  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag[m
[32m+[m[32m  *     @arg I2C_FLAG_PECERR: PEC error in reception flag[m
[32m+[m[32m  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_AF: Acknowledge failure flag[m
[32m+[m[32m  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_BERR: Bus error flag[m
[32m+[m[32m  *     @arg I2C_FLAG_TXE: Data register empty flag (Transmitter)[m
[32m+[m[32m  *     @arg I2C_FLAG_RXNE: Data register not empty (Receiver) flag[m
[32m+[m[32m  *     @arg I2C_FLAG_STOPF: Stop detection flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_ADD10: 10-bit header sent flag (Master mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_BTF: Byte transfer finished flag[m
[32m+[m[32m  *     @arg I2C_FLAG_ADDR: Address sent flag (Master mode) "ADSL"[m
[32m+[m[32m  *   Address matched flag (Slave mode)"ENDA"[m
[32m+[m[32m  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)[m
[32m+[m[32m  * @retval The new state of I2C_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  __IO uint32_t i2creg = 0, i2cxbase = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));[m
[32m+[m
[32m+[m[32m  /* Get the I2Cx peripheral base address */[m
[32m+[m[32m  i2cxbase = (uint32_t)I2Cx;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Read flag register index */[m
[32m+[m[32m  i2creg = I2C_FLAG >> 28;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get bit[23:0] of the flag */[m
[32m+[m[32m  I2C_FLAG &= FLAG_Mask;[m
[32m+[m[41m  [m
[32m+[m[32m  if(i2creg != 0)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the I2Cx SR1 register address */[m
[32m+[m[32m    i2cxbase += 0x14;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Flag in I2Cx SR2 Register */[m
[32m+[m[32m    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);[m
[32m+[m[32m    /* Get the I2Cx SR2 register address */[m
[32m+[m[32m    i2cxbase += 0x18;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* I2C_FLAG is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* I2C_FLAG is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the I2C_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the I2Cx's pending flags.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_FLAG: specifies the flag to clear.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg I2C_FLAG_SMBALERT: SMBus Alert flag[m
[32m+[m[32m  *     @arg I2C_FLAG_TIMEOUT: Timeout or Tlow error flag[m
[32m+[m[32m  *     @arg I2C_FLAG_PECERR: PEC error in reception flag[m
[32m+[m[32m  *     @arg I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_AF: Acknowledge failure flag[m
[32m+[m[32m  *     @arg I2C_FLAG_ARLO: Arbitration lost flag (Master mode)[m
[32m+[m[32m  *     @arg I2C_FLAG_BERR: Bus error flag[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - STOPF (STOP detection) is cleared by software sequence: a read operation[m[41m [m
[32m+[m[32m  *     to I2C_SR1 register (I2C_GetFlagStatus()) followed by a write operation[m[41m [m
[32m+[m[32m  *     to I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).[m
[32m+[m[32m  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read[m[41m [m
[32m+[m[32m  *     operation to I2C_SR1 (I2C_GetFlagStatus()) followed by writing the[m[41m [m
[32m+[m[32m  *     second byte of the address in DR register.[m
[32m+[m[32m  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read[m[41m [m
[32m+[m[32m  *     operation to I2C_SR1 register (I2C_GetFlagStatus()) followed by a[m[41m [m
[32m+[m[32m  *     read/write to I2C_DR register (I2C_SendData()).[m
[32m+[m[32m  *   - ADDR (Address sent) is cleared by software sequence: a read operation to[m[41m [m
[32m+[m[32m  *     I2C_SR1 register (I2C_GetFlagStatus()) followed by a read operation to[m[41m [m
[32m+[m[32m  *     I2C_SR2 register ((void)(I2Cx->SR2)).[m
[32m+[m[32m  *   - SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1[m
[32m+[m[32m  *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR[m
[32m+[m[32m  *     register  (I2C_SendData()).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t flagpos = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));[m
[32m+[m[32m  /* Get the I2C flag position */[m
[32m+[m[32m  flagpos = I2C_FLAG & FLAG_Mask;[m
[32m+[m[32m  /* Clear the selected I2C flag */[m
[32m+[m[32m  I2Cx->SR1 = (uint16_t)~flagpos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified I2C interrupt has occurred or not.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_IT: specifies the interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg I2C_IT_SMBALERT: SMBus Alert flag[m
[32m+[m[32m  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error flag[m
[32m+[m[32m  *     @arg I2C_IT_PECERR: PEC error in reception flag[m
[32m+[m[32m  *     @arg I2C_IT_OVR: Overrun/Underrun flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_IT_AF: Acknowledge failure flag[m
[32m+[m[32m  *     @arg I2C_IT_ARLO: Arbitration lost flag (Master mode)[m
[32m+[m[32m  *     @arg I2C_IT_BERR: Bus error flag[m
[32m+[m[32m  *     @arg I2C_IT_TXE: Data register empty flag (Transmitter)[m
[32m+[m[32m  *     @arg I2C_IT_RXNE: Data register not empty (Receiver) flag[m
[32m+[m[32m  *     @arg I2C_IT_STOPF: Stop detection flag (Slave mode)[m
[32m+[m[32m  *     @arg I2C_IT_ADD10: 10-bit header sent flag (Master mode)[m
[32m+[m[32m  *     @arg I2C_IT_BTF: Byte transfer finished flag[m
[32m+[m[32m  *     @arg I2C_IT_ADDR: Address sent flag (Master mode) "ADSL"[m
[32m+[m[32m  *                       Address matched flag (Slave mode)"ENDAD"[m
[32m+[m[32m  *     @arg I2C_IT_SB: Start bit flag (Master mode)[m
[32m+[m[32m  * @retval The new state of I2C_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint32_t enablestatus = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_GET_IT(I2C_IT));[m
[32m+[m
[32m+[m[32m  /* Check if the interrupt source is enabled or not */[m
[32m+[m[32m  enablestatus = (uint32_t)(((I2C_IT & ITEN_Mask) >> 16) & (I2Cx->CR2)) ;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get bit[23:0] of the flag */[m
[32m+[m[32m  I2C_IT &= FLAG_Mask;[m
[32m+[m
[32m+[m[32m  /* Check the status of the specified I2C flag */[m
[32m+[m[32m  if (((I2Cx->SR1 & I2C_IT) != (uint32_t)RESET) && enablestatus)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* I2C_IT is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* I2C_IT is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the I2C_IT status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the I2Cxís interrupt pending bits.[m
[32m+[m[32m  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.[m
[32m+[m[32m  * @param  I2C_IT: specifies the interrupt pending bit to clear.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg I2C_IT_SMBALERT: SMBus Alert interrupt[m
[32m+[m[32m  *     @arg I2C_IT_TIMEOUT: Timeout or Tlow error interrupt[m
[32m+[m[32m  *     @arg I2C_IT_PECERR: PEC error in reception  interrupt[m
[32m+[m[32m  *     @arg I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode)[m
[32m+[m[32m  *     @arg I2C_IT_AF: Acknowledge failure interrupt[m
[32m+[m[32m  *     @arg I2C_IT_ARLO: Arbitration lost interrupt (Master mode)[m
[32m+[m[32m  *     @arg I2C_IT_BERR: Bus error interrupt[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - STOPF (STOP detection) is cleared by software sequence: a read operation[m[41m [m
[32m+[m[32m  *     to I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to[m[41m [m
[32m+[m[32m  *     I2C_CR1 register (I2C_Cmd() to re-enable the I2C peripheral).[m
[32m+[m[32m  *   - ADD10 (10-bit header sent) is cleared by software sequence: a read[m[41m [m
[32m+[m[32m  *     operation to I2C_SR1 (I2C_GetITStatus()) followed by writing the second[m[41m [m
[32m+[m[32m  *     byte of the address in I2C_DR register.[m
[32m+[m[32m  *   - BTF (Byte Transfer Finished) is cleared by software sequence: a read[m[41m [m
[32m+[m[32m  *     operation to I2C_SR1 register (I2C_GetITStatus()) followed by a[m[41m [m
[32m+[m[32m  *     read/write to I2C_DR register (I2C_SendData()).[m
[32m+[m[32m  *   - ADDR (Address sent) is cleared by software sequence: a read operation to[m[41m [m
[32m+[m[32m  *     I2C_SR1 register (I2C_GetITStatus()) followed by a read operation to[m[41m [m
[32m+[m[32m  *     I2C_SR2 register ((void)(I2Cx->SR2)).[m
[32m+[m[32m  *   - SB (Start Bit) is cleared by software sequence: a read operation to[m[41m [m
[32m+[m[32m  *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to[m[41m [m
[32m+[m[32m  *     I2C_DR register (I2C_SendData()).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t flagpos = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_I2C_ALL_PERIPH(I2Cx));[m
[32m+[m[32m  assert_param(IS_I2C_CLEAR_IT(I2C_IT));[m
[32m+[m[32m  /* Get the I2C flag position */[m
[32m+[m[32m  flagpos = I2C_IT & FLAG_Mask;[m
[32m+[m[32m  /* Clear the selected I2C flag */[m
[32m+[m[32m  I2Cx->SR1 = (uint16_t)~flagpos;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c[m
[1mnew file mode 100644[m
[1mindex 0000000..c7cbf7e[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_iwdg.c[m
[36m@@ -0,0 +1,190 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_iwdg.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the IWDG firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_iwdg.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG[m[41m [m
[32m+[m[32m  * @brief IWDG driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/* ---------------------- IWDG registers bit mask ----------------------------*/[m
[32m+[m
[32m+[m[32m/* KR register bit mask */[m
[32m+[m[32m#define KR_KEY_Reload    ((uint16_t)0xAAAA)[m
[32m+[m[32m#define KR_KEY_Enable    ((uint16_t)0xCCCC)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup IWDG_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables write access to IWDG_PR and IWDG_RLR registers.[m
[32m+[m[32m  * @param  IWDG_WriteAccess: new state of write access to IWDG_PR and IWDG_RLR registers.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers[m
[32m+[m[32m  *     @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));[m
[32m+[m[32m  IWDG->KR = IWDG_WriteAccess;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets IWDG Prescaler value.[m
[32m+[m[32m  * @param  IWDG_Prescaler: specifies the IWDG Prescaler value.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg IWDG_Prescaler_4: IWDG prescaler set to 4[m
[32m+[m[32m  *     @arg IWDG_Prescaler_8: IWDG prescaler set to 8[m
[32m+[m[32m  *     @arg IWDG_Prescaler_16: IWDG prescaler set to 16[m
[32m+[m[32m  *     @arg IWDG_Prescaler_32: IWDG prescaler set to 32[m
[32m+[m[32m  *     @arg IWDG_Prescaler_64: IWDG prescaler set to 64[m
[32m+[m[32m  *     @arg IWDG_Prescaler_128: IWDG prescaler set to 128[m
[32m+[m[32m  *     @arg IWDG_Prescaler_256: IWDG prescaler set to 256[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid IWDG_SetPrescaler(uint8_t IWDG_Prescaler)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));[m
[32m+[m[32m  IWDG->PR = IWDG_Prescaler;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets IWDG Reload value.[m
[32m+[m[32m  * @param  Reload: specifies the IWDG Reload value.[m
[32m+[m[32m  *   This parameter must be a number between 0 and 0x0FFF.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid IWDG_SetReload(uint16_t Reload)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_IWDG_RELOAD(Reload));[m
[32m+[m[32m  IWDG->RLR = Reload;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Reloads IWDG counter with value defined in the reload register[m
[32m+[m[32m  *   (write access to IWDG_PR and IWDG_RLR registers disabled).[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid IWDG_ReloadCounter(void)[m
[32m+[m[32m{[m
[32m+[m[32m  IWDG->KR = KR_KEY_Reload;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid IWDG_Enable(void)[m
[32m+[m[32m{[m
[32m+[m[32m  IWDG->KR = KR_KEY_Enable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified IWDG flag is set or not.[m
[32m+[m[32m  * @param  IWDG_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg IWDG_FLAG_PVU: Prescaler Value Update on going[m
[32m+[m[32m  *     @arg IWDG_FLAG_RVU: Reload Value Update on going[m
[32m+[m[32m  * @retval The new state of IWDG_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_IWDG_FLAG(IWDG_FLAG));[m
[32m+[m[32m  if ((IWDG->SR & IWDG_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the flag status */[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c[m
[1mnew file mode 100644[m
[1mindex 0000000..a5a5c57[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_pwr.c[m
[36m@@ -0,0 +1,307 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_pwr.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the PWR firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_pwr.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR[m[41m [m
[32m+[m[32m  * @brief PWR driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* --------- PWR registers bit address in the alias region ---------- */[m
[32m+[m[32m#define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* --- CR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of DBP bit */[m
[32m+[m[32m#define CR_OFFSET                (PWR_OFFSET + 0x00)[m
[32m+[m[32m#define DBP_BitNumber            0x08[m
[32m+[m[32m#define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of PVDE bit */[m
[32m+[m[32m#define PVDE_BitNumber           0x04[m
[32m+[m[32m#define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- CSR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of EWUP bit */[m
[32m+[m[32m#define CSR_OFFSET               (PWR_OFFSET + 0x04)[m
[32m+[m[32m#define EWUP_BitNumber           0x08[m
[32m+[m[32m#define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* ------------------ PWR registers bit mask ------------------------ */[m
[32m+[m
[32m+[m[32m/* CR register bit mask */[m
[32m+[m[32m#define CR_DS_MASK               ((uint32_t)0xFFFFFFFC)[m
[32m+[m[32m#define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup PWR_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the PWR peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables access to the RTC and backup registers.[m
[32m+[m[32m  * @param  NewState: new state of the access to the RTC and backup registers.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_BackupAccessCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Power Voltage Detector(PVD).[m
[32m+[m[32m  * @param  NewState: new state of the PVD.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_PVDCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).[m
[32m+[m[32m  * @param  PWR_PVDLevel: specifies the PVD detection level[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V2: PVD detection level set to 2.2V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V3: PVD detection level set to 2.3V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V4: PVD detection level set to 2.4V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V5: PVD detection level set to 2.5V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V6: PVD detection level set to 2.6V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V7: PVD detection level set to 2.7V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V8: PVD detection level set to 2.8V[m
[32m+[m[32m  *     @arg PWR_PVDLevel_2V9: PVD detection level set to 2.9V[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));[m
[32m+[m[32m  tmpreg = PWR->CR;[m
[32m+[m[32m  /* Clear PLS[7:5] bits */[m
[32m+[m[32m  tmpreg &= CR_PLS_MASK;[m
[32m+[m[32m  /* Set PLS[7:5] bits according to PWR_PVDLevel value */[m
[32m+[m[32m  tmpreg |= PWR_PVDLevel;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  PWR->CR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the WakeUp Pin functionality.[m
[32m+[m[32m  * @param  NewState: new state of the WakeUp Pin functionality.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_WakeUpPinCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enters STOP mode.[m
[32m+[m[32m  * @param  PWR_Regulator: specifies the regulator state in STOP mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg PWR_Regulator_ON: STOP mode with regulator ON[m
[32m+[m[32m  *     @arg PWR_Regulator_LowPower: STOP mode with regulator in low power mode[m
[32m+[m[32m  * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction[m
[32m+[m[32m  *     @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_PWR_REGULATOR(PWR_Regulator));[m
[32m+[m[32m  assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Select the regulator state in STOP mode ---------------------------------*/[m
[32m+[m[32m  tmpreg = PWR->CR;[m
[32m+[m[32m  /* Clear PDDS and LPDS bits */[m
[32m+[m[32m  tmpreg &= CR_DS_MASK;[m
[32m+[m[32m  /* Set LPDS bit according to PWR_Regulator value */[m
[32m+[m[32m  tmpreg |= PWR_Regulator;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  PWR->CR = tmpreg;[m
[32m+[m[32m  /* Set SLEEPDEEP bit of Cortex System Control Register */[m
[32m+[m[32m  SCB->SCR |= SCB_SCR_SLEEPDEEP;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Select STOP mode entry --------------------------------------------------*/[m
[32m+[m[32m  if(PWR_STOPEntry == PWR_STOPEntry_WFI)[m
[32m+[m[32m  {[m[41m   [m
[32m+[m[32m    /* Request Wait For Interrupt */[m
[32m+[m[32m    __WFI();[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Request Wait For Event */[m
[32m+[m[32m    __WFE();[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset SLEEPDEEP bit of Cortex System Control Register */[m
[32m+[m[32m  SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enters STANDBY mode.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_EnterSTANDBYMode(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Clear Wake-up flag */[m
[32m+[m[32m  PWR->CR |= PWR_CR_CWUF;[m
[32m+[m[32m  /* Select STANDBY mode */[m
[32m+[m[32m  PWR->CR |= PWR_CR_PDDS;[m
[32m+[m[32m  /* Set SLEEPDEEP bit of Cortex System Control Register */[m
[32m+[m[32m  SCB->SCR |= SCB_SCR_SLEEPDEEP;[m
[32m+[m[32m/* This option is used to ensure that store operations are completed */[m
[32m+[m[32m#if defined ( __CC_ARM   )[m
[32m+[m[32m  __force_stores();[m
[32m+[m[32m#endif[m
[32m+[m[32m  /* Request Wait For Interrupt */[m
[32m+[m[32m  __WFI();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified PWR flag is set or not.[m
[32m+[m[32m  * @param  PWR_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg PWR_FLAG_WU: Wake Up flag[m
[32m+[m[32m  *     @arg PWR_FLAG_SB: StandBy flag[m
[32m+[m[32m  *     @arg PWR_FLAG_PVDO: PVD Output[m
[32m+[m[32m  * @retval The new state of PWR_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_PWR_GET_FLAG(PWR_FLAG));[m
[32m+[m[41m  [m
[32m+[m[32m  if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the flag status */[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the PWR's pending flags.[m
[32m+[m[32m  * @param  PWR_FLAG: specifies the flag to clear.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg PWR_FLAG_WU: Wake Up flag[m
[32m+[m[32m  *     @arg PWR_FLAG_SB: StandBy flag[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PWR_ClearFlag(uint32_t PWR_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));[m
[32m+[m[41m         [m
[32m+[m[32m  PWR->CR |=  PWR_FLAG << 2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c[m
[1mnew file mode 100644[m
[1mindex 0000000..a29034b[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rcc.c[m
[36m@@ -0,0 +1,1470 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_rcc.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the RCC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC[m[41m [m
[32m+[m[32m  * @brief RCC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* ------------ RCC registers bit address in the alias region ----------- */[m
[32m+[m[32m#define RCC_OFFSET                (RCC_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* --- CR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of HSION bit */[m
[32m+[m[32m#define CR_OFFSET                 (RCC_OFFSET + 0x00)[m
[32m+[m[32m#define HSION_BitNumber           0x00[m
[32m+[m[32m#define CR_HSION_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (HSION_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of PLLON bit */[m
[32m+[m[32m#define PLLON_BitNumber           0x18[m
[32m+[m[32m#define CR_PLLON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLLON_BitNumber * 4))[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m /* Alias word address of PLL2ON bit */[m
[32m+[m[32m #define PLL2ON_BitNumber          0x1A[m
[32m+[m[32m #define CR_PLL2ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL2ON_BitNumber * 4))[m
[32m+[m
[32m+[m[32m /* Alias word address of PLL3ON bit */[m
[32m+[m[32m #define PLL3ON_BitNumber          0x1C[m
[32m+[m[32m #define CR_PLL3ON_BB              (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PLL3ON_BitNumber * 4))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/* Alias word address of CSSON bit */[m
[32m+[m[32m#define CSSON_BitNumber           0x13[m
[32m+[m[32m#define CR_CSSON_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (CSSON_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- CFGR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of USBPRE bit */[m
[32m+[m[32m#define CFGR_OFFSET               (RCC_OFFSET + 0x04)[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m #define USBPRE_BitNumber          0x16[m
[32m+[m[32m #define CFGR_USBPRE_BB            (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (USBPRE_BitNumber * 4))[m
[32m+[m[32m#else[m
[32m+[m[32m #define OTGFSPRE_BitNumber        0x16[m
[32m+[m[32m #define CFGR_OTGFSPRE_BB          (PERIPH_BB_BASE + (CFGR_OFFSET * 32) + (OTGFSPRE_BitNumber * 4))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/* --- BDCR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of RTCEN bit */[m
[32m+[m[32m#define BDCR_OFFSET               (RCC_OFFSET + 0x20)[m
[32m+[m[32m#define RTCEN_BitNumber           0x0F[m
[32m+[m[32m#define BDCR_RTCEN_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (RTCEN_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of BDRST bit */[m
[32m+[m[32m#define BDRST_BitNumber           0x10[m
[32m+[m[32m#define BDCR_BDRST_BB             (PERIPH_BB_BASE + (BDCR_OFFSET * 32) + (BDRST_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- CSR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of LSION bit */[m
[32m+[m[32m#define CSR_OFFSET                (RCC_OFFSET + 0x24)[m
[32m+[m[32m#define LSION_BitNumber           0x00[m
[32m+[m[32m#define CSR_LSION_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (LSION_BitNumber * 4))[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/* --- CFGR2 Register ---*/[m
[32m+[m
[32m+[m[32m /* Alias word address of I2S2SRC bit */[m
[32m+[m[32m #define CFGR2_OFFSET              (RCC_OFFSET + 0x2C)[m
[32m+[m[32m #define I2S2SRC_BitNumber         0x11[m
[32m+[m[32m #define CFGR2_I2S2SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S2SRC_BitNumber * 4))[m
[32m+[m
[32m+[m[32m /* Alias word address of I2S3SRC bit */[m
[32m+[m[32m #define I2S3SRC_BitNumber         0x12[m
[32m+[m[32m #define CFGR2_I2S3SRC_BB          (PERIPH_BB_BASE + (CFGR2_OFFSET * 32) + (I2S3SRC_BitNumber * 4))[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/* ---------------------- RCC registers bit mask ------------------------ */[m
[32m+[m
[32m+[m[32m/* CR register bit mask */[m
[32m+[m[32m#define CR_HSEBYP_Reset           ((uint32_t)0xFFFBFFFF)[m
[32m+[m[32m#define CR_HSEBYP_Set             ((uint32_t)0x00040000)[m
[32m+[m[32m#define CR_HSEON_Reset            ((uint32_t)0xFFFEFFFF)[m
[32m+[m[32m#define CR_HSEON_Set              ((uint32_t)0x00010000)[m
[32m+[m[32m#define CR_HSITRIM_Mask           ((uint32_t)0xFFFFFF07)[m
[32m+[m
[32m+[m[32m/* CFGR register bit mask */[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)[m[41m [m
[32m+[m[32m #define CFGR_PLL_Mask            ((uint32_t)0xFFC2FFFF)[m
[32m+[m[32m#else[m
[32m+[m[32m #define CFGR_PLL_Mask            ((uint32_t)0xFFC0FFFF)[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m#define CFGR_PLLMull_Mask         ((uint32_t)0x003C0000)[m
[32m+[m[32m#define CFGR_PLLSRC_Mask          ((uint32_t)0x00010000)[m
[32m+[m[32m#define CFGR_PLLXTPRE_Mask        ((uint32_t)0x00020000)[m
[32m+[m[32m#define CFGR_SWS_Mask             ((uint32_t)0x0000000C)[m
[32m+[m[32m#define CFGR_SW_Mask              ((uint32_t)0xFFFFFFFC)[m
[32m+[m[32m#define CFGR_HPRE_Reset_Mask      ((uint32_t)0xFFFFFF0F)[m
[32m+[m[32m#define CFGR_HPRE_Set_Mask        ((uint32_t)0x000000F0)[m
[32m+[m[32m#define CFGR_PPRE1_Reset_Mask     ((uint32_t)0xFFFFF8FF)[m
[32m+[m[32m#define CFGR_PPRE1_Set_Mask       ((uint32_t)0x00000700)[m
[32m+[m[32m#define CFGR_PPRE2_Reset_Mask     ((uint32_t)0xFFFFC7FF)[m
[32m+[m[32m#define CFGR_PPRE2_Set_Mask       ((uint32_t)0x00003800)[m
[32m+[m[32m#define CFGR_ADCPRE_Reset_Mask    ((uint32_t)0xFFFF3FFF)[m
[32m+[m[32m#define CFGR_ADCPRE_Set_Mask      ((uint32_t)0x0000C000)[m
[32m+[m
[32m+[m[32m/* CSR register bit mask */[m
[32m+[m[32m#define CSR_RMVF_Set              ((uint32_t)0x01000000)[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)[m[41m [m
[32m+[m[32m/* CFGR2 register bit mask */[m
[32m+[m[32m #define CFGR2_PREDIV1SRC         ((uint32_t)0x00010000)[m
[32m+[m[32m #define CFGR2_PREDIV1            ((uint32_t)0x0000000F)[m
[32m+[m[32m#endif[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define CFGR2_PREDIV2            ((uint32_t)0x000000F0)[m
[32m+[m[32m #define CFGR2_PLL2MUL            ((uint32_t)0x00000F00)[m
[32m+[m[32m #define CFGR2_PLL3MUL            ((uint32_t)0x0000F000)[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/* RCC Flag Mask */[m
[32m+[m[32m#define FLAG_Mask                 ((uint8_t)0x1F)[m
[32m+[m
[32m+[m[32m/* CIR register byte 2 (Bits[15:8]) base address */[m
[32m+[m[32m#define CIR_BYTE2_ADDRESS         ((uint32_t)0x40021009)[m
[32m+[m
[32m+[m[32m/* CIR register byte 3 (Bits[23:16]) base address */[m
[32m+[m[32m#define CIR_BYTE3_ADDRESS         ((uint32_t)0x4002100A)[m
[32m+[m
[32m+[m[32m/* CFGR register byte 4 (Bits[31:24]) base address */[m
[32m+[m[32m#define CFGR_BYTE4_ADDRESS        ((uint32_t)0x40021007)[m
[32m+[m
[32m+[m[32m/* BDCR register base address */[m
[32m+[m[32m#define BDCR_ADDRESS              (PERIPH_BASE + BDCR_OFFSET)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32mstatic __I uint8_t APBAHBPrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};[m
[32m+[m[32mstatic __I uint8_t ADCPrescTable[4] = {2, 4, 6, 8};[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RCC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Resets the RCC clock configuration to the default reset state.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set HSION bit */[m
[32m+[m[32m  RCC->CR |= (uint32_t)0x00000001;[m
[32m+[m
[32m+[m[32m  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m  RCC->CFGR &= (uint32_t)0xF8FF0000;[m
[32m+[m[32m#else[m
[32m+[m[32m  RCC->CFGR &= (uint32_t)0xF0FF0000;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m   [m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset HSEON, CSSON and PLLON bits */[m
[32m+[m[32m  RCC->CR &= (uint32_t)0xFEF6FFFF;[m
[32m+[m
[32m+[m[32m  /* Reset HSEBYP bit */[m
[32m+[m[32m  RCC->CR &= (uint32_t)0xFFFBFFFF;[m
[32m+[m
[32m+[m[32m  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */[m
[32m+[m[32m  RCC->CFGR &= (uint32_t)0xFF80FFFF;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m  /* Reset PLL2ON and PLL3ON bits */[m
[32m+[m[32m  RCC->CR &= (uint32_t)0xEBFFFFFF;[m
[32m+[m
[32m+[m[32m  /* Disable all interrupts and clear pending bits  */[m
[32m+[m[32m  RCC->CIR = 0x00FF0000;[m
[32m+[m
[32m+[m[32m  /* Reset CFGR2 register */[m
[32m+[m[32m  RCC->CFGR2 = 0x00000000;[m
[32m+[m[32m#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m  /* Disable all interrupts and clear pending bits  */[m
[32m+[m[32m  RCC->CIR = 0x009F0000;[m
[32m+[m
[32m+[m[32m  /* Reset CFGR2 register */[m
[32m+[m[32m  RCC->CFGR2 = 0x00000000;[m[41m      [m
[32m+[m[32m#else[m
[32m+[m[32m  /* Disable all interrupts and clear pending bits  */[m
[32m+[m[32m  RCC->CIR = 0x009F0000;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the External High Speed oscillator (HSE).[m
[32m+[m[32m  * @note   HSE can not be stopped if it is used directly or through the PLL as system clock.[m
[32m+[m[32m  * @param  RCC_HSE: specifies the new state of the HSE.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_HSE_OFF: HSE oscillator OFF[m
[32m+[m[32m  *     @arg RCC_HSE_ON: HSE oscillator ON[m
[32m+[m[32m  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_HSEConfig(uint32_t RCC_HSE)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_HSE(RCC_HSE));[m
[32m+[m[32m  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/[m
[32m+[m[32m  /* Reset HSEON bit */[m
[32m+[m[32m  RCC->CR &= CR_HSEON_Reset;[m
[32m+[m[32m  /* Reset HSEBYP bit */[m
[32m+[m[32m  RCC->CR &= CR_HSEBYP_Reset;[m
[32m+[m[32m  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */[m
[32m+[m[32m  switch(RCC_HSE)[m
[32m+[m[32m  {[m
[32m+[m[32m    case RCC_HSE_ON:[m
[32m+[m[32m      /* Set HSEON bit */[m
[32m+[m[32m      RCC->CR |= CR_HSEON_Set;[m
[32m+[m[32m      break;[m
[32m+[m[41m      [m
[32m+[m[32m    case RCC_HSE_Bypass:[m
[32m+[m[32m      /* Set HSEBYP and HSEON bits */[m
[32m+[m[32m      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;[m
[32m+[m[32m      break;[m
[32m+[m[41m      [m
[32m+[m[32m    default:[m
[32m+[m[32m      break;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Waits for HSE start-up.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval An ErrorStatus enumuration value:[m
[32m+[m[32m  * - SUCCESS: HSE oscillator is stable and ready to use[m
[32m+[m[32m  * - ERROR: HSE oscillator not yet ready[m
[32m+[m[32m  */[m
[32m+[m[32mErrorStatus RCC_WaitForHSEStartUp(void)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t StartUpCounter = 0;[m
[32m+[m[32m  ErrorStatus status = ERROR;[m
[32m+[m[32m  FlagStatus HSEStatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Wait till HSE is ready and if Time out is reached exit */[m
[32m+[m[32m  do[m
[32m+[m[32m  {[m
[32m+[m[32m    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);[m
[32m+[m[32m    StartUpCounter++;[m[41m  [m
[32m+[m[32m  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));[m
[32m+[m[41m  [m
[32m+[m[32m  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    status = SUCCESS;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    status = ERROR;[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  return (status);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Adjusts the Internal High Speed oscillator (HSI) calibration value.[m
[32m+[m[32m  * @param  HSICalibrationValue: specifies the calibration trimming value.[m
[32m+[m[32m  *   This parameter must be a number between 0 and 0x1F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));[m
[32m+[m[32m  tmpreg = RCC->CR;[m
[32m+[m[32m  /* Clear HSITRIM[4:0] bits */[m
[32m+[m[32m  tmpreg &= CR_HSITRIM_Mask;[m
[32m+[m[32m  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */[m
[32m+[m[32m  tmpreg |= (uint32_t)HSICalibrationValue << 3;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Internal High Speed oscillator (HSI).[m
[32m+[m[32m  * @note   HSI can not be stopped if it is used directly or through the PLL as system clock.[m
[32m+[m[32m  * @param  NewState: new state of the HSI. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_HSICmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the PLL clock source and multiplication factor.[m
[32m+[m[32m  * @note   This function must be used only when the PLL is disabled.[m
[32m+[m[32m  * @param  RCC_PLLSource: specifies the PLL entry clock source.[m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices or @b STM32_Value_line_devices,[m[41m [m
[32m+[m[32m  *   this parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry[m
[32m+[m[32m  *     @arg RCC_PLLSource_PREDIV1: PREDIV1 clock selected as PLL clock entry[m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_PLLSource_HSI_Div2: HSI oscillator clock divided by 2 selected as PLL clock entry[m
[32m+[m[32m  *     @arg RCC_PLLSource_HSE_Div1: HSE oscillator clock selected as PLL clock entry[m
[32m+[m[32m  *     @arg RCC_PLLSource_HSE_Div2: HSE oscillator clock divided by 2 selected as PLL clock entry[m[41m [m
[32m+[m[32m  * @param  RCC_PLLMul: specifies the PLL multiplication factor.[m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}[m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16][m[41m  [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));[m
[32m+[m[32m  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));[m
[32m+[m
[32m+[m[32m  tmpreg = RCC->CFGR;[m
[32m+[m[32m  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */[m
[32m+[m[32m  tmpreg &= CFGR_PLL_Mask;[m
[32m+[m[32m  /* Set the PLL configuration bits */[m
[32m+[m[32m  tmpreg |= RCC_PLLSource | RCC_PLLMul;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the PLL.[m
[32m+[m[32m  * @note   The PLL can not be disabled if it is used as system clock.[m
[32m+[m[32m  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PLLCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL) || defined (STM32F10X_CL)[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the PREDIV1 division factor.[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   - This function must be used only when the PLL is disabled.[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line and Value line[m[41m [m
[32m+[m[32m  *     devices.[m
[32m+[m[32m  * @param  RCC_PREDIV1_Source: specifies the PREDIV1 clock source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_PREDIV1_Source_HSE: HSE selected as PREDIV1 clock[m
[32m+[m[32m  *     @arg RCC_PREDIV1_Source_PLL2: PLL2 selected as PREDIV1 clock[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   For @b STM32_Value_line_devices this parameter is always RCC_PREDIV1_Source_HSE[m[41m  [m
[32m+[m[32m  * @param  RCC_PREDIV1_Div: specifies the PREDIV1 clock division factor.[m
[32m+[m[32m  *   This parameter can be RCC_PREDIV1_Divx where x:[1,16][m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PREDIV1Config(uint32_t RCC_PREDIV1_Source, uint32_t RCC_PREDIV1_Div)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PREDIV1_SOURCE(RCC_PREDIV1_Source));[m
[32m+[m[32m  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));[m
[32m+[m
[32m+[m[32m  tmpreg = RCC->CFGR2;[m
[32m+[m[32m  /* Clear PREDIV1[3:0] and PREDIV1SRC bits */[m
[32m+[m[32m  tmpreg &= ~(CFGR2_PREDIV1 | CFGR2_PREDIV1SRC);[m
[32m+[m[32m  /* Set the PREDIV1 clock source and division factor */[m
[32m+[m[32m  tmpreg |= RCC_PREDIV1_Source | RCC_PREDIV1_Div ;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR2 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the PREDIV2 division factor.[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   - This function must be used only when both PLL2 and PLL3 are disabled.[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_PREDIV2_Div: specifies the PREDIV2 clock division factor.[m
[32m+[m[32m  *   This parameter can be RCC_PREDIV2_Divx where x:[1,16][m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PREDIV2Config(uint32_t RCC_PREDIV2_Div)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PREDIV2(RCC_PREDIV2_Div));[m
[32m+[m
[32m+[m[32m  tmpreg = RCC->CFGR2;[m
[32m+[m[32m  /* Clear PREDIV2[3:0] bits */[m
[32m+[m[32m  tmpreg &= ~CFGR2_PREDIV2;[m
[32m+[m[32m  /* Set the PREDIV2 division factor */[m
[32m+[m[32m  tmpreg |= RCC_PREDIV2_Div;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR2 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the PLL2 multiplication factor.[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - This function must be used only when the PLL2 is disabled.[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_PLL2Mul: specifies the PLL2 multiplication factor.[m
[32m+[m[32m  *   This parameter can be RCC_PLL2Mul_x where x:{[8,14], 16, 20}[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PLL2Config(uint32_t RCC_PLL2Mul)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PLL2_MUL(RCC_PLL2Mul));[m
[32m+[m
[32m+[m[32m  tmpreg = RCC->CFGR2;[m
[32m+[m[32m  /* Clear PLL2Mul[3:0] bits */[m
[32m+[m[32m  tmpreg &= ~CFGR2_PLL2MUL;[m
[32m+[m[32m  /* Set the PLL2 configuration bits */[m
[32m+[m[32m  tmpreg |= RCC_PLL2Mul;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR2 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the PLL2.[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   - The PLL2 can not be disabled if it is used indirectly as system clock[m
[32m+[m[32m  *     (i.e. it is used as PLL clock entry that is used as System clock).[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  NewState: new state of the PLL2. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PLL2Cmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CR_PLL2ON_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the PLL3 multiplication factor.[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   - This function must be used only when the PLL3 is disabled.[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_PLL3Mul: specifies the PLL3 multiplication factor.[m
[32m+[m[32m  *   This parameter can be RCC_PLL3Mul_x where x:{[8,14], 16, 20}[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PLL3Config(uint32_t RCC_PLL3Mul)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PLL3_MUL(RCC_PLL3Mul));[m
[32m+[m
[32m+[m[32m  tmpreg = RCC->CFGR2;[m
[32m+[m[32m  /* Clear PLL3Mul[3:0] bits */[m
[32m+[m[32m  tmpreg &= ~CFGR2_PLL3MUL;[m
[32m+[m[32m  /* Set the PLL3 configuration bits */[m
[32m+[m[32m  tmpreg |= RCC_PLL3Mul;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR2 = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the PLL3.[m
[32m+[m[32m  * @note   This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  NewState: new state of the PLL3. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PLL3Cmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CR_PLL3ON_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the system clock (SYSCLK).[m
[32m+[m[32m  * @param  RCC_SYSCLKSource: specifies the clock source used as system clock.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_SYSCLKSource_HSI: HSI selected as system clock[m
[32m+[m[32m  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock[m
[32m+[m[32m  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));[m
[32m+[m[32m  tmpreg = RCC->CFGR;[m
[32m+[m[32m  /* Clear SW[1:0] bits */[m
[32m+[m[32m  tmpreg &= CFGR_SW_Mask;[m
[32m+[m[32m  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */[m
[32m+[m[32m  tmpreg |= RCC_SYSCLKSource;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the clock source used as system clock.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The clock source used as system clock. The returned value can[m
[32m+[m[32m  *   be one of the following:[m
[32m+[m[32m  *     - 0x00: HSI used as system clock[m
[32m+[m[32m  *     - 0x04: HSE used as system clock[m
[32m+[m[32m  *     - 0x08: PLL used as system clock[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t RCC_GetSYSCLKSource(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the AHB clock (HCLK).[m
[32m+[m[32m  * @param  RCC_SYSCLK: defines the AHB clock divider. This clock is derived from[m[41m [m
[32m+[m[32m  *   the system clock (SYSCLK).[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div1: AHB clock = SYSCLK[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div2: AHB clock = SYSCLK/2[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div4: AHB clock = SYSCLK/4[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div8: AHB clock = SYSCLK/8[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div16: AHB clock = SYSCLK/16[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div64: AHB clock = SYSCLK/64[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div128: AHB clock = SYSCLK/128[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256[m
[32m+[m[32m  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_HCLKConfig(uint32_t RCC_SYSCLK)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_HCLK(RCC_SYSCLK));[m
[32m+[m[32m  tmpreg = RCC->CFGR;[m
[32m+[m[32m  /* Clear HPRE[3:0] bits */[m
[32m+[m[32m  tmpreg &= CFGR_HPRE_Reset_Mask;[m
[32m+[m[32m  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */[m
[32m+[m[32m  tmpreg |= RCC_SYSCLK;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the Low Speed APB clock (PCLK1).[m
[32m+[m[32m  * @param  RCC_HCLK: defines the APB1 clock divider. This clock is derived from[m[41m [m
[32m+[m[32m  *   the AHB clock (HCLK).[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_HCLK_Div1: APB1 clock = HCLK[m
[32m+[m[32m  *     @arg RCC_HCLK_Div2: APB1 clock = HCLK/2[m
[32m+[m[32m  *     @arg RCC_HCLK_Div4: APB1 clock = HCLK/4[m
[32m+[m[32m  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8[m
[32m+[m[32m  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PCLK1Config(uint32_t RCC_HCLK)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PCLK(RCC_HCLK));[m
[32m+[m[32m  tmpreg = RCC->CFGR;[m
[32m+[m[32m  /* Clear PPRE1[2:0] bits */[m
[32m+[m[32m  tmpreg &= CFGR_PPRE1_Reset_Mask;[m
[32m+[m[32m  /* Set PPRE1[2:0] bits according to RCC_HCLK value */[m
[32m+[m[32m  tmpreg |= RCC_HCLK;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the High Speed APB clock (PCLK2).[m
[32m+[m[32m  * @param  RCC_HCLK: defines the APB2 clock divider. This clock is derived from[m[41m [m
[32m+[m[32m  *   the AHB clock (HCLK).[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_HCLK_Div1: APB2 clock = HCLK[m
[32m+[m[32m  *     @arg RCC_HCLK_Div2: APB2 clock = HCLK/2[m
[32m+[m[32m  *     @arg RCC_HCLK_Div4: APB2 clock = HCLK/4[m
[32m+[m[32m  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8[m
[32m+[m[32m  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_PCLK2Config(uint32_t RCC_HCLK)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_PCLK(RCC_HCLK));[m
[32m+[m[32m  tmpreg = RCC->CFGR;[m
[32m+[m[32m  /* Clear PPRE2[2:0] bits */[m
[32m+[m[32m  tmpreg &= CFGR_PPRE2_Reset_Mask;[m
[32m+[m[32m  /* Set PPRE2[2:0] bits according to RCC_HCLK value */[m
[32m+[m[32m  tmpreg |= RCC_HCLK << 3;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified RCC interrupts.[m
[32m+[m[32m  * @param  RCC_IT: specifies the RCC interrupt sources to be enabled or disabled.[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination[m
[32m+[m[32m  *   of the following values[m[41m        [m
[32m+[m[32m  *     @arg RCC_IT_LSIRDY: LSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_LSERDY: LSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSIRDY: HSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSERDY: HSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLLRDY: PLL ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be any combination of the[m[41m [m
[32m+[m[32m  *   following values[m[41m        [m
[32m+[m[32m  *     @arg RCC_IT_LSIRDY: LSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_LSERDY: LSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSIRDY: HSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSERDY: HSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLLRDY: PLL ready interrupt[m
[32m+[m[32m  *[m[41m       [m
[32m+[m[32m  * @param  NewState: new state of the specified RCC interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_IT(RCC_IT));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */[m
[32m+[m[32m    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */[m
[32m+[m[32m    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the USB clock (USBCLK).[m
[32m+[m[32m  * @param  RCC_USBCLKSource: specifies the USB clock source. This clock is[m[41m [m
[32m+[m[32m  *   derived from the PLL output.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_USBCLKSource_PLLCLK_1Div5: PLL clock divided by 1,5 selected as USB[m[41m [m
[32m+[m[32m  *                                     clock source[m
[32m+[m[32m  *     @arg RCC_USBCLKSource_PLLCLK_Div1: PLL clock selected as USB clock source[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;[m
[32m+[m[32m}[m
[32m+[m[32m#else[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the USB OTG FS clock (OTGFSCLK).[m
[32m+[m[32m  *   This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_OTGFSCLKSource: specifies the USB OTG FS clock source.[m
[32m+[m[32m  *   This clock is derived from the PLL output.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div3: PLL VCO clock divided by 2 selected as USB OTG FS clock source[m
[32m+[m[32m  *     @arg  RCC_OTGFSCLKSource_PLLVCO_Div2: PLL VCO clock divided by 2 selected as USB OTG FS clock source[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_OTGFSCLKConfig(uint32_t RCC_OTGFSCLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_OTGFSCLK_SOURCE(RCC_OTGFSCLKSource));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CFGR_OTGFSPRE_BB = RCC_OTGFSCLKSource;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the ADC clock (ADCCLK).[m
[32m+[m[32m  * @param  RCC_PCLK2: defines the ADC clock divider. This clock is derived from[m[41m [m
[32m+[m[32m  *   the APB2 clock (PCLK2).[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_PCLK2_Div2: ADC clock = PCLK2/2[m
[32m+[m[32m  *     @arg RCC_PCLK2_Div4: ADC clock = PCLK2/4[m
[32m+[m[32m  *     @arg RCC_PCLK2_Div6: ADC clock = PCLK2/6[m
[32m+[m[32m  *     @arg RCC_PCLK2_Div8: ADC clock = PCLK2/8[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_ADCCLKConfig(uint32_t RCC_PCLK2)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_ADCCLK(RCC_PCLK2));[m
[32m+[m[32m  tmpreg = RCC->CFGR;[m
[32m+[m[32m  /* Clear ADCPRE[1:0] bits */[m
[32m+[m[32m  tmpreg &= CFGR_ADCPRE_Reset_Mask;[m
[32m+[m[32m  /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */[m
[32m+[m[32m  tmpreg |= RCC_PCLK2;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  RCC->CFGR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the I2S2 clock source(I2S2CLK).[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - This function must be called before enabling I2S2 APB clock.[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_I2S2CLKSource: specifies the I2S2 clock source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_I2S2CLKSource_SYSCLK: system clock selected as I2S2 clock entry[m
[32m+[m[32m  *     @arg RCC_I2S2CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S2 clock entry[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_I2S2CLKConfig(uint32_t RCC_I2S2CLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_I2S2CLK_SOURCE(RCC_I2S2CLKSource));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CFGR2_I2S2SRC_BB = RCC_I2S2CLKSource;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the I2S3 clock source(I2S2CLK).[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - This function must be called before enabling I2S3 APB clock.[m
[32m+[m[32m  *   - This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_I2S3CLKSource: specifies the I2S3 clock source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_I2S3CLKSource_SYSCLK: system clock selected as I2S3 clock entry[m
[32m+[m[32m  *     @arg RCC_I2S3CLKSource_PLL3_VCO: PLL3 VCO clock selected as I2S3 clock entry[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_I2S3CLKConfig(uint32_t RCC_I2S3CLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_I2S3CLK_SOURCE(RCC_I2S3CLKSource));[m
[32m+[m
[32m+[m[32m  *(__IO uint32_t *) CFGR2_I2S3SRC_BB = RCC_I2S3CLKSource;[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the External Low Speed oscillator (LSE).[m
[32m+[m[32m  * @param  RCC_LSE: specifies the new state of the LSE.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_LSE_OFF: LSE oscillator OFF[m
[32m+[m[32m  *     @arg RCC_LSE_ON: LSE oscillator ON[m
[32m+[m[32m  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_LSEConfig(uint8_t RCC_LSE)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_LSE(RCC_LSE));[m
[32m+[m[32m  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/[m
[32m+[m[32m  /* Reset LSEON bit */[m
[32m+[m[32m  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;[m
[32m+[m[32m  /* Reset LSEBYP bit */[m
[32m+[m[32m  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;[m
[32m+[m[32m  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */[m
[32m+[m[32m  switch(RCC_LSE)[m
[32m+[m[32m  {[m
[32m+[m[32m    case RCC_LSE_ON:[m
[32m+[m[32m      /* Set LSEON bit */[m
[32m+[m[32m      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;[m
[32m+[m[32m      break;[m
[32m+[m[41m      [m
[32m+[m[32m    case RCC_LSE_Bypass:[m
[32m+[m[32m      /* Set LSEBYP and LSEON bits */[m
[32m+[m[32m      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;[m
[32m+[m[32m      break;[m[41m            [m
[32m+[m[41m      [m
[32m+[m[32m    default:[m
[32m+[m[32m      break;[m[41m      [m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Internal Low Speed oscillator (LSI).[m
[32m+[m[32m  * @note   LSI can not be disabled if the IWDG is running.[m
[32m+[m[32m  * @param  NewState: new state of the LSI. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_LSICmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the RTC clock (RTCCLK).[m
[32m+[m[32m  * @note   Once the RTC clock is selected it can't be changed unless the Backup domain is reset.[m
[32m+[m[32m  * @param  RCC_RTCCLKSource: specifies the RTC clock source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RCC_RTCCLKSource_LSE: LSE selected as RTC clock[m
[32m+[m[32m  *     @arg RCC_RTCCLKSource_LSI: LSI selected as RTC clock[m
[32m+[m[32m  *     @arg RCC_RTCCLKSource_HSE_Div128: HSE clock divided by 128 selected as RTC clock[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));[m
[32m+[m[32m  /* Select the RTC clock source */[m
[32m+[m[32m  RCC->BDCR |= RCC_RTCCLKSource;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the RTC clock.[m
[32m+[m[32m  * @note   This function must be used only after the RTC clock was selected using the RCC_RTCCLKConfig function.[m
[32m+[m[32m  * @param  NewState: new state of the RTC clock. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_RTCCLKCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the frequencies of different on chip clocks.[m
[32m+[m[32m  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold[m
[32m+[m[32m  *         the clocks frequencies.[m
[32m+[m[32m  * @note   The result of this function could be not correct when using[m[41m [m
[32m+[m[32m  *         fractional value for HSE crystal.[m[41m  [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;[m
[32m+[m
[32m+[m[32m#ifdef  STM32F10X_CL[m
[32m+[m[32m  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m  uint32_t prediv1factor = 0;[m
[32m+[m[32m#endif[m
[32m+[m[41m    [m
[32m+[m[32m  /* Get SYSCLK source -------------------------------------------------------*/[m
[32m+[m[32m  tmp = RCC->CFGR & CFGR_SWS_Mask;[m
[32m+[m[41m  [m
[32m+[m[32m  switch (tmp)[m
[32m+[m[32m  {[m
[32m+[m[32m    case 0x00:  /* HSI used as system clock */[m
[32m+[m[32m      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case 0x04:  /* HSE used as system clock */[m
[32m+[m[32m      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;[m
[32m+[m[32m      break;[m
[32m+[m[32m    case 0x08:  /* PLL used as system clock */[m
[32m+[m
[32m+[m[32m      /* Get PLL clock source and multiplication factor ----------------------*/[m
[32m+[m[32m      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;[m
[32m+[m[32m      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;[m
[32m+[m[41m      [m
[32m+[m[32m#ifndef STM32F10X_CL[m[41m      [m
[32m+[m[32m      pllmull = ( pllmull >> 18) + 2;[m
[32m+[m[41m      [m
[32m+[m[32m      if (pllsource == 0x00)[m
[32m+[m[32m      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */[m
[32m+[m[32m        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m       prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;[m
[32m+[m[32m       /* HSE oscillator clock selected as PREDIV1 clock entry */[m
[32m+[m[32m       RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;[m[41m [m
[32m+[m[32m #else[m
[32m+[m[32m        /* HSE selected as PLL clock entry */[m
[32m+[m[32m        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)[m
[32m+[m[32m        {/* HSE oscillator clock divided by 2 */[m
[32m+[m[32m          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;[m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {[m
[32m+[m[32m          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;[m
[32m+[m[32m        }[m
[32m+[m[32m #endif[m
[32m+[m[32m      }[m
[32m+[m[32m#else[m
[32m+[m[32m      pllmull = pllmull >> 18;[m
[32m+[m[41m      [m
[32m+[m[32m      if (pllmull != 0x0D)[m
[32m+[m[32m      {[m
[32m+[m[32m         pllmull += 2;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      { /* PLL multiplication factor = PLL input clock * 6.5 */[m
[32m+[m[32m        pllmull = 13 / 2;[m[41m [m
[32m+[m[32m      }[m
[32m+[m[41m            [m
[32m+[m[32m      if (pllsource == 0x00)[m
[32m+[m[32m      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */[m
[32m+[m[32m        RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {/* PREDIV1 selected as PLL clock entry */[m
[32m+[m[41m        [m
[32m+[m[32m        /* Get PREDIV1 clock source and division factor */[m
[32m+[m[32m        prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;[m
[32m+[m[32m        prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;[m
[32m+[m[41m        [m
[32m+[m[32m        if (prediv1source == 0)[m
[32m+[m[32m        { /* HSE oscillator clock selected as PREDIV1 clock entry */[m
[32m+[m[32m          RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;[m[41m          [m
[32m+[m[32m        }[m
[32m+[m[32m        else[m
[32m+[m[32m        {/* PLL2 clock selected as PREDIV1 clock entry */[m
[32m+[m[41m          [m
[32m+[m[32m          /* Get PREDIV2 division factor and PLL2 multiplication factor */[m
[32m+[m[32m          prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;[m
[32m+[m[32m          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2;[m[41m [m
[32m+[m[32m          RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;[m[41m                         [m
[32m+[m[32m        }[m
[32m+[m[32m      }[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m[32m      break;[m
[32m+[m
[32m+[m[32m    default:[m
[32m+[m[32m      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;[m
[32m+[m[32m      break;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/[m
[32m+[m[32m  /* Get HCLK prescaler */[m
[32m+[m[32m  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;[m
[32m+[m[32m  tmp = tmp >> 4;[m
[32m+[m[32m  presc = APBAHBPrescTable[tmp];[m
[32m+[m[32m  /* HCLK clock frequency */[m
[32m+[m[32m  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;[m
[32m+[m[32m  /* Get PCLK1 prescaler */[m
[32m+[m[32m  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;[m
[32m+[m[32m  tmp = tmp >> 8;[m
[32m+[m[32m  presc = APBAHBPrescTable[tmp];[m
[32m+[m[32m  /* PCLK1 clock frequency */[m
[32m+[m[32m  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;[m
[32m+[m[32m  /* Get PCLK2 prescaler */[m
[32m+[m[32m  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;[m
[32m+[m[32m  tmp = tmp >> 11;[m
[32m+[m[32m  presc = APBAHBPrescTable[tmp];[m
[32m+[m[32m  /* PCLK2 clock frequency */[m
[32m+[m[32m  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;[m
[32m+[m[32m  /* Get ADCCLK prescaler */[m
[32m+[m[32m  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;[m
[32m+[m[32m  tmp = tmp >> 14;[m
[32m+[m[32m  presc = ADCPrescTable[tmp];[m
[32m+[m[32m  /* ADCCLK clock frequency */[m
[32m+[m[32m  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the AHB peripheral clock.[m
[32m+[m[32m  * @param  RCC_AHBPeriph: specifies the AHB peripheral to gates its clock.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination[m
[32m+[m[32m  *   of the following values:[m[41m        [m
[32m+[m[32m  *     @arg RCC_AHBPeriph_DMA1[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_DMA2[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_SRAM[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_FLITF[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_CRC[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_OTG_FS[m[41m    [m
[32m+[m[32m  *     @arg RCC_AHBPeriph_ETH_MAC[m[41m   [m
[32m+[m[32m  *     @arg RCC_AHBPeriph_ETH_MAC_Tx[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_ETH_MAC_Rx[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be any combination of the[m[41m [m
[32m+[m[32m  *   following values:[m[41m        [m
[32m+[m[32m  *     @arg RCC_AHBPeriph_DMA1[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_DMA2[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_SRAM[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_FLITF[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_CRC[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_FSMC[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_SDIO[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @note SRAM and FLITF clock can be disabled only during sleep mode.[m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral clock.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->AHBENR |= RCC_AHBPeriph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->AHBENR &= ~RCC_AHBPeriph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the High Speed APB (APB2) peripheral clock.[m
[32m+[m[32m  * @param  RCC_APB2Periph: specifies the APB2 peripheral to gates its clock.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,[m
[32m+[m[32m  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,[m
[32m+[m[32m  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,[m
[32m+[m[32m  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,[m
[32m+[m[32m  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,[m
[32m+[m[32m  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,[m
[32m+[m[32m  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11[m[41m     [m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral clock.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB2ENR |= RCC_APB2Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB2ENR &= ~RCC_APB2Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Low Speed APB (APB1) peripheral clock.[m
[32m+[m[32m  * @param  RCC_APB1Periph: specifies the APB1 peripheral to gates its clock.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,[m
[32m+[m[32m  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,[m
[32m+[m[32m  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,[m
[32m+[m[32m  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4,[m[41m [m
[32m+[m[32m  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,[m
[32m+[m[32m  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,[m
[32m+[m[32m  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,[m
[32m+[m[32m  *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14[m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral clock.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB1ENR |= RCC_APB1Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB1ENR &= ~RCC_APB1Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces or releases AHB peripheral reset.[m
[32m+[m[32m  * @note   This function applies only to STM32 Connectivity line devices.[m
[32m+[m[32m  * @param  RCC_AHBPeriph: specifies the AHB peripheral to reset.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RCC_AHBPeriph_OTG_FS[m[41m [m
[32m+[m[32m  *     @arg RCC_AHBPeriph_ETH_MAC[m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral reset.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_AHB_PERIPH_RESET(RCC_AHBPeriph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->AHBRSTR |= RCC_AHBPeriph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->AHBRSTR &= ~RCC_AHBPeriph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces or releases High Speed APB (APB2) peripheral reset.[m
[32m+[m[32m  * @param  RCC_APB2Periph: specifies the APB2 peripheral to reset.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RCC_APB2Periph_AFIO, RCC_APB2Periph_GPIOA, RCC_APB2Periph_GPIOB,[m
[32m+[m[32m  *          RCC_APB2Periph_GPIOC, RCC_APB2Periph_GPIOD, RCC_APB2Periph_GPIOE,[m
[32m+[m[32m  *          RCC_APB2Periph_GPIOF, RCC_APB2Periph_GPIOG, RCC_APB2Periph_ADC1,[m
[32m+[m[32m  *          RCC_APB2Periph_ADC2, RCC_APB2Periph_TIM1, RCC_APB2Periph_SPI1,[m
[32m+[m[32m  *          RCC_APB2Periph_TIM8, RCC_APB2Periph_USART1, RCC_APB2Periph_ADC3,[m
[32m+[m[32m  *          RCC_APB2Periph_TIM15, RCC_APB2Periph_TIM16, RCC_APB2Periph_TIM17,[m
[32m+[m[32m  *          RCC_APB2Periph_TIM9, RCC_APB2Periph_TIM10, RCC_APB2Periph_TIM11[m[41m  [m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral reset.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB2RSTR |= RCC_APB2Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB2RSTR &= ~RCC_APB2Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces or releases Low Speed APB (APB1) peripheral reset.[m
[32m+[m[32m  * @param  RCC_APB1Periph: specifies the APB1 peripheral to reset.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RCC_APB1Periph_TIM2, RCC_APB1Periph_TIM3, RCC_APB1Periph_TIM4,[m
[32m+[m[32m  *          RCC_APB1Periph_TIM5, RCC_APB1Periph_TIM6, RCC_APB1Periph_TIM7,[m
[32m+[m[32m  *          RCC_APB1Periph_WWDG, RCC_APB1Periph_SPI2, RCC_APB1Periph_SPI3,[m
[32m+[m[32m  *          RCC_APB1Periph_USART2, RCC_APB1Periph_USART3, RCC_APB1Periph_USART4,[m[41m [m
[32m+[m[32m  *          RCC_APB1Periph_USART5, RCC_APB1Periph_I2C1, RCC_APB1Periph_I2C2,[m
[32m+[m[32m  *          RCC_APB1Periph_USB, RCC_APB1Periph_CAN1, RCC_APB1Periph_BKP,[m
[32m+[m[32m  *          RCC_APB1Periph_PWR, RCC_APB1Periph_DAC, RCC_APB1Periph_CEC,[m
[32m+[m[32m  *          RCC_APB1Periph_TIM12, RCC_APB1Periph_TIM13, RCC_APB1Periph_TIM14[m[41m  [m
[32m+[m[32m  * @param  NewState: new state of the specified peripheral clock.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB1RSTR |= RCC_APB1Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC->APB1RSTR &= ~RCC_APB1Periph;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces or releases the Backup domain reset.[m
[32m+[m[32m  * @param  NewState: new state of the Backup domain reset.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_BackupResetCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the Clock Security System.[m
[32m+[m[32m  * @param  NewState: new state of the Clock Security System..[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the clock source to output on MCO pin.[m
[32m+[m[32m  * @param  RCC_MCO: specifies the clock source to output.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the[m
[32m+[m[32m  *   following values:[m[41m       [m
[32m+[m[32m  *     @arg RCC_MCO_NoClock: No clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_SYSCLK: System clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_HSI: HSI oscillator clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_HSE: HSE oscillator clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected[m
[32m+[m[32m  *     @arg RCC_MCO_PLL2CLK: PLL2 clock selected[m[41m                     [m
[32m+[m[32m  *     @arg RCC_MCO_PLL3CLK_Div2: PLL3 clock divided by 2 selected[m[41m   [m
[32m+[m[32m  *     @arg RCC_MCO_XT1: External 3-25 MHz oscillator clock selected[m[41m  [m
[32m+[m[32m  *     @arg RCC_MCO_PLL3CLK: PLL3 clock selected[m[41m [m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For  @b other_STM32_devices, this parameter can be one of the following values:[m[41m        [m
[32m+[m[32m  *     @arg RCC_MCO_NoClock: No clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_SYSCLK: System clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_HSI: HSI oscillator clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_HSE: HSE oscillator clock selected[m
[32m+[m[32m  *     @arg RCC_MCO_PLLCLK_Div2: PLL clock divided by 2 selected[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_MCOConfig(uint8_t RCC_MCO)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_MCO(RCC_MCO));[m
[32m+[m
[32m+[m[32m  /* Perform Byte access to MCO bits to select the MCO source */[m
[32m+[m[32m  *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified RCC flag is set or not.[m
[32m+[m[32m  * @param  RCC_FLAG: specifies the flag to check.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the[m
[32m+[m[32m  *   following values:[m
[32m+[m[32m  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_PLLRDY: PLL clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_PLL2RDY: PLL2 clock ready[m[41m      [m
[32m+[m[32m  *     @arg RCC_FLAG_PLL3RDY: PLL3 clock ready[m[41m                           [m
[32m+[m[32m  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_PINRST: Pin reset[m
[32m+[m[32m  *     @arg RCC_FLAG_PORRST: POR/PDR reset[m
[32m+[m[32m  *     @arg RCC_FLAG_SFTRST: Software reset[m
[32m+[m[32m  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset[m
[32m+[m[32m  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset[m
[32m+[m[32m  *     @arg RCC_FLAG_LPWRRST: Low Power reset[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be one of the following values:[m[41m        [m
[32m+[m[32m  *     @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_HSERDY: HSE oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_PLLRDY: PLL clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_LSERDY: LSE oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready[m
[32m+[m[32m  *     @arg RCC_FLAG_PINRST: Pin reset[m
[32m+[m[32m  *     @arg RCC_FLAG_PORRST: POR/PDR reset[m
[32m+[m[32m  *     @arg RCC_FLAG_SFTRST: Software reset[m
[32m+[m[32m  *     @arg RCC_FLAG_IWDGRST: Independent Watchdog reset[m
[32m+[m[32m  *     @arg RCC_FLAG_WWDGRST: Window Watchdog reset[m
[32m+[m[32m  *     @arg RCC_FLAG_LPWRRST: Low Power reset[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @retval The new state of RCC_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0;[m
[32m+[m[32m  uint32_t statusreg = 0;[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_FLAG(RCC_FLAG));[m
[32m+[m
[32m+[m[32m  /* Get the RCC register index */[m
[32m+[m[32m  tmp = RCC_FLAG >> 5;[m
[32m+[m[32m  if (tmp == 1)               /* The flag to check is in CR register */[m
[32m+[m[32m  {[m
[32m+[m[32m    statusreg = RCC->CR;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (tmp == 2)          /* The flag to check is in BDCR register */[m
[32m+[m[32m  {[m
[32m+[m[32m    statusreg = RCC->BDCR;[m
[32m+[m[32m  }[m
[32m+[m[32m  else                       /* The flag to check is in CSR register */[m
[32m+[m[32m  {[m
[32m+[m[32m    statusreg = RCC->CSR;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Get the flag position */[m
[32m+[m[32m  tmp = RCC_FLAG & FLAG_Mask;[m
[32m+[m[32m  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Return the flag status */[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the RCC reset flags.[m
[32m+[m[32m  * @note   The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST,[m
[32m+[m[32m  *   RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_ClearFlag(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set RMVF bit to clear the reset flags */[m
[32m+[m[32m  RCC->CSR |= CSR_RMVF_Set;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified RCC interrupt has occurred or not.[m
[32m+[m[32m  * @param  RCC_IT: specifies the RCC interrupt source to check.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be one of the[m
[32m+[m[32m  *   following values:[m
[32m+[m[32m  *     @arg RCC_IT_LSIRDY: LSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_LSERDY: LSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSIRDY: HSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSERDY: HSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLLRDY: PLL ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt[m[41m [m
[32m+[m[32m  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt[m[41m                      [m
[32m+[m[32m  *     @arg RCC_IT_CSS: Clock Security System interrupt[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be one of the following values:[m[41m        [m
[32m+[m[32m  *     @arg RCC_IT_LSIRDY: LSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_LSERDY: LSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSIRDY: HSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSERDY: HSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLLRDY: PLL ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_CSS: Clock Security System interrupt[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @retval The new state of RCC_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus RCC_GetITStatus(uint8_t RCC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_GET_IT(RCC_IT));[m
[32m+[m
[32m+[m[32m  /* Check the status of the specified RCC interrupt */[m
[32m+[m[32m  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Return the RCC_IT status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the RCC's interrupt pending bits.[m
[32m+[m[32m  * @param  RCC_IT: specifies the interrupt pending bit to clear.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  *   For @b STM32_Connectivity_line_devices, this parameter can be any combination[m
[32m+[m[32m  *   of the following values:[m
[32m+[m[32m  *     @arg RCC_IT_LSIRDY: LSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_LSERDY: LSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSIRDY: HSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSERDY: HSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLLRDY: PLL ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLL2RDY: PLL2 ready interrupt[m[41m [m
[32m+[m[32m  *     @arg RCC_IT_PLL3RDY: PLL3 ready interrupt[m[41m                      [m
[32m+[m[32m  *     @arg RCC_IT_CSS: Clock Security System interrupt[m
[32m+[m[32m  *[m[41m [m
[32m+[m[32m  *   For @b other_STM32_devices, this parameter can be any combination of the[m
[32m+[m[32m  *   following values:[m[41m        [m
[32m+[m[32m  *     @arg RCC_IT_LSIRDY: LSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_LSERDY: LSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSIRDY: HSI ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_HSERDY: HSE ready interrupt[m
[32m+[m[32m  *     @arg RCC_IT_PLLRDY: PLL ready interrupt[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  *     @arg RCC_IT_CSS: Clock Security System interrupt[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RCC_ClearITPendingBit(uint8_t RCC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RCC_CLEAR_IT(RCC_IT));[m
[32m+[m
[32m+[m[32m  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt[m
[32m+[m[32m     pending bits */[m
[32m+[m[32m  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c[m
[1mnew file mode 100644[m
[1mindex 0000000..f05aef5[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_rtc.c[m
[36m@@ -0,0 +1,339 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_rtc.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the RTC firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_rtc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC[m[41m [m
[32m+[m[32m  * @brief RTC driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[32m#define RTC_LSB_MASK     ((uint32_t)0x0000FFFF)  /*!< RTC LSB Mask */[m
[32m+[m[32m#define PRLH_MSB_MASK    ((uint32_t)0x000F0000)  /*!< RTC Prescaler MSB Mask */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup RTC_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified RTC interrupts.[m
[32m+[m[32m  * @param  RTC_IT: specifies the RTC interrupts sources to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RTC_IT_OW: Overflow interrupt[m
[32m+[m[32m  *     @arg RTC_IT_ALR: Alarm interrupt[m
[32m+[m[32m  *     @arg RTC_IT_SEC: Second interrupt[m
[32m+[m[32m  * @param  NewState: new state of the specified RTC interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RTC_IT(RTC_IT));[m[41m  [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    RTC->CRH |= RTC_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    RTC->CRH &= (uint16_t)~RTC_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enters the RTC configuration mode.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_EnterConfigMode(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the CNF flag to enter in the Configuration Mode */[m
[32m+[m[32m  RTC->CRL |= RTC_CRL_CNF;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Exits from the RTC configuration mode.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_ExitConfigMode(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Reset the CNF flag to exit from the Configuration Mode */[m
[32m+[m[32m  RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF);[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the RTC counter value.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval RTC counter value.[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t RTC_GetCounter(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmp = 0;[m
[32m+[m[32m  tmp = RTC->CNTL;[m
[32m+[m[32m  return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the RTC counter value.[m
[32m+[m[32m  * @param  CounterValue: RTC counter new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_SetCounter(uint32_t CounterValue)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  RTC_EnterConfigMode();[m
[32m+[m[32m  /* Set RTC COUNTER MSB word */[m
[32m+[m[32m  RTC->CNTH = CounterValue >> 16;[m
[32m+[m[32m  /* Set RTC COUNTER LSB word */[m
[32m+[m[32m  RTC->CNTL = (CounterValue & RTC_LSB_MASK);[m
[32m+[m[32m  RTC_ExitConfigMode();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the RTC prescaler value.[m
[32m+[m[32m  * @param  PrescalerValue: RTC prescaler new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_SetPrescaler(uint32_t PrescalerValue)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RTC_PRESCALER(PrescalerValue));[m
[32m+[m[41m  [m
[32m+[m[32m  RTC_EnterConfigMode();[m
[32m+[m[32m  /* Set RTC PRESCALER MSB word */[m
[32m+[m[32m  RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;[m
[32m+[m[32m  /* Set RTC PRESCALER LSB word */[m
[32m+[m[32m  RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);[m
[32m+[m[32m  RTC_ExitConfigMode();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the RTC alarm value.[m
[32m+[m[32m  * @param  AlarmValue: RTC alarm new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_SetAlarm(uint32_t AlarmValue)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  RTC_EnterConfigMode();[m
[32m+[m[32m  /* Set the ALARM MSB word */[m
[32m+[m[32m  RTC->ALRH = AlarmValue >> 16;[m
[32m+[m[32m  /* Set the ALARM LSB word */[m
[32m+[m[32m  RTC->ALRL = (AlarmValue & RTC_LSB_MASK);[m
[32m+[m[32m  RTC_ExitConfigMode();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the RTC divider value.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval RTC Divider value.[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t RTC_GetDivider(void)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0x00;[m
[32m+[m[32m  tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;[m
[32m+[m[32m  tmp |= RTC->DIVL;[m
[32m+[m[32m  return tmp;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Waits until last write operation on RTC registers has finished.[m
[32m+[m[32m  * @note   This function must be called before any write to RTC registers.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_WaitForLastTask(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Loop until RTOFF flag is set */[m
[32m+[m[32m  while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Waits until the RTC registers (RTC_CNT, RTC_ALR and RTC_PRL)[m
[32m+[m[32m  *   are synchronized with RTC APB clock.[m
[32m+[m[32m  * @note   This function must be called before any read operation after an APB reset[m
[32m+[m[32m  *   or an APB clock stop.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_WaitForSynchro(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Clear RSF flag */[m
[32m+[m[32m  RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;[m
[32m+[m[32m  /* Loop until RSF flag is set */[m
[32m+[m[32m  while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified RTC flag is set or not.[m
[32m+[m[32m  * @param  RTC_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one the following values:[m
[32m+[m[32m  *     @arg RTC_FLAG_RTOFF: RTC Operation OFF flag[m
[32m+[m[32m  *     @arg RTC_FLAG_RSF: Registers Synchronized flag[m
[32m+[m[32m  *     @arg RTC_FLAG_OW: Overflow flag[m
[32m+[m[32m  *     @arg RTC_FLAG_ALR: Alarm flag[m
[32m+[m[32m  *     @arg RTC_FLAG_SEC: Second flag[m
[32m+[m[32m  * @retval The new state of RTC_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RTC_GET_FLAG(RTC_FLAG));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the RTC's pending flags.[m
[32m+[m[32m  * @param  RTC_FLAG: specifies the flag to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RTC_FLAG_RSF: Registers Synchronized flag. This flag is cleared only after[m
[32m+[m[32m  *                        an APB reset or an APB Clock stop.[m
[32m+[m[32m  *     @arg RTC_FLAG_OW: Overflow flag[m
[32m+[m[32m  *     @arg RTC_FLAG_ALR: Alarm flag[m
[32m+[m[32m  *     @arg RTC_FLAG_SEC: Second flag[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_ClearFlag(uint16_t RTC_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m  /* Clear the corresponding RTC flag */[m
[32m+[m[32m  RTC->CRL &= (uint16_t)~RTC_FLAG;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified RTC interrupt has occurred or not.[m
[32m+[m[32m  * @param  RTC_IT: specifies the RTC interrupts sources to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg RTC_IT_OW: Overflow interrupt[m
[32m+[m[32m  *     @arg RTC_IT_ALR: Alarm interrupt[m
[32m+[m[32m  *     @arg RTC_IT_SEC: Second interrupt[m
[32m+[m[32m  * @retval The new state of the RTC_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus RTC_GetITStatus(uint16_t RTC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RTC_GET_IT(RTC_IT));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  bitstatus = (ITStatus)(RTC->CRL & RTC_IT);[m
[32m+[m[32m  if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the RTC's interrupt pending bits.[m
[32m+[m[32m  * @param  RTC_IT: specifies the interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg RTC_IT_OW: Overflow interrupt[m
[32m+[m[32m  *     @arg RTC_IT_ALR: Alarm interrupt[m
[32m+[m[32m  *     @arg RTC_IT_SEC: Second interrupt[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid RTC_ClearITPendingBit(uint16_t RTC_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_RTC_IT(RTC_IT));[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear the corresponding RTC pending bit */[m
[32m+[m[32m  RTC->CRL &= (uint16_t)~RTC_IT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c[m
[1mnew file mode 100644[m
[1mindex 0000000..bc1719d[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_sdio.c[m
[36m@@ -0,0 +1,799 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_sdio.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the SDIO firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_sdio.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO[m[41m [m
[32m+[m[32m  * @brief SDIO driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/* ------------ SDIO registers bit address in the alias region ----------- */[m
[32m+[m[32m#define SDIO_OFFSET                (SDIO_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* --- CLKCR Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of CLKEN bit */[m
[32m+[m[32m#define CLKCR_OFFSET              (SDIO_OFFSET + 0x04)[m
[32m+[m[32m#define CLKEN_BitNumber           0x08[m
[32m+[m[32m#define CLKCR_CLKEN_BB            (PERIPH_BB_BASE + (CLKCR_OFFSET * 32) + (CLKEN_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- CMD Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of SDIOSUSPEND bit */[m
[32m+[m[32m#define CMD_OFFSET                (SDIO_OFFSET + 0x0C)[m
[32m+[m[32m#define SDIOSUSPEND_BitNumber     0x0B[m
[32m+[m[32m#define CMD_SDIOSUSPEND_BB        (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (SDIOSUSPEND_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of ENCMDCOMPL bit */[m
[32m+[m[32m#define ENCMDCOMPL_BitNumber      0x0C[m
[32m+[m[32m#define CMD_ENCMDCOMPL_BB         (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ENCMDCOMPL_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of NIEN bit */[m
[32m+[m[32m#define NIEN_BitNumber            0x0D[m
[32m+[m[32m#define CMD_NIEN_BB               (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (NIEN_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of ATACMD bit */[m
[32m+[m[32m#define ATACMD_BitNumber          0x0E[m
[32m+[m[32m#define CMD_ATACMD_BB             (PERIPH_BB_BASE + (CMD_OFFSET * 32) + (ATACMD_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --- DCTRL Register ---*/[m
[32m+[m
[32m+[m[32m/* Alias word address of DMAEN bit */[m
[32m+[m[32m#define DCTRL_OFFSET              (SDIO_OFFSET + 0x2C)[m
[32m+[m[32m#define DMAEN_BitNumber           0x03[m
[32m+[m[32m#define DCTRL_DMAEN_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (DMAEN_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of RWSTART bit */[m
[32m+[m[32m#define RWSTART_BitNumber         0x08[m
[32m+[m[32m#define DCTRL_RWSTART_BB          (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTART_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of RWSTOP bit */[m
[32m+[m[32m#define RWSTOP_BitNumber          0x09[m
[32m+[m[32m#define DCTRL_RWSTOP_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWSTOP_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of RWMOD bit */[m
[32m+[m[32m#define RWMOD_BitNumber           0x0A[m
[32m+[m[32m#define DCTRL_RWMOD_BB            (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (RWMOD_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* Alias word address of SDIOEN bit */[m
[32m+[m[32m#define SDIOEN_BitNumber          0x0B[m
[32m+[m[32m#define DCTRL_SDIOEN_BB           (PERIPH_BB_BASE + (DCTRL_OFFSET * 32) + (SDIOEN_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* ---------------------- SDIO registers bit mask ------------------------ */[m
[32m+[m
[32m+[m[32m/* --- CLKCR Register ---*/[m
[32m+[m
[32m+[m[32m/* CLKCR register clear mask */[m
[32m+[m[32m#define CLKCR_CLEAR_MASK         ((uint32_t)0xFFFF8100)[m[41m [m
[32m+[m
[32m+[m[32m/* --- PWRCTRL Register ---*/[m
[32m+[m
[32m+[m[32m/* SDIO PWRCTRL Mask */[m
[32m+[m[32m#define PWR_PWRCTRL_MASK         ((uint32_t)0xFFFFFFFC)[m
[32m+[m
[32m+[m[32m/* --- DCTRL Register ---*/[m
[32m+[m
[32m+[m[32m/* SDIO DCTRL Clear Mask */[m
[32m+[m[32m#define DCTRL_CLEAR_MASK         ((uint32_t)0xFFFFFF08)[m
[32m+[m
[32m+[m[32m/* --- CMD Register ---*/[m
[32m+[m
[32m+[m[32m/* CMD Register clear mask */[m
[32m+[m[32m#define CMD_CLEAR_MASK           ((uint32_t)0xFFFFF800)[m
[32m+[m
[32m+[m[32m/* SDIO RESP Registers Address */[m
[32m+[m[32m#define SDIO_RESP_ADDR           ((uint32_t)(SDIO_BASE + 0x14))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SDIO_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the SDIO peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  SDIO->POWER = 0x00000000;[m
[32m+[m[32m  SDIO->CLKCR = 0x00000000;[m
[32m+[m[32m  SDIO->ARG = 0x00000000;[m
[32m+[m[32m  SDIO->CMD = 0x00000000;[m
[32m+[m[32m  SDIO->DTIMER = 0x00000000;[m
[32m+[m[32m  SDIO->DLEN = 0x00000000;[m
[32m+[m[32m  SDIO->DCTRL = 0x00000000;[m
[32m+[m[32m  SDIO->ICR = 0x00C007FF;[m
[32m+[m[32m  SDIO->MASK = 0x00000000;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the SDIO peripheral according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the SDIO_InitStruct.[m
[32m+[m[32m  * @param  SDIO_InitStruct : pointer to a SDIO_InitTypeDef structure[m[41m [m
[32m+[m[32m  *         that contains the configuration information for the SDIO peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_CLOCK_EDGE(SDIO_InitStruct->SDIO_ClockEdge));[m
[32m+[m[32m  assert_param(IS_SDIO_CLOCK_BYPASS(SDIO_InitStruct->SDIO_ClockBypass));[m
[32m+[m[32m  assert_param(IS_SDIO_CLOCK_POWER_SAVE(SDIO_InitStruct->SDIO_ClockPowerSave));[m
[32m+[m[32m  assert_param(IS_SDIO_BUS_WIDE(SDIO_InitStruct->SDIO_BusWide));[m
[32m+[m[32m  assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(SDIO_InitStruct->SDIO_HardwareFlowControl));[m[41m [m
[32m+[m[41m   [m
[32m+[m[32m/*---------------------------- SDIO CLKCR Configuration ------------------------*/[m[41m  [m
[32m+[m[32m  /* Get the SDIO CLKCR value */[m
[32m+[m[32m  tmpreg = SDIO->CLKCR;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear CLKDIV, PWRSAV, BYPASS, WIDBUS, NEGEDGE, HWFC_EN bits */[m
[32m+[m[32m  tmpreg &= CLKCR_CLEAR_MASK;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set CLKDIV bits according to SDIO_ClockDiv value */[m
[32m+[m[32m  /* Set PWRSAV bit according to SDIO_ClockPowerSave value */[m
[32m+[m[32m  /* Set BYPASS bit according to SDIO_ClockBypass value */[m
[32m+[m[32m  /* Set WIDBUS bits according to SDIO_BusWide value */[m
[32m+[m[32m  /* Set NEGEDGE bits according to SDIO_ClockEdge value */[m
[32m+[m[32m  /* Set HWFC_EN bits according to SDIO_HardwareFlowControl value */[m
[32m+[m[32m  tmpreg |= (SDIO_InitStruct->SDIO_ClockDiv  | SDIO_InitStruct->SDIO_ClockPowerSave |[m
[32m+[m[32m             SDIO_InitStruct->SDIO_ClockBypass | SDIO_InitStruct->SDIO_BusWide |[m
[32m+[m[32m             SDIO_InitStruct->SDIO_ClockEdge | SDIO_InitStruct->SDIO_HardwareFlowControl);[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to SDIO CLKCR */[m
[32m+[m[32m  SDIO->CLKCR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each SDIO_InitStruct member with its default value.[m
[32m+[m[32m  * @param  SDIO_InitStruct: pointer to an SDIO_InitTypeDef structure which[m[41m [m
[32m+[m[32m  *   will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* SDIO_InitStruct members default value */[m
[32m+[m[32m  SDIO_InitStruct->SDIO_ClockDiv = 0x00;[m
[32m+[m[32m  SDIO_InitStruct->SDIO_ClockEdge = SDIO_ClockEdge_Rising;[m
[32m+[m[32m  SDIO_InitStruct->SDIO_ClockBypass = SDIO_ClockBypass_Disable;[m
[32m+[m[32m  SDIO_InitStruct->SDIO_ClockPowerSave = SDIO_ClockPowerSave_Disable;[m
[32m+[m[32m  SDIO_InitStruct->SDIO_BusWide = SDIO_BusWide_1b;[m
[32m+[m[32m  SDIO_InitStruct->SDIO_HardwareFlowControl = SDIO_HardwareFlowControl_Disable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SDIO Clock.[m
[32m+[m[32m  * @param  NewState: new state of the SDIO Clock. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_ClockCmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) CLKCR_CLKEN_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the power status of the controller.[m
[32m+[m[32m  * @param  SDIO_PowerState: new state of the Power state.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SDIO_PowerState_OFF[m
[32m+[m[32m  *     @arg SDIO_PowerState_ON[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_SetPowerState(uint32_t SDIO_PowerState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_POWER_STATE(SDIO_PowerState));[m
[32m+[m[41m  [m
[32m+[m[32m  SDIO->POWER &= PWR_PWRCTRL_MASK;[m
[32m+[m[32m  SDIO->POWER |= SDIO_PowerState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the power status of the controller.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Power status of the controller. The returned value can[m
[32m+[m[32m  *   be one of the following:[m
[32m+[m[32m  * - 0x00: Power OFF[m
[32m+[m[32m  * - 0x02: Power UP[m
[32m+[m[32m  * - 0x03: Power ON[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32muint32_t SDIO_GetPowerState(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (SDIO->POWER & (~PWR_PWRCTRL_MASK));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SDIO interrupts.[m
[32m+[m[32m  * @param  SDIO_IT: specifies the SDIO interrupt sources to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be one or a combination of the following values:[m
[32m+[m[32m  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide[m[41m [m
[32m+[m[32m  *                            bus mode interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt[m
[32m+[m[32m  * @param  NewState: new state of the specified SDIO interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m[41m [m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_IT(SDIO_IT));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the SDIO interrupts */[m
[32m+[m[32m    SDIO->MASK |= SDIO_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the SDIO interrupts */[m
[32m+[m[32m    SDIO->MASK &= ~SDIO_IT;[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SDIO DMA request.[m
[32m+[m[32m  * @param  NewState: new state of the selected SDIO DMA request.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_DMACmd(FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) DCTRL_DMAEN_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the SDIO Command according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the SDIO_CmdInitStruct and send the command.[m
[32m+[m[32m  * @param  SDIO_CmdInitStruct : pointer to a SDIO_CmdInitTypeDef[m[41m [m
[32m+[m[32m  *         structure that contains the configuration information for the SDIO command.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_CMD_INDEX(SDIO_CmdInitStruct->SDIO_CmdIndex));[m
[32m+[m[32m  assert_param(IS_SDIO_RESPONSE(SDIO_CmdInitStruct->SDIO_Response));[m
[32m+[m[32m  assert_param(IS_SDIO_WAIT(SDIO_CmdInitStruct->SDIO_Wait));[m
[32m+[m[32m  assert_param(IS_SDIO_CPSM(SDIO_CmdInitStruct->SDIO_CPSM));[m
[32m+[m[41m  [m
[32m+[m[32m/*---------------------------- SDIO ARG Configuration ------------------------*/[m
[32m+[m[32m  /* Set the SDIO Argument value */[m
[32m+[m[32m  SDIO->ARG = SDIO_CmdInitStruct->SDIO_Argument;[m
[32m+[m[41m  [m
[32m+[m[32m/*---------------------------- SDIO CMD Configuration ------------------------*/[m[41m  [m
[32m+[m[32m  /* Get the SDIO CMD value */[m
[32m+[m[32m  tmpreg = SDIO->CMD;[m
[32m+[m[32m  /* Clear CMDINDEX, WAITRESP, WAITINT, WAITPEND, CPSMEN bits */[m
[32m+[m[32m  tmpreg &= CMD_CLEAR_MASK;[m
[32m+[m[32m  /* Set CMDINDEX bits according to SDIO_CmdIndex value */[m
[32m+[m[32m  /* Set WAITRESP bits according to SDIO_Response value */[m
[32m+[m[32m  /* Set WAITINT and WAITPEND bits according to SDIO_Wait value */[m
[32m+[m[32m  /* Set CPSMEN bits according to SDIO_CPSM value */[m
[32m+[m[32m  tmpreg |= (uint32_t)SDIO_CmdInitStruct->SDIO_CmdIndex | SDIO_CmdInitStruct->SDIO_Response[m
[32m+[m[32m           | SDIO_CmdInitStruct->SDIO_Wait | SDIO_CmdInitStruct->SDIO_CPSM;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to SDIO CMD */[m
[32m+[m[32m  SDIO->CMD = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each SDIO_CmdInitStruct member with its default value.[m
[32m+[m[32m  * @param  SDIO_CmdInitStruct: pointer to an SDIO_CmdInitTypeDef[m[41m [m
[32m+[m[32m  *         structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* SDIO_CmdInitStruct members default value */[m
[32m+[m[32m  SDIO_CmdInitStruct->SDIO_Argument = 0x00;[m
[32m+[m[32m  SDIO_CmdInitStruct->SDIO_CmdIndex = 0x00;[m
[32m+[m[32m  SDIO_CmdInitStruct->SDIO_Response = SDIO_Response_No;[m
[32m+[m[32m  SDIO_CmdInitStruct->SDIO_Wait = SDIO_Wait_No;[m
[32m+[m[32m  SDIO_CmdInitStruct->SDIO_CPSM = SDIO_CPSM_Disable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns command index of last command for which response received.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Returns the command index of the last command response received.[m
[32m+[m[32m  */[m
[32m+[m[32muint8_t SDIO_GetCommandResponse(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (uint8_t)(SDIO->RESPCMD);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns response received from the card for the last command.[m
[32m+[m[32m  * @param  SDIO_RESP: Specifies the SDIO response register.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SDIO_RESP1: Response Register 1[m
[32m+[m[32m  *     @arg SDIO_RESP2: Response Register 2[m
[32m+[m[32m  *     @arg SDIO_RESP3: Response Register 3[m
[32m+[m[32m  *     @arg SDIO_RESP4: Response Register 4[m
[32m+[m[32m  * @retval The Corresponding response register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t SDIO_GetResponse(uint32_t SDIO_RESP)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_RESP(SDIO_RESP));[m
[32m+[m
[32m+[m[32m  tmp = SDIO_RESP_ADDR + SDIO_RESP;[m
[32m+[m[41m  [m
[32m+[m[32m  return (*(__IO uint32_t *) tmp);[m[41m [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the SDIO data path according to the specified[m[41m [m
[32m+[m[32m  *   parameters in the SDIO_DataInitStruct.[m
[32m+[m[32m  * @param  SDIO_DataInitStruct : pointer to a SDIO_DataInitTypeDef structure that[m
[32m+[m[32m  *   contains the configuration information for the SDIO command.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_DATA_LENGTH(SDIO_DataInitStruct->SDIO_DataLength));[m
[32m+[m[32m  assert_param(IS_SDIO_BLOCK_SIZE(SDIO_DataInitStruct->SDIO_DataBlockSize));[m
[32m+[m[32m  assert_param(IS_SDIO_TRANSFER_DIR(SDIO_DataInitStruct->SDIO_TransferDir));[m
[32m+[m[32m  assert_param(IS_SDIO_TRANSFER_MODE(SDIO_DataInitStruct->SDIO_TransferMode));[m
[32m+[m[32m  assert_param(IS_SDIO_DPSM(SDIO_DataInitStruct->SDIO_DPSM));[m
[32m+[m
[32m+[m[32m/*---------------------------- SDIO DTIMER Configuration ---------------------*/[m
[32m+[m[32m  /* Set the SDIO Data TimeOut value */[m
[32m+[m[32m  SDIO->DTIMER = SDIO_DataInitStruct->SDIO_DataTimeOut;[m
[32m+[m
[32m+[m[32m/*---------------------------- SDIO DLEN Configuration -----------------------*/[m
[32m+[m[32m  /* Set the SDIO DataLength value */[m
[32m+[m[32m  SDIO->DLEN = SDIO_DataInitStruct->SDIO_DataLength;[m
[32m+[m
[32m+[m[32m/*---------------------------- SDIO DCTRL Configuration ----------------------*/[m[41m  [m
[32m+[m[32m  /* Get the SDIO DCTRL value */[m
[32m+[m[32m  tmpreg = SDIO->DCTRL;[m
[32m+[m[32m  /* Clear DEN, DTMODE, DTDIR and DBCKSIZE bits */[m
[32m+[m[32m  tmpreg &= DCTRL_CLEAR_MASK;[m
[32m+[m[32m  /* Set DEN bit according to SDIO_DPSM value */[m
[32m+[m[32m  /* Set DTMODE bit according to SDIO_TransferMode value */[m
[32m+[m[32m  /* Set DTDIR bit according to SDIO_TransferDir value */[m
[32m+[m[32m  /* Set DBCKSIZE bits according to SDIO_DataBlockSize value */[m
[32m+[m[32m  tmpreg |= (uint32_t)SDIO_DataInitStruct->SDIO_DataBlockSize | SDIO_DataInitStruct->SDIO_TransferDir[m
[32m+[m[32m           | SDIO_DataInitStruct->SDIO_TransferMode | SDIO_DataInitStruct->SDIO_DPSM;[m
[32m+[m
[32m+[m[32m  /* Write to SDIO DCTRL */[m
[32m+[m[32m  SDIO->DCTRL = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each SDIO_DataInitStruct member with its default value.[m
[32m+[m[32m  * @param  SDIO_DataInitStruct: pointer to an SDIO_DataInitTypeDef structure which[m
[32m+[m[32m  *         will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* SDIO_DataInitStruct members default value */[m
[32m+[m[32m  SDIO_DataInitStruct->SDIO_DataTimeOut = 0xFFFFFFFF;[m
[32m+[m[32m  SDIO_DataInitStruct->SDIO_DataLength = 0x00;[m
[32m+[m[32m  SDIO_DataInitStruct->SDIO_DataBlockSize = SDIO_DataBlockSize_1b;[m
[32m+[m[32m  SDIO_DataInitStruct->SDIO_TransferDir = SDIO_TransferDir_ToCard;[m
[32m+[m[32m  SDIO_DataInitStruct->SDIO_TransferMode = SDIO_TransferMode_Block;[m[41m  [m
[32m+[m[32m  SDIO_DataInitStruct->SDIO_DPSM = SDIO_DPSM_Disable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns number of remaining data bytes to be transferred.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Number of remaining data bytes to be transferred[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t SDIO_GetDataCounter(void)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  return SDIO->DCOUNT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Read one data word from Rx FIFO.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Data received[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t SDIO_ReadData(void)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  return SDIO->FIFO;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Write one data word to Tx FIFO.[m
[32m+[m[32m  * @param  Data: 32-bit data word to write.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_WriteData(uint32_t Data)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  SDIO->FIFO = Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the number of words left to be written to or read from FIFO.[m[41m	[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval Remaining number of words.[m
[32m+[m[32m  */[m
[32m+[m[32muint32_t SDIO_GetFIFOCount(void)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  return SDIO->FIFOCNT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Starts the SD I/O Read Wait operation.[m[41m	[m
[32m+[m[32m  * @param  NewState: new state of the Start SDIO Read Wait operation.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_StartSDIOReadWait(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) DCTRL_RWSTART_BB = (uint32_t) NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Stops the SD I/O Read Wait operation.[m[41m	[m
[32m+[m[32m  * @param  NewState: new state of the Stop SDIO Read Wait operation.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_StopSDIOReadWait(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) DCTRL_RWSTOP_BB = (uint32_t) NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets one of the two options of inserting read wait interval.[m
[32m+[m[32m  * @param  SDIO_ReadWaitMode: SD I/O Read Wait operation mode.[m
[32m+[m[32m  *   This parameter can be:[m
[32m+[m[32m  *     @arg SDIO_ReadWaitMode_CLK: Read Wait control by stopping SDIOCLK[m
[32m+[m[32m  *     @arg SDIO_ReadWaitMode_DATA2: Read Wait control using SDIO_DATA2[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) DCTRL_RWMOD_BB = SDIO_ReadWaitMode;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SD I/O Mode Operation.[m
[32m+[m[32m  * @param  NewState: new state of SDIO specific operation.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_SetSDIOOperation(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) DCTRL_SDIOEN_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SD I/O Mode suspend command sending.[m
[32m+[m[32m  * @param  NewState: new state of the SD I/O Mode suspend command.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_SendSDIOSuspendCmd(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) CMD_SDIOSUSPEND_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the command completion signal.[m
[32m+[m[32m  * @param  NewState: new state of command completion signal.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_CommandCompletionCmd(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) CMD_ENCMDCOMPL_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the CE-ATA interrupt.[m
[32m+[m[32m  * @param  NewState: new state of CE-ATA interrupt. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_CEATAITCmd(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) CMD_NIEN_BB = (uint32_t)((~((uint32_t)NewState)) & ((uint32_t)0x1));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sends CE-ATA command (CMD61).[m
[32m+[m[32m  * @param  NewState: new state of CE-ATA command. This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_SendCEATACmd(FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  *(__IO uint32_t *) CMD_ATACMD_BB = (uint32_t)NewState;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified SDIO flag is set or not.[m
[32m+[m[32m  * @param  SDIO_FLAG: specifies the flag to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout[m
[32m+[m[32m  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error[m
[32m+[m[32m  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)[m
[32m+[m[32m  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)[m
[32m+[m[32m  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide[m[41m [m
[32m+[m[32m  *                              bus mode.[m
[32m+[m[32m  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_CMDACT:   Command transfer in progress[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXACT:    Data transmit in progress[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXACT:    Data receive in progress[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXFIFOHE: Transmit FIFO Half Empty[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXFIFOHF: Receive FIFO Half Full[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXFIFOF:  Transmit FIFO full[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXFIFOF:  Receive FIFO full[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXFIFOE:  Transmit FIFO empty[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXFIFOE:  Receive FIFO empty[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXDAVL:   Data available in transmit FIFO[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXDAVL:   Data available in receive FIFO[m
[32m+[m[32m  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received[m
[32m+[m[32m  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61[m
[32m+[m[32m  * @retval The new state of SDIO_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_FLAG(SDIO_FLAG));[m
[32m+[m[41m  [m
[32m+[m[32m  if ((SDIO->STA & SDIO_FLAG) != (uint32_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the SDIO's pending flags.[m
[32m+[m[32m  * @param  SDIO_FLAG: specifies the flag to clear.[m[41m  [m
[32m+[m[32m  *   This parameter can be one or a combination of the following values:[m
[32m+[m[32m  *     @arg SDIO_FLAG_CCRCFAIL: Command response received (CRC check failed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_DCRCFAIL: Data block sent/received (CRC check failed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_CTIMEOUT: Command response timeout[m
[32m+[m[32m  *     @arg SDIO_FLAG_DTIMEOUT: Data timeout[m
[32m+[m[32m  *     @arg SDIO_FLAG_TXUNDERR: Transmit FIFO underrun error[m
[32m+[m[32m  *     @arg SDIO_FLAG_RXOVERR:  Received FIFO overrun error[m
[32m+[m[32m  *     @arg SDIO_FLAG_CMDREND:  Command response received (CRC check passed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_CMDSENT:  Command sent (no response required)[m
[32m+[m[32m  *     @arg SDIO_FLAG_DATAEND:  Data end (data counter, SDIDCOUNT, is zero)[m
[32m+[m[32m  *     @arg SDIO_FLAG_STBITERR: Start bit not detected on all data signals in wide[m[41m [m
[32m+[m[32m  *                              bus mode[m
[32m+[m[32m  *     @arg SDIO_FLAG_DBCKEND:  Data block sent/received (CRC check passed)[m
[32m+[m[32m  *     @arg SDIO_FLAG_SDIOIT:   SD I/O interrupt received[m
[32m+[m[32m  *     @arg SDIO_FLAG_CEATAEND: CE-ATA command completion signal received for CMD61[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_ClearFlag(uint32_t SDIO_FLAG)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_CLEAR_FLAG(SDIO_FLAG));[m
[32m+[m[41m   [m
[32m+[m[32m  SDIO->ICR = SDIO_FLAG;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified SDIO interrupt has occurred or not.[m
[32m+[m[32m  * @param  SDIO_IT: specifies the SDIO interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide[m[41m [m
[32m+[m[32m  *                            bus mode interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DBCKEND:  Data block sent/received (CRC check passed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDACT:   Command transfer in progress interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXACT:    Data transmit in progress interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXACT:    Data receive in progress interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXFIFOHE: Transmit FIFO Half Empty interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXFIFOHF: Receive FIFO Half Full interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXFIFOF:  Transmit FIFO full interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXFIFOF:  Receive FIFO full interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXFIFOE:  Transmit FIFO empty interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXFIFOE:  Receive FIFO empty interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXDAVL:   Data available in transmit FIFO interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXDAVL:   Data available in receive FIFO interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61 interrupt[m
[32m+[m[32m  * @retval The new state of SDIO_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus SDIO_GetITStatus(uint32_t SDIO_IT)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_GET_IT(SDIO_IT));[m
[32m+[m[32m  if ((SDIO->STA & SDIO_IT) != (uint32_t)RESET)[m[41m  [m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the SDIO's interrupt pending bits.[m
[32m+[m[32m  * @param  SDIO_IT: specifies the interrupt pending bit to clear.[m[41m [m
[32m+[m[32m  *   This parameter can be one or a combination of the following values:[m
[32m+[m[32m  *     @arg SDIO_IT_CCRCFAIL: Command response received (CRC check failed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DCRCFAIL: Data block sent/received (CRC check failed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CTIMEOUT: Command response timeout interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DTIMEOUT: Data timeout interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_TXUNDERR: Transmit FIFO underrun error interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_RXOVERR:  Received FIFO overrun error interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDREND:  Command response received (CRC check passed) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CMDSENT:  Command sent (no response required) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_DATAEND:  Data end (data counter, SDIDCOUNT, is zero) interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_STBITERR: Start bit not detected on all data signals in wide[m[41m [m
[32m+[m[32m  *                            bus mode interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_SDIOIT:   SD I/O interrupt received interrupt[m
[32m+[m[32m  *     @arg SDIO_IT_CEATAEND: CE-ATA command completion signal received for CMD61[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SDIO_ClearITPendingBit(uint32_t SDIO_IT)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SDIO_CLEAR_IT(SDIO_IT));[m
[32m+[m[41m   [m
[32m+[m[32m  SDIO->ICR = SDIO_IT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c[m
[1mnew file mode 100644[m
[1mindex 0000000..4ec65b2[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_spi.c[m
[36m@@ -0,0 +1,908 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_spi.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the SPI firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_spi.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI[m[41m [m
[32m+[m[32m  * @brief SPI driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* SPI SPE mask */[m
[32m+[m[32m#define CR1_SPE_Set          ((uint16_t)0x0040)[m
[32m+[m[32m#define CR1_SPE_Reset        ((uint16_t)0xFFBF)[m
[32m+[m
[32m+[m[32m/* I2S I2SE mask */[m
[32m+[m[32m#define I2SCFGR_I2SE_Set     ((uint16_t)0x0400)[m
[32m+[m[32m#define I2SCFGR_I2SE_Reset   ((uint16_t)0xFBFF)[m
[32m+[m
[32m+[m[32m/* SPI CRCNext mask */[m
[32m+[m[32m#define CR1_CRCNext_Set      ((uint16_t)0x1000)[m
[32m+[m
[32m+[m[32m/* SPI CRCEN mask */[m
[32m+[m[32m#define CR1_CRCEN_Set        ((uint16_t)0x2000)[m
[32m+[m[32m#define CR1_CRCEN_Reset      ((uint16_t)0xDFFF)[m
[32m+[m
[32m+[m[32m/* SPI SSOE mask */[m
[32m+[m[32m#define CR2_SSOE_Set         ((uint16_t)0x0004)[m
[32m+[m[32m#define CR2_SSOE_Reset       ((uint16_t)0xFFFB)[m
[32m+[m
[32m+[m[32m/* SPI registers Masks */[m
[32m+[m[32m#define CR1_CLEAR_Mask       ((uint16_t)0x3040)[m
[32m+[m[32m#define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)[m
[32m+[m
[32m+[m[32m/* SPI or I2S mode selection masks */[m
[32m+[m[32m#define SPI_Mode_Select      ((uint16_t)0xF7FF)[m
[32m+[m[32m#define I2S_Mode_Select      ((uint16_t)0x0800)[m[41m [m
[32m+[m
[32m+[m[32m/* I2S clock source selection masks */[m
[32m+[m[32m#define I2S2_CLOCK_SRC       ((uint32_t)(0x00020000))[m
[32m+[m[32m#define I2S3_CLOCK_SRC       ((uint32_t)(0x00040000))[m
[32m+[m[32m#define I2S_MUL_MASK         ((uint32_t)(0x0000F000))[m
[32m+[m[32m#define I2S_DIV_MASK         ((uint32_t)(0x000000F0))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup SPI_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the SPIx peripheral registers to their default[m
[32m+[m[32m  *         reset values (Affects also the I2Ss).[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m
[32m+[m[32m  if (SPIx == SPI1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable SPI1 reset state */[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);[m
[32m+[m[32m    /* Release SPI1 from reset state */[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (SPIx == SPI2)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable SPI2 reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);[m
[32m+[m[32m    /* Release SPI2 from reset state */[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if (SPIx == SPI3)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Enable SPI3 reset state */[m
[32m+[m[32m      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);[m
[32m+[m[32m      /* Release SPI3 from reset state */[m
[32m+[m[32m      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the SPIx peripheral according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the SPI_InitStruct.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that[m
[32m+[m[32m  *         contains the configuration information for the specified SPI peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m[41m   [m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the SPI parameters */[m
[32m+[m[32m  assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));[m
[32m+[m[32m  assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));[m
[32m+[m[32m  assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));[m
[32m+[m[32m  assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));[m
[32m+[m[32m  assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));[m
[32m+[m[32m  assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));[m
[32m+[m[32m  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));[m
[32m+[m[32m  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));[m
[32m+[m[32m  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));[m
[32m+[m
[32m+[m[32m/*---------------------------- SPIx CR1 Configuration ------------------------*/[m
[32m+[m[32m  /* Get the SPIx CR1 value */[m
[32m+[m[32m  tmpreg = SPIx->CR1;[m
[32m+[m[32m  /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */[m
[32m+[m[32m  tmpreg &= CR1_CLEAR_Mask;[m
[32m+[m[32m  /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler[m
[32m+[m[32m     master/salve mode, CPOL and CPHA */[m
[32m+[m[32m  /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */[m
[32m+[m[32m  /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */[m
[32m+[m[32m  /* Set LSBFirst bit according to SPI_FirstBit value */[m
[32m+[m[32m  /* Set BR bits according to SPI_BaudRatePrescaler value */[m
[32m+[m[32m  /* Set CPOL bit according to SPI_CPOL value */[m
[32m+[m[32m  /* Set CPHA bit according to SPI_CPHA value */[m
[32m+[m[32m  tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |[m
[32m+[m[32m                  SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |[m[41m  [m
[32m+[m[32m                  SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |[m[41m  [m
[32m+[m[32m                  SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);[m
[32m+[m[32m  /* Write to SPIx CR1 */[m
[32m+[m[32m  SPIx->CR1 = tmpreg;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */[m
[32m+[m[32m  SPIx->I2SCFGR &= SPI_Mode_Select;[m[41m		[m
[32m+[m
[32m+[m[32m/*---------------------------- SPIx CRCPOLY Configuration --------------------*/[m
[32m+[m[32m  /* Write to SPIx CRCPOLY */[m
[32m+[m[32m  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the SPIx peripheral according to the specified[m[41m [m
[32m+[m[32m  *         parameters in the I2S_InitStruct.[m
[32m+[m[32m  * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral[m
[32m+[m[32m  *         (configured in I2S mode).[m
[32m+[m[32m  * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that[m
[32m+[m[32m  *         contains the configuration information for the specified SPI peripheral[m
[32m+[m[32m  *         configured in I2S mode.[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *  The function calculates the optimal prescaler needed to obtain the most[m[41m [m
[32m+[m[32m  *  accurate audio frequency (depending on the I2S clock source, the PLL values[m[41m [m
[32m+[m[32m  *  and the product configuration). But in case the prescaler value is greater[m[41m [m
[32m+[m[32m  *  than 511, the default value (0x02) will be configured instead.  *[m[41m   [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;[m
[32m+[m[32m  uint32_t tmp = 0;[m
[32m+[m[32m  RCC_ClocksTypeDef RCC_Clocks;[m
[32m+[m[32m  uint32_t sourceclock = 0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Check the I2S parameters */[m
[32m+[m[32m  assert_param(IS_SPI_23_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));[m
[32m+[m[32m  assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));[m
[32m+[m[32m  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));[m
[32m+[m[32m  assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));[m
[32m+[m[32m  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));[m
[32m+[m[32m  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));[m[41m  [m
[32m+[m
[32m+[m[32m/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/[m
[32m+[m[32m  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */[m
[32m+[m[32m  SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask;[m[41m [m
[32m+[m[32m  SPIx->I2SPR = 0x0002;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the I2SCFGR register value */[m
[32m+[m[32m  tmpreg = SPIx->I2SCFGR;[m
[32m+[m[41m  [m
[32m+[m[32m  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/[m
[32m+[m[32m  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)[m
[32m+[m[32m  {[m
[32m+[m[32m    i2sodd = (uint16_t)0;[m
[32m+[m[32m    i2sdiv = (uint16_t)2;[m[41m   [m
[32m+[m[32m  }[m
[32m+[m[32m  /* If the requested audio frequency is not the default, compute the prescaler */[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Check the frame length (For the Prescaler computing) */[m
[32m+[m[32m    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Packet length is 16 bits */[m
[32m+[m[32m      packetlength = 1;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Packet length is 32 bits */[m
[32m+[m[32m      packetlength = 2;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Get the I2S clock source mask depending on the peripheral number */[m
[32m+[m[32m    if(((uint32_t)SPIx) == SPI2_BASE)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* The mask is relative to I2S2 */[m
[32m+[m[32m      tmp = I2S2_CLOCK_SRC;[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m[41m [m
[32m+[m[32m    {[m
[32m+[m[32m      /* The mask is relative to I2S3 */[m[41m      [m
[32m+[m[32m      tmp = I2S3_CLOCK_SRC;[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    /* Check the I2S clock source configuration depending on the Device:[m
[32m+[m[32m       Only Connectivity line devices have the PLL3 VCO clock */[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m    if((RCC->CFGR2 & tmp) != 0)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* Get the configuration bits of RCC PLL3 multiplier */[m
[32m+[m[32m      tmp = (uint32_t)((RCC->CFGR2 & I2S_MUL_MASK) >> 12);[m
[32m+[m
[32m+[m[32m      /* Get the value of the PLL3 multiplier */[m[41m      [m
[32m+[m[32m      if((tmp > 5) && (tmp < 15))[m
[32m+[m[32m      {[m
[32m+[m[32m        /* Multiplier is between 8 and 14 (value 15 is forbidden) */[m
[32m+[m[32m        tmp += 2;[m
[32m+[m[32m      }[m
[32m+[m[32m      else[m
[32m+[m[32m      {[m
[32m+[m[32m        if (tmp == 15)[m
[32m+[m[32m        {[m
[32m+[m[32m          /* Multiplier is 20 */[m
[32m+[m[32m          tmp = 20;[m
[32m+[m[32m        }[m
[32m+[m[32m      }[m[41m      [m
[32m+[m[32m      /* Get the PREDIV2 value */[m
[32m+[m[32m      sourceclock = (uint32_t)(((RCC->CFGR2 & I2S_DIV_MASK) >> 4) + 1);[m
[32m+[m[41m      [m
[32m+[m[32m      /* Calculate the Source Clock frequency based on PLL3 and PREDIV2 values */[m
[32m+[m[32m      sourceclock = (uint32_t) ((HSE_Value / sourceclock) * tmp * 2);[m[41m [m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* I2S Clock source is System clock: Get System Clock frequency */[m
[32m+[m[32m      RCC_GetClocksFreq(&RCC_Clocks);[m[41m      [m
[32m+[m[41m      [m
[32m+[m[32m      /* Get the source clock value: based on System Clock value */[m
[32m+[m[32m      sourceclock = RCC_Clocks.SYSCLK_Frequency;[m
[32m+[m[32m    }[m[41m        [m
[32m+[m[32m#else /* STM32F10X_HD */[m
[32m+[m[32m    /* I2S Clock source is System clock: Get System Clock frequency */[m
[32m+[m[32m    RCC_GetClocksFreq(&RCC_Clocks);[m[41m      [m
[32m+[m[41m      [m
[32m+[m[32m    /* Get the source clock value: based on System Clock value */[m
[32m+[m[32m    sourceclock = RCC_Clocks.SYSCLK_Frequency;[m[41m    [m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m    [m
[32m+[m
[32m+[m[32m    /* Compute the Real divider depending on the MCLK output state with a floating point */[m
[32m+[m[32m    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)[m
[32m+[m[32m    {[m
[32m+[m[32m      /* MCLK output is enabled */[m
[32m+[m[32m      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);[m
[32m+[m[32m    }[m
[32m+[m[32m    else[m
[32m+[m[32m    {[m
[32m+[m[32m      /* MCLK output is disabled */[m
[32m+[m[32m      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    /* Remove the floating point */[m
[32m+[m[32m    tmp = tmp / 10;[m[41m  [m
[32m+[m[41m      [m
[32m+[m[32m    /* Check the parity of the divider */[m
[32m+[m[32m    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);[m
[32m+[m[41m   [m
[32m+[m[32m    /* Compute the i2sdiv prescaler */[m
[32m+[m[32m    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);[m
[32m+[m[41m   [m
[32m+[m[32m    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */[m
[32m+[m[32m    i2sodd = (uint16_t) (i2sodd << 8);[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Test if the divider is 1 or 0 or greater than 0xFF */[m
[32m+[m[32m  if ((i2sdiv < 2) || (i2sdiv > 0xFF))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the default values */[m
[32m+[m[32m    i2sdiv = 2;[m
[32m+[m[32m    i2sodd = 0;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Write to SPIx I2SPR register the computed value */[m
[32m+[m[32m  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));[m[41m  [m
[32m+[m[41m [m
[32m+[m[32m  /* Configure the I2S with the SPI_InitStruct values */[m
[32m+[m[32m  tmpreg |= (uint16_t)(I2S_Mode_Select | (uint16_t)(I2S_InitStruct->I2S_Mode | \[m
[32m+[m[32m                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \[m
[32m+[m[32m                  (uint16_t)I2S_InitStruct->I2S_CPOL))));[m
[32m+[m[41m [m
[32m+[m[32m  /* Write to SPIx I2SCFGR */[m[41m  [m
[32m+[m[32m  SPIx->I2SCFGR = tmpreg;[m[41m   [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each SPI_InitStruct member with its default value.[m
[32m+[m[32m  * @param  SPI_InitStruct : pointer to a SPI_InitTypeDef structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m/*--------------- Reset SPI init structure parameters values -----------------*/[m
[32m+[m[32m  /* Initialize the SPI_Direction member */[m
[32m+[m[32m  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;[m
[32m+[m[32m  /* initialize the SPI_Mode member */[m
[32m+[m[32m  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;[m
[32m+[m[32m  /* initialize the SPI_DataSize member */[m
[32m+[m[32m  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;[m
[32m+[m[32m  /* Initialize the SPI_CPOL member */[m
[32m+[m[32m  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;[m
[32m+[m[32m  /* Initialize the SPI_CPHA member */[m
[32m+[m[32m  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;[m
[32m+[m[32m  /* Initialize the SPI_NSS member */[m
[32m+[m[32m  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;[m
[32m+[m[32m  /* Initialize the SPI_BaudRatePrescaler member */[m
[32m+[m[32m  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;[m
[32m+[m[32m  /* Initialize the SPI_FirstBit member */[m
[32m+[m[32m  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;[m
[32m+[m[32m  /* Initialize the SPI_CRCPolynomial member */[m
[32m+[m[32m  SPI_InitStruct->SPI_CRCPolynomial = 7;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each I2S_InitStruct member with its default value.[m
[32m+[m[32m  * @param  I2S_InitStruct : pointer to a I2S_InitTypeDef structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m/*--------------- Reset I2S init structure parameters values -----------------*/[m
[32m+[m[32m  /* Initialize the I2S_Mode member */[m
[32m+[m[32m  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the I2S_Standard member */[m
[32m+[m[32m  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the I2S_DataFormat member */[m
[32m+[m[32m  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the I2S_MCLKOutput member */[m
[32m+[m[32m  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the I2S_AudioFreq member */[m
[32m+[m[32m  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Initialize the I2S_CPOL member */[m
[32m+[m[32m  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified SPI peripheral.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the SPIx peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected SPI peripheral */[m
[32m+[m[32m    SPIx->CR1 |= CR1_SPE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected SPI peripheral */[m
[32m+[m[32m    SPIx->CR1 &= CR1_SPE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified SPI peripheral (in I2S mode).[m
[32m+[m[32m  * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the SPIx peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_23_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected SPI peripheral (in I2S mode) */[m
[32m+[m[32m    SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected SPI peripheral (in I2S mode) */[m
[32m+[m[32m    SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified SPI/I2S interrupts.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  *   - 2 or 3 in I2S mode[m
[32m+[m[32m  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to be enabled or disabled.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask[m
[32m+[m[32m  *     @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask[m
[32m+[m[32m  *     @arg SPI_I2S_IT_ERR: Error interrupt mask[m
[32m+[m[32m  * @param  NewState: new state of the specified SPI/I2S interrupt.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t itpos = 0, itmask = 0 ;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));[m
[32m+[m
[32m+[m[32m  /* Get the SPI/I2S IT index */[m
[32m+[m[32m  itpos = SPI_I2S_IT >> 4;[m
[32m+[m
[32m+[m[32m  /* Set the IT mask */[m
[32m+[m[32m  itmask = (uint16_t)1 << (uint16_t)itpos;[m
[32m+[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected SPI/I2S interrupt */[m
[32m+[m[32m    SPIx->CR2 |= itmask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected SPI/I2S interrupt */[m
[32m+[m[32m    SPIx->CR2 &= (uint16_t)~itmask;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SPIx/I2Sx DMA interface.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  *   - 2 or 3 in I2S mode[m
[32m+[m[32m  * @param  SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request to be enabled or disabled.[m[41m [m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request[m
[32m+[m[32m  *     @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request[m
[32m+[m[32m  * @param  NewState: new state of the selected SPI/I2S DMA transfer request.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected SPI/I2S DMA requests */[m
[32m+[m[32m    SPIx->CR2 |= SPI_I2S_DMAReq;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected SPI/I2S DMA requests */[m
[32m+[m[32m    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmits a Data through the SPIx/I2Sx peripheral.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  *   - 2 or 3 in I2S mode[m
[32m+[m[32m  * @param  Data : Data to be transmitted.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write in the DR register the data to be sent */[m
[32m+[m[32m  SPIx->DR = Data;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral.[m[41m [m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  *   - 2 or 3 in I2S mode[m
[32m+[m[32m  * @retval The value of the received data.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the data in the DR register */[m
[32m+[m[32m  return SPIx->DR;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures internally by software the NSS pin for the selected SPI.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_NSSInternalSoft_Set: Set NSS pin internally[m
[32m+[m[32m  *     @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));[m
[32m+[m[32m  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set NSS pin internally by software */[m
[32m+[m[32m    SPIx->CR1 |= SPI_NSSInternalSoft_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset NSS pin internally by software */[m
[32m+[m[32m    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the SS output for the selected SPI.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the SPIx SS output.[m[41m [m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected SPI SS output */[m
[32m+[m[32m    SPIx->CR2 |= CR2_SSOE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected SPI SS output */[m
[32m+[m[32m    SPIx->CR2 &= CR2_SSOE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the data size for the selected SPI.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  SPI_DataSize: specifies the SPI data size.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_DataSize_16b: Set data frame format to 16bit[m
[32m+[m[32m  *     @arg SPI_DataSize_8b: Set data frame format to 8bit[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_DATASIZE(SPI_DataSize));[m
[32m+[m[32m  /* Clear DFF bit */[m
[32m+[m[32m  SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;[m
[32m+[m[32m  /* Set new DFF bit value */[m
[32m+[m[32m  SPIx->CR1 |= SPI_DataSize;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmit the SPIx CRC value.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_TransmitCRC(SPI_TypeDef* SPIx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Enable the selected SPI CRC transmission */[m
[32m+[m[32m  SPIx->CR1 |= CR1_CRCNext_Set;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the CRC value calculation of the transferred bytes.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the SPIx CRC value calculation.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected SPI CRC calculation */[m
[32m+[m[32m    SPIx->CR1 |= CR1_CRCEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected SPI CRC calculation */[m
[32m+[m[32m    SPIx->CR1 &= CR1_CRCEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the transmit or the receive CRC register value for the specified SPI.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  SPI_CRC: specifies the CRC register to be read.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_CRC_Tx: Selects Tx CRC register[m
[32m+[m[32m  *     @arg SPI_CRC_Rx: Selects Rx CRC register[m
[32m+[m[32m  * @retval The selected CRC register value..[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t crcreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_CRC(SPI_CRC));[m
[32m+[m[32m  if (SPI_CRC != SPI_CRC_Rx)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the Tx CRC register */[m
[32m+[m[32m    crcreg = SPIx->TXCRCR;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Get the Rx CRC register */[m
[32m+[m[32m    crcreg = SPIx->RXCRCR;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the selected CRC register */[m
[32m+[m[32m  return crcreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the CRC Polynomial register value for the specified SPI.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @retval The CRC Polynomial register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Return the CRC polynomial register */[m
[32m+[m[32m  return SPIx->CRCPR;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the data transfer direction in bi-directional mode for the specified SPI.[m
[32m+[m[32m  * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.[m
[32m+[m[32m  * @param  SPI_Direction: specifies the data transfer direction in bi-directional mode.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_Direction_Tx: Selects Tx transmission direction[m
[32m+[m[32m  *     @arg SPI_Direction_Rx: Selects Rx receive direction[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_DIRECTION(SPI_Direction));[m
[32m+[m[32m  if (SPI_Direction == SPI_Direction_Tx)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the Tx only mode */[m
[32m+[m[32m    SPIx->CR1 |= SPI_Direction_Tx;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the Rx only mode */[m
[32m+[m[32m    SPIx->CR1 &= SPI_Direction_Rx;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified SPI/I2S flag is set or not.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  *   - 2 or 3 in I2S mode[m
[32m+[m[32m  * @param  SPI_I2S_FLAG: specifies the SPI/I2S flag to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.[m
[32m+[m[32m  *     @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.[m
[32m+[m[32m  *     @arg SPI_I2S_FLAG_BSY: Busy flag.[m
[32m+[m[32m  *     @arg SPI_I2S_FLAG_OVR: Overrun flag.[m
[32m+[m[32m  *     @arg SPI_FLAG_MODF: Mode Fault flag.[m
[32m+[m[32m  *     @arg SPI_FLAG_CRCERR: CRC Error flag.[m
[32m+[m[32m  *     @arg I2S_FLAG_UDR: Underrun Error flag.[m
[32m+[m[32m  *     @arg I2S_FLAG_CHSIDE: Channel Side flag.[m
[32m+[m[32m  * @retval The new state of SPI_I2S_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));[m
[32m+[m[32m  /* Check the status of the specified SPI/I2S flag */[m
[32m+[m[32m  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SPI_I2S_FLAG is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SPI_I2S_FLAG is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the SPI_I2S_FLAG status */[m
[32m+[m[32m  return  bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the SPIx CRC Error (CRCERR) flag.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  * @param  SPI_I2S_FLAG: specifies the SPI flag to clear.[m[41m [m
[32m+[m[32m  *   This function clears only CRCERR flag.[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - OVR (OverRun error) flag is cleared by software sequence: a read[m[41m [m
[32m+[m[32m  *     operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read[m[41m [m
[32m+[m[32m  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()).[m
[32m+[m[32m  *   - UDR (UnderRun error) flag is cleared by a read operation to[m[41m [m
[32m+[m[32m  *     SPI_SR register (SPI_I2S_GetFlagStatus()).[m
[32m+[m[32m  *   - MODF (Mode Fault) flag is cleared by software sequence: a read/write[m[41m [m
[32m+[m[32m  *     operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a[m[41m [m
[32m+[m[32m  *     write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Clear the selected SPI CRC Error (CRCERR) flag */[m
[32m+[m[32m    SPIx->SR = (uint16_t)~SPI_I2S_FLAG;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  *   - 2 or 3 in I2S mode[m
[32m+[m[32m  * @param  SPI_I2S_IT: specifies the SPI/I2S interrupt source to check.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.[m
[32m+[m[32m  *     @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.[m
[32m+[m[32m  *     @arg SPI_I2S_IT_OVR: Overrun interrupt.[m
[32m+[m[32m  *     @arg SPI_IT_MODF: Mode Fault interrupt.[m
[32m+[m[32m  *     @arg SPI_IT_CRCERR: CRC Error interrupt.[m
[32m+[m[32m  *     @arg I2S_IT_UDR: Underrun Error interrupt.[m
[32m+[m[32m  * @retval The new state of SPI_I2S_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  uint16_t itpos = 0, itmask = 0, enablestatus = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));[m
[32m+[m
[32m+[m[32m  /* Get the SPI/I2S IT index */[m
[32m+[m[32m  itpos = 0x01 << (SPI_I2S_IT & 0x0F);[m
[32m+[m
[32m+[m[32m  /* Get the SPI/I2S IT mask */[m
[32m+[m[32m  itmask = SPI_I2S_IT >> 4;[m
[32m+[m
[32m+[m[32m  /* Set the IT mask */[m
[32m+[m[32m  itmask = 0x01 << itmask;[m
[32m+[m
[32m+[m[32m  /* Get the SPI_I2S_IT enable bit status */[m
[32m+[m[32m  enablestatus = (SPIx->CR2 & itmask) ;[m
[32m+[m
[32m+[m[32m  /* Check the status of the specified SPI/I2S interrupt */[m
[32m+[m[32m  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SPI_I2S_IT is set */[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* SPI_I2S_IT is reset */[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Return the SPI_I2S_IT status */[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.[m
[32m+[m[32m  * @param  SPIx: where x can be[m
[32m+[m[32m  *   - 1, 2 or 3 in SPI mode[m[41m [m
[32m+[m[32m  * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.[m
[32m+[m[32m  *   This function clears only CRCERR interrupt pending bit.[m[41m   [m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - OVR (OverRun Error) interrupt pending bit is cleared by software[m[41m [m
[32m+[m[32m  *     sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData())[m[41m [m
[32m+[m[32m  *     followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).[m
[32m+[m[32m  *   - UDR (UnderRun Error) interrupt pending bit is cleared by a read[m[41m [m
[32m+[m[32m  *     operation to SPI_SR register (SPI_I2S_GetITStatus()).[m
[32m+[m[32m  *   - MODF (Mode Fault) interrupt pending bit is cleared by software sequence:[m
[32m+[m[32m  *     a read/write operation to SPI_SR register (SPI_I2S_GetITStatus())[m[41m [m
[32m+[m[32m  *     followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable[m[41m [m
[32m+[m[32m  *     the SPI).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t itpos = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_SPI_ALL_PERIPH(SPIx));[m
[32m+[m[32m  assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));[m
[32m+[m
[32m+[m[32m  /* Get the SPI IT index */[m
[32m+[m[32m  itpos = 0x01 << (SPI_I2S_IT & 0x0F);[m
[32m+[m
[32m+[m[32m  /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */[m
[32m+[m[32m  SPIx->SR = (uint16_t)~itpos;[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c[m
[1mnew file mode 100644[m
[1mindex 0000000..bfb4dd1[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_tim.c[m
[36m@@ -0,0 +1,2890 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_tim.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the TIM firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_tim.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM[m[41m [m
[32m+[m[32m  * @brief TIM driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* ---------------------- TIM registers bit mask ------------------------ */[m
[32m+[m[32m#define SMCR_ETR_Mask               ((uint16_t)0x00FF)[m[41m [m
[32m+[m[32m#define CCMR_Offset                 ((uint16_t)0x0018)[m
[32m+[m[32m#define CCER_CCE_Set                ((uint16_t)0x0001)[m[41m  [m
[32m+[m[32m#define	CCER_CCNE_Set               ((uint16_t)0x0004)[m[41m [m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mstatic void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter);[m
[32m+[m[32mstatic void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter);[m
[32m+[m[32mstatic void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter);[m
[32m+[m[32mstatic void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter);[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup TIM_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the TIMx peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_DeInit(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m[41m [m
[32m+[m[41m [m
[32m+[m[32m  if (TIMx == TIM1)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);[m[41m  [m
[32m+[m[32m  }[m[41m     [m
[32m+[m[32m  else if (TIMx == TIM2)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (TIMx == TIM3)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (TIMx == TIM4)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else if (TIMx == TIM5)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else if (TIMx == TIM6)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else if (TIMx == TIM7)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else if (TIMx == TIM8)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (TIMx == TIM9)[m
[32m+[m[32m  {[m[41m      [m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);[m[41m  [m
[32m+[m[32m   }[m[41m  [m
[32m+[m[32m  else if (TIMx == TIM10)[m
[32m+[m[32m  {[m[41m      [m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);[m[41m  [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if (TIMx == TIM11)[m[41m [m
[32m+[m[32m  {[m[41m     [m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);[m[41m  [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if (TIMx == TIM12)[m
[32m+[m[32m  {[m[41m      [m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);[m[41m  [m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m  else if (TIMx == TIM13)[m[41m [m
[32m+[m[32m  {[m[41m       [m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);[m[41m  [m
[32m+[m[32m  }[m
[32m+[m[32m  else if (TIMx == TIM14)[m[41m [m
[32m+[m[32m  {[m[41m       [m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);[m[41m  [m
[32m+[m[32m  }[m[41m        [m
[32m+[m[32m  else if (TIMx == TIM15)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else if (TIMx == TIM16)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);[m
[32m+[m[32m  }[m[41m [m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if (TIMx == TIM17)[m
[32m+[m[32m    {[m
[32m+[m[32m      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);[m
[32m+[m[32m      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);[m
[32m+[m[32m    }[m[41m  [m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the TIMx Time Base Unit peripheral according to[m[41m [m
[32m+[m[32m  *         the specified parameters in the TIM_TimeBaseInitStruct.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef[m
[32m+[m[32m  *         structure that contains the configuration information for the[m[41m [m
[32m+[m[32m  *         specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpcr1 = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m[41m [m
[32m+[m[32m  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));[m
[32m+[m[32m  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));[m
[32m+[m
[32m+[m[32m  tmpcr1 = TIMx->CR1;[m[41m  [m
[32m+[m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||[m
[32m+[m[32m     (TIMx == TIM4) || (TIMx == TIM5))[m[41m [m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Counter Mode */[m
[32m+[m[32m    tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));[m
[32m+[m[32m    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;[m
[32m+[m[32m  }[m
[32m+[m[41m [m
[32m+[m[32m  if((TIMx != TIM6) && (TIMx != TIM7))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the clock division */[m
[32m+[m[32m    tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));[m
[32m+[m[32m    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  TIMx->CR1 = tmpcr1;[m
[32m+[m
[32m+[m[32m  /* Set the Autoreload value */[m
[32m+[m[32m  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;[m
[32m+[m[41m [m
[32m+[m[32m  /* Set the Prescaler value */[m
[32m+[m[32m  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;[m
[32m+[m[41m    [m
[32m+[m[32m  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))[m[41m  [m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the Repetition Counter value */[m
[32m+[m[32m    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Generate an update event to reload the Prescaler and the Repetition counter[m
[32m+[m[32m     values immediately */[m
[32m+[m[32m  TIMx->EGR = TIM_PSCReloadMode_Immediate;[m[41m           [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the TIMx Channel1 according to the specified[m
[32m+[m[32m  *         parameters in the TIM_OCInitStruct.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));[m
[32m+[m[32m  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));[m[41m   [m
[32m+[m[32m /* Disable the Channel 1: Reset the CC1E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);[m
[32m+[m[32m  /* Get the TIMx CCER register value */[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Get the TIMx CR2 register value */[m
[32m+[m[32m  tmpcr2 =  TIMx->CR2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCMR1 register value */[m
[32m+[m[32m  tmpccmrx = TIMx->CCMR1;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Reset the Output Compare Mode Bits */[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));[m
[32m+[m
[32m+[m[32m  /* Select the Output Compare Mode */[m
[32m+[m[32m  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset the Output Polarity level */[m
[32m+[m[32m  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));[m
[32m+[m[32m  /* Set the Output Compare Polarity */[m
[32m+[m[32m  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the Output State */[m
[32m+[m[32m  tmpccer |= TIM_OCInitStruct->TIM_OutputState;[m
[32m+[m[41m    [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||[m
[32m+[m[32m     (TIMx == TIM16)|| (TIMx == TIM17))[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));[m
[32m+[m[32m    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));[m
[32m+[m[32m    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));[m
[32m+[m[32m    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output N Polarity level */[m
[32m+[m[32m    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));[m
[32m+[m[32m    /* Set the Output N Polarity */[m
[32m+[m[32m    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output N State */[m
[32m+[m[32m    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));[m[41m    [m
[32m+[m[32m    /* Set the Output N State */[m
[32m+[m[32m    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output Compare and Output Compare N IDLE State */[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Set the Output Idle state */[m
[32m+[m[32m    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;[m
[32m+[m[32m    /* Set the Output N Idle state */[m
[32m+[m[32m    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Write to TIMx CR2 */[m
[32m+[m[32m  TIMx->CR2 = tmpcr2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCMR1 */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmrx;[m
[32m+[m
[32m+[m[32m  /* Set the Capture Compare Register value */[m
[32m+[m[32m  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;[m[41m [m
[32m+[m[41m [m
[32m+[m[32m  /* Write to TIMx CCER */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the TIMx Channel2 according to the specified[m
[32m+[m[32m  *         parameters in the TIM_OCInitStruct.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select[m[41m [m
[32m+[m[32m  *         the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m[41m [m
[32m+[m[32m  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));[m
[32m+[m[32m  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));[m[41m   [m
[32m+[m[32m   /* Disable the Channel 2: Reset the CC2E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCER register value */[m[41m  [m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Get the TIMx CR2 register value */[m
[32m+[m[32m  tmpcr2 =  TIMx->CR2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCMR1 register value */[m
[32m+[m[32m  tmpccmrx = TIMx->CCMR1;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Reset the Output Compare mode and Capture/Compare selection Bits */[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Select the Output Compare Mode */[m
[32m+[m[32m  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset the Output Polarity level */[m
[32m+[m[32m  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));[m
[32m+[m[32m  /* Set the Output Compare Polarity */[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the Output State */[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);[m
[32m+[m[41m    [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8))[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));[m
[32m+[m[32m    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));[m
[32m+[m[32m    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));[m
[32m+[m[32m    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output N Polarity level */[m
[32m+[m[32m    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));[m
[32m+[m[32m    /* Set the Output N Polarity */[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output N State */[m
[32m+[m[32m    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));[m[41m    [m
[32m+[m[32m    /* Set the Output N State */[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output Compare and Output Compare N IDLE State */[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Set the Output Idle state */[m
[32m+[m[32m    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);[m
[32m+[m[32m    /* Set the Output N Idle state */[m
[32m+[m[32m    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Write to TIMx CR2 */[m
[32m+[m[32m  TIMx->CR2 = tmpcr2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCMR1 */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmrx;[m
[32m+[m
[32m+[m[32m  /* Set the Capture Compare Register value */[m
[32m+[m[32m  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCER */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the TIMx Channel3 according to the specified[m
[32m+[m[32m  *         parameters in the TIM_OCInitStruct.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m[41m [m
[32m+[m[32m  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));[m
[32m+[m[32m  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));[m[41m   [m
[32m+[m[32m  /* Disable the Channel 2: Reset the CC2E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCER register value */[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Get the TIMx CR2 register value */[m
[32m+[m[32m  tmpcr2 =  TIMx->CR2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCMR2 register value */[m
[32m+[m[32m  tmpccmrx = TIMx->CCMR2;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Reset the Output Compare mode and Capture/Compare selection Bits */[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));[m[41m  [m
[32m+[m[32m  /* Select the Output Compare Mode */[m
[32m+[m[32m  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset the Output Polarity level */[m
[32m+[m[32m  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));[m
[32m+[m[32m  /* Set the Output Compare Polarity */[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the Output State */[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);[m
[32m+[m[41m    [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8))[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));[m
[32m+[m[32m    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));[m
[32m+[m[32m    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));[m
[32m+[m[32m    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Reset the Output N Polarity level */[m
[32m+[m[32m    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));[m
[32m+[m[32m    /* Set the Output N Polarity */[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);[m
[32m+[m[32m    /* Reset the Output N State */[m
[32m+[m[32m    tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));[m
[32m+[m[41m    [m
[32m+[m[32m    /* Set the Output N State */[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);[m
[32m+[m[32m    /* Reset the Output Compare and Output Compare N IDLE State */[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));[m
[32m+[m[32m    /* Set the Output Idle state */[m
[32m+[m[32m    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);[m
[32m+[m[32m    /* Set the Output N Idle state */[m
[32m+[m[32m    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Write to TIMx CR2 */[m
[32m+[m[32m  TIMx->CR2 = tmpcr2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCMR2 */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmrx;[m
[32m+[m
[32m+[m[32m  /* Set the Capture Compare Register value */[m
[32m+[m[32m  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCER */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the TIMx Channel4 according to the specified[m
[32m+[m[32m  *         parameters in the TIM_OCInitStruct.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;[m
[32m+[m[41m   [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m[41m [m
[32m+[m[32m  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));[m
[32m+[m[32m  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));[m[41m   [m
[32m+[m[32m  /* Disable the Channel 2: Reset the CC4E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCER register value */[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Get the TIMx CR2 register value */[m
[32m+[m[32m  tmpcr2 =  TIMx->CR2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCMR2 register value */[m
[32m+[m[32m  tmpccmrx = TIMx->CCMR2;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Reset the Output Compare mode and Capture/Compare selection Bits */[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));[m
[32m+[m[32m  tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Select the Output Compare Mode */[m
[32m+[m[32m  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Reset the Output Polarity level */[m
[32m+[m[32m  tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));[m
[32m+[m[32m  /* Set the Output Compare Polarity */[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the Output State */[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);[m
[32m+[m[41m    [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8))[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));[m
[32m+[m[32m    /* Reset the Output Compare IDLE State */[m
[32m+[m[32m    tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));[m
[32m+[m[32m    /* Set the Output Idle state */[m
[32m+[m[32m    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Write to TIMx CR2 */[m
[32m+[m[32m  TIMx->CR2 = tmpcr2;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCMR2 */[m[41m  [m
[32m+[m[32m  TIMx->CCMR2 = tmpccmrx;[m
[32m+[m
[32m+[m[32m  /* Set the Capture Compare Register value */[m
[32m+[m[32m  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCER */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the TIM peripheral according to the specified[m
[32m+[m[32m  *         parameters in the TIM_ICInitStruct.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));[m[41m  [m
[32m+[m[32m  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));[m
[32m+[m[32m  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));[m
[32m+[m[32m  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));[m
[32m+[m[41m  [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||[m
[32m+[m[32m     (TIMx == TIM4) ||(TIMx == TIM5))[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));[m
[32m+[m[32m  }[m
[32m+[m[32m  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m    /* TI1 Configuration */[m
[32m+[m[32m    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICSelection,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m    /* TI2 Configuration */[m
[32m+[m[32m    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICSelection,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m    /* TI3 Configuration */[m
[32m+[m[32m    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICSelection,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m    /* TI4 Configuration */[m
[32m+[m[32m    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICSelection,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIM peripheral according to the specified[m
[32m+[m[32m  *         parameters in the TIM_ICInitStruct to measure an external PWM signal.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t icoppositepolarity = TIM_ICPolarity_Rising;[m
[32m+[m[32m  uint16_t icoppositeselection = TIM_ICSelection_DirectTI;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  /* Select the Opposite Input Polarity */[m
[32m+[m[32m  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)[m
[32m+[m[32m  {[m
[32m+[m[32m    icoppositepolarity = TIM_ICPolarity_Falling;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    icoppositepolarity = TIM_ICPolarity_Rising;[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Select the Opposite Input */[m
[32m+[m[32m  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)[m
[32m+[m[32m  {[m
[32m+[m[32m    icoppositeselection = TIM_ICSelection_IndirectTI;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    icoppositeselection = TIM_ICSelection_DirectTI;[m
[32m+[m[32m  }[m
[32m+[m[32m  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* TI1 Configuration */[m
[32m+[m[32m    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m    /* TI2 Configuration */[m
[32m+[m[32m    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m[41m [m
[32m+[m[32m    /* TI2 Configuration */[m
[32m+[m[32m    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,[m
[32m+[m[32m               TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m    /* TI1 Configuration */[m
[32m+[m[32m    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);[m
[32m+[m[32m    /* Set the Input Capture Prescaler value */[m
[32m+[m[32m    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the: Break feature, dead time, Lock level, the OSSI,[m
[32m+[m[32m  *         the OSSR State and the AOE(automatic output enable).[m
[32m+[m[32m  * @param  TIMx: where x can be  1 or 8 to select the TIM[m[41m [m
[32m+[m[32m  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure that[m
[32m+[m[32m  *         contains the BDTR Register configuration  information for the TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST2_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));[m
[32m+[m[32m  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));[m
[32m+[m[32m  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));[m
[32m+[m[32m  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));[m
[32m+[m[32m  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));[m
[32m+[m[32m  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));[m
[32m+[m[32m  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,[m
[32m+[m[32m     the OSSI State, the dead time value and the Automatic Output Enable Bit */[m
[32m+[m[32m  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |[m
[32m+[m[32m             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |[m
[32m+[m[32m             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |[m
[32m+[m[32m             TIM_BDTRInitStruct->TIM_AutomaticOutput;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each TIM_TimeBaseInitStruct member with its default value.[m
[32m+[m[32m  * @param  TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef[m
[32m+[m[32m  *         structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the default configuration */[m
[32m+[m[32m  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;[m
[32m+[m[32m  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;[m
[32m+[m[32m  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;[m
[32m+[m[32m  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;[m
[32m+[m[32m  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each TIM_OCInitStruct member with its default value.[m
[32m+[m[32m  * @param  TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure which will[m
[32m+[m[32m  *         be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the default configuration */[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_Pulse = 0x0000;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;[m
[32m+[m[32m  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each TIM_ICInitStruct member with its default value.[m
[32m+[m[32m  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure which will[m
[32m+[m[32m  *         be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the default configuration */[m
[32m+[m[32m  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;[m
[32m+[m[32m  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;[m
[32m+[m[32m  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;[m
[32m+[m[32m  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;[m
[32m+[m[32m  TIM_ICInitStruct->TIM_ICFilter = 0x00;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each TIM_BDTRInitStruct member with its default value.[m
[32m+[m[32m  * @param  TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef structure which[m
[32m+[m[32m  *         will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Set the default configuration */[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;[m
[32m+[m[32m  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified TIM peripheral.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the TIMx peripheral.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the TIM Counter */[m
[32m+[m[32m    TIMx->CR1 |= TIM_CR1_CEN;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the TIM Counter */[m
[32m+[m[32m    TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIM peripheral Main Outputs.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIMx peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the TIM peripheral Main Outputs.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST2_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the TIM Main Output */[m
[32m+[m[32m    TIMx->BDTR |= TIM_BDTR_MOE;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the TIM Main Output */[m
[32m+[m[32m    TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified TIM interrupts.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIMx peripheral.[m
[32m+[m[32m  * @param  TIM_IT: specifies the TIM interrupts sources to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg TIM_IT_Update: TIM update Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_COM: TIM Commutation Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_Break: TIM Break Interrupt source[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   - TIM6 and TIM7 can only generate an update interrupt.[m
[32m+[m[32m  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,[m
[32m+[m[32m  *      TIM_IT_CC2 or TIM_IT_Trigger.[m[41m [m
[32m+[m[32m  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.[m[41m   [m
[32m+[m[32m  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15.[m[41m [m
[32m+[m[32m  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.[m[41m    [m
[32m+[m[32m  * @param  NewState: new state of the TIM interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_IT(TIM_IT));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the Interrupt sources */[m
[32m+[m[32m    TIMx->DIER |= TIM_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the Interrupt sources */[m
[32m+[m[32m    TIMx->DIER &= (uint16_t)~TIM_IT;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx event to be generate by software.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_EventSource: specifies the event source.[m
[32m+[m[32m  *   This parameter can be one or more of the following values:[m[41m	   [m
[32m+[m[32m  *     @arg TIM_EventSource_Update: Timer update Event source[m
[32m+[m[32m  *     @arg TIM_EventSource_CC1: Timer Capture Compare 1 Event source[m
[32m+[m[32m  *     @arg TIM_EventSource_CC2: Timer Capture Compare 2 Event source[m
[32m+[m[32m  *     @arg TIM_EventSource_CC3: Timer Capture Compare 3 Event source[m
[32m+[m[32m  *     @arg TIM_EventSource_CC4: Timer Capture Compare 4 Event source[m
[32m+[m[32m  *     @arg TIM_EventSource_COM: Timer COM event source[m[41m  [m
[32m+[m[32m  *     @arg TIM_EventSource_Trigger: Timer Trigger Event source[m
[32m+[m[32m  *     @arg TIM_EventSource_Break: Timer Break event source[m
[32m+[m[32m  * @note[m[41m [m
[32m+[m[32m  *   - TIM6 and TIM7 can only generate an update event.[m[41m [m
[32m+[m[32m  *   - TIM_EventSource_COM and TIM_EventSource_Break are used only with TIM1 and TIM8.[m[41m      [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the event sources */[m
[32m+[m[32m  TIMx->EGR = TIM_EventSource;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx's DMA interface.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select[m[41m [m
[32m+[m[32m  *   the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_DMABase: DMA Base address.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,[m
[32m+[m[32m  *          TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,[m
[32m+[m[32m  *          TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,[m
[32m+[m[32m  *          TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,[m
[32m+[m[32m  *          TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,[m
[32m+[m[32m  *          TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,[m
[32m+[m[32m  *          TIM_DMABase_DCR.[m
[32m+[m[32m  * @param  TIM_DMABurstLength: DMA Burst length.[m
[32m+[m[32m  *   This parameter can be one value between:[m
[32m+[m[32m  *   TIM_DMABurstLength_1Transfer and TIM_DMABurstLength_18Transfers.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST4_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));[m
[32m+[m[32m  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));[m
[32m+[m[32m  /* Set the DMA Base and the DMA Burst Length */[m
[32m+[m[32m  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIMx's DMA Requests.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 6, 7, 8, 15, 16 or 17[m[41m [m
[32m+[m[32m  *   to select the TIM peripheral.[m[41m [m
[32m+[m[32m  * @param  TIM_DMASource: specifies the DMA Request sources.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg TIM_DMA_Update: TIM update Interrupt source[m
[32m+[m[32m  *     @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source[m
[32m+[m[32m  *     @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source[m
[32m+[m[32m  *     @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source[m
[32m+[m[32m  *     @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source[m
[32m+[m[32m  *     @arg TIM_DMA_COM: TIM Commutation DMA source[m
[32m+[m[32m  *     @arg TIM_DMA_Trigger: TIM Trigger DMA source[m
[32m+[m[32m  * @param  NewState: new state of the DMA Request sources.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST9_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the DMA sources */[m
[32m+[m[32m    TIMx->DIER |= TIM_DMASource;[m[41m [m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the DMA sources */[m
[32m+[m[32m    TIMx->DIER &= (uint16_t)~TIM_DMASource;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx internal Clock[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15[m
[32m+[m[32m  *         to select the TIM peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  /* Disable slave mode to clock the prescaler directly with the internal clock */[m
[32m+[m[32m  TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Internal Trigger as External Clock[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ITRSource: Trigger source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  * @param  TIM_TS_ITR0: Internal Trigger 0[m
[32m+[m[32m  * @param  TIM_TS_ITR1: Internal Trigger 1[m
[32m+[m[32m  * @param  TIM_TS_ITR2: Internal Trigger 2[m
[32m+[m[32m  * @param  TIM_TS_ITR3: Internal Trigger 3[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));[m
[32m+[m[32m  /* Select the Internal Trigger */[m
[32m+[m[32m  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);[m
[32m+[m[32m  /* Select the External clock mode1 */[m
[32m+[m[32m  TIMx->SMCR |= TIM_SlaveMode_External1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Trigger as External Clock[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_TIxExternalCLKSource: Trigger source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector[m
[32m+[m[32m  *     @arg TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1[m
[32m+[m[32m  *     @arg TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2[m
[32m+[m[32m  * @param  TIM_ICPolarity: specifies the TIx Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling[m
[32m+[m[32m  * @param  ICFilter : specifies the filter value.[m
[32m+[m[32m  *   This parameter must be a value between 0x0 and 0xF.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,[m
[32m+[m[32m                                uint16_t TIM_ICPolarity, uint16_t ICFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));[m
[32m+[m[32m  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));[m
[32m+[m[32m  assert_param(IS_TIM_IC_FILTER(ICFilter));[m
[32m+[m[32m  /* Configure the Timer Input Clock Source */[m
[32m+[m[32m  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)[m
[32m+[m[32m  {[m
[32m+[m[32m    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Select the Trigger source */[m
[32m+[m[32m  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);[m
[32m+[m[32m  /* Select the External clock mode1 */[m
[32m+[m[32m  TIMx->SMCR |= TIM_SlaveMode_External1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the External clock Mode1[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.[m
[32m+[m[32m  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.[m
[32m+[m[32m  * @param  ExtTRGFilter: External Trigger Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,[m
[32m+[m[32m                             uint16_t ExtTRGFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpsmcr = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));[m
[32m+[m[32m  /* Configure the ETR Clock source */[m
[32m+[m[32m  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx SMCR register value */[m
[32m+[m[32m  tmpsmcr = TIMx->SMCR;[m
[32m+[m[32m  /* Reset the SMS Bits */[m
[32m+[m[32m  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));[m
[32m+[m[32m  /* Select the External clock mode1 */[m
[32m+[m[32m  tmpsmcr |= TIM_SlaveMode_External1;[m
[32m+[m[32m  /* Select the Trigger selection : ETRF */[m
[32m+[m[32m  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));[m
[32m+[m[32m  tmpsmcr |= TIM_TS_ETRF;[m
[32m+[m[32m  /* Write to TIMx SMCR */[m
[32m+[m[32m  TIMx->SMCR = tmpsmcr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the External clock Mode2[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.[m
[32m+[m[32m  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.[m
[32m+[m[32m  * @param  ExtTRGFilter: External Trigger Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,[m[41m [m
[32m+[m[32m                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));[m
[32m+[m[32m  /* Configure the ETR Clock source */[m
[32m+[m[32m  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);[m
[32m+[m[32m  /* Enable the External clock mode2 */[m
[32m+[m[32m  TIMx->SMCR |= TIM_SMCR_ECE;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx External Trigger (ETR).[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ExtTRGPrescaler: The external Trigger Prescaler.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_OFF: ETRP Prescaler OFF.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV2: ETRP frequency divided by 2.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV4: ETRP frequency divided by 4.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPSC_DIV8: ETRP frequency divided by 8.[m
[32m+[m[32m  * @param  TIM_ExtTRGPolarity: The external Trigger Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ExtTRGPolarity_Inverted: active low or falling edge active.[m
[32m+[m[32m  *     @arg TIM_ExtTRGPolarity_NonInverted: active high or rising edge active.[m
[32m+[m[32m  * @param  ExtTRGFilter: External Trigger Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,[m
[32m+[m[32m                   uint16_t ExtTRGFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpsmcr = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));[m
[32m+[m[32m  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));[m
[32m+[m[32m  tmpsmcr = TIMx->SMCR;[m
[32m+[m[32m  /* Reset the ETR Bits */[m
[32m+[m[32m  tmpsmcr &= SMCR_ETR_Mask;[m
[32m+[m[32m  /* Set the Prescaler, the Filter value and the Polarity */[m
[32m+[m[32m  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));[m
[32m+[m[32m  /* Write to TIMx SMCR */[m
[32m+[m[32m  TIMx->SMCR = tmpsmcr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Prescaler.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Prescaler: specifies the Prescaler Register value[m
[32m+[m[32m  * @param  TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_PSCReloadMode_Update: The Prescaler is loaded at the update event.[m
[32m+[m[32m  *     @arg TIM_PSCReloadMode_Immediate: The Prescaler is loaded immediately.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));[m
[32m+[m[32m  /* Set the Prescaler value */[m
[32m+[m[32m  TIMx->PSC = Prescaler;[m
[32m+[m[32m  /* Set or reset the UG Bit */[m
[32m+[m[32m  TIMx->EGR = TIM_PSCReloadMode;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Specifies the TIMx Counter Mode to be used.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_CounterMode: specifies the Counter Mode to be used[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_CounterMode_Up: TIM Up Counting Mode[m
[32m+[m[32m  *     @arg TIM_CounterMode_Down: TIM Down Counting Mode[m
[32m+[m[32m  *     @arg TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1[m
[32m+[m[32m  *     @arg TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2[m
[32m+[m[32m  *     @arg TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpcr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));[m
[32m+[m[32m  tmpcr1 = TIMx->CR1;[m
[32m+[m[32m  /* Reset the CMS and DIR Bits */[m
[32m+[m[32m  tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));[m
[32m+[m[32m  /* Set the Counter Mode */[m
[32m+[m[32m  tmpcr1 |= TIM_CounterMode;[m
[32m+[m[32m  /* Write to TIMx CR1 register */[m
[32m+[m[32m  TIMx->CR1 = tmpcr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the Input Trigger source[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_InputTriggerSource: The Input Trigger source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_TS_ITR0: Internal Trigger 0[m
[32m+[m[32m  *     @arg TIM_TS_ITR1: Internal Trigger 1[m
[32m+[m[32m  *     @arg TIM_TS_ITR2: Internal Trigger 2[m
[32m+[m[32m  *     @arg TIM_TS_ITR3: Internal Trigger 3[m
[32m+[m[32m  *     @arg TIM_TS_TI1F_ED: TI1 Edge Detector[m
[32m+[m[32m  *     @arg TIM_TS_TI1FP1: Filtered Timer Input 1[m
[32m+[m[32m  *     @arg TIM_TS_TI2FP2: Filtered Timer Input 2[m
[32m+[m[32m  *     @arg TIM_TS_ETRF: External Trigger input[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpsmcr = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));[m
[32m+[m[32m  /* Get the TIMx SMCR register value */[m
[32m+[m[32m  tmpsmcr = TIMx->SMCR;[m
[32m+[m[32m  /* Reset the TS Bits */[m
[32m+[m[32m  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));[m
[32m+[m[32m  /* Set the Input Trigger source */[m
[32m+[m[32m  tmpsmcr |= TIM_InputTriggerSource;[m
[32m+[m[32m  /* Write to TIMx SMCR */[m
[32m+[m[32m  TIMx->SMCR = tmpsmcr;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Encoder Interface.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_EncoderMode: specifies the TIMx Encoder Mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge depending on TI2FP2 level.[m
[32m+[m[32m  *     @arg TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge depending on TI1FP1 level.[m
[32m+[m[32m  *     @arg TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and TI2FP2 edges depending[m
[32m+[m[32m  *                                on the level of the other input.[m
[32m+[m[32m  * @param  TIM_IC1Polarity: specifies the IC1 Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling: IC Falling edge.[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising: IC Rising edge.[m
[32m+[m[32m  * @param  TIM_IC2Polarity: specifies the IC2 Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling: IC Falling edge.[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising: IC Rising edge.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,[m
[32m+[m[32m                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpsmcr = 0;[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[41m    [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST5_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));[m
[32m+[m[32m  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));[m
[32m+[m[32m  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));[m
[32m+[m
[32m+[m[32m  /* Get the TIMx SMCR register value */[m
[32m+[m[32m  tmpsmcr = TIMx->SMCR;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCMR1 register value */[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the TIMx CCER register value */[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the encoder Mode */[m
[32m+[m[32m  tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));[m
[32m+[m[32m  tmpsmcr |= TIM_EncoderMode;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Select the Capture Compare 1 and the Capture Compare 2 as input */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));[m
[32m+[m[32m  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set the TI1 and the TI2 Polarities */[m
[32m+[m[32m  tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx SMCR */[m
[32m+[m[32m  TIMx->SMCR = tmpsmcr;[m
[32m+[m[32m  /* Write to TIMx CCMR1 */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m  /* Write to TIMx CCER */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces the TIMx output 1 waveform to active or inactive level.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ForcedAction_Active: Force active level on OC1REF[m
[32m+[m[32m  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC1REF.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC1M Bits */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);[m
[32m+[m[32m  /* Configure The Forced output Mode */[m
[32m+[m[32m  tmpccmr1 |= TIM_ForcedAction;[m
[32m+[m[32m  /* Write to TIMx CCMR1 register */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces the TIMx output 2 waveform to active or inactive level.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ForcedAction_Active: Force active level on OC2REF[m
[32m+[m[32m  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC2REF.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC2M Bits */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);[m
[32m+[m[32m  /* Configure The Forced output Mode */[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR1 register */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces the TIMx output 3 waveform to active or inactive level.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ForcedAction_Active: Force active level on OC3REF[m
[32m+[m[32m  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC3REF.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC1M Bits */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);[m
[32m+[m[32m  /* Configure The Forced output Mode */[m
[32m+[m[32m  tmpccmr2 |= TIM_ForcedAction;[m
[32m+[m[32m  /* Write to TIMx CCMR2 register */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Forces the TIMx output 4 waveform to active or inactive level.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ForcedAction: specifies the forced Action to be set to the output waveform.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ForcedAction_Active: Force active level on OC4REF[m
[32m+[m[32m  *     @arg TIM_ForcedAction_InActive: Force inactive level on OC4REF.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC2M Bits */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);[m
[32m+[m[32m  /* Configure The Forced output Mode */[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR2 register */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables TIMx peripheral Preload register on ARR.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the TIMx peripheral Preload register[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the ARR Preload Bit */[m
[32m+[m[32m    TIMx->CR1 |= TIM_CR1_ARPE;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the ARR Preload Bit */[m
[32m+[m[32m    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the TIM peripheral Commutation event.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 8, 15, 16 or 17 to select the TIMx peripheral[m
[32m+[m[32m  * @param  NewState: new state of the Commutation event.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST2_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the COM Bit */[m
[32m+[m[32m    TIMx->CR2 |= TIM_CR2_CCUS;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the COM Bit */[m
[32m+[m[32m    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the TIMx peripheral Capture Compare DMA source.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 15, 16 or 17 to select[m[41m [m
[32m+[m[32m  *         the TIM peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the Capture Compare DMA source[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST4_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the CCDS Bit */[m
[32m+[m[32m    TIMx->CR2 |= TIM_CR2_CCDS;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the CCDS Bit */[m
[32m+[m[32m    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets or Resets the TIM peripheral Capture Compare Preload Control bit.[m
[32m+[m[32m  * @param  TIMx: where x can be   1, 2, 3, 4, 5, 8 or 15[m[41m [m
[32m+[m[32m  *         to select the TIMx peripheral[m
[32m+[m[32m  * @param  NewState: new state of the Capture Compare Preload Control bit[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST5_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the CCPC Bit */[m
[32m+[m[32m    TIMx->CR2 |= TIM_CR2_CCPC;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the CCPC Bit */[m
[32m+[m[32m    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIMx peripheral Preload register on CCR1.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPreload_Enable[m
[32m+[m[32m  *     @arg TIM_OCPreload_Disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC1PE Bit */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Preload feature */[m
[32m+[m[32m  tmpccmr1 |= TIM_OCPreload;[m
[32m+[m[32m  /* Write to TIMx CCMR1 register */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIMx peripheral Preload register on CCR2.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select[m[41m [m
[32m+[m[32m  *         the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPreload_Enable[m
[32m+[m[32m  *     @arg TIM_OCPreload_Disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC2PE Bit */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Preload feature */[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR1 register */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIMx peripheral Preload register on CCR3.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPreload_Enable[m
[32m+[m[32m  *     @arg TIM_OCPreload_Disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC3PE Bit */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Preload feature */[m
[32m+[m[32m  tmpccmr2 |= TIM_OCPreload;[m
[32m+[m[32m  /* Write to TIMx CCMR2 register */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIMx peripheral Preload register on CCR4.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPreload: new state of the TIMx peripheral Preload register[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPreload_Enable[m
[32m+[m[32m  *     @arg TIM_OCPreload_Disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC4PE Bit */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Preload feature */[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR2 register */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Output Compare 1 Fast feature.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCFast_Enable: TIM output compare fast enable[m
[32m+[m[32m  *     @arg TIM_OCFast_Disable: TIM output compare fast disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));[m
[32m+[m[32m  /* Get the TIMx CCMR1 register value */[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC1FE Bit */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Fast Bit */[m
[32m+[m[32m  tmpccmr1 |= TIM_OCFast;[m
[32m+[m[32m  /* Write to TIMx CCMR1 */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Output Compare 2 Fast feature.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5, 8, 9, 12 or 15 to select[m[41m [m
[32m+[m[32m  *         the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCFast_Enable: TIM output compare fast enable[m
[32m+[m[32m  *     @arg TIM_OCFast_Disable: TIM output compare fast disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));[m
[32m+[m[32m  /* Get the TIMx CCMR1 register value */[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC2FE Bit */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Fast Bit */[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR1 */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Output Compare 3 Fast feature.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCFast_Enable: TIM output compare fast enable[m
[32m+[m[32m  *     @arg TIM_OCFast_Disable: TIM output compare fast disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));[m
[32m+[m[32m  /* Get the TIMx CCMR2 register value */[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC3FE Bit */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Fast Bit */[m
[32m+[m[32m  tmpccmr2 |= TIM_OCFast;[m
[32m+[m[32m  /* Write to TIMx CCMR2 */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Output Compare 4 Fast feature.[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCFast: new state of the Output Compare Fast Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCFast_Enable: TIM output compare fast enable[m
[32m+[m[32m  *     @arg TIM_OCFast_Disable: TIM output compare fast disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));[m
[32m+[m[32m  /* Get the TIMx CCMR2 register value */[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC4FE Bit */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Fast Bit */[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR2 */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears or safeguards the OCREF1 signal on an external event[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCClear_Enable: TIM Output clear enable[m
[32m+[m[32m  *     @arg TIM_OCClear_Disable: TIM Output clear disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));[m
[32m+[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m
[32m+[m[32m  /* Reset the OC1CE Bit */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Clear Bit */[m
[32m+[m[32m  tmpccmr1 |= TIM_OCClear;[m
[32m+[m[32m  /* Write to TIMx CCMR1 register */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears or safeguards the OCREF2 signal on an external event[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCClear_Enable: TIM Output clear enable[m
[32m+[m[32m  *     @arg TIM_OCClear_Disable: TIM Output clear disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  /* Reset the OC2CE Bit */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Clear Bit */[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR1 register */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears or safeguards the OCREF3 signal on an external event[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCClear_Enable: TIM Output clear enable[m
[32m+[m[32m  *     @arg TIM_OCClear_Disable: TIM Output clear disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC3CE Bit */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Clear Bit */[m
[32m+[m[32m  tmpccmr2 |= TIM_OCClear;[m
[32m+[m[32m  /* Write to TIMx CCMR2 register */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears or safeguards the OCREF4 signal on an external event[m
[32m+[m[32m  * @param  TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCClear: new state of the Output Compare Clear Enable Bit.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCClear_Enable: TIM Output clear enable[m
[32m+[m[32m  *     @arg TIM_OCClear_Disable: TIM Output clear disable[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  /* Reset the OC4CE Bit */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);[m
[32m+[m[32m  /* Enable or Disable the Output Compare Clear Bit */[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);[m
[32m+[m[32m  /* Write to TIMx CCMR2 register */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx channel 1 polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPolarity: specifies the OC1 Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC1P Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);[m
[32m+[m[32m  tmpccer |= TIM_OCPolarity;[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Channel 1N polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCNPolarity: specifies the OC1N Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCNPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCNPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST2_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));[m
[32m+[m[41m   [m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC1NP Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);[m
[32m+[m[32m  tmpccer |= TIM_OCNPolarity;[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx channel 2 polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPolarity: specifies the OC2 Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC2P Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCPolarity << 4);[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Channel 2N polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCNPolarity: specifies the OC2N Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCNPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCNPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST1_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));[m
[32m+[m[41m  [m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC2NP Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx channel 3 polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPolarity: specifies the OC3 Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC3P Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCPolarity << 8);[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Channel 3N polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCNPolarity: specifies the OC3N Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCNPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCNPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST1_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));[m
[32m+[m[41m    [m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC3NP Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx channel 4 polarity.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OCPolarity: specifies the OC4 Polarity[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCPolarity_High: Output Compare active high[m
[32m+[m[32m  *     @arg TIM_OCPolarity_Low: Output Compare active low[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccer = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Set or Reset the CC4P Bit */[m
[32m+[m[32m  tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);[m
[32m+[m[32m  tmpccer |= (uint16_t)(TIM_OCPolarity << 12);[m
[32m+[m[32m  /* Write to TIMx CCER register */[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIM Capture Compare Channel x.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_Channel: specifies the TIM Channel[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_Channel_1: TIM Channel 1[m
[32m+[m[32m  *     @arg TIM_Channel_2: TIM Channel 2[m
[32m+[m[32m  *     @arg TIM_Channel_3: TIM Channel 3[m
[32m+[m[32m  *     @arg TIM_Channel_4: TIM Channel 4[m
[32m+[m[32m  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.[m
[32m+[m[32m  *   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable.[m[41m [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_CHANNEL(TIM_Channel));[m
[32m+[m[32m  assert_param(IS_TIM_CCX(TIM_CCx));[m
[32m+[m
[32m+[m[32m  tmp = CCER_CCE_Set << TIM_Channel;[m
[32m+[m
[32m+[m[32m  /* Reset the CCxE Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)~ tmp;[m
[32m+[m
[32m+[m[32m  /* Set or reset the CCxE Bit */[m[41m [m
[32m+[m[32m  TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIM Capture Compare Channel xN.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 8, 15, 16 or 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_Channel: specifies the TIM Channel[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_Channel_1: TIM Channel 1[m
[32m+[m[32m  *     @arg TIM_Channel_2: TIM Channel 2[m
[32m+[m[32m  *     @arg TIM_Channel_3: TIM Channel 3[m
[32m+[m[32m  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.[m
[32m+[m[32m  *   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable.[m[41m [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmp = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST2_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));[m
[32m+[m[32m  assert_param(IS_TIM_CCXN(TIM_CCxN));[m
[32m+[m
[32m+[m[32m  tmp = CCER_CCNE_Set << TIM_Channel;[m
[32m+[m
[32m+[m[32m  /* Reset the CCxNE Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t) ~tmp;[m
[32m+[m
[32m+[m[32m  /* Set or reset the CCxNE Bit */[m[41m [m
[32m+[m[32m  TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the TIM Output Compare Mode.[m
[32m+[m[32m  * @note   This function disables the selected channel before changing the Output[m
[32m+[m[32m  *         Compare Mode.[m
[32m+[m[32m  *         User has to enable this channel using TIM_CCxCmd and TIM_CCxNCmd functions.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_Channel: specifies the TIM Channel[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_Channel_1: TIM Channel 1[m
[32m+[m[32m  *     @arg TIM_Channel_2: TIM Channel 2[m
[32m+[m[32m  *     @arg TIM_Channel_3: TIM Channel 3[m
[32m+[m[32m  *     @arg TIM_Channel_4: TIM Channel 4[m
[32m+[m[32m  * @param  TIM_OCMode: specifies the TIM Output Compare Mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OCMode_Timing[m
[32m+[m[32m  *     @arg TIM_OCMode_Active[m
[32m+[m[32m  *     @arg TIM_OCMode_Toggle[m
[32m+[m[32m  *     @arg TIM_OCMode_PWM1[m
[32m+[m[32m  *     @arg TIM_OCMode_PWM2[m
[32m+[m[32m  *     @arg TIM_ForcedAction_Active[m
[32m+[m[32m  *     @arg TIM_ForcedAction_InActive[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmp = 0;[m
[32m+[m[32m  uint16_t tmp1 = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_CHANNEL(TIM_Channel));[m
[32m+[m[32m  assert_param(IS_TIM_OCM(TIM_OCMode));[m
[32m+[m
[32m+[m[32m  tmp = (uint32_t) TIMx;[m
[32m+[m[32m  tmp += CCMR_Offset;[m
[32m+[m
[32m+[m[32m  tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;[m
[32m+[m
[32m+[m[32m  /* Disable the Channel: Reset the CCxE Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t) ~tmp1;[m
[32m+[m
[32m+[m[32m  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))[m
[32m+[m[32m  {[m
[32m+[m[32m    tmp += (TIM_Channel>>1);[m
[32m+[m
[32m+[m[32m    /* Reset the OCxM bits in the CCMRx register */[m
[32m+[m[32m    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);[m
[32m+[m[41m   [m
[32m+[m[32m    /* Configure the OCxM bits in the CCMRx register */[m
[32m+[m[32m    *(__IO uint32_t *) tmp |= TIM_OCMode;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;[m
[32m+[m
[32m+[m[32m    /* Reset the OCxM bits in the CCMRx register */[m
[32m+[m[32m    *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);[m
[32m+[m[41m    [m
[32m+[m[32m    /* Configure the OCxM bits in the CCMRx register */[m
[32m+[m[32m    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or Disables the TIMx Update event.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the TIMx UDIS bit[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the Update Disable Bit */[m
[32m+[m[32m    TIMx->CR1 |= TIM_CR1_UDIS;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the Update Disable Bit */[m
[32m+[m[32m    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the TIMx Update Request Interrupt source.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_UpdateSource: specifies the Update source.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_UpdateSource_Regular: Source of update is the counter overflow/underflow[m
[32m+[m[32m                                       or the setting of UG bit, or an update generation[m
[32m+[m[32m                                       through the slave mode controller.[m
[32m+[m[32m  *     @arg TIM_UpdateSource_Global: Source of update is counter overflow/underflow.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));[m
[32m+[m[32m  if (TIM_UpdateSource != TIM_UpdateSource_Global)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the URS Bit */[m
[32m+[m[32m    TIMx->CR1 |= TIM_CR1_URS;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the URS Bit */[m
[32m+[m[32m    TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the TIMx's Hall sensor interface.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the TIMx Hall sensor interface.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Set the TI1S Bit */[m
[32m+[m[32m    TIMx->CR2 |= TIM_CR2_TI1S;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Reset the TI1S Bit */[m
[32m+[m[32m    TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the TIMx's One Pulse Mode.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_OPMode: specifies the OPM Mode to be used.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_OPMode_Single[m
[32m+[m[32m  *     @arg TIM_OPMode_Repetitive[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));[m
[32m+[m[32m  /* Reset the OPM Bit */[m
[32m+[m[32m  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);[m
[32m+[m[32m  /* Configure the OPM Mode */[m
[32m+[m[32m  TIMx->CR1 |= TIM_OPMode;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the TIMx Trigger Output Mode.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 6, 7, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_TRGOSource: specifies the Trigger Output source.[m
[32m+[m[32m  *   This paramter can be one of the following values:[m
[32m+[m[32m  *[m
[32m+[m[32m  *  - For all TIMx[m
[32m+[m[32m  *     @arg TIM_TRGOSource_Reset:  The UG bit in the TIM_EGR register is used as the trigger output (TRGO).[m
[32m+[m[32m  *     @arg TIM_TRGOSource_Enable: The Counter Enable CEN is used as the trigger output (TRGO).[m
[32m+[m[32m  *     @arg TIM_TRGOSource_Update: The update event is selected as the trigger output (TRGO).[m
[32m+[m[32m  *[m
[32m+[m[32m  *  - For all TIMx except TIM6 and TIM7[m
[32m+[m[32m  *     @arg TIM_TRGOSource_OC1: The trigger output sends a positive pulse when the CC1IF flag[m
[32m+[m[32m  *                              is to be set, as soon as a capture or compare match occurs (TRGO).[m
[32m+[m[32m  *     @arg TIM_TRGOSource_OC1Ref: OC1REF signal is used as the trigger output (TRGO).[m
[32m+[m[32m  *     @arg TIM_TRGOSource_OC2Ref: OC2REF signal is used as the trigger output (TRGO).[m
[32m+[m[32m  *     @arg TIM_TRGOSource_OC3Ref: OC3REF signal is used as the trigger output (TRGO).[m
[32m+[m[32m  *     @arg TIM_TRGOSource_OC4Ref: OC4REF signal is used as the trigger output (TRGO).[m
[32m+[m[32m  *[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST7_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));[m
[32m+[m[32m  /* Reset the MMS Bits */[m
[32m+[m[32m  TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);[m
[32m+[m[32m  /* Select the TRGO source */[m
[32m+[m[32m  TIMx->CR2 |=  TIM_TRGOSource;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the TIMx Slave Mode.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_SlaveMode: specifies the Timer Slave Mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_SlaveMode_Reset: Rising edge of the selected trigger signal (TRGI) re-initializes[m
[32m+[m[32m  *                               the counter and triggers an update of the registers.[m
[32m+[m[32m  *     @arg TIM_SlaveMode_Gated:     The counter clock is enabled when the trigger signal (TRGI) is high.[m
[32m+[m[32m  *     @arg TIM_SlaveMode_Trigger:   The counter starts at a rising edge of the trigger TRGI.[m
[32m+[m[32m  *     @arg TIM_SlaveMode_External1: Rising edges of the selected trigger (TRGI) clock the counter.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));[m
[32m+[m[32m /* Reset the SMS Bits */[m
[32m+[m[32m  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);[m
[32m+[m[32m  /* Select the Slave Mode */[m
[32m+[m[32m  TIMx->SMCR |= TIM_SlaveMode;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets or Resets the TIMx Master/Slave Mode.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_MasterSlaveMode_Enable: synchronization between the current timer[m
[32m+[m[32m  *                                      and its slaves (through TRGO).[m
[32m+[m[32m  *     @arg TIM_MasterSlaveMode_Disable: No action[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));[m
[32m+[m[32m  /* Reset the MSM Bit */[m
[32m+[m[32m  TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);[m
[32m+[m[41m  [m
[32m+[m[32m  /* Set or Reset the MSM Bit */[m
[32m+[m[32m  TIMx->SMCR |= TIM_MasterSlaveMode;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Counter Register value[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Counter: specifies the Counter register new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  /* Set the Counter Register value */[m
[32m+[m[32m  TIMx->CNT = Counter;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Autoreload Register value[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Autoreload: specifies the Autoreload register new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  /* Set the Autoreload Register value */[m
[32m+[m[32m  TIMx->ARR = Autoreload;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Capture Compare1 Register value[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Compare1: specifies the Capture Compare1 register new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  /* Set the Capture Compare1 Register value */[m
[32m+[m[32m  TIMx->CCR1 = Compare1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Capture Compare2 Register value[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Compare2: specifies the Capture Compare2 register new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  /* Set the Capture Compare2 Register value */[m
[32m+[m[32m  TIMx->CCR2 = Compare2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Capture Compare3 Register value[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Compare3: specifies the Capture Compare3 register new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  /* Set the Capture Compare3 Register value */[m
[32m+[m[32m  TIMx->CCR3 = Compare3;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Capture Compare4 Register value[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  Compare4: specifies the Capture Compare4 register new value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  /* Set the Capture Compare4 Register value */[m
[32m+[m[32m  TIMx->CCR4 = Compare4;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Input Capture 1 prescaler.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPSC: specifies the Input Capture1 prescaler new value.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV1: no prescaler[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));[m
[32m+[m[32m  /* Reset the IC1PSC Bits */[m
[32m+[m[32m  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);[m
[32m+[m[32m  /* Set the IC1PSC value */[m
[32m+[m[32m  TIMx->CCMR1 |= TIM_ICPSC;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Input Capture 2 prescaler.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPSC: specifies the Input Capture2 prescaler new value.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV1: no prescaler[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));[m
[32m+[m[32m  /* Reset the IC2PSC Bits */[m
[32m+[m[32m  TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);[m
[32m+[m[32m  /* Set the IC2PSC value */[m
[32m+[m[32m  TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Input Capture 3 prescaler.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPSC: specifies the Input Capture3 prescaler new value.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV1: no prescaler[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));[m
[32m+[m[32m  /* Reset the IC3PSC Bits */[m
[32m+[m[32m  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);[m
[32m+[m[32m  /* Set the IC3PSC value */[m
[32m+[m[32m  TIMx->CCMR2 |= TIM_ICPSC;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Input Capture 4 prescaler.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPSC: specifies the Input Capture4 prescaler new value.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV1: no prescaler[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV2: capture is done once every 2 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV4: capture is done once every 4 events[m
[32m+[m[32m  *     @arg TIM_ICPSC_DIV8: capture is done once every 8 events[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));[m
[32m+[m[32m  /* Reset the IC4PSC Bits */[m
[32m+[m[32m  TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);[m
[32m+[m[32m  /* Set the IC4PSC value */[m
[32m+[m[32m  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the TIMx Clock Division value.[m
[32m+[m[32m  * @param  TIMx: where x can be  1 to 17 except 6 and 7 to select[m[41m [m
[32m+[m[32m  *   the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_CKD: specifies the clock division value.[m
[32m+[m[32m  *   This parameter can be one of the following value:[m
[32m+[m[32m  *     @arg TIM_CKD_DIV1: TDTS = Tck_tim[m
[32m+[m[32m  *     @arg TIM_CKD_DIV2: TDTS = 2*Tck_tim[m
[32m+[m[32m  *     @arg TIM_CKD_DIV4: TDTS = 4*Tck_tim[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_CKD_DIV(TIM_CKD));[m
[32m+[m[32m  /* Reset the CKD Bits */[m
[32m+[m[32m  TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);[m
[32m+[m[32m  /* Set the CKD value */[m
[32m+[m[32m  TIMx->CR1 |= TIM_CKD;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the TIMx Input Capture 1 value.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @retval Capture Compare 1 Register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST8_PERIPH(TIMx));[m
[32m+[m[32m  /* Get the Capture 1 Register value */[m
[32m+[m[32m  return TIMx->CCR1;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the TIMx Input Capture 2 value.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @retval Capture Compare 2 Register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST6_PERIPH(TIMx));[m
[32m+[m[32m  /* Get the Capture 2 Register value */[m
[32m+[m[32m  return TIMx->CCR2;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the TIMx Input Capture 3 value.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @retval Capture Compare 3 Register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m[41m [m
[32m+[m[32m  /* Get the Capture 3 Register value */[m
[32m+[m[32m  return TIMx->CCR3;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the TIMx Input Capture 4 value.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @retval Capture Compare 4 Register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_LIST3_PERIPH(TIMx));[m
[32m+[m[32m  /* Get the Capture 4 Register value */[m
[32m+[m[32m  return TIMx->CCR4;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the TIMx Counter value.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @retval Counter Register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t TIM_GetCounter(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  /* Get the Counter Register value */[m
[32m+[m[32m  return TIMx->CNT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Gets the TIMx Prescaler value.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @retval Prescaler Register value.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  /* Get the Prescaler Register value */[m
[32m+[m[32m  return TIMx->PSC;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified TIM flag is set or not.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_FLAG_Update: TIM update Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_COM: TIM Commutation Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_Break: TIM Break Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - TIM6 and TIM7 can have only one update flag.[m[41m [m
[32m+[m[32m  *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,[m
[32m+[m[32m  *      TIM_FLAG_CC2 or TIM_FLAG_Trigger.[m[41m [m
[32m+[m[32m  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.[m[41m   [m
[32m+[m[32m  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15.[m[41m [m
[32m+[m[32m  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.[m[41m    [m
[32m+[m[32m  * @retval The new state of TIM_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  ITStatus bitstatus = RESET;[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));[m
[32m+[m[41m  [m
[32m+[m[32m  if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the TIMx's pending flags.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_FLAG: specifies the flag bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg TIM_FLAG_Update: TIM update Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC1: TIM Capture Compare 1 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC2: TIM Capture Compare 2 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC3: TIM Capture Compare 3 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC4: TIM Capture Compare 4 Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_COM: TIM Commutation Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_Trigger: TIM Trigger Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_Break: TIM Break Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag[m
[32m+[m[32m  *     @arg TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - TIM6 and TIM7 can have only one update flag.[m[41m [m
[32m+[m[32m  *   - TIM9, TIM12 and TIM15 can have only TIM_FLAG_Update, TIM_FLAG_CC1,[m
[32m+[m[32m  *      TIM_FLAG_CC2 or TIM_FLAG_Trigger.[m[41m [m
[32m+[m[32m  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_FLAG_Update or TIM_FLAG_CC1.[m[41m   [m
[32m+[m[32m  *   - TIM_FLAG_Break is used only with TIM1, TIM8 and TIM15.[m[41m [m
[32m+[m[32m  *   - TIM_FLAG_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.[m[41m   [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)[m
[32m+[m[32m{[m[41m  [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));[m
[32m+[m[41m   [m
[32m+[m[32m  /* Clear the flags */[m
[32m+[m[32m  TIMx->SR = (uint16_t)~TIM_FLAG;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the TIM interrupt has occurred or not.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_IT: specifies the TIM interrupt source to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_IT_Update: TIM update Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_COM: TIM Commutation Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_Break: TIM Break Interrupt source[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - TIM6 and TIM7 can generate only an update interrupt.[m
[32m+[m[32m  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,[m
[32m+[m[32m  *      TIM_IT_CC2 or TIM_IT_Trigger.[m[41m [m
[32m+[m[32m  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.[m[41m   [m
[32m+[m[32m  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15.[m[41m [m
[32m+[m[32m  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.[m[41m  [m
[32m+[m[32m  * @retval The new state of the TIM_IT(SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m[41m  [m
[32m+[m[32m  uint16_t itstatus = 0x0, itenable = 0x0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_GET_IT(TIM_IT));[m
[32m+[m[41m   [m
[32m+[m[32m  itstatus = TIMx->SR & TIM_IT;[m
[32m+[m[41m  [m
[32m+[m[32m  itenable = TIMx->DIER & TIM_IT;[m
[32m+[m[32m  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the TIMx's interrupt pending bits.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_IT: specifies the pending bit to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg TIM_IT_Update: TIM1 update Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC1: TIM Capture Compare 1 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC2: TIM Capture Compare 2 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC3: TIM Capture Compare 3 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_CC4: TIM Capture Compare 4 Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_COM: TIM Commutation Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_Trigger: TIM Trigger Interrupt source[m
[32m+[m[32m  *     @arg TIM_IT_Break: TIM Break Interrupt source[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - TIM6 and TIM7 can generate only an update interrupt.[m
[32m+[m[32m  *   - TIM9, TIM12 and TIM15 can have only TIM_IT_Update, TIM_IT_CC1,[m
[32m+[m[32m  *      TIM_IT_CC2 or TIM_IT_Trigger.[m[41m [m
[32m+[m[32m  *   - TIM10, TIM11, TIM13, TIM14, TIM16 and TIM17 can have TIM_IT_Update or TIM_IT_CC1.[m[41m   [m
[32m+[m[32m  *   - TIM_IT_Break is used only with TIM1, TIM8 and TIM15.[m[41m [m
[32m+[m[32m  *   - TIM_IT_COM is used only with TIM1, TIM8, TIM15, TIM16 and TIM17.[m[41m    [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_TIM_ALL_PERIPH(TIMx));[m
[32m+[m[32m  assert_param(IS_TIM_IT(TIM_IT));[m
[32m+[m[32m  /* Clear the IT pending Bit */[m
[32m+[m[32m  TIMx->SR = (uint16_t)~TIM_IT;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configure the TI1 as Input.[m
[32m+[m[32m  * @param  TIMx: where x can be 1 to 17 except 6 and 7 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPolarity : The Input Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling[m
[32m+[m[32m  * @param  TIM_ICSelection: specifies the input to be used.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICSelection_DirectTI: TIM Input 1 is selected to be connected to IC1.[m
[32m+[m[32m  *     @arg TIM_ICSelection_IndirectTI: TIM Input 1 is selected to be connected to IC2.[m
[32m+[m[32m  *     @arg TIM_ICSelection_TRC: TIM Input 1 is selected to be connected to TRC.[m
[32m+[m[32m  * @param  TIM_ICFilter: Specifies the Input Capture Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0, tmpccer = 0;[m
[32m+[m[32m  /* Disable the Channel 1: Reset the CC1E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  /* Select the Input and set the filter */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));[m
[32m+[m[41m  [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||[m
[32m+[m[32m     (TIMx == TIM4) ||(TIMx == TIM5))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC1E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC1E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  /* Write to TIMx CCMR1 and CCER registers */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1;[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configure the TI2 as Input.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5, 8, 9, 12 or 15 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPolarity : The Input Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling[m
[32m+[m[32m  * @param  TIM_ICSelection: specifies the input to be used.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICSelection_DirectTI: TIM Input 2 is selected to be connected to IC2.[m
[32m+[m[32m  *     @arg TIM_ICSelection_IndirectTI: TIM Input 2 is selected to be connected to IC1.[m
[32m+[m[32m  *     @arg TIM_ICSelection_TRC: TIM Input 2 is selected to be connected to TRC.[m
[32m+[m[32m  * @param  TIM_ICFilter: Specifies the Input Capture Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;[m
[32m+[m[32m  /* Disable the Channel 2: Reset the CC2E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);[m
[32m+[m[32m  tmpccmr1 = TIMx->CCMR1;[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  tmp = (uint16_t)(TIM_ICPolarity << 4);[m
[32m+[m[32m  /* Select the Input and set the filter */[m
[32m+[m[32m  tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);[m
[32m+[m[32m  tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);[m
[32m+[m[41m  [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||[m
[32m+[m[32m     (TIMx == TIM4) ||(TIMx == TIM5))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC2E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));[m
[32m+[m[32m    tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC2E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCMR1 and CCER registers */[m
[32m+[m[32m  TIMx->CCMR1 = tmpccmr1 ;[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configure the TI3 as Input.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPolarity : The Input Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling[m
[32m+[m[32m  * @param  TIM_ICSelection: specifies the input to be used.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICSelection_DirectTI: TIM Input 3 is selected to be connected to IC3.[m
[32m+[m[32m  *     @arg TIM_ICSelection_IndirectTI: TIM Input 3 is selected to be connected to IC4.[m
[32m+[m[32m  *     @arg TIM_ICSelection_TRC: TIM Input 3 is selected to be connected to TRC.[m
[32m+[m[32m  * @param  TIM_ICFilter: Specifies the Input Capture Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void TI3_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;[m
[32m+[m[32m  /* Disable the Channel 3: Reset the CC3E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC3E);[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  tmp = (uint16_t)(TIM_ICPolarity << 8);[m
[32m+[m[32m  /* Select the Input and set the filter */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR2_CC3S)) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC3F)));[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));[m
[32m+[m[41m    [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||[m
[32m+[m[32m     (TIMx == TIM4) ||(TIMx == TIM5))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC3E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P));[m
[32m+[m[32m    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC3E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC3NP));[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC3E);[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to TIMx CCMR2 and CCER registers */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configure the TI4 as Input.[m
[32m+[m[32m  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.[m
[32m+[m[32m  * @param  TIM_ICPolarity : The Input Polarity.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Rising[m
[32m+[m[32m  *     @arg TIM_ICPolarity_Falling[m
[32m+[m[32m  * @param  TIM_ICSelection: specifies the input to be used.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg TIM_ICSelection_DirectTI: TIM Input 4 is selected to be connected to IC4.[m
[32m+[m[32m  *     @arg TIM_ICSelection_IndirectTI: TIM Input 4 is selected to be connected to IC3.[m
[32m+[m[32m  *     @arg TIM_ICSelection_TRC: TIM Input 4 is selected to be connected to TRC.[m
[32m+[m[32m  * @param  TIM_ICFilter: Specifies the Input Capture Filter.[m
[32m+[m[32m  *   This parameter must be a value between 0x00 and 0x0F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mstatic void TI4_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,[m
[32m+[m[32m                       uint16_t TIM_ICFilter)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;[m
[32m+[m
[32m+[m[32m   /* Disable the Channel 4: Reset the CC4E Bit */[m
[32m+[m[32m  TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC4E);[m
[32m+[m[32m  tmpccmr2 = TIMx->CCMR2;[m
[32m+[m[32m  tmpccer = TIMx->CCER;[m
[32m+[m[32m  tmp = (uint16_t)(TIM_ICPolarity << 12);[m
[32m+[m[32m  /* Select the Input and set the filter */[m
[32m+[m[32m  tmpccmr2 &= (uint16_t)((uint16_t)(~(uint16_t)TIM_CCMR2_CC4S) & ((uint16_t)~((uint16_t)TIM_CCMR2_IC4F)));[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);[m
[32m+[m[32m  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);[m
[32m+[m[41m  [m
[32m+[m[32m  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||[m
[32m+[m[32m     (TIMx == TIM4) ||(TIMx == TIM5))[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC4E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC4P));[m
[32m+[m[32m    tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Select the Polarity and set the CC4E Bit */[m
[32m+[m[32m    tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC3P | TIM_CCER_CC4NP));[m
[32m+[m[32m    tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC4E);[m
[32m+[m[32m  }[m
[32m+[m[32m  /* Write to TIMx CCMR2 and CCER registers */[m
[32m+[m[32m  TIMx->CCMR2 = tmpccmr2;[m
[32m+[m[32m  TIMx->CCER = tmpccer;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c[m
[1mnew file mode 100644[m
[1mindex 0000000..e794eae[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_usart.c[m
[36m@@ -0,0 +1,1058 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_usart.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the USART firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_usart.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART[m[41m [m
[32m+[m[32m  * @brief USART driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define CR1_UE_Set                ((uint16_t)0x2000)  /*!< USART Enable Mask */[m
[32m+[m[32m#define CR1_UE_Reset              ((uint16_t)0xDFFF)  /*!< USART Disable Mask */[m
[32m+[m
[32m+[m[32m#define CR1_WAKE_Mask             ((uint16_t)0xF7FF)  /*!< USART WakeUp Method Mask */[m
[32m+[m
[32m+[m[32m#define CR1_RWU_Set               ((uint16_t)0x0002)  /*!< USART mute mode Enable Mask */[m
[32m+[m[32m#define CR1_RWU_Reset             ((uint16_t)0xFFFD)  /*!< USART mute mode Enable Mask */[m
[32m+[m[32m#define CR1_SBK_Set               ((uint16_t)0x0001)  /*!< USART Break Character send Mask */[m
[32m+[m[32m#define CR1_CLEAR_Mask            ((uint16_t)0xE9F3)  /*!< USART CR1 Mask */[m
[32m+[m[32m#define CR2_Address_Mask          ((uint16_t)0xFFF0)  /*!< USART address Mask */[m
[32m+[m
[32m+[m[32m#define CR2_LINEN_Set              ((uint16_t)0x4000)  /*!< USART LIN Enable Mask */[m
[32m+[m[32m#define CR2_LINEN_Reset            ((uint16_t)0xBFFF)  /*!< USART LIN Disable Mask */[m
[32m+[m
[32m+[m[32m#define CR2_LBDL_Mask             ((uint16_t)0xFFDF)  /*!< USART LIN Break detection Mask */[m
[32m+[m[32m#define CR2_STOP_CLEAR_Mask       ((uint16_t)0xCFFF)  /*!< USART CR2 STOP Bits Mask */[m
[32m+[m[32m#define CR2_CLOCK_CLEAR_Mask      ((uint16_t)0xF0FF)  /*!< USART CR2 Clock Mask */[m
[32m+[m
[32m+[m[32m#define CR3_SCEN_Set              ((uint16_t)0x0020)  /*!< USART SC Enable Mask */[m
[32m+[m[32m#define CR3_SCEN_Reset            ((uint16_t)0xFFDF)  /*!< USART SC Disable Mask */[m
[32m+[m
[32m+[m[32m#define CR3_NACK_Set              ((uint16_t)0x0010)  /*!< USART SC NACK Enable Mask */[m
[32m+[m[32m#define CR3_NACK_Reset            ((uint16_t)0xFFEF)  /*!< USART SC NACK Disable Mask */[m
[32m+[m
[32m+[m[32m#define CR3_HDSEL_Set             ((uint16_t)0x0008)  /*!< USART Half-Duplex Enable Mask */[m
[32m+[m[32m#define CR3_HDSEL_Reset           ((uint16_t)0xFFF7)  /*!< USART Half-Duplex Disable Mask */[m
[32m+[m
[32m+[m[32m#define CR3_IRLP_Mask             ((uint16_t)0xFFFB)  /*!< USART IrDA LowPower mode Mask */[m
[32m+[m[32m#define CR3_CLEAR_Mask            ((uint16_t)0xFCFF)  /*!< USART CR3 Mask */[m
[32m+[m
[32m+[m[32m#define CR3_IREN_Set              ((uint16_t)0x0002)  /*!< USART IrDA Enable Mask */[m
[32m+[m[32m#define CR3_IREN_Reset            ((uint16_t)0xFFFD)  /*!< USART IrDA Disable Mask */[m
[32m+[m[32m#define GTPR_LSB_Mask             ((uint16_t)0x00FF)  /*!< Guard Time Register LSB Mask */[m
[32m+[m[32m#define GTPR_MSB_Mask             ((uint16_t)0xFF00)  /*!< Guard Time Register MSB Mask */[m
[32m+[m[32m#define IT_Mask                   ((uint16_t)0x001F)  /*!< USART Interrupt Mask */[m
[32m+[m
[32m+[m[32m/* USART OverSampling-8 Mask */[m
[32m+[m[32m#define CR1_OVER8_Set             ((u16)0x8000)  /* USART OVER8 mode Enable Mask */[m
[32m+[m[32m#define CR1_OVER8_Reset           ((u16)0x7FFF)  /* USART OVER8 mode Disable Mask */[m
[32m+[m
[32m+[m[32m/* USART One Bit Sampling Mask */[m
[32m+[m[32m#define CR3_ONEBITE_Set           ((u16)0x0800)  /* USART ONEBITE mode Enable Mask */[m
[32m+[m[32m#define CR3_ONEBITE_Reset         ((u16)0xF7FF)  /* USART ONEBITE mode Disable Mask */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup USART_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the USARTx peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m[41m [m
[32m+[m[32m  *      USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_DeInit(USART_TypeDef* USARTx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m
[32m+[m[32m  if (USARTx == USART1)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);[m
[32m+[m[32m    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (USARTx == USART2)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (USARTx == USART3)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  else if (USARTx == UART4)[m
[32m+[m[32m  {[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);[m
[32m+[m[32m    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);[m
[32m+[m[32m  }[m[41m    [m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    if (USARTx == UART5)[m
[32m+[m[32m    {[m[41m [m
[32m+[m[32m      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);[m
[32m+[m[32m      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);[m
[32m+[m[32m    }[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the USARTx peripheral according to the specified[m
[32m+[m[32m  *         parameters in the USART_InitStruct .[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure[m
[32m+[m[32m  *         that contains the configuration information for the specified USART[m[41m [m
[32m+[m[32m  *         peripheral.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0x00, apbclock = 0x00;[m
[32m+[m[32m  uint32_t integerdivider = 0x00;[m
[32m+[m[32m  uint32_t fractionaldivider = 0x00;[m
[32m+[m[32m  uint32_t usartxbase = 0;[m
[32m+[m[32m  RCC_ClocksTypeDef RCC_ClocksStatus;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));[m[41m  [m
[32m+[m[32m  assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));[m
[32m+[m[32m  assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));[m
[32m+[m[32m  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));[m
[32m+[m[32m  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));[m
[32m+[m[32m  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));[m
[32m+[m[32m  /* The hardware flow control is available only for USART1, USART2 and USART3 */[m
[32m+[m[32m  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  }[m
[32m+[m
[32m+[m[32m  usartxbase = (uint32_t)USARTx;[m
[32m+[m
[32m+[m[32m/*---------------------------- USART CR2 Configuration -----------------------*/[m
[32m+[m[32m  tmpreg = USARTx->CR2;[m
[32m+[m[32m  /* Clear STOP[13:12] bits */[m
[32m+[m[32m  tmpreg &= CR2_STOP_CLEAR_Mask;[m
[32m+[m[32m  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/[m
[32m+[m[32m  /* Set STOP[13:12] bits according to USART_StopBits value */[m
[32m+[m[32m  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to USART CR2 */[m
[32m+[m[32m  USARTx->CR2 = (uint16_t)tmpreg;[m
[32m+[m
[32m+[m[32m/*---------------------------- USART CR1 Configuration -----------------------*/[m
[32m+[m[32m  tmpreg = USARTx->CR1;[m
[32m+[m[32m  /* Clear M, PCE, PS, TE and RE bits */[m
[32m+[m[32m  tmpreg &= CR1_CLEAR_Mask;[m
[32m+[m[32m  /* Configure the USART Word Length, Parity and mode ----------------------- */[m
[32m+[m[32m  /* Set the M bits according to USART_WordLength value */[m
[32m+[m[32m  /* Set PCE and PS bits according to USART_Parity value */[m
[32m+[m[32m  /* Set TE and RE bits according to USART_Mode value */[m
[32m+[m[32m  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |[m
[32m+[m[32m            USART_InitStruct->USART_Mode;[m
[32m+[m[32m  /* Write to USART CR1 */[m
[32m+[m[32m  USARTx->CR1 = (uint16_t)tmpreg;[m
[32m+[m
[32m+[m[32m/*---------------------------- USART CR3 Configuration -----------------------*/[m[41m  [m
[32m+[m[32m  tmpreg = USARTx->CR3;[m
[32m+[m[32m  /* Clear CTSE and RTSE bits */[m
[32m+[m[32m  tmpreg &= CR3_CLEAR_Mask;[m
[32m+[m[32m  /* Configure the USART HFC -------------------------------------------------*/[m
[32m+[m[32m  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */[m
[32m+[m[32m  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;[m
[32m+[m[32m  /* Write to USART CR3 */[m
[32m+[m[32m  USARTx->CR3 = (uint16_t)tmpreg;[m
[32m+[m
[32m+[m[32m/*---------------------------- USART BRR Configuration -----------------------*/[m
[32m+[m[32m  /* Configure the USART Baud Rate -------------------------------------------*/[m
[32m+[m[32m  RCC_GetClocksFreq(&RCC_ClocksStatus);[m
[32m+[m[32m  if (usartxbase == USART1_BASE)[m
[32m+[m[32m  {[m
[32m+[m[32m    apbclock = RCC_ClocksStatus.PCLK2_Frequency;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    apbclock = RCC_ClocksStatus.PCLK1_Frequency;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Determine the integer part */[m
[32m+[m[32m  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Integer part computing in case Oversampling mode is 8 Samples */[m
[32m+[m[32m    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));[m[41m    [m
[32m+[m[32m  }[m
[32m+[m[32m  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Integer part computing in case Oversampling mode is 16 Samples */[m
[32m+[m[32m    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));[m[41m    [m
[32m+[m[32m  }[m
[32m+[m[32m  tmpreg = (integerdivider / 100) << 4;[m
[32m+[m
[32m+[m[32m  /* Determine the fractional part */[m
[32m+[m[32m  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));[m
[32m+[m
[32m+[m[32m  /* Implement the fractional part in the register */[m
[32m+[m[32m  if ((USARTx->CR1 & CR1_OVER8_Set) != 0)[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */[m
[32m+[m[32m  {[m
[32m+[m[32m    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  /* Write to USART BRR */[m
[32m+[m[32m  USARTx->BRR = (uint16_t)tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each USART_InitStruct member with its default value.[m
[32m+[m[32m  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure[m
[32m+[m[32m  *         which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* USART_InitStruct members default value */[m
[32m+[m[32m  USART_InitStruct->USART_BaudRate = 9600;[m
[32m+[m[32m  USART_InitStruct->USART_WordLength = USART_WordLength_8b;[m
[32m+[m[32m  USART_InitStruct->USART_StopBits = USART_StopBits_1;[m
[32m+[m[32m  USART_InitStruct->USART_Parity = USART_Parity_No ;[m
[32m+[m[32m  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;[m
[32m+[m[32m  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Initializes the USARTx peripheral Clock according to the[m[41m [m
[32m+[m[32m  *          specified parameters in the USART_ClockInitStruct .[m
[32m+[m[32m  * @param  USARTx: where x can be 1, 2, 3 to select the USART peripheral.[m
[32m+[m[32m  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef[m
[32m+[m[32m  *         structure that contains the configuration information for the specified[m[41m [m
[32m+[m[32m  *         USART peripheral.[m[41m  [m
[32m+[m[32m  * @note The Smart Card and Synchronous modes are not available for UART4 and UART5.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));[m
[32m+[m[32m  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));[m
[32m+[m[32m  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));[m
[32m+[m[32m  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));[m
[32m+[m[41m  [m
[32m+[m[32m/*---------------------------- USART CR2 Configuration -----------------------*/[m
[32m+[m[32m  tmpreg = USARTx->CR2;[m
[32m+[m[32m  /* Clear CLKEN, CPOL, CPHA and LBCL bits */[m
[32m+[m[32m  tmpreg &= CR2_CLOCK_CLEAR_Mask;[m
[32m+[m[32m  /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/[m
[32m+[m[32m  /* Set CLKEN bit according to USART_Clock value */[m
[32m+[m[32m  /* Set CPOL bit according to USART_CPOL value */[m
[32m+[m[32m  /* Set CPHA bit according to USART_CPHA value */[m
[32m+[m[32m  /* Set LBCL bit according to USART_LastBit value */[m
[32m+[m[32m  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL |[m[41m [m
[32m+[m[32m                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;[m
[32m+[m[32m  /* Write to USART CR2 */[m
[32m+[m[32m  USARTx->CR2 = (uint16_t)tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Fills each USART_ClockInitStruct member with its default value.[m
[32m+[m[32m  * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef[m
[32m+[m[32m  *         structure which will be initialized.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)[m
[32m+[m[32m{[m
[32m+[m[32m  /* USART_ClockInitStruct members default value */[m
[32m+[m[32m  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;[m
[32m+[m[32m  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;[m
[32m+[m[32m  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;[m
[32m+[m[32m  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified USART peripheral.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *         This parameter can be one of the following values:[m
[32m+[m[32m  *           USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the USARTx peripheral.[m
[32m+[m[32m  *         This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the selected USART by setting the UE bit in the CR1 register */[m
[32m+[m[32m    USARTx->CR1 |= CR1_UE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the selected USART by clearing the UE bit in the CR1 register */[m
[32m+[m[32m    USARTx->CR1 &= CR1_UE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the specified USART interrupts.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)[m
[32m+[m[32m  *     @arg USART_IT_LBD:  LIN Break detection interrupt[m
[32m+[m[32m  *     @arg USART_IT_TXE:  Transmit Data Register empty interrupt[m
[32m+[m[32m  *     @arg USART_IT_TC:   Transmission complete interrupt[m
[32m+[m[32m  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt[m
[32m+[m[32m  *     @arg USART_IT_IDLE: Idle line detection interrupt[m
[32m+[m[32m  *     @arg USART_IT_PE:   Parity Error interrupt[m
[32m+[m[32m  *     @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)[m
[32m+[m[32m  * @param  NewState: new state of the specified USARTx interrupts.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;[m
[32m+[m[32m  uint32_t usartxbase = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_CONFIG_IT(USART_IT));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  /* The CTS interrupt is not available for UART4 and UART5 */[m
[32m+[m[32m  if (USART_IT == USART_IT_CTS)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  }[m[41m   [m
[32m+[m[41m  [m
[32m+[m[32m  usartxbase = (uint32_t)USARTx;[m
[32m+[m
[32m+[m[32m  /* Get the USART register index */[m
[32m+[m[32m  usartreg = (((uint8_t)USART_IT) >> 0x05);[m
[32m+[m
[32m+[m[32m  /* Get the interrupt position */[m
[32m+[m[32m  itpos = USART_IT & IT_Mask;[m
[32m+[m[32m  itmask = (((uint32_t)0x01) << itpos);[m
[32m+[m[41m    [m
[32m+[m[32m  if (usartreg == 0x01) /* The IT is in CR1 register */[m
[32m+[m[32m  {[m
[32m+[m[32m    usartxbase += 0x0C;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (usartreg == 0x02) /* The IT is in CR2 register */[m
[32m+[m[32m  {[m
[32m+[m[32m    usartxbase += 0x10;[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* The IT is in CR3 register */[m
[32m+[m[32m  {[m
[32m+[m[32m    usartxbase += 0x14;[m[41m [m
[32m+[m[32m  }[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    *(__IO uint32_t*)usartxbase  |= itmask;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    *(__IO uint32_t*)usartxbase &= ~itmask;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USARTís DMA interface.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_DMAReq: specifies the DMA request.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg USART_DMAReq_Tx: USART DMA transmit request[m
[32m+[m[32m  *     @arg USART_DMAReq_Rx: USART DMA receive request[m
[32m+[m[32m  * @param  NewState: new state of the DMA Request sources.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @note The DMA mode is not available for UART5 except in the STM32[m
[32m+[m[32m  *       High density value line devices(STM32F10X_HD_VL).[m[41m  [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_DMAREQ(USART_DMAReq));[m[41m  [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m[41m [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the DMA transfer for selected requests by setting the DMAT and/or[m
[32m+[m[32m       DMAR bits in the USART CR3 register */[m
[32m+[m[32m    USARTx->CR3 |= USART_DMAReq;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or[m
[32m+[m[32m       DMAR bits in the USART CR3 register */[m
[32m+[m[32m    USARTx->CR3 &= (uint16_t)~USART_DMAReq;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the address of the USART node.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_Address: Indicates the address of the USART node.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_ADDRESS(USART_Address));[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m  /* Clear the USART address */[m
[32m+[m[32m  USARTx->CR2 &= CR2_Address_Mask;[m
[32m+[m[32m  /* Set the USART address node */[m
[32m+[m[32m  USARTx->CR2 |= USART_Address;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Selects the USART WakeUp method.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_WakeUp: specifies the USART wakeup method.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection[m
[32m+[m[32m  *     @arg USART_WakeUp_AddressMark: WakeUp by an address mark[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_WAKEUP(USART_WakeUp));[m
[32m+[m[41m  [m
[32m+[m[32m  USARTx->CR1 &= CR1_WAKE_Mask;[m
[32m+[m[32m  USARTx->CR1 |= USART_WakeUp;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Determines if the USART is in mute mode or not.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the USART mute mode.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */[m
[32m+[m[32m    USARTx->CR1 |= CR1_RWU_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */[m
[32m+[m[32m    USARTx->CR1 &= CR1_RWU_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the USART LIN Break detection length.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_LINBreakDetectLength_10b: 10-bit break detection[m
[32m+[m[32m  *     @arg USART_LINBreakDetectLength_11b: 11-bit break detection[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));[m
[32m+[m[41m  [m
[32m+[m[32m  USARTx->CR2 &= CR2_LBDL_Mask;[m
[32m+[m[32m  USARTx->CR2 |= USART_LINBreakDetectLength;[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USARTís LIN mode.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the USART LIN mode.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */[m
[32m+[m[32m    USARTx->CR2 |= CR2_LINEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */[m
[32m+[m[32m    USARTx->CR2 &= CR2_LINEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmits single data through the USARTx peripheral.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  Data: the data to transmit.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_DATA(Data));[m[41m [m
[32m+[m[41m    [m
[32m+[m[32m  /* Transmit Data */[m
[32m+[m[32m  USARTx->DR = (Data & (uint16_t)0x01FF);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Returns the most recent received data by the USARTx peripheral.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @retval The received data.[m
[32m+[m[32m  */[m
[32m+[m[32muint16_t USART_ReceiveData(USART_TypeDef* USARTx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Receive Data */[m
[32m+[m[32m  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Transmits break characters.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SendBreak(USART_TypeDef* USARTx)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Send break characters */[m
[32m+[m[32m  USARTx->CR1 |= CR1_SBK_Set;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the specified USART guard time.[m
[32m+[m[32m  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.[m
[32m+[m[32m  * @param  USART_GuardTime: specifies the guard time.[m
[32m+[m[32m  * @note The guard time bits are not available for UART4 and UART5.[m[41m   [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)[m
[32m+[m[32m{[m[41m    [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear the USART Guard time */[m
[32m+[m[32m  USARTx->GTPR &= GTPR_LSB_Mask;[m
[32m+[m[32m  /* Set the USART guard time */[m
[32m+[m[32m  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the system clock prescaler.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_Prescaler: specifies the prescaler clock.[m[41m  [m
[32m+[m[32m  * @note   The function is used for IrDA mode with UART4 and UART5.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)[m
[32m+[m[32m{[m[41m [m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[41m  [m
[32m+[m[32m  /* Clear the USART prescaler */[m
[32m+[m[32m  USARTx->GTPR &= GTPR_MSB_Mask;[m
[32m+[m[32m  /* Set the USART prescaler */[m
[32m+[m[32m  USARTx->GTPR |= USART_Prescaler;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USARTís Smart Card mode.[m
[32m+[m[32m  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.[m
[32m+[m[32m  * @param  NewState: new state of the Smart Card mode.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m[41m     [m
[32m+[m[32m  * @note The Smart Card mode is not available for UART4 and UART5.[m[41m [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the SC mode by setting the SCEN bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 |= CR3_SCEN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 &= CR3_SCEN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables NACK transmission.[m
[32m+[m[32m  * @param  USARTx: where x can be 1, 2 or 3 to select the USART peripheral.[m[41m [m
[32m+[m[32m  * @param  NewState: new state of the NACK transmission.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m[41m  [m
[32m+[m[32m  * @note The Smart Card mode is not available for UART4 and UART5.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_123_PERIPH(USARTx));[m[41m  [m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 |= CR3_NACK_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 &= CR3_NACK_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USARTís Half Duplex communication.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the USART Communication.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 |= CR3_HDSEL_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 &= CR3_HDSEL_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USART's 8x oversampling mode.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the USART one bit sampling method.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @note[m
[32m+[m[32m  *     This function has to be called before calling USART_Init()[m
[32m+[m[32m  *     function in order to have correct baudrate Divider value.[m[41m   [m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */[m
[32m+[m[32m    USARTx->CR1 |= CR1_OVER8_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */[m
[32m+[m[32m    USARTx->CR1 &= CR1_OVER8_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USART's one bit sampling method.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the USART one bit sampling method.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m  [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 |= CR3_ONEBITE_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 &= CR3_ONEBITE_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Configures the USART's IrDA interface.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_IrDAMode: specifies the IrDA mode.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_IrDAMode_LowPower[m
[32m+[m[32m  *     @arg USART_IrDAMode_Normal[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));[m
[32m+[m[41m    [m
[32m+[m[32m  USARTx->CR3 &= CR3_IRLP_Mask;[m
[32m+[m[32m  USARTx->CR3 |= USART_IrDAMode;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables or disables the USART's IrDA interface.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  NewState: new state of the IrDA mode.[m
[32m+[m[32m  *   This parameter can be: ENABLE or DISABLE.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_FUNCTIONAL_STATE(NewState));[m
[32m+[m[41m    [m
[32m+[m[32m  if (NewState != DISABLE)[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 |= CR3_IREN_Set;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */[m
[32m+[m[32m    USARTx->CR3 &= CR3_IREN_Reset;[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified USART flag is set or not.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_FLAG: specifies the flag to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)[m
[32m+[m[32m  *     @arg USART_FLAG_LBD:  LIN Break detection flag[m
[32m+[m[32m  *     @arg USART_FLAG_TXE:  Transmit data register empty flag[m
[32m+[m[32m  *     @arg USART_FLAG_TC:   Transmission Complete flag[m
[32m+[m[32m  *     @arg USART_FLAG_RXNE: Receive data register not empty flag[m
[32m+[m[32m  *     @arg USART_FLAG_IDLE: Idle Line detection flag[m
[32m+[m[32m  *     @arg USART_FLAG_ORE:  OverRun Error flag[m
[32m+[m[32m  *     @arg USART_FLAG_NE:   Noise Error flag[m
[32m+[m[32m  *     @arg USART_FLAG_FE:   Framing Error flag[m
[32m+[m[32m  *     @arg USART_FLAG_PE:   Parity Error flag[m
[32m+[m[32m  * @retval The new state of USART_FLAG (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  FlagStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_FLAG(USART_FLAG));[m
[32m+[m[32m  /* The CTS flag is not available for UART4 and UART5 */[m
[32m+[m[32m  if (USART_FLAG == USART_FLAG_CTS)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  }[m[41m  [m
[32m+[m[41m  [m
[32m+[m[32m  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[32m  return bitstatus;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the USARTx's pending flags.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_FLAG: specifies the flag to clear.[m
[32m+[m[32m  *   This parameter can be any combination of the following values:[m
[32m+[m[32m  *     @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).[m
[32m+[m[32m  *     @arg USART_FLAG_LBD:  LIN Break detection flag.[m
[32m+[m[32m  *     @arg USART_FLAG_TC:   Transmission Complete flag.[m
[32m+[m[32m  *     @arg USART_FLAG_RXNE: Receive data register not empty flag.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun[m[41m [m
[32m+[m[32m  *     error) and IDLE (Idle line detected) flags are cleared by software[m[41m [m
[32m+[m[32m  *     sequence: a read operation to USART_SR register (USART_GetFlagStatus())[m[41m [m
[32m+[m[32m  *     followed by a read operation to USART_DR register (USART_ReceiveData()).[m
[32m+[m[32m  *   - RXNE flag can be also cleared by a read to the USART_DR register[m[41m [m
[32m+[m[32m  *     (USART_ReceiveData()).[m
[32m+[m[32m  *   - TC flag can be also cleared by software sequence: a read operation to[m[41m [m
[32m+[m[32m  *     USART_SR register (USART_GetFlagStatus()) followed by a write operation[m
[32m+[m[32m  *     to USART_DR register (USART_SendData()).[m
[32m+[m[32m  *   - TXE flag is cleared only by a write to the USART_DR register[m[41m [m
[32m+[m[32m  *     (USART_SendData()).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));[m
[32m+[m[32m  /* The CTS flag is not available for UART4 and UART5 */[m
[32m+[m[32m  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  }[m[41m [m
[32m+[m[41m   [m
[32m+[m[32m  USARTx->SR = (uint16_t)~USART_FLAG;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the specified USART interrupt has occurred or not.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_IT: specifies the USART interrupt source to check.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)[m
[32m+[m[32m  *     @arg USART_IT_LBD:  LIN Break detection interrupt[m
[32m+[m[32m  *     @arg USART_IT_TXE:  Tansmit Data Register empty interrupt[m
[32m+[m[32m  *     @arg USART_IT_TC:   Transmission complete interrupt[m
[32m+[m[32m  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt[m
[32m+[m[32m  *     @arg USART_IT_IDLE: Idle line detection interrupt[m
[32m+[m[32m  *     @arg USART_IT_ORE:  OverRun Error interrupt[m
[32m+[m[32m  *     @arg USART_IT_NE:   Noise Error interrupt[m
[32m+[m[32m  *     @arg USART_IT_FE:   Framing Error interrupt[m
[32m+[m[32m  *     @arg USART_IT_PE:   Parity Error interrupt[m
[32m+[m[32m  * @retval The new state of USART_IT (SET or RESET).[m
[32m+[m[32m  */[m
[32m+[m[32mITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;[m
[32m+[m[32m  ITStatus bitstatus = RESET;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_GET_IT(USART_IT));[m
[32m+[m[32m  /* The CTS interrupt is not available for UART4 and UART5 */[m[41m [m
[32m+[m[32m  if (USART_IT == USART_IT_CTS)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  }[m[41m   [m
[32m+[m[41m  [m
[32m+[m[32m  /* Get the USART register index */[m
[32m+[m[32m  usartreg = (((uint8_t)USART_IT) >> 0x05);[m
[32m+[m[32m  /* Get the interrupt position */[m
[32m+[m[32m  itmask = USART_IT & IT_Mask;[m
[32m+[m[32m  itmask = (uint32_t)0x01 << itmask;[m
[32m+[m[41m  [m
[32m+[m[32m  if (usartreg == 0x01) /* The IT  is in CR1 register */[m
[32m+[m[32m  {[m
[32m+[m[32m    itmask &= USARTx->CR1;[m
[32m+[m[32m  }[m
[32m+[m[32m  else if (usartreg == 0x02) /* The IT  is in CR2 register */[m
[32m+[m[32m  {[m
[32m+[m[32m    itmask &= USARTx->CR2;[m
[32m+[m[32m  }[m
[32m+[m[32m  else /* The IT  is in CR3 register */[m
[32m+[m[32m  {[m
[32m+[m[32m    itmask &= USARTx->CR3;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  bitpos = USART_IT >> 0x08;[m
[32m+[m[32m  bitpos = (uint32_t)0x01 << bitpos;[m
[32m+[m[32m  bitpos &= USARTx->SR;[m
[32m+[m[32m  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = SET;[m
[32m+[m[32m  }[m
[32m+[m[32m  else[m
[32m+[m[32m  {[m
[32m+[m[32m    bitstatus = RESET;[m
[32m+[m[32m  }[m
[32m+[m[41m  [m
[32m+[m[32m  return bitstatus;[m[41m  [m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears the USARTx's interrupt pending bits.[m
[32m+[m[32m  * @param  USARTx: Select the USART or the UART peripheral.[m[41m [m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *   USART1, USART2, USART3, UART4 or UART5.[m
[32m+[m[32m  * @param  USART_IT: specifies the interrupt pending bit to clear.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)[m
[32m+[m[32m  *     @arg USART_IT_LBD:  LIN Break detection interrupt[m
[32m+[m[32m  *     @arg USART_IT_TC:   Transmission complete interrupt.[m[41m [m
[32m+[m[32m  *     @arg USART_IT_RXNE: Receive Data register not empty interrupt.[m
[32m+[m[32m  *[m[41m   [m
[32m+[m[32m  * @note[m
[32m+[m[32m  *   - PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun[m[41m [m
[32m+[m[32m  *     error) and IDLE (Idle line detected) pending bits are cleared by[m[41m [m
[32m+[m[32m  *     software sequence: a read operation to USART_SR register[m[41m [m
[32m+[m[32m  *     (USART_GetITStatus()) followed by a read operation to USART_DR register[m[41m [m
[32m+[m[32m  *     (USART_ReceiveData()).[m
[32m+[m[32m  *   - RXNE pending bit can be also cleared by a read to the USART_DR register[m[41m [m
[32m+[m[32m  *     (USART_ReceiveData()).[m
[32m+[m[32m  *   - TC pending bit can be also cleared by software sequence: a read[m[41m [m
[32m+[m[32m  *     operation to USART_SR register (USART_GetITStatus()) followed by a write[m[41m [m
[32m+[m[32m  *     operation to USART_DR register (USART_SendData()).[m
[32m+[m[32m  *   - TXE pending bit is cleared only by a write to the USART_DR register[m[41m [m
[32m+[m[32m  *     (USART_SendData()).[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)[m
[32m+[m[32m{[m
[32m+[m[32m  uint16_t bitpos = 0x00, itmask = 0x00;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_USART_ALL_PERIPH(USARTx));[m
[32m+[m[32m  assert_param(IS_USART_CLEAR_IT(USART_IT));[m
[32m+[m[32m  /* The CTS interrupt is not available for UART4 and UART5 */[m
[32m+[m[32m  if (USART_IT == USART_IT_CTS)[m
[32m+[m[32m  {[m
[32m+[m[32m    assert_param(IS_USART_123_PERIPH(USARTx));[m
[32m+[m[32m  }[m[41m   [m
[32m+[m[41m  [m
[32m+[m[32m  bitpos = USART_IT >> 0x08;[m
[32m+[m[32m  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);[m
[32m+[m[32m  USARTx->SR = (uint16_t)~itmask;[m
[32m+[m[32m}[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c[m
[1mnew file mode 100644[m
[1mindex 0000000..4a901e4[m
[1m--- /dev/null[m
[1m+++ b/Libraries/STM32F10x_StdPeriph_Driver/src/stm32f10x_wwdg.c[m
[36m@@ -0,0 +1,224 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x_wwdg.c[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   This file provides all the WWDG firmware functions.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_wwdg.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Driver[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG[m[41m [m
[32m+[m[32m  * @brief WWDG driver modules[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Private_TypesDefinitions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Private_Defines[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* ----------- WWDG registers bit address in the alias region ----------- */[m
[32m+[m[32m#define WWDG_OFFSET       (WWDG_BASE - PERIPH_BASE)[m
[32m+[m
[32m+[m[32m/* Alias word address of EWI bit */[m
[32m+[m[32m#define CFR_OFFSET        (WWDG_OFFSET + 0x04)[m
[32m+[m[32m#define EWI_BitNumber     0x09[m
[32m+[m[32m#define CFR_EWI_BB        (PERIPH_BB_BASE + (CFR_OFFSET * 32) + (EWI_BitNumber * 4))[m
[32m+[m
[32m+[m[32m/* --------------------- WWDG registers bit mask ------------------------ */[m
[32m+[m
[32m+[m[32m/* CR register bit mask */[m
[32m+[m[32m#define CR_WDGA_Set       ((uint32_t)0x00000080)[m
[32m+[m
[32m+[m[32m/* CFR register bit mask */[m
[32m+[m[32m#define CFR_WDGTB_Mask    ((uint32_t)0xFFFFFE7F)[m
[32m+[m[32m#define CFR_W_Mask        ((uint32_t)0xFFFFFF80)[m
[32m+[m[32m#define BIT_Mask          ((uint8_t)0x7F)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Private_Macros[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Private_Variables[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Private_FunctionPrototypes[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @defgroup WWDG_Private_Functions[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Deinitializes the WWDG peripheral registers to their default reset values.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_DeInit(void)[m
[32m+[m[32m{[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, ENABLE);[m
[32m+[m[32m  RCC_APB1PeriphResetCmd(RCC_APB1Periph_WWDG, DISABLE);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the WWDG Prescaler.[m
[32m+[m[32m  * @param  WWDG_Prescaler: specifies the WWDG Prescaler.[m
[32m+[m[32m  *   This parameter can be one of the following values:[m
[32m+[m[32m  *     @arg WWDG_Prescaler_1: WWDG counter clock = (PCLK1/4096)/1[m
[32m+[m[32m  *     @arg WWDG_Prescaler_2: WWDG counter clock = (PCLK1/4096)/2[m
[32m+[m[32m  *     @arg WWDG_Prescaler_4: WWDG counter clock = (PCLK1/4096)/4[m
[32m+[m[32m  *     @arg WWDG_Prescaler_8: WWDG counter clock = (PCLK1/4096)/8[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_SetPrescaler(uint32_t WWDG_Prescaler)[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t tmpreg = 0;[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_WWDG_PRESCALER(WWDG_Prescaler));[m
[32m+[m[32m  /* Clear WDGTB[1:0] bits */[m
[32m+[m[32m  tmpreg = WWDG->CFR & CFR_WDGTB_Mask;[m
[32m+[m[32m  /* Set WDGTB[1:0] bits according to WWDG_Prescaler value */[m
[32m+[m[32m  tmpreg |= WWDG_Prescaler;[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  WWDG->CFR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the WWDG window value.[m
[32m+[m[32m  * @param  WindowValue: specifies the window value to be compared to the downcounter.[m
[32m+[m[32m  *   This parameter value must be lower than 0x80.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_SetWindowValue(uint8_t WindowValue)[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t tmpreg = 0;[m
[32m+[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_WWDG_WINDOW_VALUE(WindowValue));[m
[32m+[m[32m  /* Clear W[6:0] bits */[m
[32m+[m
[32m+[m[32m  tmpreg = WWDG->CFR & CFR_W_Mask;[m
[32m+[m
[32m+[m[32m  /* Set W[6:0] bits according to WindowValue value */[m
[32m+[m[32m  tmpreg |= WindowValue & (uint32_t) BIT_Mask;[m
[32m+[m
[32m+[m[32m  /* Store the new value */[m
[32m+[m[32m  WWDG->CFR = tmpreg;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables the WWDG Early Wakeup interrupt(EWI).[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_EnableIT(void)[m
[32m+[m[32m{[m
[32m+[m[32m  *(__IO uint32_t *) CFR_EWI_BB = (uint32_t)ENABLE;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Sets the WWDG counter value.[m
[32m+[m[32m  * @param  Counter: specifies the watchdog counter value.[m
[32m+[m[32m  *   This parameter must be a number between 0x40 and 0x7F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_SetCounter(uint8_t Counter)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_WWDG_COUNTER(Counter));[m
[32m+[m[32m  /* Write to T[6:0] bits to configure the counter value, no need to do[m
[32m+[m[32m     a read-modify-write; writing a 0 to WDGA bit does nothing */[m
[32m+[m[32m  WWDG->CR = Counter & BIT_Mask;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Enables WWDG and load the counter value.[m[41m                  [m
[32m+[m[32m  * @param  Counter: specifies the watchdog counter value.[m
[32m+[m[32m  *   This parameter must be a number between 0x40 and 0x7F.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_Enable(uint8_t Counter)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Check the parameters */[m
[32m+[m[32m  assert_param(IS_WWDG_COUNTER(Counter));[m
[32m+[m[32m  WWDG->CR = CR_WDGA_Set | Counter;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Checks whether the Early Wakeup interrupt flag is set or not.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval The new state of the Early Wakeup interrupt flag (SET or RESET)[m
[32m+[m[32m  */[m
[32m+[m[32mFlagStatus WWDG_GetFlagStatus(void)[m
[32m+[m[32m{[m
[32m+[m[32m  return (FlagStatus)(WWDG->SR);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  Clears Early Wakeup interrupt flag.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid WWDG_ClearFlag(void)[m
[32m+[m[32m{[m
[32m+[m[32m  WWDG->SR = (uint32_t)RESET;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/Obj/Template.hex b/Obj/Template.hex[m
[1mnew file mode 100644[m
[1mindex 0000000..a04ceda[m
[1m--- /dev/null[m
[1m+++ b/Obj/Template.hex[m
[36m@@ -0,0 +1,81 @@[m
[32m+[m[32m:020000040800F2[m
[32m+[m[32m:10000000000400204501000801030008C3020008A5[m
[32m+[m[32m:10001000FD0200088D0100087504000800000000C2[m
[32m+[m[32m:1000200000000000000000000000000025030008A0[m
[32m+[m[32m:1000300091010008000000000303000811040008FB[m
[32m+[m[32m:100040005F0100085F0100085F0100085F01000810[m
[32m+[m[32m:100050005F0100085F0100085F0100085F01000800[m
[32m+[m[32m:100060005F0100085F0100085F0100085F010008F0[m
[32m+[m[32m:100070005F0100085F0100085F0100085F010008E0[m
[32m+[m[32m:100080005F0100085F0100085F0100085F010008D0[m
[32m+[m[32m:100090005F0100085F0100085F0100085F010008C0[m
[32m+[m[32m:1000A0005F0100085F0100085F0100085F010008B0[m
[32m+[m[32m:1000B0005F0100085F0100085F0100085F010008A0[m
[32m+[m[32m:1000C0005F0100085F0100085F0100085F01000890[m
[32m+[m[32m:1000D0005F0100085F0100085F0100085F01000880[m
[32m+[m[32m:1000E0005F0100085F0100085F0100085F01000870[m
[32m+[m[32m:1000F0005F0100085F0100085F0100085F01000860[m
[32m+[m[32m:100100005F0100085F0100085F0100085F0100084F[m
[32m+[m[32m:100110005F0100085F0100085F0100085F0100083F[m
[32m+[m[32m:100120005F0100085F0100085F0100085F0100082F[m
[32m+[m[32m:10013000DFF80CD000F018F80048004799040008D8[m
[32m+[m[32m:10014000000400200648804706480047FEE7FEE717[m
[32m+[m[32m:10015000FEE7FEE7FEE7FEE7FEE7FEE7FEE7FEE777[m
[32m+[m[32m:100160001504000831010008064C074D06E0E06860[m
[32m+[m[32m:1001700040F0010394E8070098471034AC42F6D3EE[m
[32m+[m[32m:10018000FFF7DAFFC4040008D404000800BFFEE74C[m
[32m+[m[32m:10019000704741F21841484300BF0100A0F101003F[m
[32m+[m[32m:1001A000FBD170472DE9F0410246002500260020D2[m
[32m+[m[32m:1001B00000230024002791F803C00CF00F0591F8EC[m
[32m+[m[32m:1001C00003C00CF0100CBCF1000F03D091F802C07A[m
[32m+[m[32m:1001D0004CEA050591F800C0BCF1000F31D014685D[m
[32m+[m[32m:1001E00000202BE04FF0010C0CFA00F3B1F800C036[m
[32m+[m[32m:1001F0000CEA03069E4220D183004FF00F0C0CFA4C[m
[32m+[m[32m:1002000003F7BC4305FA03FC4CEA040491F803C06D[m
[32m+[m[32m:10021000BCF1280F06D14FF0010C0CFA00FCC2F81B[m
[32m+[m[32m:1002200014C00AE091F803C0BCF1480F05D14FF0AB[m
[32m+[m[32m:10023000010C0CFA00FCC2F810C0401C0828D1D3F5[m
[32m+[m[32m:100240001460B1F800C0BCF1FF0F34DD5468002029[m
[32m+[m[32m:100250002EE000F1080C4FF0010808FA0CF3B1F899[m
[32m+[m[32m:1002600000C00CEA03069E4221D183004FF00F0C20[m
[32m+[m[32m:100270000CFA03F7BC4305FA03FC4CEA040491F8BA[m
[32m+[m[32m:1002800003C0BCF1280F05D100F1080C08FA0CF8E6[m
[32m+[m[32m:10029000C2F8148091F803C0BCF1480F07D100F1F7[m
[32m+[m[32m:1002A000080C4FF0010808FA0CF8C2F81080401C46[m
[32m+[m[32m:1002B0000828CED35460BDE8F081416170470161E8[m
[32m+[m[32m:1002C000704700BFFEE7000008B50121102000F0D4[m
[32m+[m[32m:1002D00019F8FF20ADF8000010208DF8030003206E[m
[32m+[m[32m:1002E0008DF8020069460448FFF75CFFFF210248D1[m
[32m+[m[32m:1002F000FFF7E5FF08BD00000010014000BFFEE76A[m
[32m+[m[32m:100300007047704729B1064A92690243044B9A61CB[m
[32m+[m[32m:1003100004E0034A92698243014B9A6170470000EE[m
[32m+[m[32m:1003200000100240704710B500F002F810BD000048[m
[32m+[m[32m:100330000CB50020019000903348006840F48030F4[m
[32m+[m[32m:100340003149086000BF3048006800F40030009078[m
[32m+[m[32m:100350000198401C0190009818B90198B0F5A06F61[m
[32m+[m[32m:10036000F1D12948006800F4003010B1012000905C[m
[32m+[m[32m:1003700001E0002000900098012843D12348006844[m
[32m+[m[32m:1003800040F01000214908600846006820F0030092[m
[32m+[m[32m:1003900008600846006840F0020008601A4840689B[m
[32m+[m[32m:1003A000194948600846406848600846406840F47B[m
[32m+[m[32m:1003B000806048600846406820F47C104860084629[m
[32m+[m[32m:1003C000406840F4E81048600846006840F08070DB[m
[32m+[m[32m:1003D000086000BF0C48006800F000700028F9D0E9[m
[32m+[m[32m:1003E0000948406820F00300074948600846406813[m
[32m+[m[32m:1003F00040F00200486000BF0348406800F00C0075[m
[32m+[m[32m:100400000828F9D10CBD0000001002400020024075[m
[32m+[m[32m:100410007047000010B51348006840F00100114912[m
[32m+[m[32m:10042000086008464068104908400E494860084680[m
[32m+[m[32m:1004300000680E4908400B4908600846006820F42F[m
[32m+[m[32m:10044000802008600846406820F4FE0048604FF4B1[m
[32m+[m[32m:100450001F008860FFF767FF4FF0006004490860E5[m
[32m+[m[32m:1004600010BD0000001002400000FFF8FFFFF6FE84[m
[32m+[m[32m:1004700008ED00E000BFFEE702E008C8121F08C157[m
[32m+[m[32m:10048000002AFAD170477047002001E001C1121F15[m
[32m+[m[32m:10049000002AFBD170470000FFF716FF0FE0012193[m
[32m+[m[32m:1004A0000748FFF70AFF4FF47A70FFF772FE012149[m
[32m+[m[32m:1004B0000348FFF704FF4FF47A70FFF76AFEEEE798[m
[32m+[m[32m:1004C00000100140D40400080000002000040000D7[m
[32m+[m[32m:0404D0008804000894[m
[32m+[m[32m:0400000508000131BD[m
[32m+[m[32m:00000001FF[m
[1mdiff --git a/Template.uvguix.Administrator b/Template.uvguix.Administrator[m
[1mnew file mode 100644[m
[1mindex 0000000..777f13c[m
[1m--- /dev/null[m
[1m+++ b/Template.uvguix.Administrator[m
[36m@@ -0,0 +1,1378 @@[m
[32m+[m[32m<?xml version="1.0" encoding="UTF-8" standalone="no" ?>[m
[32m+[m[32m<ProjectGui xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_guix.xsd">[m
[32m+[m
[32m+[m[32m  <SchemaVersion>-5.1</SchemaVersion>[m
[32m+[m
[32m+[m[32m  <Header>### uVision Project, (C) Keil Software</Header>[m
[32m+[m
[32m+[m[32m  <ViewPool/>[m
[32m+[m
[32m+[m[32m  <SECTreeCtrl>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>38003</WinId>[m
[32m+[m[32m      <ViewName>Registers</ViewName>[m
[32m+[m[32m      <TableColWidths>115 275</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>346</WinId>[m
[32m+[m[32m      <ViewName>Code Coverage</ViewName>[m
[32m+[m[32m      <TableColWidths>435 160</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>204</WinId>[m
[32m+[m[32m      <ViewName>Performance Analyzer</ViewName>[m
[32m+[m[32m      <TableColWidths>595</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m  </SECTreeCtrl>[m
[32m+[m
[32m+[m[32m  <TreeListPane>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1506</WinId>[m
[32m+[m[32m      <ViewName>Symbols</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>133 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1936</WinId>[m
[32m+[m[32m      <ViewName>Watch 1</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>133 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1937</WinId>[m
[32m+[m[32m      <ViewName>Watch 2</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>133 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>1935</WinId>[m
[32m+[m[32m      <ViewName>Call Stack + Locals</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>133 133 133</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m    <View>[m
[32m+[m[32m      <WinId>2506</WinId>[m
[32m+[m[32m      <ViewName>Trace Data</ViewName>[m
[32m+[m[32m      <UserString></UserString>[m
[32m+[m[32m      <TableColWidths>75 135 130 95 70 230 200 150</TableColWidths>[m
[32m+[m[32m    </View>[m
[32m+[m[32m  </TreeListPane>[m
[32m+[m
[32m+[m[32m  <WindowSettings>[m
[32m+[m[32m    <LogicAnalizer>[m
[32m+[m[32m      <ShowLACursor>1</ShowLACursor>[m
[32m+[m[32m      <ShowSignalInfo>1</ShowSignalInfo>[m
[32m+[m[32m      <ShowCycles>0</ShowCycles>[m
[32m+[m[32m      <LeftSideBarSize>0</LeftSideBarSize>[m
[32m+[m[32m      <TimeBaseIndex>-1</TimeBaseIndex>[m
[32m+[m[32m    </LogicAnalizer>[m
[32m+[m[32m  </WindowSettings>[m
[32m+[m
[32m+[m[32m  <WinLayoutEx>[m
[32m+[m[32m    <sActiveDebugView></sActiveDebugView>[m
[32m+[m[32m    <WindowPosition>[m
[32m+[m[32m      <length>44</length>[m
[32m+[m[32m      <flags>2</flags>[m
[32m+[m[32m      <showCmd>3</showCmd>[m
[32m+[m[32m      <MinPosition>[m
[32m+[m[32m        <xPos>-32000</xPos>[m
[32m+[m[32m        <yPos>-32000</yPos>[m
[32m+[m[32m      </MinPosition>[m
[32m+[m[32m      <MaxPosition>[m
[32m+[m[32m        <xPos>-1</xPos>[m
[32m+[m[32m        <yPos>-1</yPos>[m
[32m+[m[32m      </MaxPosition>[m
[32m+[m[32m      <NormalPosition>[m
[32m+[m[32m        <Top>0</Top>[m
[32m+[m[32m        <Left>-3</Left>[m
[32m+[m[32m        <Right>952</Right>[m
[32m+[m[32m        <Bottom>735</Bottom>[m
[32m+[m[32m      </NormalPosition>[m
[32m+[m[32m    </WindowPosition>[m
[32m+[m[32m    <MDIClientArea>[m
[32m+[m[32m      <RegID>0</RegID>[m
[32m+[m[32m      <MDITabState>[m
[32m+[m[32m        <Len>453</Len>[m
[32m+[m[32m        <Data>01000000040000000100000001000000010000000100000000000000020000000000000001000000010000000000000028000000280000000100000003000000010000000100000047463A5CCEC4BCFE5C53544D3332B5C4B1E0B3CCD1A7CFB05CD1A7CFB0B1E0B3CC5CB1E0B3CC5C342ECAB9D3C3BFE2BAAFCAFDB5E3C1C14C45445C4150505C4C45445C6C65642E6300000000056C65642E6300000000F0A0A100FFFFFFFF45463A5CCEC4BCFE5C53544D3332B5C4B1E0B3CCD1A7CFB05CD1A7CFB0B1E0B3CC5CB1E0B3CC5C342ECAB9D3C3BFE2BAAFCAFDB5E3C1C14C45445C557365725C6D61696E2E6300000000066D61696E2E6300000000BECEA100FFFFFFFF47463A5CCEC4BCFE5C53544D3332B5C4B1E0B3CCD1A7CFB05CD1A7CFB0B1E0B3CC5CB1E0B3CC5C342ECAB9D3C3BFE2BAAFCAFDB5E3C1C14C45445C4150505C4C45445C6C65642E6800000000056C65642E6800000000FFDC7800FFFFFFFF0100000010000000C5D4F200FFDC7800BECEA100F0A0A100BCA8E1009CC1B600F7B88600D9ADC200A5C2D700B3A6BE00EAD6A300F6FA7D00B5E99D005FC3CF00C1838300CACAD50001000000000000000200000094010000660000005605000038020000</Data>[m
[32m+[m[32m      </MDITabState>[m
[32m+[m[32m    </MDIClientArea>[m
[32m+[m[32m    <ViewEx>[m
[32m+[m[32m      <ViewType>0</ViewType>[m
[32m+[m[32m      <ViewName>Build</ViewName>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>-1</RegID>[m
[32m+[m[32m        <PaneID>-1</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>940100004F000000F1030000B3000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9401000066000000F1030000CA000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1005</RegID>[m
[32m+[m[32m        <PaneID>1005</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000660000008D01000008020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>109</RegID>[m
[32m+[m[32m        <PaneID>109</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000660000008D01000008020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000EB000000BE010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1465</RegID>[m
[32m+[m[32m        <PaneID>1465</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1466</RegID>[m
[32m+[m[32m        <PaneID>1466</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1467</RegID>[m
[32m+[m[32m        <PaneID>1467</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1468</RegID>[m
[32m+[m[32m        <PaneID>1468</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1506</RegID>[m
[32m+[m[32m        <PaneID>1506</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>16384</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1913</RegID>[m
[32m+[m[32m        <PaneID>1913</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9701000066000000EE0300009A000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1935</RegID>[m
[32m+[m[32m        <PaneID>1935</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>32768</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1936</RegID>[m
[32m+[m[32m        <PaneID>1936</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1937</RegID>[m
[32m+[m[32m        <PaneID>1937</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1939</RegID>[m
[32m+[m[32m        <PaneID>1939</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1940</RegID>[m
[32m+[m[32m        <PaneID>1940</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1941</RegID>[m
[32m+[m[32m        <PaneID>1941</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>1942</RegID>[m
[32m+[m[32m        <PaneID>1942</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>195</RegID>[m
[32m+[m[32m        <PaneID>195</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000660000008D01000008020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000EB000000BE010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>196</RegID>[m
[32m+[m[32m        <PaneID>196</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000660000008D01000008020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000EB000000BE010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>197</RegID>[m
[32m+[m[32m        <PaneID>197</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>32768</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>000000003902000056050000AE020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>198</RegID>[m
[32m+[m[32m        <PaneID>198</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>32768</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>000000005E010000F1030000D3010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>199</RegID>[m
[32m+[m[32m        <PaneID>199</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>030000003C020000A803000095020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>203</RegID>[m
[32m+[m[32m        <PaneID>203</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9701000066000000EE0300009A000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>204</RegID>[m
[32m+[m[32m        <PaneID>204</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9701000066000000EE0300009A000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>221</RegID>[m
[32m+[m[32m        <PaneID>221</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000000000000000000000000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>2506</RegID>[m
[32m+[m[32m        <PaneID>2506</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>2507</RegID>[m
[32m+[m[32m        <PaneID>2507</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>343</RegID>[m
[32m+[m[32m        <PaneID>343</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9701000066000000EE0300009A000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>346</RegID>[m
[32m+[m[32m        <PaneID>346</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9701000066000000EE0300009A000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35824</RegID>[m
[32m+[m[32m        <PaneID>35824</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>9701000066000000EE0300009A000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35885</RegID>[m
[32m+[m[32m        <PaneID>35885</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35886</RegID>[m
[32m+[m[32m        <PaneID>35886</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35887</RegID>[m
[32m+[m[32m        <PaneID>35887</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35888</RegID>[m
[32m+[m[32m        <PaneID>35888</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35889</RegID>[m
[32m+[m[32m        <PaneID>35889</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35890</RegID>[m
[32m+[m[32m        <PaneID>35890</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35891</RegID>[m
[32m+[m[32m        <PaneID>35891</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35892</RegID>[m
[32m+[m[32m        <PaneID>35892</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35893</RegID>[m
[32m+[m[32m        <PaneID>35893</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35894</RegID>[m
[32m+[m[32m        <PaneID>35894</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35895</RegID>[m
[32m+[m[32m        <PaneID>35895</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35896</RegID>[m
[32m+[m[32m        <PaneID>35896</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35897</RegID>[m
[32m+[m[32m        <PaneID>35897</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35898</RegID>[m
[32m+[m[32m        <PaneID>35898</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35899</RegID>[m
[32m+[m[32m        <PaneID>35899</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35900</RegID>[m
[32m+[m[32m        <PaneID>35900</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35901</RegID>[m
[32m+[m[32m        <PaneID>35901</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35902</RegID>[m
[32m+[m[32m        <PaneID>35902</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35903</RegID>[m
[32m+[m[32m        <PaneID>35903</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35904</RegID>[m
[32m+[m[32m        <PaneID>35904</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>35905</RegID>[m
[32m+[m[32m        <PaneID>35905</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>6402000066000000EE03000052010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>38003</RegID>[m
[32m+[m[32m        <PaneID>38003</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>03000000660000008D010000FF010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000EB000000BE010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>38007</RegID>[m
[32m+[m[32m        <PaneID>38007</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>030000003C020000A803000095020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>22000000390000001A0200009A000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>436</RegID>[m
[32m+[m[32m        <PaneID>436</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>030000003C020000A803000095020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000EB000000BE010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>437</RegID>[m
[32m+[m[32m        <PaneID>437</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>440</RegID>[m
[32m+[m[32m        <PaneID>440</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0300000075010000EE030000BA010000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>2200000039000000B2010000C9010000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59392</RegID>[m
[32m+[m[32m        <PaneID>59392</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>940</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0000000000000000B70300001C000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59393</RegID>[m
[32m+[m[32m        <PaneID>0</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>32767</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>4096</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>0</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000AE02000056050000C1020000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59399</RegID>[m
[32m+[m[32m        <PaneID>59399</PaneID>[m
[32m+[m[32m        <IsVisible>1</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>463</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>1</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>000000001C000000DA01000038000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <Window>[m
[32m+[m[32m        <RegID>59400</RegID>[m
[32m+[m[32m        <PaneID>59400</PaneID>[m
[32m+[m[32m        <IsVisible>0</IsVisible>[m
[32m+[m[32m        <IsFloating>0</IsFloating>[m
[32m+[m[32m        <IsTabbed>0</IsTabbed>[m
[32m+[m[32m        <IsActivated>0</IsActivated>[m
[32m+[m[32m        <MRUWidth>612</MRUWidth>[m
[32m+[m[32m        <PinState>0</PinState>[m
[32m+[m[32m        <RecentFrameAlignment>8192</RecentFrameAlignment>[m
[32m+[m[32m        <RecentRowIndex>2</RecentRowIndex>[m
[32m+[m[32m        <RectRecentDocked>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>00000000380000006F02000054000000</Data>[m
[32m+[m[32m        </RectRecentDocked>[m
[32m+[m[32m        <RectRecentFloat>[m
[32m+[m[32m          <Len>16</Len>[m
[32m+[m[32m          <Data>0A0000000A0000006E0000006E000000</Data>[m
[32m+[m[32m        </RectRecentFloat>[m
[32m+[m[32m      </Window>[m
[32m+[m[32m      <DockMan>[m
[32m+[m[32m        <Len>2619</Len>[m
[32m+[m[32m        <Data>000000000B000000000000000020000000000000FFFFFFFFFFFFFFFF94010000B3000000F1030000B7000000000000000100000004000000010000000000000000000000FFFFFFFF06000000CB00000057010000CC000000F08B00005A01000079070000FFFF02000B004354616262656450616E6500200000000000009401000066000000F1030000CA000000940100004F000000F1030000B30000000000000040280046060000000B446973617373656D626C7900000000CB00000001000000FFFFFFFFFFFFFFFF14506572666F726D616E636520416E616C797A6572000000005701000001000000FFFFFFFFFFFFFFFF14506572666F726D616E636520416E616C797A657200000000CC00000001000000FFFFFFFFFFFFFFFF0E4C6F67696320416E616C797A657200000000F08B000001000000FFFFFFFFFFFFFFFF0D436F646520436F766572616765000000005A01000001000000FFFFFFFFFFFFFFFF11496E737472756374696F6E205472616365000000007907000001000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000001000000FFFFFFFFCB00000001000000FFFFFFFFCB000000000000000040000000000000FFFFFFFFFFFFFFFF5D0200004F000000610200006B010000000000000200000004000000010000000000000000000000FFFFFFFF17000000E2050000CA0900002D8C00002E8C00002F8C0000308C0000318C0000328C0000338C0000348C0000358C0000368C0000378C0000388C0000398C00003A8C00003B8C00003C8C00003D8C00003E8C00003F8C0000408C0000418C0000018000400000000000006102000066000000F103000082010000610200004F000000F10300006B0100000000000040410046170000000753796D626F6C7300000000E205000001000000FFFFFFFFFFFFFFFF0A5472616365204461746100000000CA09000001000000FFFFFFFFFFFFFFFF00000000002D8C000001000000FFFFFFFFFFFFFFFF00000000002E8C000001000000FFFFFFFFFFFFFFFF00000000002F8C000001000000FFFFFFFFFFFFFFFF0000000000308C000001000000FFFFFFFFFFFFFFFF0000000000318C000001000000FFFFFFFFFFFFFFFF0000000000328C000001000000FFFFFFFFFFFFFFFF0000000000338C000001000000FFFFFFFFFFFFFFFF0000000000348C000001000000FFFFFFFFFFFFFFFF0000000000358C000001000000FFFFFFFFFFFFFFFF0000000000368C000001000000FFFFFFFFFFFFFFFF0000000000378C000001000000FFFFFFFFFFFFFFFF0000000000388C000001000000FFFFFFFFFFFFFFFF0000000000398C000001000000FFFFFFFFFFFFFFFF00000000003A8C000001000000FFFFFFFFFFFFFFFF00000000003B8C000001000000FFFFFFFFFFFFFFFF00000000003C8C000001000000FFFFFFFFFFFFFFFF00000000003D8C000001000000FFFFFFFFFFFFFFFF00000000003E8C000001000000FFFFFFFFFFFFFFFF00000000003F8C000001000000FFFFFFFFFFFFFFFF0000000000408C000001000000FFFFFFFFFFFFFFFF0000000000418C000001000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000001000000FFFFFFFFE205000001000000FFFFFFFFE2050000000000000010000001000000FFFFFFFFFFFFFFFF900100004F0000009401000021020000010000000200001004000000010000000000000000000000FFFFFFFF05000000ED0300006D000000C3000000C400000073940000018000100000010000000000000066000000900100002F020000000000004F00000090010000210200000000000040410056050000000750726F6A65637401000000ED03000001000000FFFFFFFFFFFFFFFF05426F6F6B73010000006D00000001000000FFFFFFFFFFFFFFFF0946756E6374696F6E7301000000C300000001000000FFFFFFFFFFFFFFFF0954656D706C6174657301000000C400000001000000FFFFFFFFFFFFFFFF09526567697374657273000000007394000001000000FFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000001000000FFFFFFFFED03000001000000FFFFFFFFED030000000000000080000000000000FFFFFFFFFFFFFFFF000000005A010000F10300005E01000000000000010000000400000001000000000000000000000000000000000000000000000001000000C6000000FFFFFFFF0E0000008F070000930700009407000095070000960700009007000091070000B5010000B8010000B9050000BA050000BB050000BC050000CB090000018000800000000000000000000075010000F1030000EA010000000000005E010000F1030000D301000000000000404100460E0000001343616C6C20537461636B202B204C6F63616C73000000008F07000001000000FFFFFFFFFFFFFFFF0755415254202331000000009307000001000000FFFFFFFFFFFFFFFF0755415254202332000000009407000001000000FFFFFFFFFFFFFFFF0755415254202333000000009507000001000000FFFFFFFFFFFFFFFF15446562756720287072696E74662920566965776572000000009607000001000000FFFFFFFFFFFFFFFF0757617463682031000000009007000001000000FFFFFFFFFFFFFFFF0757617463682032000000009107000001000000FFFFFFFFFFFFFFFF10547261636520457863657074696F6E7300000000B501000001000000FFFFFFFFFFFFFFFF0E4576656E7420436F756E7465727300000000B801000001000000FFFFFFFFFFFFFFFF084D656D6F7279203100000000B905000001000000FFFFFFFFFFFFFFFF084D656D6F7279203200000000BA05000001000000FFFFFFFFFFFFFFFF084D656D6F7279203300000000BB05000001000000FFFFFFFFFFFFFFFF084D656D6F7279203400000000BC05000001000000FFFFFFFFFFFFFFFF105472616365204E617669676174696F6E00000000CB09000001000000FFFFFFFFFFFFFFFFFFFFFFFF0000000001000000000000000000000001000000FFFFFFFFF90100005E010000FD010000D301000000000000020000000400000000000000000000000000000000000000000000000000000002000000C6000000FFFFFFFF8F07000001000000FFFFFFFF8F07000001000000C6000000000000000080000001000000FFFFFFFFFFFFFFFF0000000021020000560500002502000001000000010000100400000001000000EFFDFFFF43000000FFFFFFFF04000000C5000000C7000000B401000077940000018000800000010000000000000033020000AB030000BC020000000000002502000056050000AE0200000000000040820056040000000C4275696C64204F757470757401000000C500000001000000FFFFFFFFFFFFFFFF0D46696E6420496E2046696C657300000000C700000001000000FFFFFFFFFFFFFFFF0A4572726F72204C69737400000000B401000001000000FFFFFFFFFFFFFFFF0742726F77736572000000007794000001000000FFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000001000000FFFFFFFFC500000001000000FFFFFFFFC5000000000000000000000000000000</Data>[m
[32m+[m[32m      </DockMan>[m
[32m+[m[32m      <ToolBar>[m
[32m+[m[32m        <RegID>59392</RegID>[m
[32m+[m[32m        <Name>File</Name>[m
[32m+[m[32m        <Buttons>[m
[32m+[m[32m          <Len>2378</Len>[m
[32m+[m[32m          <Data>00200000010000002800FFFF01001100434D4643546F6F6C426172427574746F6E00E100000000000000000000000000000000000000000000000100000001000000018001E100000000000001000000000000000000000000000000000100000001000000018003E1000000000000020000000000000000000000000000000001000000010000000180CD7F0000000000000300000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018023E100000000040004000000000000000000000000000000000100000001000000018022E100000000040005000000000000000000000000000000000100000001000000018025E10000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001802BE10000000004000700000000000000000000000000000000010000000100000001802CE10000000004000800000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001807A8A0000000000000900000000000000000000000000000000010000000100000001807B8A0000000004000A00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180D3B00000000000000B000000000000000000000000000000000100000001000000018015B10000000004000C0000000000000000000000000000000001000000010000000180F4B00000000004000D000000000000000000000000000000000100000001000000018036B10000000004000E00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FF88000000000400460000000000000000000000000000000001000000010000000180FE880000000004004500000000000000000000000000000000010000000100000001800B810000000004001300000000000000000000000000000000010000000100000001800C810000000004001400000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180F0880000020000000F000000000000000000000000000000000100000001000000FFFF0100120043555646696E64436F6D626F427574746F6EE8030000000000000000000000000000000000000000000000010000000100000096000000020020500000000006446174615F319600000000000000140006446174615F3104446174610C5A68695869616E67466C6167114B6F6E674A69616E506F696E5F666C61670E6875616E5869616E675F666C61670E546573745F5363616E5F54696D650F46595F5363616E5F5A686978696E670C4D616943686F6E675F636E740C6469616F796F6E675F636E740F737465705F64657369676E5F7365740E737465705F6F70656E5F666C6167126D6973735F64697374616E63655F666C61671153656E645F4D616943686F6E675F434E540A4D6F64655F43686F73650E46575F6C6F636174696F6E5F6B700E4368616E67655F666C61675F6C790A4A69655975655F636E74094361694A695F434E541A46595F6C6F636174696F6E5F6C6F6F705F6F70656E5F666C6167116875696C696E675F6F6E63655F666C61670000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000018024E10000000000001100000000000000000000000000000000010000000100000001800A810000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018022800000020000001500000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C488000000000000160000000000000000000000000000000001000000010000000180C988000000000400180000000000000000000000000000000001000000010000000180C788000000000000190000000000000000000000000000000001000000010000000180C8880000000000001700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6E4C010000020001001A0000000F50726F6A6563742057696E646F7773000000000000000000000000010000000100000000000000000000000100000008002880DD880000000000001A0000000750726F6A656374000000000000000000000000010000000100000000000000000000000100000000002880DC8B0000000000003A00000005426F6F6B73000000000000000000000000010000000100000000000000000000000100000000002880E18B0000000000003B0000000946756E6374696F6E73000000000000000000000000010000000100000000000000000000000100000000002880E28B000000000000400000000954656D706C6174657300000000000000000000000001000000010000000000000000000000010000000000288018890000000000003D0000000E536F757263652042726F777365720000000000000000000000000100000001000000000000000000000001000000000028800000000000000400FFFFFFFF00000000000000000001000000000000000100000000000000000000000100000000002880D988000000000000390000000C4275696C64204F7574707574000000000000000000000000010000000100000000000000000000000100000000002880E38B000000000000410000000B46696E64204F75747075740000000000000000000000000100000001000000000000000000000001000000000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FB7F0000000000001B000000000000000000000000000000000100000001000000000000000446696C65AC030000</Data>[m
[32m+[m[32m        </Buttons>[m
[32m+[m[32m        <OriginalItems>[m
[32m+[m[32m          <Len>1423</Len>[m
[32m+[m[32m          <Data>2800FFFF01001100434D4643546F6F6C426172427574746F6E00E1000000000000FFFFFFFF000100000000000000010000000000000001000000018001E1000000000000FFFFFFFF000100000000000000010000000000000001000000018003E1000000000000FFFFFFFF0001000000000000000100000000000000010000000180CD7F000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF000000000000000000010000000000000001000000018023E1000000000000FFFFFFFF000100000000000000010000000000000001000000018022E1000000000000FFFFFFFF000100000000000000010000000000000001000000018025E1000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001802BE1000000000000FFFFFFFF00010000000000000001000000000000000100000001802CE1000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001807A8A000000000000FFFFFFFF00010000000000000001000000000000000100000001807B8A000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180D3B0000000000000FFFFFFFF000100000000000000010000000000000001000000018015B1000000000000FFFFFFFF0001000000000000000100000000000000010000000180F4B0000000000000FFFFFFFF000100000000000000010000000000000001000000018036B1000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180FF88000000000000FFFFFFFF0001000000000000000100000000000000010000000180FE88000000000000FFFFFFFF00010000000000000001000000000000000100000001800B81000000000000FFFFFFFF00010000000000000001000000000000000100000001800C81000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180F088000000000000FFFFFFFF0001000000000000000100000000000000010000000180EE7F000000000000FFFFFFFF000100000000000000010000000000000001000000018024E1000000000000FFFFFFFF00010000000000000001000000000000000100000001800A81000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001802280000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180C488000000000000FFFFFFFF0001000000000000000100000000000000010000000180C988000000000000FFFFFFFF0001000000000000000100000000000000010000000180C788000000000000FFFFFFFF0001000000000000000100000000000000010000000180C888000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180DD88000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180FB7F000000000000FFFFFFFF000100000000000000010000000000000001000000</Data>[m
[32m+[m[32m        </OriginalItems>[m
[32m+[m[32m        <OrigResetItems>[m
[32m+[m[32m          <Len>1423</Len>[m
[32m+[m[32m          <Data>2800FFFF01001100434D4643546F6F6C426172427574746F6E00E100000000000000000000000000000000000000000000000100000001000000018001E100000000000001000000000000000000000000000000000100000001000000018003E1000000000000020000000000000000000000000000000001000000010000000180CD7F0000000000000300000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018023E100000000000004000000000000000000000000000000000100000001000000018022E100000000000005000000000000000000000000000000000100000001000000018025E10000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001802BE10000000000000700000000000000000000000000000000010000000100000001802CE10000000000000800000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001807A8A0000000000000900000000000000000000000000000000010000000100000001807B8A0000000000000A00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180D3B00000000000000B000000000000000000000000000000000100000001000000018015B10000000000000C0000000000000000000000000000000001000000010000000180F4B00000000000000D000000000000000000000000000000000100000001000000018036B10000000000000E00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FF880000000000000F0000000000000000000000000000000001000000010000000180FE880000000000001000000000000000000000000000000000010000000100000001800B810000000000001100000000000000000000000000000000010000000100000001800C810000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180F088000000000000130000000000000000000000000000000001000000010000000180EE7F00000000000014000000000000000000000000000000000100000001000000018024E10000000000001500000000000000000000000000000000010000000100000001800A810000000000001600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018022800000000000001700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C488000000000000180000000000000000000000000000000001000000010000000180C988000000000000190000000000000000000000000000000001000000010000000180C7880000000000001A0000000000000000000000000000000001000000010000000180C8880000000000001B00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180DD880000000000001C00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180FB7F0000000000001D000000000000000000000000000000000100000001000000</Data>[m
[32m+[m[32m        </OrigResetItems>[m
[32m+[m[32m      </ToolBar>[m
[32m+[m[32m      <ToolBar>[m
[32m+[m[32m        <RegID>59399</RegID>[m
[32m+[m[32m        <Name>Build</Name>[m
[32m+[m[32m        <Buttons>[m
[32m+[m[32m          <Len>678</Len>[m
[32m+[m[32m          <Data>00200000010000001000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F0000000000001C0000000000000000000000000000000001000000010000000180D07F0000000000001D000000000000000000000000000000000100000001000000018030800000000000001E00000000000000000000000000000000010000000100000001809E8A0000000000001F0000000000000000000000000000000001000000010000000180D17F0000000004002000000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001804C8A0000000000002100000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000FFFF01001900434D4643546F6F6C426172436F6D626F426F78427574746F6EBA000000000000000000000000000000000000000000000000010000000100000096000000030020500000000008546172676574203196000000000000000100085461726765742031000000000180EB880000000000002200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C07F000000000000230000000000000000000000000000000001000000010000000180B08A000000000400240000000000000000000000000000000001000000010000000180A8010000000000004E00000000000000000000000000000000010000000100000001807202000000000000530000000000000000000000000000000001000000010000000180BE010000000000005000000000000000000000000000000000010000000100000000000000054275696C64CF010000</Data>[m
[32m+[m[32m        </Buttons>[m
[32m+[m[32m        <OriginalItems>[m
[32m+[m[32m          <Len>583</Len>[m
[32m+[m[32m          <Data>1000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F000000000000FFFFFFFF0001000000000000000100000000000000010000000180D07F000000000000FFFFFFFF00010000000000000001000000000000000100000001803080000000000000FFFFFFFF00010000000000000001000000000000000100000001809E8A000000000000FFFFFFFF0001000000000000000100000000000000010000000180D17F000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001804C8A000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001806680000000000000FFFFFFFF0001000000000000000100000000000000010000000180EB88000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180C07F000000000000FFFFFFFF0001000000000000000100000000000000010000000180B08A000000000000FFFFFFFF0001000000000000000100000000000000010000000180A801000000000000FFFFFFFF00010000000000000001000000000000000100000001807202000000000000FFFFFFFF0001000000000000000100000000000000010000000180BE01000000000000FFFFFFFF000100000000000000010000000000000001000000</Data>[m
[32m+[m[32m        </OriginalItems>[m
[32m+[m[32m        <OrigResetItems>[m
[32m+[m[32m          <Len>583</Len>[m
[32m+[m[32m          <Data>1000FFFF01001100434D4643546F6F6C426172427574746F6ECF7F000000000000000000000000000000000000000000000001000000010000000180D07F00000000000001000000000000000000000000000000000100000001000000018030800000000000000200000000000000000000000000000000010000000100000001809E8A000000000000030000000000000000000000000000000001000000010000000180D17F0000000000000400000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001804C8A0000000000000500000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001806680000000000000060000000000000000000000000000000001000000010000000180EB880000000000000700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180C07F000000000000080000000000000000000000000000000001000000010000000180B08A000000000000090000000000000000000000000000000001000000010000000180A8010000000000000A000000000000000000000000000000000100000001000000018072020000000000000B0000000000000000000000000000000001000000010000000180BE010000000000000C000000000000000000000000000000000100000001000000</Data>[m
[32m+[m[32m        </OrigResetItems>[m
[32m+[m[32m      </ToolBar>[m
[32m+[m[32m      <ToolBar>[m
[32m+[m[32m        <RegID>59400</RegID>[m
[32m+[m[32m        <Name>Debug</Name>[m
[32m+[m[32m        <Buttons>[m
[32m+[m[32m          <Len>2220</Len>[m
[32m+[m[32m          <Data>00200000000000001900FFFF01001100434D4643546F6F6C426172427574746F6ECC880000000000002500000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018017800000000000002600000000000000000000000000000000010000000100000001801D800000000000002700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001801A800000000000002800000000000000000000000000000000010000000100000001801B80000000000000290000000000000000000000000000000001000000010000000180E57F0000000000002A00000000000000000000000000000000010000000100000001801C800000000000002B00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018000890000000000002C00000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180E48B0000000000002D0000000000000000000000000000000001000000010000000180F07F0000000000002E0000000000000000000000000000000001000000010000000180E8880000000000003700000000000000000000000000000000010000000100000001803B010000000000002F0000000000000000000000000000000001000000010000000180BB8A00000000000030000000000000000000000000000000000100000001000000FFFF01001500434D4643546F6F6C4261724D656E75427574746F6E0E01000000000000310000000D57617463682057696E646F7773000000000000000000000000010000000100000000000000000000000100000002001380D88B000000000000310000000757617463682031000000000000000000000000010000000100000000000000000000000100000000001380D98B0000000000003100000007576174636820320000000000000000000000000100000001000000000000000000000001000000000013800F01000000000000320000000E4D656D6F72792057696E646F7773000000000000000000000000010000000100000000000000000000000100000004001380D28B00000000000032000000084D656D6F72792031000000000000000000000000010000000100000000000000000000000100000000001380D38B00000000000032000000084D656D6F72792032000000000000000000000000010000000100000000000000000000000100000000001380D48B00000000000032000000084D656D6F72792033000000000000000000000000010000000100000000000000000000000100000000001380D58B00000000000032000000084D656D6F727920340000000000000000000000000100000001000000000000000000000001000000000013801001000000000000330000000E53657269616C2057696E646F77730000000000000000000000000100000001000000000000000000000001000000040013809307000000000000330000000755415254202331000000000000000000000000010000000100000000000000000000000100000000001380940700000000000033000000075541525420233200000000000000000000000001000000010000000000000000000000010000000000138095070000000000003300000007554152542023330000000000000000000000000100000001000000000000000000000001000000000013809607000000000000330000000E49544D2F525441205669657765720000000000000000000000000100000001000000000000000000000001000000000013803C010000000000003400000010416E616C797369732057696E646F7773000000000000000000000000010000000100000000000000000000000100000003001380658A000000000000340000000E4C6F67696320416E616C797A6572000000000000000000000000010000000100000000000000000000000100000000001380DC7F0000000000003E00000014506572666F726D616E636520416E616C797A6572000000000000000000000000010000000100000000000000000000000100000000001380E788000000000000380000000D436F646520436F76657261676500000000000000000000000001000000010000000000000000000000010000000000138053010000000000003F0000000D54726163652057696E646F77730000000000000000000000000100000001000000000000000000000001000000010013805401000000000000FFFFFFFF115472616365204D656E7520416E63686F720100000000000000010000000000000001000000000000000000000001000000000013802901000000000000350000001553797374656D205669657765722057696E646F77730000000000000000000000000100000001000000000000000000000001000000010013804B01000000000000FFFFFFFF1453797374656D2056696577657220416E63686F720100000000000000010000000000000001000000000000000000000001000000000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000138001890000000000003600000007546F6F6C626F7800000000000000000000000001000000010000000000000000000000010000000300138044C5000000000000FFFFFFFF0E5570646174652057696E646F77730100000000000000010000000000000001000000000000000000000001000000000013800000000000000400FFFFFFFF000000000000000000010000000000000001000000000000000000000001000000000013805B01000000000000FFFFFFFF12546F6F6C626F78204D656E75416E63686F72010000000000000001000000000000000100000000000000000000000100000000000000000005446562756764020000</Data>[m
[32m+[m[32m        </Buttons>[m
[32m+[m[32m        <OriginalItems>[m
[32m+[m[32m          <Len>898</Len>[m
[32m+[m[32m          <Data>1900FFFF01001100434D4643546F6F6C426172427574746F6ECC88000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001801780000000000000FFFFFFFF00010000000000000001000000000000000100000001801D80000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001801A80000000000000FFFFFFFF00010000000000000001000000000000000100000001801B80000000000000FFFFFFFF0001000000000000000100000000000000010000000180E57F000000000000FFFFFFFF00010000000000000001000000000000000100000001801C80000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001800089000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF0000000000000000000100000000000000010000000180E48B000000000000FFFFFFFF0001000000000000000100000000000000010000000180F07F000000000000FFFFFFFF0001000000000000000100000000000000010000000180E888000000000000FFFFFFFF00010000000000000001000000000000000100000001803B01000000000000FFFFFFFF0001000000000000000100000000000000010000000180BB8A000000000000FFFFFFFF0001000000000000000100000000000000010000000180D88B000000000000FFFFFFFF0001000000000000000100000000000000010000000180D28B000000000000FFFFFFFF00010000000000000001000000000000000100000001809307000000000000FFFFFFFF0001000000000000000100000000000000010000000180658A000000000000FFFFFFFF0001000000000000000100000000000000010000000180C18A000000000000FFFFFFFF0001000000000000000100000000000000010000000180EE8B000000000000FFFFFFFF00010000000000000001000000000000000100000001800000000000000000FFFFFFFF00000000000000000001000000000000000100000001800189000000000000FFFFFFFF000100000000000000010000000000000001000000</Data>[m
[32m+[m[32m        </OriginalItems>[m
[32m+[m[32m        <OrigResetItems>[m
[32m+[m[32m          <Len>898</Len>[m
[32m+[m[32m          <Data>1900FFFF01001100434D4643546F6F6C426172427574746F6ECC880000000000000000000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018017800000000000000100000000000000000000000000000000010000000100000001801D800000000000000200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF00000000000000000000000000010000000100000001801A800000000000000300000000000000000000000000000000010000000100000001801B80000000000000040000000000000000000000000000000001000000010000000180E57F0000000000000500000000000000000000000000000000010000000100000001801C800000000000000600000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF000000000000000000000000000100000001000000018000890000000000000700000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180E48B000000000000080000000000000000000000000000000001000000010000000180F07F000000000000090000000000000000000000000000000001000000010000000180E8880000000000000A00000000000000000000000000000000010000000100000001803B010000000000000B0000000000000000000000000000000001000000010000000180BB8A0000000000000C0000000000000000000000000000000001000000010000000180D88B0000000000000D0000000000000000000000000000000001000000010000000180D28B0000000000000E000000000000000000000000000000000100000001000000018093070000000000000F0000000000000000000000000000000001000000010000000180658A000000000000100000000000000000000000000000000001000000010000000180C18A000000000000110000000000000000000000000000000001000000010000000180EE8B0000000000001200000000000000000000000000000000010000000100000001800000000001000000FFFFFFFF0000000000000000000000000001000000010000000180018900000000000013000000000000000000000000000000000100000001000000</Data>[m
[32m+[m[32m        </OrigResetItems>[m
[32m+[m[32m      </ToolBar>[m
[32m+[m[32m      <ControlBarsSummary>[m
[32m+[m[32m        <Bars>0</Bars>[m
[32m+[m[32m        <ScreenCX>1366</ScreenCX>[m
[32m+[m[32m        <ScreenCY>768</ScreenCY>[m
[32m+[m[32m      </ControlBarsSummary>[m
[32m+[m[32m    </ViewEx>[m
[32m+[m[32m  </WinLayoutEx>[m
[32m+[m
[32m+[m[32m  <MDIGroups>[m
[32m+[m[32m    <Orientation>1</Orientation>[m
[32m+[m[32m    <ActiveMDIGroup>0</ActiveMDIGroup>[m
[32m+[m[32m    <MDIGroup>[m
[32m+[m[32m      <Size>100</Size>[m
[32m+[m[32m      <ActiveTab>1</ActiveTab>[m
[32m+[m[32m      <Doc>[m
[32m+[m[32m        <Name>.\APP\LED\led.c</Name>[m
[32m+[m[32m        <ColumnNumber>47</ColumnNumber>[m
[32m+[m[32m        <TopLine>1</TopLine>[m
[32m+[m[32m        <CurrentLine>7</CurrentLine>[m
[32m+[m[32m        <Folding>1</Folding>[m
[32m+[m[32m        <ContractedFolders></ContractedFolders>[m
[32m+[m[32m        <PaneID>0</PaneID>[m
[32m+[m[32m      </Doc>[m
[32m+[m[32m      <Doc>[m
[32m+[m[32m        <Name>.\User\main.c</Name>[m
[32m+[m[32m        <ColumnNumber>15</ColumnNumber>[m
[32m+[m[32m        <TopLine>1</TopLine>[m
[32m+[m[32m        <CurrentLine>13</CurrentLine>[m
[32m+[m[32m        <Folding>1</Folding>[m
[32m+[m[32m        <ContractedFolders></ContractedFolders>[m
[32m+[m[32m        <PaneID>0</PaneID>[m
[32m+[m[32m      </Doc>[m
[32m+[m[32m      <Doc>[m
[32m+[m[32m        <Name>.\APP\LED\led.h</Name>[m
[32m+[m[32m        <ColumnNumber>0</ColumnNumber>[m
[32m+[m[32m        <TopLine>1</TopLine>[m
[32m+[m[32m        <CurrentLine>8</CurrentLine>[m
[32m+[m[32m        <Folding>1</Folding>[m
[32m+[m[32m        <ContractedFolders></ContractedFolders>[m
[32m+[m[32m        <PaneID>0</PaneID>[m
[32m+[m[32m      </Doc>[m
[32m+[m[32m    </MDIGroup>[m
[32m+[m[32m  </MDIGroups>[m
[32m+[m
[32m+[m[32m</ProjectGui>[m
[1mdiff --git a/Template.uvoptx b/Template.uvoptx[m
[1mnew file mode 100644[m
[1mindex 0000000..ad57117[m
[1m--- /dev/null[m
[1m+++ b/Template.uvoptx[m
[36m@@ -0,0 +1,334 @@[m
[32m+[m[32m<?xml version="1.0" encoding="UTF-8" standalone="no" ?>[m
[32m+[m[32m<ProjectOpt xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_optx.xsd">[m
[32m+[m
[32m+[m[32m  <SchemaVersion>1.0</SchemaVersion>[m
[32m+[m
[32m+[m[32m  <Header>### uVision Project, (C) Keil Software</Header>[m
[32m+[m
[32m+[m[32m  <Extensions>[m
[32m+[m[32m    <cExt>*.c</cExt>[m
[32m+[m[32m    <aExt>*.s*; *.src; *.a*</aExt>[m
[32m+[m[32m    <oExt>*.obj</oExt>[m
[32m+[m[32m    <lExt>*.lib</lExt>[m
[32m+[m[32m    <tExt>*.txt; *.h; *.inc</tExt>[m
[32m+[m[32m    <pExt>*.plm</pExt>[m
[32m+[m[32m    <CppX>*.cpp</CppX>[m
[32m+[m[32m    <nMigrate>0</nMigrate>[m
[32m+[m[32m  </Extensions>[m
[32m+[m
[32m+[m[32m  <DaveTm>[m
[32m+[m[32m    <dwLowDateTime>0</dwLowDateTime>[m
[32m+[m[32m    <dwHighDateTime>0</dwHighDateTime>[m
[32m+[m[32m  </DaveTm>[m
[32m+[m
[32m+[m[32m  <Target>[m
[32m+[m[32m    <TargetName>Target 1</TargetName>[m
[32m+[m[32m    <ToolsetNumber>0x4</ToolsetNumber>[m
[32m+[m[32m    <ToolsetName>ARM-ADS</ToolsetName>[m
[32m+[m[32m    <TargetOption>[m
[32m+[m[32m      <CLKADS>12000000</CLKADS>[m
[32m+[m[32m      <OPTTT>[m
[32m+[m[32m        <gFlags>1</gFlags>[m
[32m+[m[32m        <BeepAtEnd>1</BeepAtEnd>[m
[32m+[m[32m        <RunSim>0</RunSim>[m
[32m+[m[32m        <RunTarget>1</RunTarget>[m
[32m+[m[32m        <RunAbUc>0</RunAbUc>[m
[32m+[m[32m      </OPTTT>[m
[32m+[m[32m      <OPTHX>[m
[32m+[m[32m        <HexSelection>1</HexSelection>[m
[32m+[m[32m        <FlashByte>65535</FlashByte>[m
[32m+[m[32m        <HexRangeLowAddress>0</HexRangeLowAddress>[m
[32m+[m[32m        <HexRangeHighAddress>0</HexRangeHighAddress>[m
[32m+[m[32m        <HexOffset>0</HexOffset>[m
[32m+[m[32m      </OPTHX>[m
[32m+[m[32m      <OPTLEX>[m
[32m+[m[32m        <PageWidth>79</PageWidth>[m
[32m+[m[32m        <PageLength>66</PageLength>[m
[32m+[m[32m        <TabStop>8</TabStop>[m
[32m+[m[32m        <ListingPath>.\Obj\</ListingPath>[m
[32m+[m[32m      </OPTLEX>[m
[32m+[m[32m      <ListingPage>[m
[32m+[m[32m        <CreateCListing>1</CreateCListing>[m
[32m+[m[32m        <CreateAListing>1</CreateAListing>[m
[32m+[m[32m        <CreateLListing>1</CreateLListing>[m
[32m+[m[32m        <CreateIListing>0</CreateIListing>[m
[32m+[m[32m        <AsmCond>1</AsmCond>[m
[32m+[m[32m        <AsmSymb>1</AsmSymb>[m
[32m+[m[32m        <AsmXref>0</AsmXref>[m
[32m+[m[32m        <CCond>1</CCond>[m
[32m+[m[32m        <CCode>0</CCode>[m
[32m+[m[32m        <CListInc>0</CListInc>[m
[32m+[m[32m        <CSymb>0</CSymb>[m
[32m+[m[32m        <LinkerCodeListing>0</LinkerCodeListing>[m
[32m+[m[32m      </ListingPage>[m
[32m+[m[32m      <OPTXL>[m
[32m+[m[32m        <LMap>1</LMap>[m
[32m+[m[32m        <LComments>1</LComments>[m
[32m+[m[32m        <LGenerateSymbols>1</LGenerateSymbols>[m
[32m+[m[32m        <LLibSym>1</LLibSym>[m
[32m+[m[32m        <LLines>1</LLines>[m
[32m+[m[32m        <LLocSym>1</LLocSym>[m
[32m+[m[32m        <LPubSym>1</LPubSym>[m
[32m+[m[32m        <LXref>0</LXref>[m
[32m+[m[32m        <LExpSel>0</LExpSel>[m
[32m+[m[32m      </OPTXL>[m
[32m+[m[32m      <OPTFL>[m
[32m+[m[32m        <tvExp>1</tvExp>[m
[32m+[m[32m        <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m        <IsCurrentTarget>1</IsCurrentTarget>[m
[32m+[m[32m      </OPTFL>[m
[32m+[m[32m      <CpuCode>18</CpuCode>[m
[32m+[m[32m      <Books>[m
[32m+[m[32m        <Book>[m
[32m+[m[32m          <Number>0</Number>[m
[32m+[m[32m          <Title>Base Board Schematics (MCBSTM32E)</Title>[m
[32m+[m[32m          <Path>C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Documents\mcbstm32e-base-board-schematics.pdf</Path>[m
[32m+[m[32m        </Book>[m
[32m+[m[32m        <Book>[m
[32m+[m[32m          <Number>1</Number>[m
[32m+[m[32m          <Title>Display Board Schematics (MCBSTM32E)</Title>[m
[32m+[m[32m          <Path>C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Documents\mcbstm32e-display-board-schematics.pdf</Path>[m
[32m+[m[32m        </Book>[m
[32m+[m[32m        <Book>[m
[32m+[m[32m          <Number>2</Number>[m
[32m+[m[32m          <Title>User Manual (MCBSTM32E)</Title>[m
[32m+[m[32m          <Path>C:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Documents\mcbstm32e.chm</Path>[m
[32m+[m[32m        </Book>[m
[32m+[m[32m        <Book>[m
[32m+[m[32m          <Number>3</Number>[m
[32m+[m[32m          <Title>MCBSTM32E Evaluation Board Web Page (MCBSTM32E)</Title>[m
[32m+[m[32m          <Path>http://www.keil.com/mcbstm32e/</Path>[m
[32m+[m[32m        </Book>[m
[32m+[m[32m      </Books>[m
[32m+[m[32m      <DebugOpt>[m
[32m+[m[32m        <uSim>0</uSim>[m
[32m+[m[32m        <uTrg>1</uTrg>[m
[32m+[m[32m        <sLdApp>1</sLdApp>[m
[32m+[m[32m        <sGomain>1</sGomain>[m
[32m+[m[32m        <sRbreak>1</sRbreak>[m
[32m+[m[32m        <sRwatch>1</sRwatch>[m
[32m+[m[32m        <sRmem>1</sRmem>[m
[32m+[m[32m        <sRfunc>1</sRfunc>[m
[32m+[m[32m        <sRbox>1</sRbox>[m
[32m+[m[32m        <tLdApp>1</tLdApp>[m
[32m+[m[32m        <tGomain>1</tGomain>[m
[32m+[m[32m        <tRbreak>1</tRbreak>[m
[32m+[m[32m        <tRwatch>1</tRwatch>[m
[32m+[m[32m        <tRmem>1</tRmem>[m
[32m+[m[32m        <tRfunc>0</tRfunc>[m
[32m+[m[32m        <tRbox>1</tRbox>[m
[32m+[m[32m        <tRtrace>1</tRtrace>[m
[32m+[m[32m        <sRSysVw>1</sRSysVw>[m
[32m+[m[32m        <tRSysVw>1</tRSysVw>[m
[32m+[m[32m        <sRunDeb>0</sRunDeb>[m
[32m+[m[32m        <sLrtime>0</sLrtime>[m
[32m+[m[32m        <nTsel>6</nTsel>[m
[32m+[m[32m        <sDll></sDll>[m
[32m+[m[32m        <sDllPa></sDllPa>[m
[32m+[m[32m        <sDlgDll></sDlgDll>[m
[32m+[m[32m        <sDlgPa></sDlgPa>[m
[32m+[m[32m        <sIfile></sIfile>[m
[32m+[m[32m        <tDll></tDll>[m
[32m+[m[32m        <tDllPa></tDllPa>[m
[32m+[m[32m        <tDlgDll></tDlgDll>[m
[32m+[m[32m        <tDlgPa></tDlgPa>[m
[32m+[m[32m        <tIfile></tIfile>[m
[32m+[m[32m        <pMon>Segger\JL2CM3.dll</pMon>[m
[32m+[m[32m      </DebugOpt>[m
[32m+[m[32m      <TargetDriverDllRegistry>[m
[32m+[m[32m        <SetRegEntry>[m
[32m+[m[32m          <Number>0</Number>[m
[32m+[m[32m          <Key>JL2CM3</Key>[m
[32m+[m[32m          <Name>-U20090928 -O78 -S0 -A0 -C0 -JU1 -JI127.0.0.1 -JP0 -RST0 -N00("ARM CoreSight SW-DP") -D00(1BA01477) -L00(0) -TO18 -TC10000000 -TP21 -TDS8007 -TDT0 -TDC1F -TIEFFFFFFFF -TIP8 -TB1 -TFE0 -FO7 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_512.FLM -FS08000000 -FL080000 -FP0($$Device:STM32F103ZE$Flash\STM32F10x_512.FLM)</Name>[m
[32m+[m[32m        </SetRegEntry>[m
[32m+[m[32m        <SetRegEntry>[m
[32m+[m[32m          <Number>0</Number>[m
[32m+[m[32m          <Key>CMSIS_AGDI</Key>[m
[32m+[m[32m          <Name>-X"" -U -O718 -S0 -C0 -P00 -FO15 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_512.FLM -FS08000000 -FL080000 -FP0($$Device:STM32F103ZE$Flash\STM32F10x_512.FLM)</Name>[m
[32m+[m[32m        </SetRegEntry>[m
[32m+[m[32m        <SetRegEntry>[m
[32m+[m[32m          <Number>0</Number>[m
[32m+[m[32m          <Key>UL2CM3</Key>[m
[32m+[m[32m          <Name>UL2CM3(-S0 -C0 -P0 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_512 -FS08000000 -FL080000 -FP0($$Device:STM32F103ZE$Flash\STM32F10x_512.FLM))</Name>[m
[32m+[m[32m        </SetRegEntry>[m
[32m+[m[32m      </TargetDriverDllRegistry>[m
[32m+[m[32m      <Breakpoint/>[m
[32m+[m[32m      <Tracepoint>[m
[32m+[m[32m        <THDelay>0</THDelay>[m
[32m+[m[32m      </Tracepoint>[m
[32m+[m[32m      <DebugFlag>[m
[32m+[m[32m        <trace>0</trace>[m
[32m+[m[32m        <periodic>1</periodic>[m
[32m+[m[32m        <aLwin>0</aLwin>[m
[32m+[m[32m        <aCover>0</aCover>[m
[32m+[m[32m        <aSer1>0</aSer1>[m
[32m+[m[32m        <aSer2>0</aSer2>[m
[32m+[m[32m        <aPa>0</aPa>[m
[32m+[m[32m        <viewmode>0</viewmode>[m
[32m+[m[32m        <vrSel>0</vrSel>[m
[32m+[m[32m        <aSym>0</aSym>[m
[32m+[m[32m        <aTbox>0</aTbox>[m
[32m+[m[32m        <AscS1>0</AscS1>[m
[32m+[m[32m        <AscS2>0</AscS2>[m
[32m+[m[32m        <AscS3>0</AscS3>[m
[32m+[m[32m        <aSer3>0</aSer3>[m
[32m+[m[32m        <eProf>0</eProf>[m
[32m+[m[32m        <aLa>0</aLa>[m
[32m+[m[32m        <aPa1>0</aPa1>[m
[32m+[m[32m        <AscS4>0</AscS4>[m
[32m+[m[32m        <aSer4>0</aSer4>[m
[32m+[m[32m        <StkLoc>0</StkLoc>[m
[32m+[m[32m        <TrcWin>0</TrcWin>[m
[32m+[m[32m        <newCpu>0</newCpu>[m
[32m+[m[32m        <uProt>0</uProt>[m
[32m+[m[32m      </DebugFlag>[m
[32m+[m[32m      <LintExecutable></LintExecutable>[m
[32m+[m[32m      <LintConfigFile></LintConfigFile>[m
[32m+[m[32m    </TargetOption>[m
[32m+[m[32m  </Target>[m
[32m+[m
[32m+[m[32m  <Group>[m
[32m+[m[32m    <GroupName>User</GroupName>[m
[32m+[m[32m    <tvExp>1</tvExp>[m
[32m+[m[32m    <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m    <cbSel>0</cbSel>[m
[32m+[m[32m    <RteFlg>0</RteFlg>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>1</GroupNumber>[m
[32m+[m[32m      <FileNumber>1</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\User\main.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>main.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>1</GroupNumber>[m
[32m+[m[32m      <FileNumber>2</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\User\stm32f10x_it.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>stm32f10x_it.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m  </Group>[m
[32m+[m
[32m+[m[32m  <Group>[m
[32m+[m[32m    <GroupName>Startup</GroupName>[m
[32m+[m[32m    <tvExp>1</tvExp>[m
[32m+[m[32m    <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m    <cbSel>0</cbSel>[m
[32m+[m[32m    <RteFlg>0</RteFlg>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>2</GroupNumber>[m
[32m+[m[32m      <FileNumber>3</FileNumber>[m
[32m+[m[32m      <FileType>2</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\Libraries\CMSIS\startup_stm32f10x_hd.s</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>startup_stm32f10x_hd.s</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m  </Group>[m
[32m+[m
[32m+[m[32m  <Group>[m
[32m+[m[32m    <GroupName>StdPeriph_Driver</GroupName>[m
[32m+[m[32m    <tvExp>1</tvExp>[m
[32m+[m[32m    <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m    <cbSel>0</cbSel>[m
[32m+[m[32m    <RteFlg>0</RteFlg>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>3</GroupNumber>[m
[32m+[m[32m      <FileNumber>4</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>stm32f10x_gpio.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>3</GroupNumber>[m
[32m+[m[32m      <FileNumber>5</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>stm32f10x_rcc.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m  </Group>[m
[32m+[m
[32m+[m[32m  <Group>[m
[32m+[m[32m    <GroupName>CMSIS</GroupName>[m
[32m+[m[32m    <tvExp>1</tvExp>[m
[32m+[m[32m    <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m    <cbSel>0</cbSel>[m
[32m+[m[32m    <RteFlg>0</RteFlg>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>4</GroupNumber>[m
[32m+[m[32m      <FileNumber>6</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\Libraries\CMSIS\core_cm3.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>core_cm3.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>4</GroupNumber>[m
[32m+[m[32m      <FileNumber>7</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\Libraries\CMSIS\system_stm32f10x.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>system_stm32f10x.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m  </Group>[m
[32m+[m
[32m+[m[32m  <Group>[m
[32m+[m[32m    <GroupName>APP</GroupName>[m
[32m+[m[32m    <tvExp>1</tvExp>[m
[32m+[m[32m    <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m    <cbSel>0</cbSel>[m
[32m+[m[32m    <RteFlg>0</RteFlg>[m
[32m+[m[32m    <File>[m
[32m+[m[32m      <GroupNumber>5</GroupNumber>[m
[32m+[m[32m      <FileNumber>8</FileNumber>[m
[32m+[m[32m      <FileType>1</FileType>[m
[32m+[m[32m      <tvExp>0</tvExp>[m
[32m+[m[32m      <Focus>0</Focus>[m
[32m+[m[32m      <tvExpOptDlg>0</tvExpOptDlg>[m
[32m+[m[32m      <bDave2>0</bDave2>[m
[32m+[m[32m      <PathWithFileName>.\APP\LED\led.c</PathWithFileName>[m
[32m+[m[32m      <FilenameWithoutPath>led.c</FilenameWithoutPath>[m
[32m+[m[32m      <RteFlg>0</RteFlg>[m
[32m+[m[32m      <bShared>0</bShared>[m
[32m+[m[32m    </File>[m
[32m+[m[32m  </Group>[m
[32m+[m
[32m+[m[32m</ProjectOpt>[m
[1mdiff --git a/Template.uvprojx b/Template.uvprojx[m
[1mnew file mode 100644[m
[1mindex 0000000..7c81d92[m
[1m--- /dev/null[m
[1m+++ b/Template.uvprojx[m
[36m@@ -0,0 +1,477 @@[m
[32m+[m[32m<?xml version="1.0" encoding="UTF-8" standalone="no" ?>[m
[32m+[m[32m<Project xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="project_projx.xsd">[m
[32m+[m
[32m+[m[32m  <SchemaVersion>2.1</SchemaVersion>[m
[32m+[m
[32m+[m[32m  <Header>### uVision Project, (C) Keil Software</Header>[m
[32m+[m
[32m+[m[32m  <Targets>[m
[32m+[m[32m    <Target>[m
[32m+[m[32m      <TargetName>Target 1</TargetName>[m
[32m+[m[32m      <ToolsetNumber>0x4</ToolsetNumber>[m
[32m+[m[32m      <ToolsetName>ARM-ADS</ToolsetName>[m
[32m+[m[32m      <TargetOption>[m
[32m+[m[32m        <TargetCommonOption>[m
[32m+[m[32m          <Device>STM32F103ZE</Device>[m
[32m+[m[32m          <Vendor>STMicroelectronics</Vendor>[m
[32m+[m[32m          <PackID>Keil.STM32F1xx_DFP.1.0.5</PackID>[m
[32m+[m[32m          <PackURL>http://www.keil.com/pack/</PackURL>[m
[32m+[m[32m          <Cpu>IROM(0x08000000,0x80000) IRAM(0x20000000,0x10000) CPUTYPE("Cortex-M3") CLOCK(12000000) ELITTLE</Cpu>[m
[32m+[m[32m          <FlashUtilSpec></FlashUtilSpec>[m
[32m+[m[32m          <StartupFile></StartupFile>[m
[32m+[m[32m          <FlashDriverDll>UL2CM3(-S0 -C0 -P0 -FD20000000 -FC1000 -FN1 -FF0STM32F10x_512 -FS08000000 -FL080000 -FP0($$Device:STM32F103ZE$Flash\STM32F10x_512.FLM))</FlashDriverDll>[m
[32m+[m[32m          <DeviceId>0</DeviceId>[m
[32m+[m[32m          <RegisterFile>$$Device:STM32F103ZE$Device\Include\stm32f10x.h</RegisterFile>[m
[32m+[m[32m          <MemoryEnv></MemoryEnv>[m
[32m+[m[32m          <Cmp></Cmp>[m
[32m+[m[32m          <Asm></Asm>[m
[32m+[m[32m          <Linker></Linker>[m
[32m+[m[32m          <OHString></OHString>[m
[32m+[m[32m          <InfinionOptionDll></InfinionOptionDll>[m
[32m+[m[32m          <SLE66CMisc></SLE66CMisc>[m
[32m+[m[32m          <SLE66AMisc></SLE66AMisc>[m
[32m+[m[32m          <SLE66LinkerMisc></SLE66LinkerMisc>[m
[32m+[m[32m          <SFDFile>$$Device:STM32F103ZE$SVD\STM32F103xx.svd</SFDFile>[m
[32m+[m[32m          <bCustSvd>0</bCustSvd>[m
[32m+[m[32m          <UseEnv>0</UseEnv>[m
[32m+[m[32m          <BinPath></BinPath>[m
[32m+[m[32m          <IncludePath></IncludePath>[m
[32m+[m[32m          <LibPath></LibPath>[m
[32m+[m[32m          <RegisterFilePath></RegisterFilePath>[m
[32m+[m[32m          <DBRegisterFilePath></DBRegisterFilePath>[m
[32m+[m[32m          <TargetStatus>[m
[32m+[m[32m            <Error>0</Error>[m
[32m+[m[32m            <ExitCodeStop>0</ExitCodeStop>[m
[32m+[m[32m            <ButtonStop>0</ButtonStop>[m
[32m+[m[32m            <NotGenerated>0</NotGenerated>[m
[32m+[m[32m            <InvalidFlash>1</InvalidFlash>[m
[32m+[m[32m          </TargetStatus>[m
[32m+[m[32m          <OutputDirectory>.\Obj\</OutputDirectory>[m
[32m+[m[32m          <OutputName>Template</OutputName>[m
[32m+[m[32m          <CreateExecutable>1</CreateExecutable>[m
[32m+[m[32m          <CreateLib>0</CreateLib>[m
[32m+[m[32m          <CreateHexFile>1</CreateHexFile>[m
[32m+[m[32m          <DebugInformation>1</DebugInformation>[m
[32m+[m[32m          <BrowseInformation>1</BrowseInformation>[m
[32m+[m[32m          <ListingPath>.\Obj\</ListingPath>[m
[32m+[m[32m          <HexFormatSelection>1</HexFormatSelection>[m
[32m+[m[32m          <Merge32K>0</Merge32K>[m
[32m+[m[32m          <CreateBatchFile>1</CreateBatchFile>[m
[32m+[m[32m          <BeforeCompile>[m
[32m+[m[32m            <RunUserProg1>0</RunUserProg1>[m
[32m+[m[32m            <RunUserProg2>0</RunUserProg2>[m
[32m+[m[32m            <UserProg1Name></UserProg1Name>[m
[32m+[m[32m            <UserProg2Name></UserProg2Name>[m
[32m+[m[32m            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>[m
[32m+[m[32m            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>[m
[32m+[m[32m            <nStopU1X>0</nStopU1X>[m
[32m+[m[32m            <nStopU2X>0</nStopU2X>[m
[32m+[m[32m          </BeforeCompile>[m
[32m+[m[32m          <BeforeMake>[m
[32m+[m[32m            <RunUserProg1>0</RunUserProg1>[m
[32m+[m[32m            <RunUserProg2>0</RunUserProg2>[m
[32m+[m[32m            <UserProg1Name></UserProg1Name>[m
[32m+[m[32m            <UserProg2Name></UserProg2Name>[m
[32m+[m[32m            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>[m
[32m+[m[32m            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>[m
[32m+[m[32m            <nStopB1X>0</nStopB1X>[m
[32m+[m[32m            <nStopB2X>0</nStopB2X>[m
[32m+[m[32m          </BeforeMake>[m
[32m+[m[32m          <AfterMake>[m
[32m+[m[32m            <RunUserProg1>0</RunUserProg1>[m
[32m+[m[32m            <RunUserProg2>0</RunUserProg2>[m
[32m+[m[32m            <UserProg1Name></UserProg1Name>[m
[32m+[m[32m            <UserProg2Name></UserProg2Name>[m
[32m+[m[32m            <UserProg1Dos16Mode>0</UserProg1Dos16Mode>[m
[32m+[m[32m            <UserProg2Dos16Mode>0</UserProg2Dos16Mode>[m
[32m+[m[32m          </AfterMake>[m
[32m+[m[32m          <SelectedForBatchBuild>0</SelectedForBatchBuild>[m
[32m+[m[32m          <SVCSIdString></SVCSIdString>[m
[32m+[m[32m        </TargetCommonOption>[m
[32m+[m[32m        <CommonProperty>[m
[32m+[m[32m          <UseCPPCompiler>0</UseCPPCompiler>[m
[32m+[m[32m          <RVCTCodeConst>0</RVCTCodeConst>[m
[32m+[m[32m          <RVCTZI>0</RVCTZI>[m
[32m+[m[32m          <RVCTOtherData>0</RVCTOtherData>[m
[32m+[m[32m          <ModuleSelection>0</ModuleSelection>[m
[32m+[m[32m          <IncludeInBuild>1</IncludeInBuild>[m
[32m+[m[32m          <AlwaysBuild>0</AlwaysBuild>[m
[32m+[m[32m          <GenerateAssemblyFile>0</GenerateAssemblyFile>[m
[32m+[m[32m          <AssembleAssemblyFile>0</AssembleAssemblyFile>[m
[32m+[m[32m          <PublicsOnly>0</PublicsOnly>[m
[32m+[m[32m          <StopOnExitCode>3</StopOnExitCode>[m
[32m+[m[32m          <CustomArgument></CustomArgument>[m
[32m+[m[32m          <IncludeLibraryModules></IncludeLibraryModules>[m
[32m+[m[32m          <ComprImg>1</ComprImg>[m
[32m+[m[32m        </CommonProperty>[m
[32m+[m[32m        <DllOption>[m
[32m+[m[32m          <SimDllName>SARMCM3.DLL</SimDllName>[m
[32m+[m[32m          <SimDllArguments> -REMAP</SimDllArguments>[m
[32m+[m[32m          <SimDlgDll>DCM.DLL</SimDlgDll>[m
[32m+[m[32m          <SimDlgDllArguments>-pCM3</SimDlgDllArguments>[m
[32m+[m[32m          <TargetDllName>SARMCM3.DLL</TargetDllName>[m
[32m+[m[32m          <TargetDllArguments></TargetDllArguments>[m
[32m+[m[32m          <TargetDlgDll>TCM.DLL</TargetDlgDll>[m
[32m+[m[32m          <TargetDlgDllArguments>-pCM3</TargetDlgDllArguments>[m
[32m+[m[32m        </DllOption>[m
[32m+[m[32m        <DebugOption>[m
[32m+[m[32m          <OPTHX>[m
[32m+[m[32m            <HexSelection>1</HexSelection>[m
[32m+[m[32m            <HexRangeLowAddress>0</HexRangeLowAddress>[m
[32m+[m[32m            <HexRangeHighAddress>0</HexRangeHighAddress>[m
[32m+[m[32m            <HexOffset>0</HexOffset>[m
[32m+[m[32m            <Oh166RecLen>16</Oh166RecLen>[m
[32m+[m[32m          </OPTHX>[m
[32m+[m[32m          <Simulator>[m
[32m+[m[32m            <UseSimulator>0</UseSimulator>[m
[32m+[m[32m            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>[m
[32m+[m[32m            <RunToMain>1</RunToMain>[m
[32m+[m[32m            <RestoreBreakpoints>1</RestoreBreakpoints>[m
[32m+[m[32m            <RestoreWatchpoints>1</RestoreWatchpoints>[m
[32m+[m[32m            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>[m
[32m+[m[32m            <RestoreFunctions>1</RestoreFunctions>[m
[32m+[m[32m            <RestoreToolbox>1</RestoreToolbox>[m
[32m+[m[32m            <LimitSpeedToRealTime>0</LimitSpeedToRealTime>[m
[32m+[m[32m            <RestoreSysVw>1</RestoreSysVw>[m
[32m+[m[32m          </Simulator>[m
[32m+[m[32m          <Target>[m
[32m+[m[32m            <UseTarget>1</UseTarget>[m
[32m+[m[32m            <LoadApplicationAtStartup>1</LoadApplicationAtStartup>[m
[32m+[m[32m            <RunToMain>1</RunToMain>[m
[32m+[m[32m            <RestoreBreakpoints>1</RestoreBreakpoints>[m
[32m+[m[32m            <RestoreWatchpoints>1</RestoreWatchpoints>[m
[32m+[m[32m            <RestoreMemoryDisplay>1</RestoreMemoryDisplay>[m
[32m+[m[32m            <RestoreFunctions>0</RestoreFunctions>[m
[32m+[m[32m            <RestoreToolbox>1</RestoreToolbox>[m
[32m+[m[32m            <RestoreTracepoints>1</RestoreTracepoints>[m
[32m+[m[32m            <RestoreSysVw>1</RestoreSysVw>[m
[32m+[m[32m          </Target>[m
[32m+[m[32m          <RunDebugAfterBuild>0</RunDebugAfterBuild>[m
[32m+[m[32m          <TargetSelection>6</TargetSelection>[m
[32m+[m[32m          <SimDlls>[m
[32m+[m[32m            <CpuDll></CpuDll>[m
[32m+[m[32m            <CpuDllArguments></CpuDllArguments>[m
[32m+[m[32m            <PeripheralDll></PeripheralDll>[m
[32m+[m[32m            <PeripheralDllArguments></PeripheralDllArguments>[m
[32m+[m[32m            <InitializationFile></InitializationFile>[m
[32m+[m[32m          </SimDlls>[m
[32m+[m[32m          <TargetDlls>[m
[32m+[m[32m            <CpuDll></CpuDll>[m
[32m+[m[32m            <CpuDllArguments></CpuDllArguments>[m
[32m+[m[32m            <PeripheralDll></PeripheralDll>[m
[32m+[m[32m            <PeripheralDllArguments></PeripheralDllArguments>[m
[32m+[m[32m            <InitializationFile></InitializationFile>[m
[32m+[m[32m            <Driver>Segger\JL2CM3.dll</Driver>[m
[32m+[m[32m          </TargetDlls>[m
[32m+[m[32m        </DebugOption>[m
[32m+[m[32m        <Utilities>[m
[32m+[m[32m          <Flash1>[m
[32m+[m[32m            <UseTargetDll>1</UseTargetDll>[m
[32m+[m[32m            <UseExternalTool>0</UseExternalTool>[m
[32m+[m[32m            <RunIndependent>0</RunIndependent>[m
[32m+[m[32m            <UpdateFlashBeforeDebugging>1</UpdateFlashBeforeDebugging>[m
[32m+[m[32m            <Capability>1</Capability>[m
[32m+[m[32m            <DriverSelection>4099</DriverSelection>[m
[32m+[m[32m          </Flash1>[m
[32m+[m[32m          <bUseTDR>0</bUseTDR>[m
[32m+[m[32m          <Flash2>Segger\JL2CM3.dll</Flash2>[m
[32m+[m[32m          <Flash3>"" ()</Flash3>[m
[32m+[m[32m          <Flash4></Flash4>[m
[32m+[m[32m          <pFcarmOut></pFcarmOut>[m
[32m+[m[32m          <pFcarmGrp></pFcarmGrp>[m
[32m+[m[32m          <pFcArmRoot></pFcArmRoot>[m
[32m+[m[32m          <FcArmLst>0</FcArmLst>[m
[32m+[m[32m        </Utilities>[m
[32m+[m[32m        <TargetArmAds>[m
[32m+[m[32m          <ArmAdsMisc>[m
[32m+[m[32m            <GenerateListings>0</GenerateListings>[m
[32m+[m[32m            <asHll>1</asHll>[m
[32m+[m[32m            <asAsm>1</asAsm>[m
[32m+[m[32m            <asMacX>1</asMacX>[m
[32m+[m[32m            <asSyms>1</asSyms>[m
[32m+[m[32m            <asFals>1</asFals>[m
[32m+[m[32m            <asDbgD>1</asDbgD>[m
[32m+[m[32m            <asForm>1</asForm>[m
[32m+[m[32m            <ldLst>0</ldLst>[m
[32m+[m[32m            <ldmm>1</ldmm>[m
[32m+[m[32m            <ldXref>1</ldXref>[m
[32m+[m[32m            <BigEnd>0</BigEnd>[m
[32m+[m[32m            <AdsALst>1</AdsALst>[m
[32m+[m[32m            <AdsACrf>1</AdsACrf>[m
[32m+[m[32m            <AdsANop>0</AdsANop>[m
[32m+[m[32m            <AdsANot>0</AdsANot>[m
[32m+[m[32m            <AdsLLst>1</AdsLLst>[m
[32m+[m[32m            <AdsLmap>1</AdsLmap>[m
[32m+[m[32m            <AdsLcgr>1</AdsLcgr>[m
[32m+[m[32m            <AdsLsym>1</AdsLsym>[m
[32m+[m[32m            <AdsLszi>1</AdsLszi>[m
[32m+[m[32m            <AdsLtoi>1</AdsLtoi>[m
[32m+[m[32m            <AdsLsun>1</AdsLsun>[m
[32m+[m[32m            <AdsLven>1</AdsLven>[m
[32m+[m[32m            <AdsLsxf>1</AdsLsxf>[m
[32m+[m[32m            <RvctClst>0</RvctClst>[m
[32m+[m[32m            <GenPPlst>0</GenPPlst>[m
[32m+[m[32m            <AdsCpuType>"Cortex-M3"</AdsCpuType>[m
[32m+[m[32m            <RvctDeviceName></RvctDeviceName>[m
[32m+[m[32m            <mOS>0</mOS>[m
[32m+[m[32m            <uocRom>0</uocRom>[m
[32m+[m[32m            <uocRam>0</uocRam>[m
[32m+[m[32m            <hadIROM>1</hadIROM>[m
[32m+[m[32m            <hadIRAM>1</hadIRAM>[m
[32m+[m[32m            <hadXRAM>0</hadXRAM>[m
[32m+[m[32m            <uocXRam>0</uocXRam>[m
[32m+[m[32m            <RvdsVP>0</RvdsVP>[m
[32m+[m[32m            <hadIRAM2>0</hadIRAM2>[m
[32m+[m[32m            <hadIROM2>0</hadIROM2>[m
[32m+[m[32m            <StupSel>8</StupSel>[m
[32m+[m[32m            <useUlib>1</useUlib>[m
[32m+[m[32m            <EndSel>0</EndSel>[m
[32m+[m[32m            <uLtcg>0</uLtcg>[m
[32m+[m[32m            <RoSelD>3</RoSelD>[m
[32m+[m[32m            <RwSelD>3</RwSelD>[m
[32m+[m[32m            <CodeSel>0</CodeSel>[m
[32m+[m[32m            <OptFeed>0</OptFeed>[m
[32m+[m[32m            <NoZi1>0</NoZi1>[m
[32m+[m[32m            <NoZi2>0</NoZi2>[m
[32m+[m[32m            <NoZi3>0</NoZi3>[m
[32m+[m[32m            <NoZi4>0</NoZi4>[m
[32m+[m[32m            <NoZi5>0</NoZi5>[m
[32m+[m[32m            <Ro1Chk>0</Ro1Chk>[m
[32m+[m[32m            <Ro2Chk>0</Ro2Chk>[m
[32m+[m[32m            <Ro3Chk>0</Ro3Chk>[m
[32m+[m[32m            <Ir1Chk>1</Ir1Chk>[m
[32m+[m[32m            <Ir2Chk>0</Ir2Chk>[m
[32m+[m[32m            <Ra1Chk>0</Ra1Chk>[m
[32m+[m[32m            <Ra2Chk>0</Ra2Chk>[m
[32m+[m[32m            <Ra3Chk>0</Ra3Chk>[m
[32m+[m[32m            <Im1Chk>1</Im1Chk>[m
[32m+[m[32m            <Im2Chk>0</Im2Chk>[m
[32m+[m[32m            <OnChipMemories>[m
[32m+[m[32m              <Ocm1>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </Ocm1>[m
[32m+[m[32m              <Ocm2>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </Ocm2>[m
[32m+[m[32m              <Ocm3>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </Ocm3>[m
[32m+[m[32m              <Ocm4>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </Ocm4>[m
[32m+[m[32m              <Ocm5>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </Ocm5>[m
[32m+[m[32m              <Ocm6>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </Ocm6>[m
[32m+[m[32m              <IRAM>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x20000000</StartAddress>[m
[32m+[m[32m                <Size>0x10000</Size>[m
[32m+[m[32m              </IRAM>[m
[32m+[m[32m              <IROM>[m
[32m+[m[32m                <Type>1</Type>[m
[32m+[m[32m                <StartAddress>0x8000000</StartAddress>[m
[32m+[m[32m                <Size>0x80000</Size>[m
[32m+[m[32m              </IROM>[m
[32m+[m[32m              <XRAM>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </XRAM>[m
[32m+[m[32m              <OCR_RVCT1>[m
[32m+[m[32m                <Type>1</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT1>[m
[32m+[m[32m              <OCR_RVCT2>[m
[32m+[m[32m                <Type>1</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT2>[m
[32m+[m[32m              <OCR_RVCT3>[m
[32m+[m[32m                <Type>1</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT3>[m
[32m+[m[32m              <OCR_RVCT4>[m
[32m+[m[32m                <Type>1</Type>[m
[32m+[m[32m                <StartAddress>0x8000000</StartAddress>[m
[32m+[m[32m                <Size>0x80000</Size>[m
[32m+[m[32m              </OCR_RVCT4>[m
[32m+[m[32m              <OCR_RVCT5>[m
[32m+[m[32m                <Type>1</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT5>[m
[32m+[m[32m              <OCR_RVCT6>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT6>[m
[32m+[m[32m              <OCR_RVCT7>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT7>[m
[32m+[m[32m              <OCR_RVCT8>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT8>[m
[32m+[m[32m              <OCR_RVCT9>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x20000000</StartAddress>[m
[32m+[m[32m                <Size>0x10000</Size>[m
[32m+[m[32m              </OCR_RVCT9>[m
[32m+[m[32m              <OCR_RVCT10>[m
[32m+[m[32m                <Type>0</Type>[m
[32m+[m[32m                <StartAddress>0x0</StartAddress>[m
[32m+[m[32m                <Size>0x0</Size>[m
[32m+[m[32m              </OCR_RVCT10>[m
[32m+[m[32m            </OnChipMemories>[m
[32m+[m[32m            <RvctStartVector></RvctStartVector>[m
[32m+[m[32m          </ArmAdsMisc>[m
[32m+[m[32m          <Cads>[m
[32m+[m[32m            <interw>1</interw>[m
[32m+[m[32m            <Optim>1</Optim>[m
[32m+[m[32m            <oTime>0</oTime>[m
[32m+[m[32m            <SplitLS>0</SplitLS>[m
[32m+[m[32m            <OneElfS>1</OneElfS>[m
[32m+[m[32m            <Strict>0</Strict>[m
[32m+[m[32m            <EnumInt>0</EnumInt>[m
[32m+[m[32m            <PlainCh>0</PlainCh>[m
[32m+[m[32m            <Ropi>0</Ropi>[m
[32m+[m[32m            <Rwpi>0</Rwpi>[m
[32m+[m[32m            <wLevel>2</wLevel>[m
[32m+[m[32m            <uThumb>0</uThumb>[m
[32m+[m[32m            <uSurpInc>0</uSurpInc>[m
[32m+[m[32m            <uC99>1</uC99>[m
[32m+[m[32m            <useXO>0</useXO>[m
[32m+[m[32m            <VariousControls>[m
[32m+[m[32m              <MiscControls></MiscControls>[m
[32m+[m[32m              <Define>USE_STDPERIPH_DRIVER,STM32F10X_HD</Define>[m
[32m+[m[32m              <Undefine></Undefine>[m
[32m+[m[32m              <IncludePath>.\User;.\Libraries\CMSIS;.\Libraries\STM32F10x_StdPeriph_Driver\inc;.\APP\LED</IncludePath>[m
[32m+[m[32m            </VariousControls>[m
[32m+[m[32m          </Cads>[m
[32m+[m[32m          <Aads>[m
[32m+[m[32m            <interw>1</interw>[m
[32m+[m[32m            <Ropi>0</Ropi>[m
[32m+[m[32m            <Rwpi>0</Rwpi>[m
[32m+[m[32m            <thumb>0</thumb>[m
[32m+[m[32m            <SplitLS>0</SplitLS>[m
[32m+[m[32m            <SwStkChk>0</SwStkChk>[m
[32m+[m[32m            <NoWarn>0</NoWarn>[m
[32m+[m[32m            <uSurpInc>0</uSurpInc>[m
[32m+[m[32m            <useXO>0</useXO>[m
[32m+[m[32m            <VariousControls>[m
[32m+[m[32m              <MiscControls></MiscControls>[m
[32m+[m[32m              <Define></Define>[m
[32m+[m[32m              <Undefine></Undefine>[m
[32m+[m[32m              <IncludePath></IncludePath>[m
[32m+[m[32m            </VariousControls>[m
[32m+[m[32m          </Aads>[m
[32m+[m[32m          <LDads>[m
[32m+[m[32m            <umfTarg>1</umfTarg>[m
[32m+[m[32m            <Ropi>0</Ropi>[m
[32m+[m[32m            <Rwpi>0</Rwpi>[m
[32m+[m[32m            <noStLib>0</noStLib>[m
[32m+[m[32m            <RepFail>1</RepFail>[m
[32m+[m[32m            <useFile>0</useFile>[m
[32m+[m[32m            <TextAddressRange>0x08000000</TextAddressRange>[m
[32m+[m[32m            <DataAddressRange>0x20000000</DataAddressRange>[m
[32m+[m[32m            <pXoBase></pXoBase>[m
[32m+[m[32m            <ScatterFile></ScatterFile>[m
[32m+[m[32m            <IncludeLibs></IncludeLibs>[m
[32m+[m[32m            <IncludeLibsPath></IncludeLibsPath>[m
[32m+[m[32m            <Misc></Misc>[m
[32m+[m[32m            <LinkerInputFile></LinkerInputFile>[m
[32m+[m[32m            <DisabledWarnings></DisabledWarnings>[m
[32m+[m[32m          </LDads>[m
[32m+[m[32m        </TargetArmAds>[m
[32m+[m[32m      </TargetOption>[m
[32m+[m[32m      <Groups>[m
[32m+[m[32m        <Group>[m
[32m+[m[32m          <GroupName>User</GroupName>[m
[32m+[m[32m          <Files>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>main.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\User\main.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>stm32f10x_it.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\User\stm32f10x_it.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m          </Files>[m
[32m+[m[32m        </Group>[m
[32m+[m[32m        <Group>[m
[32m+[m[32m          <GroupName>Startup</GroupName>[m
[32m+[m[32m          <Files>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>startup_stm32f10x_hd.s</FileName>[m
[32m+[m[32m              <FileType>2</FileType>[m
[32m+[m[32m              <FilePath>.\Libraries\CMSIS\startup_stm32f10x_hd.s</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m          </Files>[m
[32m+[m[32m        </Group>[m
[32m+[m[32m        <Group>[m
[32m+[m[32m          <GroupName>StdPeriph_Driver</GroupName>[m
[32m+[m[32m          <Files>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>stm32f10x_gpio.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>stm32f10x_rcc.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rcc.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m          </Files>[m
[32m+[m[32m        </Group>[m
[32m+[m[32m        <Group>[m
[32m+[m[32m          <GroupName>CMSIS</GroupName>[m
[32m+[m[32m          <Files>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>core_cm3.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\Libraries\CMSIS\core_cm3.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>system_stm32f10x.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\Libraries\CMSIS\system_stm32f10x.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m          </Files>[m
[32m+[m[32m        </Group>[m
[32m+[m[32m        <Group>[m
[32m+[m[32m          <GroupName>APP</GroupName>[m
[32m+[m[32m          <Files>[m
[32m+[m[32m            <File>[m
[32m+[m[32m              <FileName>led.c</FileName>[m
[32m+[m[32m              <FileType>1</FileType>[m
[32m+[m[32m              <FilePath>.\APP\LED\led.c</FilePath>[m
[32m+[m[32m            </File>[m
[32m+[m[32m          </Files>[m
[32m+[m[32m        </Group>[m
[32m+[m[32m      </Groups>[m
[32m+[m[32m    </Target>[m
[32m+[m[32m  </Targets>[m
[32m+[m
[32m+[m[32m</Project>[m
[1mdiff --git a/User/main.c b/User/main.c[m
[1mnew file mode 100644[m
[1mindex 0000000..a1ca891[m
[1m--- /dev/null[m
[1m+++ b/User/main.c[m
[36m@@ -0,0 +1,21 @@[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m[32m#include "led.h"[m
[32m+[m[32mtypedef unsigned int u32;[m
[32m+[m
[32m+[m[32mvoid DelayMs(u32 t)[m
[32m+[m[32m{[m
[32m+[m		[32mt=t*5144;//5143[m
[32m+[m		[32mwhile(t--);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mint main()[m
[32m+[m[32m{[m
[32m+[m		[32mLED_Init();[m
[32m+[m		[32mwhile(1)[m
[32m+[m		[32m{[m
[32m+[m				[32mGPIO_ResetBits(LEN_PORT,GPIO_Pin_0);[m[41m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      [m
[32m+[m				[32mDelayMs(1000);[m
[32m+[m				[32mGPIO_SetBits(LEN_PORT,GPIO_Pin_0);[m
[32m+[m				[32mDelayMs(1000);[m
[32m+[m		[32m}[m
[32m+[m[32m}[m
[1mdiff --git a/User/stm32f10x.h b/User/stm32f10x.h[m
[1mnew file mode 100644[m
[1mindex 0000000..8bf7624[m
[1m--- /dev/null[m
[1m+++ b/User/stm32f10x.h[m
[36m@@ -0,0 +1,8336 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    stm32f10x.h[m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    11-March-2011[m
[32m+[m[32m  * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer Header File.[m[41m [m
[32m+[m[32m  *          This file contains all the peripheral register's definitions, bits[m[41m [m
[32m+[m[32m  *          definitions and memory mapping for STM32F10x Connectivity line,[m[41m [m
[32m+[m[32m  *          High density, High density value line, Medium density,[m[41m [m
[32m+[m[32m  *          Medium density Value line, Low density, Low density Value line[m[41m [m
[32m+[m[32m  *          and XL-density devices.[m
[32m+[m[32m  *[m
[32m+[m[32m  *          The file is the unique include file that the application programmer[m
[32m+[m[32m  *          is using in the C source code, usually in main.c. This file contains:[m
[32m+[m[32m  *           - Configuration section that allows to select:[m
[32m+[m[32m  *              - The device used in the target application[m
[32m+[m[32m  *              - To use or not the peripheralís drivers in application code(i.e.[m[41m [m
[32m+[m[32m  *                code will be based on direct access to peripheralís registers[m[41m [m
[32m+[m[32m  *                rather than drivers API), this option is controlled by[m[41m [m
[32m+[m[32m  *                "#define USE_STDPERIPH_DRIVER"[m
[32m+[m[32m  *              - To change few application-specific parameters such as the HSE[m[41m [m
[32m+[m[32m  *                crystal frequency[m
[32m+[m[32m  *           - Data structures and the address mapping for all peripherals[m
[32m+[m[32m  *           - Peripheral's registers declarations and bits definition[m
[32m+[m[32m  *           - Macros to access peripheralís registers hardware[m
[32m+[m[32m  *[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup CMSIS[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup stm32f10x[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m    [m
[32m+[m[32m#ifndef __STM32F10x_H[m
[32m+[m[32m#define __STM32F10x_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m/** @addtogroup Library_configuration_section[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/* Uncomment the line below according to the target STM32 device used in your[m
[32m+[m[32m   application[m[41m [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)[m[41m [m
[32m+[m[32m  /* #define STM32F10X_LD */     /*!< STM32F10X_LD: STM32 Low density devices */[m
[32m+[m[32m  /* #define STM32F10X_LD_VL */  /*!< STM32F10X_LD_VL: STM32 Low density Value Line devices */[m[41m  [m
[32m+[m[32m  /* #define STM32F10X_MD */     /*!< STM32F10X_MD: STM32 Medium density devices */[m
[32m+[m[32m  /* #define STM32F10X_MD_VL */  /*!< STM32F10X_MD_VL: STM32 Medium density Value Line devices */[m[41m  [m
[32m+[m[32m  /* #define STM32F10X_HD */     /*!< STM32F10X_HD: STM32 High density devices */[m
[32m+[m[32m  /* #define STM32F10X_HD_VL */  /*!< STM32F10X_HD_VL: STM32 High density value line devices */[m[41m  [m
[32m+[m[32m  /* #define STM32F10X_XL */     /*!< STM32F10X_XL: STM32 XL-density devices */[m
[32m+[m[32m  /* #define STM32F10X_CL */     /*!< STM32F10X_CL: STM32 Connectivity line devices */[m
[32m+[m[32m#endif[m
[32m+[m[32m/*  Tip: To avoid modifying this file each time you need to switch between these[m
[32m+[m[32m        devices, you can define the device in your toolchain compiler preprocessor.[m
[32m+[m
[32m+[m[32m - Low-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers[m
[32m+[m[32m   where the Flash memory density ranges between 16 and 32 Kbytes.[m
[32m+[m[32m - Low-density value line devices are STM32F100xx microcontrollers where the Flash[m
[32m+[m[32m   memory density ranges between 16 and 32 Kbytes.[m
[32m+[m[32m - Medium-density devices are STM32F101xx, STM32F102xx and STM32F103xx microcontrollers[m
[32m+[m[32m   where the Flash memory density ranges between 64 and 128 Kbytes.[m
[32m+[m[32m - Medium-density value line devices are STM32F100xx microcontrollers where the[m[41m [m
[32m+[m[32m   Flash memory density ranges between 64 and 128 Kbytes.[m[41m   [m
[32m+[m[32m - High-density devices are STM32F101xx and STM32F103xx microcontrollers where[m
[32m+[m[32m   the Flash memory density ranges between 256 and 512 Kbytes.[m
[32m+[m[32m - High-density value line devices are STM32F100xx microcontrollers where the[m[41m [m
[32m+[m[32m   Flash memory density ranges between 256 and 512 Kbytes.[m[41m   [m
[32m+[m[32m - XL-density devices are STM32F101xx and STM32F103xx microcontrollers where[m
[32m+[m[32m   the Flash memory density ranges between 512 and 1024 Kbytes.[m
[32m+[m[32m - Connectivity line devices are STM32F105xx and STM32F107xx microcontrollers.[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD) && !defined (STM32F10X_HD_VL) && !defined (STM32F10X_XL) && !defined (STM32F10X_CL)[m
[32m+[m[32m #error "Please select first the target STM32F10x device used in your application (in stm32f10x.h file)"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if !defined  USE_STDPERIPH_DRIVER[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Comment the line below if you will not use the peripherals drivers.[m
[32m+[m[32m   In this case, these drivers will not be included and the application code will[m[41m [m
[32m+[m[32m   be based on direct access to peripherals registers[m[41m [m
[32m+[m[32m   */[m
[32m+[m[32m  /*#define USE_STDPERIPH_DRIVER*/[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief In the following line adjust the value of External High Speed oscillator (HSE)[m
[32m+[m[32m   used in your application[m[41m [m
[32m+[m[41m   [m
[32m+[m[32m   Tip: To avoid modifying this file each time you need to use different HSE, you[m
[32m+[m[32m        can define the HSE value in your toolchain compiler preprocessor.[m
[32m+[m[32m  */[m[41m           [m
[32m+[m[32m#if !defined  HSE_VALUE[m
[32m+[m[32m #ifdef STM32F10X_CL[m[41m   [m
[32m+[m[32m  #define HSE_VALUE    ((uint32_t)25000000) /*!< Value of the External oscillator in Hz */[m
[32m+[m[32m #else[m[41m [m
[32m+[m[32m  #define HSE_VALUE    ((uint32_t)8000000) /*!< Value of the External oscillator in Hz */[m
[32m+[m[32m #endif /* STM32F10X_CL */[m
[32m+[m[32m#endif /* HSE_VALUE */[m
[32m+[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief In the following line adjust the External High Speed oscillator (HSE) Startup[m[41m [m
[32m+[m[32m   Timeout value[m[41m [m
[32m+[m[32m   */[m
[32m+[m[32m#define HSE_STARTUP_TIMEOUT   ((uint16_t)0x0500) /*!< Time out for HSE start up */[m
[32m+[m
[32m+[m[32m#define HSI_VALUE    ((uint32_t)8000000) /*!< Value of the Internal oscillator in Hz*/[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief STM32F10x Standard Peripheral Library version number[m
[32m+[m[32m   */[m
[32m+[m[32m#define __STM32F10X_STDPERIPH_VERSION_MAIN   (0x03) /*!< [31:24] main version */[m[41m                                  [m
[32m+[m[32m#define __STM32F10X_STDPERIPH_VERSION_SUB1   (0x05) /*!< [23:16] sub1 version */[m
[32m+[m[32m#define __STM32F10X_STDPERIPH_VERSION_SUB2   (0x00) /*!< [15:8]  sub2 version */[m
[32m+[m[32m#define __STM32F10X_STDPERIPH_VERSION_RC     (0x00) /*!< [7:0]  release candidate */[m[41m [m
[32m+[m[32m#define __STM32F10X_STDPERIPH_VERSION       ( (__STM32F10X_STDPERIPH_VERSION_MAIN << 24)\[m
[32m+[m[32m                                             |(__STM32F10X_STDPERIPH_VERSION_SUB1 << 16)\[m
[32m+[m[32m                                             |(__STM32F10X_STDPERIPH_VERSION_SUB2 << 8)\[m
[32m+[m[32m                                             |(__STM32F10X_STDPERIPH_VERSION_RC))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup Configuration_section_for_CMSIS[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief Configuration of the Cortex-M3 Processor and Core Peripherals[m[41m [m
[32m+[m[32m */[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m #define __MPU_PRESENT             1 /*!< STM32 XL-density devices provide an MPU */[m
[32m+[m[32m#else[m
[32m+[m[32m #define __MPU_PRESENT             0 /*!< Other STM32 devices does not provide an MPU */[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m[32m#define __NVIC_PRIO_BITS          4 /*!< STM32 uses 4 Bits for the Priority Levels    */[m
[32m+[m[32m#define __Vendor_SysTickConfig    0 /*!< Set to 1 if different SysTick Config is used */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m * @brief STM32F10x Interrupt Number Definition, according to the selected device[m[41m [m
[32m+[m[32m *        in @ref Library_configuration_section[m[41m [m
[32m+[m[32m */[m
[32m+[m[32mtypedef enum IRQn[m
[32m+[m[32m{[m
[32m+[m[32m/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/[m
[32m+[m[32m  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */[m
[32m+[m[32m  MemoryManagement_IRQn       = -12,    /*!< 4 Cortex-M3 Memory Management Interrupt              */[m
[32m+[m[32m  BusFault_IRQn               = -11,    /*!< 5 Cortex-M3 Bus Fault Interrupt                      */[m
[32m+[m[32m  UsageFault_IRQn             = -10,    /*!< 6 Cortex-M3 Usage Fault Interrupt                    */[m
[32m+[m[32m  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M3 SV Call Interrupt                       */[m
[32m+[m[32m  DebugMonitor_IRQn           = -4,     /*!< 12 Cortex-M3 Debug Monitor Interrupt                 */[m
[32m+[m[32m  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M3 Pend SV Interrupt                       */[m
[32m+[m[32m  SysTick_IRQn                = -1,     /*!< 15 Cortex-M3 System Tick Interrupt                   */[m
[32m+[m
[32m+[m[32m/******  STM32 specific Interrupt Numbers *********************************************************/[m
[32m+[m[32m  WWDG_IRQn                   = 0,      /*!< Window WatchDog Interrupt                            */[m
[32m+[m[32m  PVD_IRQn                    = 1,      /*!< PVD through EXTI Line detection Interrupt            */[m
[32m+[m[32m  TAMPER_IRQn                 = 2,      /*!< Tamper Interrupt                                     */[m
[32m+[m[32m  RTC_IRQn                    = 3,      /*!< RTC global Interrupt                                 */[m
[32m+[m[32m  FLASH_IRQn                  = 4,      /*!< FLASH global Interrupt                               */[m
[32m+[m[32m  RCC_IRQn                    = 5,      /*!< RCC global Interrupt                                 */[m
[32m+[m[32m  EXTI0_IRQn                  = 6,      /*!< EXTI Line0 Interrupt                                 */[m
[32m+[m[32m  EXTI1_IRQn                  = 7,      /*!< EXTI Line1 Interrupt                                 */[m
[32m+[m[32m  EXTI2_IRQn                  = 8,      /*!< EXTI Line2 Interrupt                                 */[m
[32m+[m[32m  EXTI3_IRQn                  = 9,      /*!< EXTI Line3 Interrupt                                 */[m
[32m+[m[32m  EXTI4_IRQn                  = 10,     /*!< EXTI Line4 Interrupt                                 */[m
[32m+[m[32m  DMA1_Channel1_IRQn          = 11,     /*!< DMA1 Channel 1 global Interrupt                      */[m
[32m+[m[32m  DMA1_Channel2_IRQn          = 12,     /*!< DMA1 Channel 2 global Interrupt                      */[m
[32m+[m[32m  DMA1_Channel3_IRQn          = 13,     /*!< DMA1 Channel 3 global Interrupt                      */[m
[32m+[m[32m  DMA1_Channel4_IRQn          = 14,     /*!< DMA1 Channel 4 global Interrupt                      */[m
[32m+[m[32m  DMA1_Channel5_IRQn          = 15,     /*!< DMA1 Channel 5 global Interrupt                      */[m
[32m+[m[32m  DMA1_Channel6_IRQn          = 16,     /*!< DMA1 Channel 6 global Interrupt                      */[m
[32m+[m[32m  DMA1_Channel7_IRQn          = 17,     /*!< DMA1 Channel 7 global Interrupt                      */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_LD[m
[32m+[m[32m  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */[m
[32m+[m[32m  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */[m
[32m+[m[32m  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */[m
[32m+[m[32m  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */[m
[32m+[m[32m  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */[m
[32m+[m[32m  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */[m
[32m+[m[32m  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */[m[41m    [m
[32m+[m[32m#endif /* STM32F10X_LD */[m[41m  [m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_LD_VL[m
[32m+[m[32m  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */[m
[32m+[m[32m  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */[m
[32m+[m[32m  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */[m
[32m+[m[32m  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */[m
[32m+[m[32m  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */[m[41m       [m
[32m+[m[32m#endif /* STM32F10X_LD_VL */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_MD[m
[32m+[m[32m  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */[m
[32m+[m[32m  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */[m
[32m+[m[32m  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */[m
[32m+[m[32m  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */[m
[32m+[m[32m  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */[m
[32m+[m[32m  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */[m
[32m+[m[32m  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */[m
[32m+[m[32m  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  USBWakeUp_IRQn              = 42      /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */[m[41m  [m
[32m+[m[32m#endif /* STM32F10X_MD */[m[41m  [m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_MD_VL[m
[32m+[m[32m  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */[m
[32m+[m[32m  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */[m
[32m+[m[32m  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */[m
[32m+[m[32m  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */[m
[32m+[m[32m  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */[m
[32m+[m[32m  TIM7_IRQn                   = 55      /*!< TIM7 Interrupt                                       */[m[41m       [m
[32m+[m[32m#endif /* STM32F10X_MD_VL */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_HD[m
[32m+[m[32m  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */[m
[32m+[m[32m  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */[m
[32m+[m[32m  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */[m
[32m+[m[32m  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */[m
[32m+[m[32m  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */[m
[32m+[m[32m  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */[m
[32m+[m[32m  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */[m
[32m+[m[32m  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */[m
[32m+[m[32m  TIM8_BRK_IRQn               = 43,     /*!< TIM8 Break Interrupt                                 */[m
[32m+[m[32m  TIM8_UP_IRQn                = 44,     /*!< TIM8 Update Interrupt                                */[m
[32m+[m[32m  TIM8_TRG_COM_IRQn           = 45,     /*!< TIM8 Trigger and Commutation Interrupt               */[m
[32m+[m[32m  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */[m
[32m+[m[32m  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */[m
[32m+[m[32m  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */[m
[32m+[m[32m  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */[m
[32m+[m[32m  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */[m
[32m+[m[32m  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */[m
[32m+[m[32m  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */[m
[32m+[m[32m  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */[m
[32m+[m[32m  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */[m
[32m+[m[32m  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */[m
[32m+[m[32m  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */[m
[32m+[m[32m#endif /* STM32F10X_HD */[m[41m  [m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_HD_VL[m
[32m+[m[32m  ADC1_IRQn                   = 18,     /*!< ADC1 global Interrupt                                */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_TIM15_IRQn         = 24,     /*!< TIM1 Break and TIM15 Interrupts                      */[m
[32m+[m[32m  TIM1_UP_TIM16_IRQn          = 25,     /*!< TIM1 Update and TIM16 Interrupts                     */[m
[32m+[m[32m  TIM1_TRG_COM_TIM17_IRQn     = 26,     /*!< TIM1 Trigger and Commutation and TIM17 Interrupt     */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */[m
[32m+[m[32m  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  CEC_IRQn                    = 42,     /*!< HDMI-CEC Interrupt                                   */[m
[32m+[m[32m  TIM12_IRQn                  = 43,     /*!< TIM12 global Interrupt                               */[m
[32m+[m[32m  TIM13_IRQn                  = 44,     /*!< TIM13 global Interrupt                               */[m
[32m+[m[32m  TIM14_IRQn                  = 45,     /*!< TIM14 global Interrupt                               */[m
[32m+[m[32m  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */[m
[32m+[m[32m  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */[m
[32m+[m[32m  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */[m
[32m+[m[32m  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */[m[41m  [m
[32m+[m[32m  TIM6_DAC_IRQn               = 54,     /*!< TIM6 and DAC underrun Interrupt                      */[m
[32m+[m[32m  TIM7_IRQn                   = 55,     /*!< TIM7 Interrupt                                       */[m[41m  [m
[32m+[m[32m  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel4_5_IRQn        = 59,     /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */[m
[32m+[m[32m  DMA2_Channel5_IRQn          = 60      /*!< DMA2 Channel 5 global Interrupt (DMA2 Channel 5 is[m[41m [m
[32m+[m[32m                                             mapped at position 60 only if the MISC_REMAP bit in[m[41m [m
[32m+[m[32m                                             the AFIO_MAPR2 register is set)                      */[m[41m       [m
[32m+[m[32m#endif /* STM32F10X_HD_VL */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */[m
[32m+[m[32m  USB_HP_CAN1_TX_IRQn         = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */[m
[32m+[m[32m  USB_LP_CAN1_RX0_IRQn        = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */[m
[32m+[m[32m  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */[m
[32m+[m[32m  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_TIM9_IRQn          = 24,     /*!< TIM1 Break Interrupt and TIM9 global Interrupt       */[m
[32m+[m[32m  TIM1_UP_TIM10_IRQn          = 25,     /*!< TIM1 Update Interrupt and TIM10 global Interrupt     */[m
[32m+[m[32m  TIM1_TRG_COM_TIM11_IRQn     = 26,     /*!< TIM1 Trigger and Commutation Interrupt and TIM11 global interrupt */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */[m
[32m+[m[32m  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  USBWakeUp_IRQn              = 42,     /*!< USB Device WakeUp from suspend through EXTI Line Interrupt */[m
[32m+[m[32m  TIM8_BRK_TIM12_IRQn         = 43,     /*!< TIM8 Break Interrupt and TIM12 global Interrupt      */[m
[32m+[m[32m  TIM8_UP_TIM13_IRQn          = 44,     /*!< TIM8 Update Interrupt and TIM13 global Interrupt     */[m
[32m+[m[32m  TIM8_TRG_COM_TIM14_IRQn     = 45,     /*!< TIM8 Trigger and Commutation Interrupt and TIM14 global interrupt */[m
[32m+[m[32m  TIM8_CC_IRQn                = 46,     /*!< TIM8 Capture Compare Interrupt                       */[m
[32m+[m[32m  ADC3_IRQn                   = 47,     /*!< ADC3 global Interrupt                                */[m
[32m+[m[32m  FSMC_IRQn                   = 48,     /*!< FSMC global Interrupt                                */[m
[32m+[m[32m  SDIO_IRQn                   = 49,     /*!< SDIO global Interrupt                                */[m
[32m+[m[32m  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */[m
[32m+[m[32m  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */[m
[32m+[m[32m  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */[m
[32m+[m[32m  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */[m
[32m+[m[32m  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */[m
[32m+[m[32m  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */[m
[32m+[m[32m  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel4_5_IRQn        = 59      /*!< DMA2 Channel 4 and Channel 5 global Interrupt        */[m
[32m+[m[32m#endif /* STM32F10X_XL */[m[41m  [m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m  ADC1_2_IRQn                 = 18,     /*!< ADC1 and ADC2 global Interrupt                       */[m
[32m+[m[32m  CAN1_TX_IRQn                = 19,     /*!< USB Device High Priority or CAN1 TX Interrupts       */[m
[32m+[m[32m  CAN1_RX0_IRQn               = 20,     /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */[m
[32m+[m[32m  CAN1_RX1_IRQn               = 21,     /*!< CAN1 RX1 Interrupt                                   */[m
[32m+[m[32m  CAN1_SCE_IRQn               = 22,     /*!< CAN1 SCE Interrupt                                   */[m
[32m+[m[32m  EXTI9_5_IRQn                = 23,     /*!< External Line[9:5] Interrupts                        */[m
[32m+[m[32m  TIM1_BRK_IRQn               = 24,     /*!< TIM1 Break Interrupt                                 */[m
[32m+[m[32m  TIM1_UP_IRQn                = 25,     /*!< TIM1 Update Interrupt                                */[m
[32m+[m[32m  TIM1_TRG_COM_IRQn           = 26,     /*!< TIM1 Trigger and Commutation Interrupt               */[m
[32m+[m[32m  TIM1_CC_IRQn                = 27,     /*!< TIM1 Capture Compare Interrupt                       */[m
[32m+[m[32m  TIM2_IRQn                   = 28,     /*!< TIM2 global Interrupt                                */[m
[32m+[m[32m  TIM3_IRQn                   = 29,     /*!< TIM3 global Interrupt                                */[m
[32m+[m[32m  TIM4_IRQn                   = 30,     /*!< TIM4 global Interrupt                                */[m
[32m+[m[32m  I2C1_EV_IRQn                = 31,     /*!< I2C1 Event Interrupt                                 */[m
[32m+[m[32m  I2C1_ER_IRQn                = 32,     /*!< I2C1 Error Interrupt                                 */[m
[32m+[m[32m  I2C2_EV_IRQn                = 33,     /*!< I2C2 Event Interrupt                                 */[m
[32m+[m[32m  I2C2_ER_IRQn                = 34,     /*!< I2C2 Error Interrupt                                 */[m
[32m+[m[32m  SPI1_IRQn                   = 35,     /*!< SPI1 global Interrupt                                */[m
[32m+[m[32m  SPI2_IRQn                   = 36,     /*!< SPI2 global Interrupt                                */[m
[32m+[m[32m  USART1_IRQn                 = 37,     /*!< USART1 global Interrupt                              */[m
[32m+[m[32m  USART2_IRQn                 = 38,     /*!< USART2 global Interrupt                              */[m
[32m+[m[32m  USART3_IRQn                 = 39,     /*!< USART3 global Interrupt                              */[m
[32m+[m[32m  EXTI15_10_IRQn              = 40,     /*!< External Line[15:10] Interrupts                      */[m
[32m+[m[32m  RTCAlarm_IRQn               = 41,     /*!< RTC Alarm through EXTI Line Interrupt                */[m
[32m+[m[32m  OTG_FS_WKUP_IRQn            = 42,     /*!< USB OTG FS WakeUp from suspend through EXTI Line Interrupt */[m
[32m+[m[32m  TIM5_IRQn                   = 50,     /*!< TIM5 global Interrupt                                */[m
[32m+[m[32m  SPI3_IRQn                   = 51,     /*!< SPI3 global Interrupt                                */[m
[32m+[m[32m  UART4_IRQn                  = 52,     /*!< UART4 global Interrupt                               */[m
[32m+[m[32m  UART5_IRQn                  = 53,     /*!< UART5 global Interrupt                               */[m
[32m+[m[32m  TIM6_IRQn                   = 54,     /*!< TIM6 global Interrupt                                */[m
[32m+[m[32m  TIM7_IRQn                   = 55,     /*!< TIM7 global Interrupt                                */[m
[32m+[m[32m  DMA2_Channel1_IRQn          = 56,     /*!< DMA2 Channel 1 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel2_IRQn          = 57,     /*!< DMA2 Channel 2 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel3_IRQn          = 58,     /*!< DMA2 Channel 3 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel4_IRQn          = 59,     /*!< DMA2 Channel 4 global Interrupt                      */[m
[32m+[m[32m  DMA2_Channel5_IRQn          = 60,     /*!< DMA2 Channel 5 global Interrupt                      */[m
[32m+[m[32m  ETH_IRQn                    = 61,     /*!< Ethernet global Interrupt                            */[m
[32m+[m[32m  ETH_WKUP_IRQn               = 62,     /*!< Ethernet Wakeup through EXTI line Interrupt          */[m
[32m+[m[32m  CAN2_TX_IRQn                = 63,     /*!< CAN2 TX Interrupt                                    */[m
[32m+[m[32m  CAN2_RX0_IRQn               = 64,     /*!< CAN2 RX0 Interrupt                                   */[m
[32m+[m[32m  CAN2_RX1_IRQn               = 65,     /*!< CAN2 RX1 Interrupt                                   */[m
[32m+[m[32m  CAN2_SCE_IRQn               = 66,     /*!< CAN2 SCE Interrupt                                   */[m
[32m+[m[32m  OTG_FS_IRQn                 = 67      /*!< USB OTG FS global Interrupt                          */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m     [m
[32m+[m[32m} IRQn_Type;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#include "core_cm3.h"[m
[32m+[m[32m#include "system_stm32f10x.h"[m
[32m+[m[32m#include <stdint.h>[m
[32m+[m
[32m+[m[32m/** @addtogroup Exported_types[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m
[32m+[m[32m/*!< STM32F10x Standard Peripheral Library old types (maintained for legacy purpose) */[m
[32m+[m[32mtypedef int32_t  s32;[m
[32m+[m[32mtypedef int16_t s16;[m
[32m+[m[32mtypedef int8_t  s8;[m
[32m+[m
[32m+[m[32mtypedef const int32_t sc32;  /*!< Read Only */[m
[32m+[m[32mtypedef const int16_t sc16;  /*!< Read Only */[m
[32m+[m[32mtypedef const int8_t sc8;   /*!< Read Only */[m
[32m+[m
[32m+[m[32mtypedef __IO int32_t  vs32;[m
[32m+[m[32mtypedef __IO int16_t  vs16;[m
[32m+[m[32mtypedef __IO int8_t   vs8;[m
[32m+[m
[32m+[m[32mtypedef __I int32_t vsc32;  /*!< Read Only */[m
[32m+[m[32mtypedef __I int16_t vsc16;  /*!< Read Only */[m
[32m+[m[32mtypedef __I int8_t vsc8;   /*!< Read Only */[m
[32m+[m
[32m+[m[32mtypedef uint32_t  u32;[m
[32m+[m[32mtypedef uint16_t u16;[m
[32m+[m[32mtypedef uint8_t  u8;[m
[32m+[m
[32m+[m[32mtypedef const uint32_t uc32;  /*!< Read Only */[m
[32m+[m[32mtypedef const uint16_t uc16;  /*!< Read Only */[m
[32m+[m[32mtypedef const uint8_t uc8;   /*!< Read Only */[m
[32m+[m
[32m+[m[32mtypedef __IO uint32_t  vu32;[m
[32m+[m[32mtypedef __IO uint16_t vu16;[m
[32m+[m[32mtypedef __IO uint8_t  vu8;[m
[32m+[m
[32m+[m[32mtypedef __I uint32_t vuc32;  /*!< Read Only */[m
[32m+[m[32mtypedef __I uint16_t vuc16;  /*!< Read Only */[m
[32m+[m[32mtypedef __I uint8_t vuc8;   /*!< Read Only */[m
[32m+[m
[32m+[m[32mtypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;[m
[32m+[m
[32m+[m[32mtypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;[m
[32m+[m[32m#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))[m
[32m+[m
[32m+[m[32mtypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;[m
[32m+[m
[32m+[m[32m/*!< STM32F10x Standard Peripheral Library old definitions (maintained for legacy purpose) */[m
[32m+[m[32m#define HSEStartUp_TimeOut   HSE_STARTUP_TIMEOUT[m
[32m+[m[32m#define HSE_Value            HSE_VALUE[m
[32m+[m[32m#define HSI_Value            HSI_VALUE[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup Peripheral_registers_structures[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m   [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Analog to Digital Converter[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t SR;[m
[32m+[m[32m  __IO uint32_t CR1;[m
[32m+[m[32m  __IO uint32_t CR2;[m
[32m+[m[32m  __IO uint32_t SMPR1;[m
[32m+[m[32m  __IO uint32_t SMPR2;[m
[32m+[m[32m  __IO uint32_t JOFR1;[m
[32m+[m[32m  __IO uint32_t JOFR2;[m
[32m+[m[32m  __IO uint32_t JOFR3;[m
[32m+[m[32m  __IO uint32_t JOFR4;[m
[32m+[m[32m  __IO uint32_t HTR;[m
[32m+[m[32m  __IO uint32_t LTR;[m
[32m+[m[32m  __IO uint32_t SQR1;[m
[32m+[m[32m  __IO uint32_t SQR2;[m
[32m+[m[32m  __IO uint32_t SQR3;[m
[32m+[m[32m  __IO uint32_t JSQR;[m
[32m+[m[32m  __IO uint32_t JDR1;[m
[32m+[m[32m  __IO uint32_t JDR2;[m
[32m+[m[32m  __IO uint32_t JDR3;[m
[32m+[m[32m  __IO uint32_t JDR4;[m
[32m+[m[32m  __IO uint32_t DR;[m
[32m+[m[32m} ADC_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Backup Registers[m[41m  [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  uint32_t  RESERVED0;[m
[32m+[m[32m  __IO uint16_t DR1;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint16_t DR2;[m
[32m+[m[32m  uint16_t  RESERVED2;[m
[32m+[m[32m  __IO uint16_t DR3;[m
[32m+[m[32m  uint16_t  RESERVED3;[m
[32m+[m[32m  __IO uint16_t DR4;[m
[32m+[m[32m  uint16_t  RESERVED4;[m
[32m+[m[32m  __IO uint16_t DR5;[m
[32m+[m[32m  uint16_t  RESERVED5;[m
[32m+[m[32m  __IO uint16_t DR6;[m
[32m+[m[32m  uint16_t  RESERVED6;[m
[32m+[m[32m  __IO uint16_t DR7;[m
[32m+[m[32m  uint16_t  RESERVED7;[m
[32m+[m[32m  __IO uint16_t DR8;[m
[32m+[m[32m  uint16_t  RESERVED8;[m
[32m+[m[32m  __IO uint16_t DR9;[m
[32m+[m[32m  uint16_t  RESERVED9;[m
[32m+[m[32m  __IO uint16_t DR10;[m
[32m+[m[32m  uint16_t  RESERVED10;[m[41m [m
[32m+[m[32m  __IO uint16_t RTCCR;[m
[32m+[m[32m  uint16_t  RESERVED11;[m
[32m+[m[32m  __IO uint16_t CR;[m
[32m+[m[32m  uint16_t  RESERVED12;[m
[32m+[m[32m  __IO uint16_t CSR;[m
[32m+[m[32m  uint16_t  RESERVED13[5];[m
[32m+[m[32m  __IO uint16_t DR11;[m
[32m+[m[32m  uint16_t  RESERVED14;[m
[32m+[m[32m  __IO uint16_t DR12;[m
[32m+[m[32m  uint16_t  RESERVED15;[m
[32m+[m[32m  __IO uint16_t DR13;[m
[32m+[m[32m  uint16_t  RESERVED16;[m
[32m+[m[32m  __IO uint16_t DR14;[m
[32m+[m[32m  uint16_t  RESERVED17;[m
[32m+[m[32m  __IO uint16_t DR15;[m
[32m+[m[32m  uint16_t  RESERVED18;[m
[32m+[m[32m  __IO uint16_t DR16;[m
[32m+[m[32m  uint16_t  RESERVED19;[m
[32m+[m[32m  __IO uint16_t DR17;[m
[32m+[m[32m  uint16_t  RESERVED20;[m
[32m+[m[32m  __IO uint16_t DR18;[m
[32m+[m[32m  uint16_t  RESERVED21;[m
[32m+[m[32m  __IO uint16_t DR19;[m
[32m+[m[32m  uint16_t  RESERVED22;[m
[32m+[m[32m  __IO uint16_t DR20;[m
[32m+[m[32m  uint16_t  RESERVED23;[m
[32m+[m[32m  __IO uint16_t DR21;[m
[32m+[m[32m  uint16_t  RESERVED24;[m
[32m+[m[32m  __IO uint16_t DR22;[m
[32m+[m[32m  uint16_t  RESERVED25;[m
[32m+[m[32m  __IO uint16_t DR23;[m
[32m+[m[32m  uint16_t  RESERVED26;[m
[32m+[m[32m  __IO uint16_t DR24;[m
[32m+[m[32m  uint16_t  RESERVED27;[m
[32m+[m[32m  __IO uint16_t DR25;[m
[32m+[m[32m  uint16_t  RESERVED28;[m
[32m+[m[32m  __IO uint16_t DR26;[m
[32m+[m[32m  uint16_t  RESERVED29;[m
[32m+[m[32m  __IO uint16_t DR27;[m
[32m+[m[32m  uint16_t  RESERVED30;[m
[32m+[m[32m  __IO uint16_t DR28;[m
[32m+[m[32m  uint16_t  RESERVED31;[m
[32m+[m[32m  __IO uint16_t DR29;[m
[32m+[m[32m  uint16_t  RESERVED32;[m
[32m+[m[32m  __IO uint16_t DR30;[m
[32m+[m[32m  uint16_t  RESERVED33;[m[41m [m
[32m+[m[32m  __IO uint16_t DR31;[m
[32m+[m[32m  uint16_t  RESERVED34;[m
[32m+[m[32m  __IO uint16_t DR32;[m
[32m+[m[32m  uint16_t  RESERVED35;[m
[32m+[m[32m  __IO uint16_t DR33;[m
[32m+[m[32m  uint16_t  RESERVED36;[m
[32m+[m[32m  __IO uint16_t DR34;[m
[32m+[m[32m  uint16_t  RESERVED37;[m
[32m+[m[32m  __IO uint16_t DR35;[m
[32m+[m[32m  uint16_t  RESERVED38;[m
[32m+[m[32m  __IO uint16_t DR36;[m
[32m+[m[32m  uint16_t  RESERVED39;[m
[32m+[m[32m  __IO uint16_t DR37;[m
[32m+[m[32m  uint16_t  RESERVED40;[m
[32m+[m[32m  __IO uint16_t DR38;[m
[32m+[m[32m  uint16_t  RESERVED41;[m
[32m+[m[32m  __IO uint16_t DR39;[m
[32m+[m[32m  uint16_t  RESERVED42;[m
[32m+[m[32m  __IO uint16_t DR40;[m
[32m+[m[32m  uint16_t  RESERVED43;[m
[32m+[m[32m  __IO uint16_t DR41;[m
[32m+[m[32m  uint16_t  RESERVED44;[m
[32m+[m[32m  __IO uint16_t DR42;[m
[32m+[m[32m  uint16_t  RESERVED45;[m[41m    [m
[32m+[m[32m} BKP_TypeDef;[m
[32m+[m[41m  [m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Controller Area Network TxMailBox[m[41m [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t TIR;[m
[32m+[m[32m  __IO uint32_t TDTR;[m
[32m+[m[32m  __IO uint32_t TDLR;[m
[32m+[m[32m  __IO uint32_t TDHR;[m
[32m+[m[32m} CAN_TxMailBox_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Controller Area Network FIFOMailBox[m[41m [m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t RIR;[m
[32m+[m[32m  __IO uint32_t RDTR;[m
[32m+[m[32m  __IO uint32_t RDLR;[m
[32m+[m[32m  __IO uint32_t RDHR;[m
[32m+[m[32m} CAN_FIFOMailBox_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Controller Area Network FilterRegister[m[41m [m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t FR1;[m
[32m+[m[32m  __IO uint32_t FR2;[m
[32m+[m[32m} CAN_FilterRegister_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Controller Area Network[m[41m [m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t MCR;[m
[32m+[m[32m  __IO uint32_t MSR;[m
[32m+[m[32m  __IO uint32_t TSR;[m
[32m+[m[32m  __IO uint32_t RF0R;[m
[32m+[m[32m  __IO uint32_t RF1R;[m
[32m+[m[32m  __IO uint32_t IER;[m
[32m+[m[32m  __IO uint32_t ESR;[m
[32m+[m[32m  __IO uint32_t BTR;[m
[32m+[m[32m  uint32_t  RESERVED0[88];[m
[32m+[m[32m  CAN_TxMailBox_TypeDef sTxMailBox[3];[m
[32m+[m[32m  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];[m
[32m+[m[32m  uint32_t  RESERVED1[12];[m
[32m+[m[32m  __IO uint32_t FMR;[m
[32m+[m[32m  __IO uint32_t FM1R;[m
[32m+[m[32m  uint32_t  RESERVED2;[m
[32m+[m[32m  __IO uint32_t FS1R;[m
[32m+[m[32m  uint32_t  RESERVED3;[m
[32m+[m[32m  __IO uint32_t FFA1R;[m
[32m+[m[32m  uint32_t  RESERVED4;[m
[32m+[m[32m  __IO uint32_t FA1R;[m
[32m+[m[32m  uint32_t  RESERVED5[8];[m
[32m+[m[32m#ifndef STM32F10X_CL[m
[32m+[m[32m  CAN_FilterRegister_TypeDef sFilterRegister[14];[m
[32m+[m[32m#else[m
[32m+[m[32m  CAN_FilterRegister_TypeDef sFilterRegister[28];[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m  [m
[32m+[m[32m} CAN_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Consumer Electronics Control (CEC)[m
[32m+[m[32m  */[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CFGR;[m
[32m+[m[32m  __IO uint32_t OAR;[m
[32m+[m[32m  __IO uint32_t PRES;[m
[32m+[m[32m  __IO uint32_t ESR;[m
[32m+[m[32m  __IO uint32_t CSR;[m
[32m+[m[32m  __IO uint32_t TXD;[m
[32m+[m[32m  __IO uint32_t RXD;[m[41m  [m
[32m+[m[32m} CEC_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief CRC calculation unit[m[41m [m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t DR;[m
[32m+[m[32m  __IO uint8_t  IDR;[m
[32m+[m[32m  uint8_t   RESERVED0;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint32_t CR;[m
[32m+[m[32m} CRC_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Digital to Analog Converter[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CR;[m
[32m+[m[32m  __IO uint32_t SWTRIGR;[m
[32m+[m[32m  __IO uint32_t DHR12R1;[m
[32m+[m[32m  __IO uint32_t DHR12L1;[m
[32m+[m[32m  __IO uint32_t DHR8R1;[m
[32m+[m[32m  __IO uint32_t DHR12R2;[m
[32m+[m[32m  __IO uint32_t DHR12L2;[m
[32m+[m[32m  __IO uint32_t DHR8R2;[m
[32m+[m[32m  __IO uint32_t DHR12RD;[m
[32m+[m[32m  __IO uint32_t DHR12LD;[m
[32m+[m[32m  __IO uint32_t DHR8RD;[m
[32m+[m[32m  __IO uint32_t DOR1;[m
[32m+[m[32m  __IO uint32_t DOR2;[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m  __IO uint32_t SR;[m
[32m+[m[32m#endif[m
[32m+[m[32m} DAC_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Debug MCU[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t IDCODE;[m
[32m+[m[32m  __IO uint32_t CR;[m[41m	[m
[32m+[m[32m}DBGMCU_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief DMA Controller[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CCR;[m
[32m+[m[32m  __IO uint32_t CNDTR;[m
[32m+[m[32m  __IO uint32_t CPAR;[m
[32m+[m[32m  __IO uint32_t CMAR;[m
[32m+[m[32m} DMA_Channel_TypeDef;[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t ISR;[m
[32m+[m[32m  __IO uint32_t IFCR;[m
[32m+[m[32m} DMA_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Ethernet MAC[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t MACCR;[m
[32m+[m[32m  __IO uint32_t MACFFR;[m
[32m+[m[32m  __IO uint32_t MACHTHR;[m
[32m+[m[32m  __IO uint32_t MACHTLR;[m
[32m+[m[32m  __IO uint32_t MACMIIAR;[m
[32m+[m[32m  __IO uint32_t MACMIIDR;[m
[32m+[m[32m  __IO uint32_t MACFCR;[m
[32m+[m[32m  __IO uint32_t MACVLANTR;             /*    8 */[m
[32m+[m[32m       uint32_t RESERVED0[2];[m
[32m+[m[32m  __IO uint32_t MACRWUFFR;             /*   11 */[m
[32m+[m[32m  __IO uint32_t MACPMTCSR;[m
[32m+[m[32m       uint32_t RESERVED1[2];[m
[32m+[m[32m  __IO uint32_t MACSR;                 /*   15 */[m
[32m+[m[32m  __IO uint32_t MACIMR;[m
[32m+[m[32m  __IO uint32_t MACA0HR;[m
[32m+[m[32m  __IO uint32_t MACA0LR;[m
[32m+[m[32m  __IO uint32_t MACA1HR;[m
[32m+[m[32m  __IO uint32_t MACA1LR;[m
[32m+[m[32m  __IO uint32_t MACA2HR;[m
[32m+[m[32m  __IO uint32_t MACA2LR;[m
[32m+[m[32m  __IO uint32_t MACA3HR;[m
[32m+[m[32m  __IO uint32_t MACA3LR;               /*   24 */[m
[32m+[m[32m       uint32_t RESERVED2[40];[m
[32m+[m[32m  __IO uint32_t MMCCR;                 /*   65 */[m
[32m+[m[32m  __IO uint32_t MMCRIR;[m
[32m+[m[32m  __IO uint32_t MMCTIR;[m
[32m+[m[32m  __IO uint32_t MMCRIMR;[m
[32m+[m[32m  __IO uint32_t MMCTIMR;               /*   69 */[m
[32m+[m[32m       uint32_t RESERVED3[14];[m
[32m+[m[32m  __IO uint32_t MMCTGFSCCR;            /*   84 */[m
[32m+[m[32m  __IO uint32_t MMCTGFMSCCR;[m
[32m+[m[32m       uint32_t RESERVED4[5];[m
[32m+[m[32m  __IO uint32_t MMCTGFCR;[m
[32m+[m[32m       uint32_t RESERVED5[10];[m
[32m+[m[32m  __IO uint32_t MMCRFCECR;[m
[32m+[m[32m  __IO uint32_t MMCRFAECR;[m
[32m+[m[32m       uint32_t RESERVED6[10];[m
[32m+[m[32m  __IO uint32_t MMCRGUFCR;[m
[32m+[m[32m       uint32_t RESERVED7[334];[m
[32m+[m[32m  __IO uint32_t PTPTSCR;[m
[32m+[m[32m  __IO uint32_t PTPSSIR;[m
[32m+[m[32m  __IO uint32_t PTPTSHR;[m
[32m+[m[32m  __IO uint32_t PTPTSLR;[m
[32m+[m[32m  __IO uint32_t PTPTSHUR;[m
[32m+[m[32m  __IO uint32_t PTPTSLUR;[m
[32m+[m[32m  __IO uint32_t PTPTSAR;[m
[32m+[m[32m  __IO uint32_t PTPTTHR;[m
[32m+[m[32m  __IO uint32_t PTPTTLR;[m
[32m+[m[32m       uint32_t RESERVED8[567];[m
[32m+[m[32m  __IO uint32_t DMABMR;[m
[32m+[m[32m  __IO uint32_t DMATPDR;[m
[32m+[m[32m  __IO uint32_t DMARPDR;[m
[32m+[m[32m  __IO uint32_t DMARDLAR;[m
[32m+[m[32m  __IO uint32_t DMATDLAR;[m
[32m+[m[32m  __IO uint32_t DMASR;[m
[32m+[m[32m  __IO uint32_t DMAOMR;[m
[32m+[m[32m  __IO uint32_t DMAIER;[m
[32m+[m[32m  __IO uint32_t DMAMFBOCR;[m
[32m+[m[32m       uint32_t RESERVED9[9];[m
[32m+[m[32m  __IO uint32_t DMACHTDR;[m
[32m+[m[32m  __IO uint32_t DMACHRDR;[m
[32m+[m[32m  __IO uint32_t DMACHTBAR;[m
[32m+[m[32m  __IO uint32_t DMACHRBAR;[m
[32m+[m[32m} ETH_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief External Interrupt/Event Controller[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t IMR;[m
[32m+[m[32m  __IO uint32_t EMR;[m
[32m+[m[32m  __IO uint32_t RTSR;[m
[32m+[m[32m  __IO uint32_t FTSR;[m
[32m+[m[32m  __IO uint32_t SWIER;[m
[32m+[m[32m  __IO uint32_t PR;[m
[32m+[m[32m} EXTI_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief FLASH Registers[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t ACR;[m
[32m+[m[32m  __IO uint32_t KEYR;[m
[32m+[m[32m  __IO uint32_t OPTKEYR;[m
[32m+[m[32m  __IO uint32_t SR;[m
[32m+[m[32m  __IO uint32_t CR;[m
[32m+[m[32m  __IO uint32_t AR;[m
[32m+[m[32m  __IO uint32_t RESERVED;[m
[32m+[m[32m  __IO uint32_t OBR;[m
[32m+[m[32m  __IO uint32_t WRPR;[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m  uint32_t RESERVED1[8];[m[41m [m
[32m+[m[32m  __IO uint32_t KEYR2;[m
[32m+[m[32m  uint32_t RESERVED2;[m[41m   [m
[32m+[m[32m  __IO uint32_t SR2;[m
[32m+[m[32m  __IO uint32_t CR2;[m
[32m+[m[32m  __IO uint32_t AR2;[m[41m [m
[32m+[m[32m#endif /* STM32F10X_XL */[m[41m  [m
[32m+[m[32m} FLASH_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Option Bytes Registers[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint16_t RDP;[m
[32m+[m[32m  __IO uint16_t USER;[m
[32m+[m[32m  __IO uint16_t Data0;[m
[32m+[m[32m  __IO uint16_t Data1;[m
[32m+[m[32m  __IO uint16_t WRP0;[m
[32m+[m[32m  __IO uint16_t WRP1;[m
[32m+[m[32m  __IO uint16_t WRP2;[m
[32m+[m[32m  __IO uint16_t WRP3;[m
[32m+[m[32m} OB_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Flexible Static Memory Controller[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t BTCR[8];[m[41m   [m
[32m+[m[32m} FSMC_Bank1_TypeDef;[m[41m [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Flexible Static Memory Controller Bank1E[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t BWTR[7];[m
[32m+[m[32m} FSMC_Bank1E_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Flexible Static Memory Controller Bank2[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t PCR2;[m
[32m+[m[32m  __IO uint32_t SR2;[m
[32m+[m[32m  __IO uint32_t PMEM2;[m
[32m+[m[32m  __IO uint32_t PATT2;[m
[32m+[m[32m  uint32_t  RESERVED0;[m[41m   [m
[32m+[m[32m  __IO uint32_t ECCR2;[m[41m [m
[32m+[m[32m} FSMC_Bank2_TypeDef;[m[41m  [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Flexible Static Memory Controller Bank3[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t PCR3;[m
[32m+[m[32m  __IO uint32_t SR3;[m
[32m+[m[32m  __IO uint32_t PMEM3;[m
[32m+[m[32m  __IO uint32_t PATT3;[m
[32m+[m[32m  uint32_t  RESERVED0;[m[41m   [m
[32m+[m[32m  __IO uint32_t ECCR3;[m[41m [m
[32m+[m[32m} FSMC_Bank3_TypeDef;[m[41m [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Flexible Static Memory Controller Bank4[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t PCR4;[m
[32m+[m[32m  __IO uint32_t SR4;[m
[32m+[m[32m  __IO uint32_t PMEM4;[m
[32m+[m[32m  __IO uint32_t PATT4;[m
[32m+[m[32m  __IO uint32_t PIO4;[m[41m [m
[32m+[m[32m} FSMC_Bank4_TypeDef;[m[41m [m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief General Purpose I/O[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CRL;[m
[32m+[m[32m  __IO uint32_t CRH;[m
[32m+[m[32m  __IO uint32_t IDR;[m
[32m+[m[32m  __IO uint32_t ODR;[m
[32m+[m[32m  __IO uint32_t BSRR;[m
[32m+[m[32m  __IO uint32_t BRR;[m
[32m+[m[32m  __IO uint32_t LCKR;[m
[32m+[m[32m} GPIO_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Alternate Function I/O[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t EVCR;[m
[32m+[m[32m  __IO uint32_t MAPR;[m
[32m+[m[32m  __IO uint32_t EXTICR[4];[m
[32m+[m[32m  uint32_t RESERVED0;[m
[32m+[m[32m  __IO uint32_t MAPR2;[m[41m  [m
[32m+[m[32m} AFIO_TypeDef;[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Inter Integrated Circuit Interface[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint16_t CR1;[m
[32m+[m[32m  uint16_t  RESERVED0;[m
[32m+[m[32m  __IO uint16_t CR2;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint16_t OAR1;[m
[32m+[m[32m  uint16_t  RESERVED2;[m
[32m+[m[32m  __IO uint16_t OAR2;[m
[32m+[m[32m  uint16_t  RESERVED3;[m
[32m+[m[32m  __IO uint16_t DR;[m
[32m+[m[32m  uint16_t  RESERVED4;[m
[32m+[m[32m  __IO uint16_t SR1;[m
[32m+[m[32m  uint16_t  RESERVED5;[m
[32m+[m[32m  __IO uint16_t SR2;[m
[32m+[m[32m  uint16_t  RESERVED6;[m
[32m+[m[32m  __IO uint16_t CCR;[m
[32m+[m[32m  uint16_t  RESERVED7;[m
[32m+[m[32m  __IO uint16_t TRISE;[m
[32m+[m[32m  uint16_t  RESERVED8;[m
[32m+[m[32m} I2C_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Independent WATCHDOG[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t KR;[m
[32m+[m[32m  __IO uint32_t PR;[m
[32m+[m[32m  __IO uint32_t RLR;[m
[32m+[m[32m  __IO uint32_t SR;[m
[32m+[m[32m} IWDG_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Power Control[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CR;[m
[32m+[m[32m  __IO uint32_t CSR;[m
[32m+[m[32m} PWR_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Reset and Clock Control[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CR;[m
[32m+[m[32m  __IO uint32_t CFGR;[m
[32m+[m[32m  __IO uint32_t CIR;[m
[32m+[m[32m  __IO uint32_t APB2RSTR;[m
[32m+[m[32m  __IO uint32_t APB1RSTR;[m
[32m+[m[32m  __IO uint32_t AHBENR;[m
[32m+[m[32m  __IO uint32_t APB2ENR;[m
[32m+[m[32m  __IO uint32_t APB1ENR;[m
[32m+[m[32m  __IO uint32_t BDCR;[m
[32m+[m[32m  __IO uint32_t CSR;[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m[41m  [m
[32m+[m[32m  __IO uint32_t AHBRSTR;[m
[32m+[m[32m  __IO uint32_t CFGR2;[m
[32m+[m[32m#endif /* STM32F10X_CL */[m[41m [m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m[41m   [m
[32m+[m[32m  uint32_t RESERVED0;[m
[32m+[m[32m  __IO uint32_t CFGR2;[m
[32m+[m[32m#endif /* STM32F10X_LD_VL || STM32F10X_MD_VL || STM32F10X_HD_VL */[m[41m [m
[32m+[m[32m} RCC_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Real-Time Clock[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint16_t CRH;[m
[32m+[m[32m  uint16_t  RESERVED0;[m
[32m+[m[32m  __IO uint16_t CRL;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint16_t PRLH;[m
[32m+[m[32m  uint16_t  RESERVED2;[m
[32m+[m[32m  __IO uint16_t PRLL;[m
[32m+[m[32m  uint16_t  RESERVED3;[m
[32m+[m[32m  __IO uint16_t DIVH;[m
[32m+[m[32m  uint16_t  RESERVED4;[m
[32m+[m[32m  __IO uint16_t DIVL;[m
[32m+[m[32m  uint16_t  RESERVED5;[m
[32m+[m[32m  __IO uint16_t CNTH;[m
[32m+[m[32m  uint16_t  RESERVED6;[m
[32m+[m[32m  __IO uint16_t CNTL;[m
[32m+[m[32m  uint16_t  RESERVED7;[m
[32m+[m[32m  __IO uint16_t ALRH;[m
[32m+[m[32m  uint16_t  RESERVED8;[m
[32m+[m[32m  __IO uint16_t ALRL;[m
[32m+[m[32m  uint16_t  RESERVED9;[m
[32m+[m[32m} RTC_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief SD host Interface[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t POWER;[m
[32m+[m[32m  __IO uint32_t CLKCR;[m
[32m+[m[32m  __IO uint32_t ARG;[m
[32m+[m[32m  __IO uint32_t CMD;[m
[32m+[m[32m  __I uint32_t RESPCMD;[m
[32m+[m[32m  __I uint32_t RESP1;[m
[32m+[m[32m  __I uint32_t RESP2;[m
[32m+[m[32m  __I uint32_t RESP3;[m
[32m+[m[32m  __I uint32_t RESP4;[m
[32m+[m[32m  __IO uint32_t DTIMER;[m
[32m+[m[32m  __IO uint32_t DLEN;[m
[32m+[m[32m  __IO uint32_t DCTRL;[m
[32m+[m[32m  __I uint32_t DCOUNT;[m
[32m+[m[32m  __I uint32_t STA;[m
[32m+[m[32m  __IO uint32_t ICR;[m
[32m+[m[32m  __IO uint32_t MASK;[m
[32m+[m[32m  uint32_t  RESERVED0[2];[m
[32m+[m[32m  __I uint32_t FIFOCNT;[m
[32m+[m[32m  uint32_t  RESERVED1[13];[m
[32m+[m[32m  __IO uint32_t FIFO;[m
[32m+[m[32m} SDIO_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Serial Peripheral Interface[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint16_t CR1;[m
[32m+[m[32m  uint16_t  RESERVED0;[m
[32m+[m[32m  __IO uint16_t CR2;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint16_t SR;[m
[32m+[m[32m  uint16_t  RESERVED2;[m
[32m+[m[32m  __IO uint16_t DR;[m
[32m+[m[32m  uint16_t  RESERVED3;[m
[32m+[m[32m  __IO uint16_t CRCPR;[m
[32m+[m[32m  uint16_t  RESERVED4;[m
[32m+[m[32m  __IO uint16_t RXCRCR;[m
[32m+[m[32m  uint16_t  RESERVED5;[m
[32m+[m[32m  __IO uint16_t TXCRCR;[m
[32m+[m[32m  uint16_t  RESERVED6;[m
[32m+[m[32m  __IO uint16_t I2SCFGR;[m
[32m+[m[32m  uint16_t  RESERVED7;[m
[32m+[m[32m  __IO uint16_t I2SPR;[m
[32m+[m[32m  uint16_t  RESERVED8;[m[41m  [m
[32m+[m[32m} SPI_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief TIM[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint16_t CR1;[m
[32m+[m[32m  uint16_t  RESERVED0;[m
[32m+[m[32m  __IO uint16_t CR2;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint16_t SMCR;[m
[32m+[m[32m  uint16_t  RESERVED2;[m
[32m+[m[32m  __IO uint16_t DIER;[m
[32m+[m[32m  uint16_t  RESERVED3;[m
[32m+[m[32m  __IO uint16_t SR;[m
[32m+[m[32m  uint16_t  RESERVED4;[m
[32m+[m[32m  __IO uint16_t EGR;[m
[32m+[m[32m  uint16_t  RESERVED5;[m
[32m+[m[32m  __IO uint16_t CCMR1;[m
[32m+[m[32m  uint16_t  RESERVED6;[m
[32m+[m[32m  __IO uint16_t CCMR2;[m
[32m+[m[32m  uint16_t  RESERVED7;[m
[32m+[m[32m  __IO uint16_t CCER;[m
[32m+[m[32m  uint16_t  RESERVED8;[m
[32m+[m[32m  __IO uint16_t CNT;[m
[32m+[m[32m  uint16_t  RESERVED9;[m
[32m+[m[32m  __IO uint16_t PSC;[m
[32m+[m[32m  uint16_t  RESERVED10;[m
[32m+[m[32m  __IO uint16_t ARR;[m
[32m+[m[32m  uint16_t  RESERVED11;[m
[32m+[m[32m  __IO uint16_t RCR;[m
[32m+[m[32m  uint16_t  RESERVED12;[m
[32m+[m[32m  __IO uint16_t CCR1;[m
[32m+[m[32m  uint16_t  RESERVED13;[m
[32m+[m[32m  __IO uint16_t CCR2;[m
[32m+[m[32m  uint16_t  RESERVED14;[m
[32m+[m[32m  __IO uint16_t CCR3;[m
[32m+[m[32m  uint16_t  RESERVED15;[m
[32m+[m[32m  __IO uint16_t CCR4;[m
[32m+[m[32m  uint16_t  RESERVED16;[m
[32m+[m[32m  __IO uint16_t BDTR;[m
[32m+[m[32m  uint16_t  RESERVED17;[m
[32m+[m[32m  __IO uint16_t DCR;[m
[32m+[m[32m  uint16_t  RESERVED18;[m
[32m+[m[32m  __IO uint16_t DMAR;[m
[32m+[m[32m  uint16_t  RESERVED19;[m
[32m+[m[32m} TIM_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Universal Synchronous Asynchronous Receiver Transmitter[m
[32m+[m[32m  */[m
[32m+[m[41m [m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint16_t SR;[m
[32m+[m[32m  uint16_t  RESERVED0;[m
[32m+[m[32m  __IO uint16_t DR;[m
[32m+[m[32m  uint16_t  RESERVED1;[m
[32m+[m[32m  __IO uint16_t BRR;[m
[32m+[m[32m  uint16_t  RESERVED2;[m
[32m+[m[32m  __IO uint16_t CR1;[m
[32m+[m[32m  uint16_t  RESERVED3;[m
[32m+[m[32m  __IO uint16_t CR2;[m
[32m+[m[32m  uint16_t  RESERVED4;[m
[32m+[m[32m  __IO uint16_t CR3;[m
[32m+[m[32m  uint16_t  RESERVED5;[m
[32m+[m[32m  __IO uint16_t GTPR;[m
[32m+[m[32m  uint16_t  RESERVED6;[m
[32m+[m[32m} USART_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m[41m [m
[32m+[m[32m  * @brief Window WATCHDOG[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32mtypedef struct[m
[32m+[m[32m{[m
[32m+[m[32m  __IO uint32_t CR;[m
[32m+[m[32m  __IO uint32_t CFR;[m
[32m+[m[32m  __IO uint32_t SR;[m
[32m+[m[32m} WWDG_TypeDef;[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/** @addtogroup Peripheral_memory_map[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m
[32m+[m[32m#define FLASH_BASE            ((uint32_t)0x08000000) /*!< FLASH base address in the alias region */[m
[32m+[m[32m#define SRAM_BASE             ((uint32_t)0x20000000) /*!< SRAM base address in the alias region */[m
[32m+[m[32m#define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias region */[m
[32m+[m
[32m+[m[32m#define SRAM_BB_BASE          ((uint32_t)0x22000000) /*!< SRAM base address in the bit-band region */[m
[32m+[m[32m#define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band region */[m
[32m+[m
[32m+[m[32m#define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */[m
[32m+[m
[32m+[m[32m/*!< Peripheral memory map */[m
[32m+[m[32m#define APB1PERIPH_BASE       PERIPH_BASE[m
[32m+[m[32m#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)[m
[32m+[m[32m#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)[m
[32m+[m
[32m+[m[32m#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)[m
[32m+[m[32m#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)[m
[32m+[m[32m#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)[m
[32m+[m[32m#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)[m
[32m+[m[32m#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)[m
[32m+[m[32m#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)[m
[32m+[m[32m#define TIM12_BASE            (APB1PERIPH_BASE + 0x1800)[m
[32m+[m[32m#define TIM13_BASE            (APB1PERIPH_BASE + 0x1C00)[m
[32m+[m[32m#define TIM14_BASE            (APB1PERIPH_BASE + 0x2000)[m
[32m+[m[32m#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)[m
[32m+[m[32m#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)[m
[32m+[m[32m#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)[m
[32m+[m[32m#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)[m
[32m+[m[32m#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)[m
[32m+[m[32m#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)[m
[32m+[m[32m#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)[m
[32m+[m[32m#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)[m
[32m+[m[32m#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)[m
[32m+[m[32m#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)[m
[32m+[m[32m#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)[m
[32m+[m[32m#define CAN1_BASE             (APB1PERIPH_BASE + 0x6400)[m
[32m+[m[32m#define CAN2_BASE             (APB1PERIPH_BASE + 0x6800)[m
[32m+[m[32m#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)[m
[32m+[m[32m#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)[m
[32m+[m[32m#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)[m
[32m+[m[32m#define CEC_BASE              (APB1PERIPH_BASE + 0x7800)[m
[32m+[m
[32m+[m[32m#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)[m
[32m+[m[32m#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)[m
[32m+[m[32m#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)[m
[32m+[m[32m#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)[m
[32m+[m[32m#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)[m
[32m+[m[32m#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)[m
[32m+[m[32m#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)[m
[32m+[m[32m#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)[m
[32m+[m[32m#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)[m
[32m+[m[32m#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)[m
[32m+[m[32m#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)[m
[32m+[m[32m#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)[m
[32m+[m[32m#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)[m
[32m+[m[32m#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)[m
[32m+[m[32m#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)[m
[32m+[m[32m#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)[m
[32m+[m[32m#define TIM15_BASE            (APB2PERIPH_BASE + 0x4000)[m
[32m+[m[32m#define TIM16_BASE            (APB2PERIPH_BASE + 0x4400)[m
[32m+[m[32m#define TIM17_BASE            (APB2PERIPH_BASE + 0x4800)[m
[32m+[m[32m#define TIM9_BASE             (APB2PERIPH_BASE + 0x4C00)[m
[32m+[m[32m#define TIM10_BASE            (APB2PERIPH_BASE + 0x5000)[m
[32m+[m[32m#define TIM11_BASE            (APB2PERIPH_BASE + 0x5400)[m
[32m+[m
[32m+[m[32m#define SDIO_BASE             (PERIPH_BASE + 0x18000)[m
[32m+[m
[32m+[m[32m#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)[m
[32m+[m[32m#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)[m
[32m+[m[32m#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)[m
[32m+[m[32m#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)[m
[32m+[m[32m#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)[m
[32m+[m[32m#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)[m
[32m+[m[32m#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)[m
[32m+[m[32m#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)[m
[32m+[m[32m#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)[m
[32m+[m[32m#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)[m
[32m+[m[32m#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)[m
[32m+[m[32m#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)[m
[32m+[m[32m#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)[m
[32m+[m[32m#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)[m
[32m+[m[32m#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)[m
[32m+[m[32m#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)[m
[32m+[m
[32m+[m[32m#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000) /*!< Flash registers base address */[m
[32m+[m[32m#define OB_BASE               ((uint32_t)0x1FFFF800)    /*!< Flash Option Bytes base address */[m
[32m+[m
[32m+[m[32m#define ETH_BASE              (AHBPERIPH_BASE + 0x8000)[m
[32m+[m[32m#define ETH_MAC_BASE          (ETH_BASE)[m
[32m+[m[32m#define ETH_MMC_BASE          (ETH_BASE + 0x0100)[m
[32m+[m[32m#define ETH_PTP_BASE          (ETH_BASE + 0x0700)[m
[32m+[m[32m#define ETH_DMA_BASE          (ETH_BASE + 0x1000)[m
[32m+[m
[32m+[m[32m#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000) /*!< FSMC Bank1 registers base address */[m
[32m+[m[32m#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104) /*!< FSMC Bank1E registers base address */[m
[32m+[m[32m#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060) /*!< FSMC Bank2 registers base address */[m
[32m+[m[32m#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080) /*!< FSMC Bank3 registers base address */[m
[32m+[m[32m#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0) /*!< FSMC Bank4 registers base address */[m
[32m+[m
[32m+[m[32m#define DBGMCU_BASE          ((uint32_t)0xE0042000) /*!< Debug MCU registers base address */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m/** @addtogroup Peripheral_declaration[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m[41m  [m
[32m+[m
[32m+[m[32m#define TIM2                ((TIM_TypeDef *) TIM2_BASE)[m
[32m+[m[32m#define TIM3                ((TIM_TypeDef *) TIM3_BASE)[m
[32m+[m[32m#define TIM4                ((TIM_TypeDef *) TIM4_BASE)[m
[32m+[m[32m#define TIM5                ((TIM_TypeDef *) TIM5_BASE)[m
[32m+[m[32m#define TIM6                ((TIM_TypeDef *) TIM6_BASE)[m
[32m+[m[32m#define TIM7                ((TIM_TypeDef *) TIM7_BASE)[m
[32m+[m[32m#define TIM12               ((TIM_TypeDef *) TIM12_BASE)[m
[32m+[m[32m#define TIM13               ((TIM_TypeDef *) TIM13_BASE)[m
[32m+[m[32m#define TIM14               ((TIM_TypeDef *) TIM14_BASE)[m
[32m+[m[32m#define RTC                 ((RTC_TypeDef *) RTC_BASE)[m
[32m+[m[32m#define WWDG                ((WWDG_TypeDef *) WWDG_BASE)[m
[32m+[m[32m#define IWDG                ((IWDG_TypeDef *) IWDG_BASE)[m
[32m+[m[32m#define SPI2                ((SPI_TypeDef *) SPI2_BASE)[m
[32m+[m[32m#define SPI3                ((SPI_TypeDef *) SPI3_BASE)[m
[32m+[m[32m#define USART2              ((USART_TypeDef *) USART2_BASE)[m
[32m+[m[32m#define USART3              ((USART_TypeDef *) USART3_BASE)[m
[32m+[m[32m#define UART4               ((USART_TypeDef *) UART4_BASE)[m
[32m+[m[32m#define UART5               ((USART_TypeDef *) UART5_BASE)[m
[32m+[m[32m#define I2C1                ((I2C_TypeDef *) I2C1_BASE)[m
[32m+[m[32m#define I2C2                ((I2C_TypeDef *) I2C2_BASE)[m
[32m+[m[32m#define CAN1                ((CAN_TypeDef *) CAN1_BASE)[m
[32m+[m[32m#define CAN2                ((CAN_TypeDef *) CAN2_BASE)[m
[32m+[m[32m#define BKP                 ((BKP_TypeDef *) BKP_BASE)[m
[32m+[m[32m#define PWR                 ((PWR_TypeDef *) PWR_BASE)[m
[32m+[m[32m#define DAC                 ((DAC_TypeDef *) DAC_BASE)[m
[32m+[m[32m#define CEC                 ((CEC_TypeDef *) CEC_BASE)[m
[32m+[m[32m#define AFIO                ((AFIO_TypeDef *) AFIO_BASE)[m
[32m+[m[32m#define EXTI                ((EXTI_TypeDef *) EXTI_BASE)[m
[32m+[m[32m#define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)[m
[32m+[m[32m#define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)[m
[32m+[m[32m#define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)[m
[32m+[m[32m#define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)[m
[32m+[m[32m#define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)[m
[32m+[m[32m#define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)[m
[32m+[m[32m#define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)[m
[32m+[m[32m#define ADC1                ((ADC_TypeDef *) ADC1_BASE)[m
[32m+[m[32m#define ADC2                ((ADC_TypeDef *) ADC2_BASE)[m
[32m+[m[32m#define TIM1                ((TIM_TypeDef *) TIM1_BASE)[m
[32m+[m[32m#define SPI1                ((SPI_TypeDef *) SPI1_BASE)[m
[32m+[m[32m#define TIM8                ((TIM_TypeDef *) TIM8_BASE)[m
[32m+[m[32m#define USART1              ((USART_TypeDef *) USART1_BASE)[m
[32m+[m[32m#define ADC3                ((ADC_TypeDef *) ADC3_BASE)[m
[32m+[m[32m#define TIM15               ((TIM_TypeDef *) TIM15_BASE)[m
[32m+[m[32m#define TIM16               ((TIM_TypeDef *) TIM16_BASE)[m
[32m+[m[32m#define TIM17               ((TIM_TypeDef *) TIM17_BASE)[m
[32m+[m[32m#define TIM9                ((TIM_TypeDef *) TIM9_BASE)[m
[32m+[m[32m#define TIM10               ((TIM_TypeDef *) TIM10_BASE)[m
[32m+[m[32m#define TIM11               ((TIM_TypeDef *) TIM11_BASE)[m
[32m+[m[32m#define SDIO                ((SDIO_TypeDef *) SDIO_BASE)[m
[32m+[m[32m#define DMA1                ((DMA_TypeDef *) DMA1_BASE)[m
[32m+[m[32m#define DMA2                ((DMA_TypeDef *) DMA2_BASE)[m
[32m+[m[32m#define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)[m
[32m+[m[32m#define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)[m
[32m+[m[32m#define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)[m
[32m+[m[32m#define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)[m
[32m+[m[32m#define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)[m
[32m+[m[32m#define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)[m
[32m+[m[32m#define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)[m
[32m+[m[32m#define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)[m
[32m+[m[32m#define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)[m
[32m+[m[32m#define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)[m
[32m+[m[32m#define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)[m
[32m+[m[32m#define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)[m
[32m+[m[32m#define RCC                 ((RCC_TypeDef *) RCC_BASE)[m
[32m+[m[32m#define CRC                 ((CRC_TypeDef *) CRC_BASE)[m
[32m+[m[32m#define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)[m
[32m+[m[32m#define OB                  ((OB_TypeDef *) OB_BASE)[m[41m [m
[32m+[m[32m#define ETH                 ((ETH_TypeDef *) ETH_BASE)[m
[32m+[m[32m#define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)[m
[32m+[m[32m#define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)[m
[32m+[m[32m#define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)[m
[32m+[m[32m#define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)[m
[32m+[m[32m#define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)[m
[32m+[m[32m#define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/** @addtogroup Exported_constants[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m  [m
[32m+[m[32m  /** @addtogroup Peripheral_Registers_Bits_Definition[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m[41m    [m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                         Peripheral Registers_Bits_Definition               */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                          CRC calculation unit                              */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CRC_DR register  *********************/[m
[32m+[m[32m#define  CRC_DR_DR                           ((uint32_t)0xFFFFFFFF) /*!< Data register bits */[m
[32m+[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CRC_IDR register  ********************/[m
[32m+[m[32m#define  CRC_IDR_IDR                         ((uint8_t)0xFF)        /*!< General-purpose 8-bit data register bits */[m
[32m+[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CRC_CR register  ********************/[m
[32m+[m[32m#define  CRC_CR_RESET                        ((uint8_t)0x01)        /*!< RESET bit */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                             Power Control                                  */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/********************  Bit definition for PWR_CR register  ********************/[m
[32m+[m[32m#define  PWR_CR_LPDS                         ((uint16_t)0x0001)     /*!< Low-Power Deepsleep */[m
[32m+[m[32m#define  PWR_CR_PDDS                         ((uint16_t)0x0002)     /*!< Power Down Deepsleep */[m
[32m+[m[32m#define  PWR_CR_CWUF                         ((uint16_t)0x0004)     /*!< Clear Wakeup Flag */[m
[32m+[m[32m#define  PWR_CR_CSBF                         ((uint16_t)0x0008)     /*!< Clear Standby Flag */[m
[32m+[m[32m#define  PWR_CR_PVDE                         ((uint16_t)0x0010)     /*!< Power Voltage Detector Enable */[m
[32m+[m
[32m+[m[32m#define  PWR_CR_PLS                          ((uint16_t)0x00E0)     /*!< PLS[2:0] bits (PVD Level Selection) */[m
[32m+[m[32m#define  PWR_CR_PLS_0                        ((uint16_t)0x0020)     /*!< Bit 0 */[m
[32m+[m[32m#define  PWR_CR_PLS_1                        ((uint16_t)0x0040)     /*!< Bit 1 */[m
[32m+[m[32m#define  PWR_CR_PLS_2                        ((uint16_t)0x0080)     /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/*!< PVD level configuration */[m
[32m+[m[32m#define  PWR_CR_PLS_2V2                      ((uint16_t)0x0000)     /*!< PVD level 2.2V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V3                      ((uint16_t)0x0020)     /*!< PVD level 2.3V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V4                      ((uint16_t)0x0040)     /*!< PVD level 2.4V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V5                      ((uint16_t)0x0060)     /*!< PVD level 2.5V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V6                      ((uint16_t)0x0080)     /*!< PVD level 2.6V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V7                      ((uint16_t)0x00A0)     /*!< PVD level 2.7V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V8                      ((uint16_t)0x00C0)     /*!< PVD level 2.8V */[m
[32m+[m[32m#define  PWR_CR_PLS_2V9                      ((uint16_t)0x00E0)     /*!< PVD level 2.9V */[m
[32m+[m
[32m+[m[32m#define  PWR_CR_DBP                          ((uint16_t)0x0100)     /*!< Disable Backup Domain write protection */[m
[32m+[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for PWR_CSR register  ********************/[m
[32m+[m[32m#define  PWR_CSR_WUF                         ((uint16_t)0x0001)     /*!< Wakeup Flag */[m
[32m+[m[32m#define  PWR_CSR_SBF                         ((uint16_t)0x0002)     /*!< Standby Flag */[m
[32m+[m[32m#define  PWR_CSR_PVDO                        ((uint16_t)0x0004)     /*!< PVD Output */[m
[32m+[m[32m#define  PWR_CSR_EWUP                        ((uint16_t)0x0100)     /*!< Enable WKUP pin */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                            Backup registers                                */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR1 register  ********************/[m
[32m+[m[32m#define  BKP_DR1_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR2 register  ********************/[m
[32m+[m[32m#define  BKP_DR2_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR3 register  ********************/[m
[32m+[m[32m#define  BKP_DR3_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR4 register  ********************/[m
[32m+[m[32m#define  BKP_DR4_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR5 register  ********************/[m
[32m+[m[32m#define  BKP_DR5_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR6 register  ********************/[m
[32m+[m[32m#define  BKP_DR6_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR7 register  ********************/[m
[32m+[m[32m#define  BKP_DR7_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR8 register  ********************/[m
[32m+[m[32m#define  BKP_DR8_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR9 register  ********************/[m
[32m+[m[32m#define  BKP_DR9_D                           ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR10 register  *******************/[m
[32m+[m[32m#define  BKP_DR10_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR11 register  *******************/[m
[32m+[m[32m#define  BKP_DR11_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR12 register  *******************/[m
[32m+[m[32m#define  BKP_DR12_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR13 register  *******************/[m
[32m+[m[32m#define  BKP_DR13_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR14 register  *******************/[m
[32m+[m[32m#define  BKP_DR14_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR15 register  *******************/[m
[32m+[m[32m#define  BKP_DR15_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR16 register  *******************/[m
[32m+[m[32m#define  BKP_DR16_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR17 register  *******************/[m
[32m+[m[32m#define  BKP_DR17_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for BKP_DR18 register  ********************/[m
[32m+[m[32m#define  BKP_DR18_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR19 register  *******************/[m
[32m+[m[32m#define  BKP_DR19_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR20 register  *******************/[m
[32m+[m[32m#define  BKP_DR20_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR21 register  *******************/[m
[32m+[m[32m#define  BKP_DR21_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR22 register  *******************/[m
[32m+[m[32m#define  BKP_DR22_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR23 register  *******************/[m
[32m+[m[32m#define  BKP_DR23_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR24 register  *******************/[m
[32m+[m[32m#define  BKP_DR24_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR25 register  *******************/[m
[32m+[m[32m#define  BKP_DR25_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR26 register  *******************/[m
[32m+[m[32m#define  BKP_DR26_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR27 register  *******************/[m
[32m+[m[32m#define  BKP_DR27_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR28 register  *******************/[m
[32m+[m[32m#define  BKP_DR28_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR29 register  *******************/[m
[32m+[m[32m#define  BKP_DR29_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR30 register  *******************/[m
[32m+[m[32m#define  BKP_DR30_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR31 register  *******************/[m
[32m+[m[32m#define  BKP_DR31_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR32 register  *******************/[m
[32m+[m[32m#define  BKP_DR32_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR33 register  *******************/[m
[32m+[m[32m#define  BKP_DR33_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR34 register  *******************/[m
[32m+[m[32m#define  BKP_DR34_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR35 register  *******************/[m
[32m+[m[32m#define  BKP_DR35_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR36 register  *******************/[m
[32m+[m[32m#define  BKP_DR36_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR37 register  *******************/[m
[32m+[m[32m#define  BKP_DR37_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR38 register  *******************/[m
[32m+[m[32m#define  BKP_DR38_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR39 register  *******************/[m
[32m+[m[32m#define  BKP_DR39_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR40 register  *******************/[m
[32m+[m[32m#define  BKP_DR40_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR41 register  *******************/[m
[32m+[m[32m#define  BKP_DR41_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_DR42 register  *******************/[m
[32m+[m[32m#define  BKP_DR42_D                          ((uint16_t)0xFFFF)     /*!< Backup data */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for BKP_RTCCR register  *******************/[m
[32m+[m[32m#define  BKP_RTCCR_CAL                       ((uint16_t)0x007F)     /*!< Calibration value */[m
[32m+[m[32m#define  BKP_RTCCR_CCO                       ((uint16_t)0x0080)     /*!< Calibration Clock Output */[m
[32m+[m[32m#define  BKP_RTCCR_ASOE                      ((uint16_t)0x0100)     /*!< Alarm or Second Output Enable */[m
[32m+[m[32m#define  BKP_RTCCR_ASOS                      ((uint16_t)0x0200)     /*!< Alarm or Second Output Selection */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for BKP_CR register  ********************/[m
[32m+[m[32m#define  BKP_CR_TPE                          ((uint8_t)0x01)        /*!< TAMPER pin enable */[m
[32m+[m[32m#define  BKP_CR_TPAL                         ((uint8_t)0x02)        /*!< TAMPER pin active level */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for BKP_CSR register  ********************/[m
[32m+[m[32m#define  BKP_CSR_CTE                         ((uint16_t)0x0001)     /*!< Clear Tamper event */[m
[32m+[m[32m#define  BKP_CSR_CTI                         ((uint16_t)0x0002)     /*!< Clear Tamper Interrupt */[m
[32m+[m[32m#define  BKP_CSR_TPIE                        ((uint16_t)0x0004)     /*!< TAMPER Pin interrupt enable */[m
[32m+[m[32m#define  BKP_CSR_TEF                         ((uint16_t)0x0100)     /*!< Tamper Event Flag */[m
[32m+[m[32m#define  BKP_CSR_TIF                         ((uint16_t)0x0200)     /*!< Tamper Interrupt Flag */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                         Reset and Clock Control                            */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/********************  Bit definition for RCC_CR register  ********************/[m
[32m+[m[32m#define  RCC_CR_HSION                        ((uint32_t)0x00000001)        /*!< Internal High Speed clock enable */[m
[32m+[m[32m#define  RCC_CR_HSIRDY                       ((uint32_t)0x00000002)        /*!< Internal High Speed clock ready flag */[m
[32m+[m[32m#define  RCC_CR_HSITRIM                      ((uint32_t)0x000000F8)        /*!< Internal High Speed clock trimming */[m
[32m+[m[32m#define  RCC_CR_HSICAL                       ((uint32_t)0x0000FF00)        /*!< Internal High Speed clock Calibration */[m
[32m+[m[32m#define  RCC_CR_HSEON                        ((uint32_t)0x00010000)        /*!< External High Speed clock enable */[m
[32m+[m[32m#define  RCC_CR_HSERDY                       ((uint32_t)0x00020000)        /*!< External High Speed clock ready flag */[m
[32m+[m[32m#define  RCC_CR_HSEBYP                       ((uint32_t)0x00040000)        /*!< External High Speed clock Bypass */[m
[32m+[m[32m#define  RCC_CR_CSSON                        ((uint32_t)0x00080000)        /*!< Clock Security System enable */[m
[32m+[m[32m#define  RCC_CR_PLLON                        ((uint32_t)0x01000000)        /*!< PLL enable */[m
[32m+[m[32m#define  RCC_CR_PLLRDY                       ((uint32_t)0x02000000)        /*!< PLL clock ready flag */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define  RCC_CR_PLL2ON                       ((uint32_t)0x04000000)        /*!< PLL2 enable */[m
[32m+[m[32m #define  RCC_CR_PLL2RDY                      ((uint32_t)0x08000000)        /*!< PLL2 clock ready flag */[m
[32m+[m[32m #define  RCC_CR_PLL3ON                       ((uint32_t)0x10000000)        /*!< PLL3 enable */[m
[32m+[m[32m #define  RCC_CR_PLL3RDY                      ((uint32_t)0x20000000)        /*!< PLL3 clock ready flag */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RCC_CFGR register  *******************/[m
[32m+[m[32m/*!< SW configuration */[m
[32m+[m[32m#define  RCC_CFGR_SW                         ((uint32_t)0x00000003)        /*!< SW[1:0] bits (System clock Switch) */[m
[32m+[m[32m#define  RCC_CFGR_SW_0                       ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_SW_1                       ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_SW_HSI                     ((uint32_t)0x00000000)        /*!< HSI selected as system clock */[m
[32m+[m[32m#define  RCC_CFGR_SW_HSE                     ((uint32_t)0x00000001)        /*!< HSE selected as system clock */[m
[32m+[m[32m#define  RCC_CFGR_SW_PLL                     ((uint32_t)0x00000002)        /*!< PLL selected as system clock */[m
[32m+[m
[32m+[m[32m/*!< SWS configuration */[m
[32m+[m[32m#define  RCC_CFGR_SWS                        ((uint32_t)0x0000000C)        /*!< SWS[1:0] bits (System Clock Switch Status) */[m
[32m+[m[32m#define  RCC_CFGR_SWS_0                      ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_SWS_1                      ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_SWS_HSI                    ((uint32_t)0x00000000)        /*!< HSI oscillator used as system clock */[m
[32m+[m[32m#define  RCC_CFGR_SWS_HSE                    ((uint32_t)0x00000004)        /*!< HSE oscillator used as system clock */[m
[32m+[m[32m#define  RCC_CFGR_SWS_PLL                    ((uint32_t)0x00000008)        /*!< PLL used as system clock */[m
[32m+[m
[32m+[m[32m/*!< HPRE configuration */[m
[32m+[m[32m#define  RCC_CFGR_HPRE                       ((uint32_t)0x000000F0)        /*!< HPRE[3:0] bits (AHB prescaler) */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_0                     ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_1                     ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_2                     ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_3                     ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV1                  ((uint32_t)0x00000000)        /*!< SYSCLK not divided */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV2                  ((uint32_t)0x00000080)        /*!< SYSCLK divided by 2 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV4                  ((uint32_t)0x00000090)        /*!< SYSCLK divided by 4 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV8                  ((uint32_t)0x000000A0)        /*!< SYSCLK divided by 8 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV16                 ((uint32_t)0x000000B0)        /*!< SYSCLK divided by 16 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV64                 ((uint32_t)0x000000C0)        /*!< SYSCLK divided by 64 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV128                ((uint32_t)0x000000D0)        /*!< SYSCLK divided by 128 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV256                ((uint32_t)0x000000E0)        /*!< SYSCLK divided by 256 */[m
[32m+[m[32m#define  RCC_CFGR_HPRE_DIV512                ((uint32_t)0x000000F0)        /*!< SYSCLK divided by 512 */[m
[32m+[m
[32m+[m[32m/*!< PPRE1 configuration */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1                      ((uint32_t)0x00000700)        /*!< PRE1[2:0] bits (APB1 prescaler) */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_2                    ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_DIV2                 ((uint32_t)0x00000400)        /*!< HCLK divided by 2 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_DIV4                 ((uint32_t)0x00000500)        /*!< HCLK divided by 4 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_DIV8                 ((uint32_t)0x00000600)        /*!< HCLK divided by 8 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE1_DIV16                ((uint32_t)0x00000700)        /*!< HCLK divided by 16 */[m
[32m+[m
[32m+[m[32m/*!< PPRE2 configuration */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2                      ((uint32_t)0x00003800)        /*!< PRE2[2:0] bits (APB2 prescaler) */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_0                    ((uint32_t)0x00000800)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_1                    ((uint32_t)0x00001000)        /*!< Bit 1 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_2                    ((uint32_t)0x00002000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_DIV1                 ((uint32_t)0x00000000)        /*!< HCLK not divided */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_DIV2                 ((uint32_t)0x00002000)        /*!< HCLK divided by 2 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_DIV4                 ((uint32_t)0x00002800)        /*!< HCLK divided by 4 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_DIV8                 ((uint32_t)0x00003000)        /*!< HCLK divided by 8 */[m
[32m+[m[32m#define  RCC_CFGR_PPRE2_DIV16                ((uint32_t)0x00003800)        /*!< HCLK divided by 16 */[m
[32m+[m
[32m+[m[32m/*!< ADCPPRE configuration */[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE                     ((uint32_t)0x0000C000)        /*!< ADCPRE[1:0] bits (ADC prescaler) */[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE_0                   ((uint32_t)0x00004000)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE_1                   ((uint32_t)0x00008000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE_DIV2                ((uint32_t)0x00000000)        /*!< PCLK2 divided by 2 */[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE_DIV4                ((uint32_t)0x00004000)        /*!< PCLK2 divided by 4 */[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE_DIV6                ((uint32_t)0x00008000)        /*!< PCLK2 divided by 6 */[m
[32m+[m[32m#define  RCC_CFGR_ADCPRE_DIV8                ((uint32_t)0x0000C000)        /*!< PCLK2 divided by 8 */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_PLLSRC                     ((uint32_t)0x00010000)        /*!< PLL entry clock source */[m
[32m+[m
[32m+[m[32m#define  RCC_CFGR_PLLXTPRE                   ((uint32_t)0x00020000)        /*!< HSE divider for PLL entry */[m
[32m+[m
[32m+[m[32m/*!< PLLMUL configuration */[m
[32m+[m[32m#define  RCC_CFGR_PLLMULL                    ((uint32_t)0x003C0000)        /*!< PLLMUL[3:0] bits (PLL multiplication factor) */[m
[32m+[m[32m#define  RCC_CFGR_PLLMULL_0                  ((uint32_t)0x00040000)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_CFGR_PLLMULL_1                  ((uint32_t)0x00080000)        /*!< Bit 1 */[m
[32m+[m[32m#define  RCC_CFGR_PLLMULL_2                  ((uint32_t)0x00100000)        /*!< Bit 2 */[m
[32m+[m[32m#define  RCC_CFGR_PLLMULL_3                  ((uint32_t)0x00200000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */[m
[32m+[m[32m #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */[m
[32m+[m[32m #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock * 4 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock * 5 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock * 6 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock * 7 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock * 8 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock * 9 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL6_5                ((uint32_t)0x00340000)        /*!< PLL input clock * 6.5 */[m
[32m+[m[41m [m
[32m+[m[32m #define  RCC_CFGR_OTGFSPRE                  ((uint32_t)0x00400000)        /*!< USB OTG FS prescaler */[m
[32m+[m[41m [m
[32m+[m[32m/*!< MCO configuration */[m
[32m+[m[32m #define  RCC_CFGR_MCO                       ((uint32_t)0x0F000000)        /*!< MCO[3:0] bits (Microcontroller Clock Output) */[m
[32m+[m[32m #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_3                     ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */[m
[32m+[m[32m #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_PLLCLK_Div2           ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_PLL2CLK               ((uint32_t)0x08000000)        /*!< PLL2 clock selected as MCO source*/[m
[32m+[m[32m #define  RCC_CFGR_MCO_PLL3CLK_Div2          ((uint32_t)0x09000000)        /*!< PLL3 clock divided by 2 selected as MCO source*/[m
[32m+[m[32m #define  RCC_CFGR_MCO_Ext_HSE               ((uint32_t)0x0A000000)        /*!< XT1 external 3-25 MHz oscillator clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_PLL3CLK               ((uint32_t)0x0B000000)        /*!< PLL3 clock selected as MCO source */[m
[32m+[m[32m#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */[m
[32m+[m[32m #define  RCC_CFGR_PLLSRC_PREDIV1            ((uint32_t)0x00010000)        /*!< PREDIV1 clock selected as PLL entry clock source */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_PLLXTPRE_PREDIV1          ((uint32_t)0x00000000)        /*!< PREDIV1 clock not divided for PLL entry */[m
[32m+[m[32m #define  RCC_CFGR_PLLXTPRE_PREDIV1_Div2     ((uint32_t)0x00020000)        /*!< PREDIV1 clock divided by 2 for PLL entry */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */[m
[32m+[m
[32m+[m[32m/*!< MCO configuration */[m
[32m+[m[32m #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */[m
[32m+[m[32m #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */[m
[32m+[m[32m #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */[m
[32m+[m[32m #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */[m
[32m+[m[32m#else[m
[32m+[m[32m #define  RCC_CFGR_PLLSRC_HSI_Div2           ((uint32_t)0x00000000)        /*!< HSI clock divided by 2 selected as PLL entry clock source */[m
[32m+[m[32m #define  RCC_CFGR_PLLSRC_HSE                ((uint32_t)0x00010000)        /*!< HSE clock selected as PLL entry clock source */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_PLLXTPRE_HSE              ((uint32_t)0x00000000)        /*!< HSE clock not divided for PLL entry */[m
[32m+[m[32m #define  RCC_CFGR_PLLXTPRE_HSE_Div2         ((uint32_t)0x00020000)        /*!< HSE clock divided by 2 for PLL entry */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL2                  ((uint32_t)0x00000000)        /*!< PLL input clock*2 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL3                  ((uint32_t)0x00040000)        /*!< PLL input clock*3 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL4                  ((uint32_t)0x00080000)        /*!< PLL input clock*4 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL5                  ((uint32_t)0x000C0000)        /*!< PLL input clock*5 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL6                  ((uint32_t)0x00100000)        /*!< PLL input clock*6 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL7                  ((uint32_t)0x00140000)        /*!< PLL input clock*7 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL8                  ((uint32_t)0x00180000)        /*!< PLL input clock*8 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL9                  ((uint32_t)0x001C0000)        /*!< PLL input clock*9 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL10                 ((uint32_t)0x00200000)        /*!< PLL input clock10 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL11                 ((uint32_t)0x00240000)        /*!< PLL input clock*11 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL12                 ((uint32_t)0x00280000)        /*!< PLL input clock*12 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL13                 ((uint32_t)0x002C0000)        /*!< PLL input clock*13 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL14                 ((uint32_t)0x00300000)        /*!< PLL input clock*14 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL15                 ((uint32_t)0x00340000)        /*!< PLL input clock*15 */[m
[32m+[m[32m #define  RCC_CFGR_PLLMULL16                 ((uint32_t)0x00380000)        /*!< PLL input clock*16 */[m
[32m+[m[32m #define  RCC_CFGR_USBPRE                    ((uint32_t)0x00400000)        /*!< USB Device prescaler */[m
[32m+[m
[32m+[m[32m/*!< MCO configuration */[m
[32m+[m[32m #define  RCC_CFGR_MCO                       ((uint32_t)0x07000000)        /*!< MCO[2:0] bits (Microcontroller Clock Output) */[m
[32m+[m[32m #define  RCC_CFGR_MCO_0                     ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_1                     ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR_MCO_2                     ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR_MCO_NOCLOCK               ((uint32_t)0x00000000)        /*!< No clock */[m
[32m+[m[32m #define  RCC_CFGR_MCO_SYSCLK                ((uint32_t)0x04000000)        /*!< System clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_HSI                   ((uint32_t)0x05000000)        /*!< HSI clock selected as MCO source */[m
[32m+[m[32m #define  RCC_CFGR_MCO_HSE                   ((uint32_t)0x06000000)        /*!< HSE clock selected as MCO source  */[m
[32m+[m[32m #define  RCC_CFGR_MCO_PLL                   ((uint32_t)0x07000000)        /*!< PLL clock divided by 2 selected as MCO source */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/*!<******************  Bit definition for RCC_CIR register  ********************/[m
[32m+[m[32m#define  RCC_CIR_LSIRDYF                     ((uint32_t)0x00000001)        /*!< LSI Ready Interrupt flag */[m
[32m+[m[32m#define  RCC_CIR_LSERDYF                     ((uint32_t)0x00000002)        /*!< LSE Ready Interrupt flag */[m
[32m+[m[32m#define  RCC_CIR_HSIRDYF                     ((uint32_t)0x00000004)        /*!< HSI Ready Interrupt flag */[m
[32m+[m[32m#define  RCC_CIR_HSERDYF                     ((uint32_t)0x00000008)        /*!< HSE Ready Interrupt flag */[m
[32m+[m[32m#define  RCC_CIR_PLLRDYF                     ((uint32_t)0x00000010)        /*!< PLL Ready Interrupt flag */[m
[32m+[m[32m#define  RCC_CIR_CSSF                        ((uint32_t)0x00000080)        /*!< Clock Security System Interrupt flag */[m
[32m+[m[32m#define  RCC_CIR_LSIRDYIE                    ((uint32_t)0x00000100)        /*!< LSI Ready Interrupt Enable */[m
[32m+[m[32m#define  RCC_CIR_LSERDYIE                    ((uint32_t)0x00000200)        /*!< LSE Ready Interrupt Enable */[m
[32m+[m[32m#define  RCC_CIR_HSIRDYIE                    ((uint32_t)0x00000400)        /*!< HSI Ready Interrupt Enable */[m
[32m+[m[32m#define  RCC_CIR_HSERDYIE                    ((uint32_t)0x00000800)        /*!< HSE Ready Interrupt Enable */[m
[32m+[m[32m#define  RCC_CIR_PLLRDYIE                    ((uint32_t)0x00001000)        /*!< PLL Ready Interrupt Enable */[m
[32m+[m[32m#define  RCC_CIR_LSIRDYC                     ((uint32_t)0x00010000)        /*!< LSI Ready Interrupt Clear */[m
[32m+[m[32m#define  RCC_CIR_LSERDYC                     ((uint32_t)0x00020000)        /*!< LSE Ready Interrupt Clear */[m
[32m+[m[32m#define  RCC_CIR_HSIRDYC                     ((uint32_t)0x00040000)        /*!< HSI Ready Interrupt Clear */[m
[32m+[m[32m#define  RCC_CIR_HSERDYC                     ((uint32_t)0x00080000)        /*!< HSE Ready Interrupt Clear */[m
[32m+[m[32m#define  RCC_CIR_PLLRDYC                     ((uint32_t)0x00100000)        /*!< PLL Ready Interrupt Clear */[m
[32m+[m[32m#define  RCC_CIR_CSSC                        ((uint32_t)0x00800000)        /*!< Clock Security System Interrupt Clear */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define  RCC_CIR_PLL2RDYF                    ((uint32_t)0x00000020)        /*!< PLL2 Ready Interrupt flag */[m
[32m+[m[32m #define  RCC_CIR_PLL3RDYF                    ((uint32_t)0x00000040)        /*!< PLL3 Ready Interrupt flag */[m
[32m+[m[32m #define  RCC_CIR_PLL2RDYIE                   ((uint32_t)0x00002000)        /*!< PLL2 Ready Interrupt Enable */[m
[32m+[m[32m #define  RCC_CIR_PLL3RDYIE                   ((uint32_t)0x00004000)        /*!< PLL3 Ready Interrupt Enable */[m
[32m+[m[32m #define  RCC_CIR_PLL2RDYC                    ((uint32_t)0x00200000)        /*!< PLL2 Ready Interrupt Clear */[m
[32m+[m[32m #define  RCC_CIR_PLL3RDYC                    ((uint32_t)0x00400000)        /*!< PLL3 Ready Interrupt Clear */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for RCC_APB2RSTR register  *****************/[m
[32m+[m[32m#define  RCC_APB2RSTR_AFIORST                ((uint32_t)0x00000001)        /*!< Alternate Function I/O reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_IOPARST                ((uint32_t)0x00000004)        /*!< I/O port A reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_IOPBRST                ((uint32_t)0x00000008)        /*!< I/O port B reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_IOPCRST                ((uint32_t)0x00000010)        /*!< I/O port C reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_IOPDRST                ((uint32_t)0x00000020)        /*!< I/O port D reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_ADC1RST                ((uint32_t)0x00000200)        /*!< ADC 1 interface reset */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)[m
[32m+[m[32m#define  RCC_APB2RSTR_ADC2RST                ((uint32_t)0x00000400)        /*!< ADC 2 interface reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#define  RCC_APB2RSTR_TIM1RST                ((uint32_t)0x00000800)        /*!< TIM1 Timer reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_SPI1RST                ((uint32_t)0x00001000)        /*!< SPI 1 reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_USART1RST              ((uint32_t)0x00004000)        /*!< USART1 reset */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m#define  RCC_APB2RSTR_TIM15RST               ((uint32_t)0x00010000)        /*!< TIM15 Timer reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_TIM16RST               ((uint32_t)0x00020000)        /*!< TIM16 Timer reset */[m
[32m+[m[32m#define  RCC_APB2RSTR_TIM17RST               ((uint32_t)0x00040000)        /*!< TIM17 Timer reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)[m
[32m+[m[32m #define  RCC_APB2RSTR_IOPERST               ((uint32_t)0x00000040)        /*!< I/O port E reset */[m
[32m+[m[32m#endif /* STM32F10X_LD && STM32F10X_LD_VL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined (STM32F10X_XL)[m
[32m+[m[32m #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */[m
[32m+[m[32m #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */[m
[32m+[m[32m #define  RCC_APB2RSTR_TIM8RST               ((uint32_t)0x00002000)        /*!< TIM8 Timer reset */[m
[32m+[m[32m #define  RCC_APB2RSTR_ADC3RST               ((uint32_t)0x00008000)        /*!< ADC3 interface reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_APB2RSTR_IOPFRST               ((uint32_t)0x00000080)        /*!< I/O port F reset */[m
[32m+[m[32m #define  RCC_APB2RSTR_IOPGRST               ((uint32_t)0x00000100)        /*!< I/O port G reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m #define  RCC_APB2RSTR_TIM9RST               ((uint32_t)0x00080000)         /*!< TIM9 Timer reset */[m
[32m+[m[32m #define  RCC_APB2RSTR_TIM10RST              ((uint32_t)0x00100000)         /*!< TIM10 Timer reset */[m
[32m+[m[32m #define  RCC_APB2RSTR_TIM11RST              ((uint32_t)0x00200000)         /*!< TIM11 Timer reset */[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for RCC_APB1RSTR register  *****************/[m
[32m+[m[32m#define  RCC_APB1RSTR_TIM2RST                ((uint32_t)0x00000001)        /*!< Timer 2 reset */[m
[32m+[m[32m#define  RCC_APB1RSTR_TIM3RST                ((uint32_t)0x00000002)        /*!< Timer 3 reset */[m
[32m+[m[32m#define  RCC_APB1RSTR_WWDGRST                ((uint32_t)0x00000800)        /*!< Window Watchdog reset */[m
[32m+[m[32m#define  RCC_APB1RSTR_USART2RST              ((uint32_t)0x00020000)        /*!< USART 2 reset */[m
[32m+[m[32m#define  RCC_APB1RSTR_I2C1RST                ((uint32_t)0x00200000)        /*!< I2C 1 reset */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)[m
[32m+[m[32m#define  RCC_APB1RSTR_CAN1RST                ((uint32_t)0x02000000)        /*!< CAN1 reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#define  RCC_APB1RSTR_BKPRST                 ((uint32_t)0x08000000)        /*!< Backup interface reset */[m
[32m+[m[32m#define  RCC_APB1RSTR_PWRRST                 ((uint32_t)0x10000000)        /*!< Power interface reset */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM4RST               ((uint32_t)0x00000004)        /*!< Timer 4 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_SPI2RST               ((uint32_t)0x00004000)        /*!< SPI 2 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_USART3RST             ((uint32_t)0x00040000)        /*!< USART 3 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_I2C2RST               ((uint32_t)0x00400000)        /*!< I2C 2 reset */[m
[32m+[m[32m#endif /* STM32F10X_LD && STM32F10X_LD_VL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined (STM32F10X_LD) || defined  (STM32F10X_XL)[m
[32m+[m[32m #define  RCC_APB1RSTR_USBRST                ((uint32_t)0x00800000)        /*!< USB Device reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_XL)[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM6RST                ((uint32_t)0x00000010)        /*!< Timer 6 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM7RST                ((uint32_t)0x00000020)        /*!< Timer 7 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_DACRST                 ((uint32_t)0x20000000)        /*!< DAC interface reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_CECRST                 ((uint32_t)0x40000000)        /*!< CEC interface reset */[m[41m [m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined  (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM5RST                ((uint32_t)0x00000008)        /*!< Timer 5 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)        /*!< TIM12 Timer reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)        /*!< TIM13 Timer reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)        /*!< TIM14 Timer reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_SPI3RST                ((uint32_t)0x00008000)        /*!< SPI 3 reset */[m[41m [m
[32m+[m[32m #define  RCC_APB1RSTR_UART4RST               ((uint32_t)0x00080000)        /*!< UART 4 reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_UART5RST               ((uint32_t)0x00100000)        /*!< UART 5 reset */[m[41m [m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define  RCC_APB1RSTR_CAN2RST                ((uint32_t)0x04000000)        /*!< CAN2 reset */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM12RST               ((uint32_t)0x00000040)         /*!< TIM12 Timer reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM13RST               ((uint32_t)0x00000080)         /*!< TIM13 Timer reset */[m
[32m+[m[32m #define  RCC_APB1RSTR_TIM14RST               ((uint32_t)0x00000100)         /*!< TIM14 Timer reset */[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for RCC_AHBENR register  ******************/[m
[32m+[m[32m#define  RCC_AHBENR_DMA1EN                   ((uint16_t)0x0001)            /*!< DMA1 clock enable */[m
[32m+[m[32m#define  RCC_AHBENR_SRAMEN                   ((uint16_t)0x0004)            /*!< SRAM interface clock enable */[m
[32m+[m[32m#define  RCC_AHBENR_FLITFEN                  ((uint16_t)0x0010)            /*!< FLITF clock enable */[m
[32m+[m[32m#define  RCC_AHBENR_CRCEN                    ((uint16_t)0x0040)            /*!< CRC clock enable */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined  (STM32F10X_CL) || defined  (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_AHBENR_DMA2EN                  ((uint16_t)0x0002)            /*!< DMA2 clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined (STM32F10X_XL)[m
[32m+[m[32m #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */[m
[32m+[m[32m #define  RCC_AHBENR_SDIOEN                  ((uint16_t)0x0400)            /*!< SDIO clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_AHBENR_FSMCEN                  ((uint16_t)0x0100)            /*!< FSMC clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define  RCC_AHBENR_OTGFSEN                 ((uint32_t)0x00001000)         /*!< USB OTG FS clock enable */[m
[32m+[m[32m #define  RCC_AHBENR_ETHMACEN                ((uint32_t)0x00004000)         /*!< ETHERNET MAC clock enable */[m
[32m+[m[32m #define  RCC_AHBENR_ETHMACTXEN              ((uint32_t)0x00008000)         /*!< ETHERNET MAC Tx clock enable */[m
[32m+[m[32m #define  RCC_AHBENR_ETHMACRXEN              ((uint32_t)0x00010000)         /*!< ETHERNET MAC Rx clock enable */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for RCC_APB2ENR register  *****************/[m
[32m+[m[32m#define  RCC_APB2ENR_AFIOEN                  ((uint32_t)0x00000001)         /*!< Alternate Function I/O clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_IOPAEN                  ((uint32_t)0x00000004)         /*!< I/O port A clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_IOPBEN                  ((uint32_t)0x00000008)         /*!< I/O port B clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_IOPCEN                  ((uint32_t)0x00000010)         /*!< I/O port C clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_IOPDEN                  ((uint32_t)0x00000020)         /*!< I/O port D clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_ADC1EN                  ((uint32_t)0x00000200)         /*!< ADC 1 interface clock enable */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)[m
[32m+[m[32m#define  RCC_APB2ENR_ADC2EN                  ((uint32_t)0x00000400)         /*!< ADC 2 interface clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#define  RCC_APB2ENR_TIM1EN                  ((uint32_t)0x00000800)         /*!< TIM1 Timer clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_SPI1EN                  ((uint32_t)0x00001000)         /*!< SPI 1 clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_USART1EN                ((uint32_t)0x00004000)         /*!< USART1 clock enable */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m#define  RCC_APB2ENR_TIM15EN                 ((uint32_t)0x00010000)         /*!< TIM15 Timer clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_TIM16EN                 ((uint32_t)0x00020000)         /*!< TIM16 Timer clock enable */[m
[32m+[m[32m#define  RCC_APB2ENR_TIM17EN                 ((uint32_t)0x00040000)         /*!< TIM17 Timer clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)[m
[32m+[m[32m #define  RCC_APB2ENR_IOPEEN                 ((uint32_t)0x00000040)         /*!< I/O port E clock enable */[m
[32m+[m[32m#endif /* STM32F10X_LD && STM32F10X_LD_VL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined (STM32F10X_XL)[m
[32m+[m[32m #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */[m
[32m+[m[32m #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */[m
[32m+[m[32m #define  RCC_APB2ENR_TIM8EN                 ((uint32_t)0x00002000)         /*!< TIM8 Timer clock enable */[m
[32m+[m[32m #define  RCC_APB2ENR_ADC3EN                 ((uint32_t)0x00008000)         /*!< DMA1 clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_APB2ENR_IOPFEN                 ((uint32_t)0x00000080)         /*!< I/O port F clock enable */[m
[32m+[m[32m #define  RCC_APB2ENR_IOPGEN                 ((uint32_t)0x00000100)         /*!< I/O port G clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m #define  RCC_APB2ENR_TIM9EN                 ((uint32_t)0x00080000)         /*!< TIM9 Timer clock enable  */[m
[32m+[m[32m #define  RCC_APB2ENR_TIM10EN                ((uint32_t)0x00100000)         /*!< TIM10 Timer clock enable  */[m
[32m+[m[32m #define  RCC_APB2ENR_TIM11EN                ((uint32_t)0x00200000)         /*!< TIM11 Timer clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for RCC_APB1ENR register  ******************/[m
[32m+[m[32m#define  RCC_APB1ENR_TIM2EN                  ((uint32_t)0x00000001)        /*!< Timer 2 clock enabled*/[m
[32m+[m[32m#define  RCC_APB1ENR_TIM3EN                  ((uint32_t)0x00000002)        /*!< Timer 3 clock enable */[m
[32m+[m[32m#define  RCC_APB1ENR_WWDGEN                  ((uint32_t)0x00000800)        /*!< Window Watchdog clock enable */[m
[32m+[m[32m#define  RCC_APB1ENR_USART2EN                ((uint32_t)0x00020000)        /*!< USART 2 clock enable */[m
[32m+[m[32m#define  RCC_APB1ENR_I2C1EN                  ((uint32_t)0x00200000)        /*!< I2C 1 clock enable */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD_VL) && !defined (STM32F10X_MD_VL) && !defined (STM32F10X_HD_VL)[m
[32m+[m[32m#define  RCC_APB1ENR_CAN1EN                  ((uint32_t)0x02000000)        /*!< CAN1 clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#define  RCC_APB1ENR_BKPEN                   ((uint32_t)0x08000000)        /*!< Backup interface clock enable */[m
[32m+[m[32m#define  RCC_APB1ENR_PWREN                   ((uint32_t)0x10000000)        /*!< Power interface clock enable */[m
[32m+[m
[32m+[m[32m#if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)[m
[32m+[m[32m #define  RCC_APB1ENR_TIM4EN                 ((uint32_t)0x00000004)        /*!< Timer 4 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_SPI2EN                 ((uint32_t)0x00004000)        /*!< SPI 2 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_USART3EN               ((uint32_t)0x00040000)        /*!< USART 3 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_I2C2EN                 ((uint32_t)0x00400000)        /*!< I2C 2 clock enable */[m
[32m+[m[32m#endif /* STM32F10X_LD && STM32F10X_LD_VL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined (STM32F10X_MD) || defined  (STM32F10X_LD)[m
[32m+[m[32m #define  RCC_APB1ENR_USBEN                  ((uint32_t)0x00800000)        /*!< USB Device clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_HD) || defined  (STM32F10X_CL)[m
[32m+[m[32m #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined  (STM32F10X_MD_VL) || defined  (STM32F10X_HD_VL)[m
[32m+[m[32m #define  RCC_APB1ENR_TIM6EN                 ((uint32_t)0x00000010)        /*!< Timer 6 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM7EN                 ((uint32_t)0x00000020)        /*!< Timer 7 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_DACEN                  ((uint32_t)0x20000000)        /*!< DAC interface clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_CECEN                  ((uint32_t)0x40000000)        /*!< CEC interface clock enable */[m[41m [m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_HD_VL[m
[32m+[m[32m #define  RCC_APB1ENR_TIM5EN                 ((uint32_t)0x00000008)        /*!< Timer 5 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_SPI3EN                 ((uint32_t)0x00008000)        /*!< SPI 3 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_UART4EN                ((uint32_t)0x00080000)        /*!< UART 4 clock enable */[m
[32m+[m[32m #define  RCC_APB1ENR_UART5EN                ((uint32_t)0x00100000)        /*!< UART 5 clock enable */[m[41m [m
[32m+[m[32m#endif /* STM32F10X_HD_VL */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m #define  RCC_APB1ENR_CAN2EN                  ((uint32_t)0x04000000)        /*!< CAN2 clock enable */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m
[32m+[m[32m #define  RCC_APB1ENR_TIM12EN                ((uint32_t)0x00000040)         /*!< TIM12 Timer clock enable  */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM13EN                ((uint32_t)0x00000080)         /*!< TIM13 Timer clock enable  */[m
[32m+[m[32m #define  RCC_APB1ENR_TIM14EN                ((uint32_t)0x00000100)         /*!< TIM14 Timer clock enable */[m
[32m+[m[32m#endif /* STM32F10X_XL */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RCC_BDCR register  *******************/[m
[32m+[m[32m#define  RCC_BDCR_LSEON                      ((uint32_t)0x00000001)        /*!< External Low Speed oscillator enable */[m
[32m+[m[32m#define  RCC_BDCR_LSERDY                     ((uint32_t)0x00000002)        /*!< External Low Speed oscillator Ready */[m
[32m+[m[32m#define  RCC_BDCR_LSEBYP                     ((uint32_t)0x00000004)        /*!< External Low Speed oscillator Bypass */[m
[32m+[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL                     ((uint32_t)0x00000300)        /*!< RTCSEL[1:0] bits (RTC clock source selection) */[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*!< RTC congiguration */[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL_NOCLOCK             ((uint32_t)0x00000000)        /*!< No clock */[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL_LSE                 ((uint32_t)0x00000100)        /*!< LSE oscillator clock used as RTC clock */[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL_LSI                 ((uint32_t)0x00000200)        /*!< LSI oscillator clock used as RTC clock */[m
[32m+[m[32m#define  RCC_BDCR_RTCSEL_HSE                 ((uint32_t)0x00000300)        /*!< HSE oscillator clock divided by 128 used as RTC clock */[m
[32m+[m
[32m+[m[32m#define  RCC_BDCR_RTCEN                      ((uint32_t)0x00008000)        /*!< RTC clock enable */[m
[32m+[m[32m#define  RCC_BDCR_BDRST                      ((uint32_t)0x00010000)        /*!< Backup domain software reset  */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RCC_CSR register  ********************/[m[41m  [m
[32m+[m[32m#define  RCC_CSR_LSION                       ((uint32_t)0x00000001)        /*!< Internal Low Speed oscillator enable */[m
[32m+[m[32m#define  RCC_CSR_LSIRDY                      ((uint32_t)0x00000002)        /*!< Internal Low Speed oscillator Ready */[m
[32m+[m[32m#define  RCC_CSR_RMVF                        ((uint32_t)0x01000000)        /*!< Remove reset flag */[m
[32m+[m[32m#define  RCC_CSR_PINRSTF                     ((uint32_t)0x04000000)        /*!< PIN reset flag */[m
[32m+[m[32m#define  RCC_CSR_PORRSTF                     ((uint32_t)0x08000000)        /*!< POR/PDR reset flag */[m
[32m+[m[32m#define  RCC_CSR_SFTRSTF                     ((uint32_t)0x10000000)        /*!< Software Reset flag */[m
[32m+[m[32m#define  RCC_CSR_IWDGRSTF                    ((uint32_t)0x20000000)        /*!< Independent Watchdog reset flag */[m
[32m+[m[32m#define  RCC_CSR_WWDGRSTF                    ((uint32_t)0x40000000)        /*!< Window watchdog reset flag */[m
[32m+[m[32m#define  RCC_CSR_LPWRRSTF                    ((uint32_t)0x80000000)        /*!< Low-Power reset flag */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/*******************  Bit definition for RCC_AHBRSTR register  ****************/[m
[32m+[m[32m #define  RCC_AHBRSTR_OTGFSRST               ((uint32_t)0x00001000)         /*!< USB OTG FS reset */[m
[32m+[m[32m #define  RCC_AHBRSTR_ETHMACRST              ((uint32_t)0x00004000)         /*!< ETHERNET MAC reset */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RCC_CFGR2 register  ******************/[m
[32m+[m[32m/*!< PREDIV1 configuration */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */[m
[32m+[m
[32m+[m[32m/*!< PREDIV2 configuration */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2                  ((uint32_t)0x000000F0)        /*!< PREDIV2[3:0] bits */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_0                ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_1                ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_2                ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_3                ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV2 input clock not divided */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV2             ((uint32_t)0x00000010)        /*!< PREDIV2 input clock divided by 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV3             ((uint32_t)0x00000020)        /*!< PREDIV2 input clock divided by 3 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV4             ((uint32_t)0x00000030)        /*!< PREDIV2 input clock divided by 4 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV5             ((uint32_t)0x00000040)        /*!< PREDIV2 input clock divided by 5 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV6             ((uint32_t)0x00000050)        /*!< PREDIV2 input clock divided by 6 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV7             ((uint32_t)0x00000060)        /*!< PREDIV2 input clock divided by 7 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV8             ((uint32_t)0x00000070)        /*!< PREDIV2 input clock divided by 8 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV9             ((uint32_t)0x00000080)        /*!< PREDIV2 input clock divided by 9 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV10            ((uint32_t)0x00000090)        /*!< PREDIV2 input clock divided by 10 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV11            ((uint32_t)0x000000A0)        /*!< PREDIV2 input clock divided by 11 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV12            ((uint32_t)0x000000B0)        /*!< PREDIV2 input clock divided by 12 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV13            ((uint32_t)0x000000C0)        /*!< PREDIV2 input clock divided by 13 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV14            ((uint32_t)0x000000D0)        /*!< PREDIV2 input clock divided by 14 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV15            ((uint32_t)0x000000E0)        /*!< PREDIV2 input clock divided by 15 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV2_DIV16            ((uint32_t)0x000000F0)        /*!< PREDIV2 input clock divided by 16 */[m
[32m+[m
[32m+[m[32m/*!< PLL2MUL configuration */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL                  ((uint32_t)0x00000F00)        /*!< PLL2MUL[3:0] bits */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL_0                ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL_1                ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL_2                ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL_3                ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL8                 ((uint32_t)0x00000600)        /*!< PLL2 input clock * 8 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL9                 ((uint32_t)0x00000700)        /*!< PLL2 input clock * 9 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL10                ((uint32_t)0x00000800)        /*!< PLL2 input clock * 10 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL11                ((uint32_t)0x00000900)        /*!< PLL2 input clock * 11 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL12                ((uint32_t)0x00000A00)        /*!< PLL2 input clock * 12 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL13                ((uint32_t)0x00000B00)        /*!< PLL2 input clock * 13 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL14                ((uint32_t)0x00000C00)        /*!< PLL2 input clock * 14 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL16                ((uint32_t)0x00000E00)        /*!< PLL2 input clock * 16 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL2MUL20                ((uint32_t)0x00000F00)        /*!< PLL2 input clock * 20 */[m
[32m+[m
[32m+[m[32m/*!< PLL3MUL configuration */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL                  ((uint32_t)0x0000F000)        /*!< PLL3MUL[3:0] bits */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL_0                ((uint32_t)0x00001000)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL_1                ((uint32_t)0x00002000)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL_2                ((uint32_t)0x00004000)        /*!< Bit 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL_3                ((uint32_t)0x00008000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL8                 ((uint32_t)0x00006000)        /*!< PLL3 input clock * 8 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL9                 ((uint32_t)0x00007000)        /*!< PLL3 input clock * 9 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL10                ((uint32_t)0x00008000)        /*!< PLL3 input clock * 10 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL11                ((uint32_t)0x00009000)        /*!< PLL3 input clock * 11 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL12                ((uint32_t)0x0000A000)        /*!< PLL3 input clock * 12 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL13                ((uint32_t)0x0000B000)        /*!< PLL3 input clock * 13 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL14                ((uint32_t)0x0000C000)        /*!< PLL3 input clock * 14 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL16                ((uint32_t)0x0000E000)        /*!< PLL3 input clock * 16 */[m
[32m+[m[32m #define  RCC_CFGR2_PLL3MUL20                ((uint32_t)0x0000F000)        /*!< PLL3 input clock * 20 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1SRC               ((uint32_t)0x00010000)        /*!< PREDIV1 entry clock source */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1SRC_PLL2          ((uint32_t)0x00010000)        /*!< PLL2 selected as PREDIV1 entry clock source */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1SRC_HSE           ((uint32_t)0x00000000)        /*!< HSE selected as PREDIV1 entry clock source */[m
[32m+[m[32m #define  RCC_CFGR2_I2S2SRC                  ((uint32_t)0x00020000)        /*!< I2S2 entry clock source */[m
[32m+[m[32m #define  RCC_CFGR2_I2S3SRC                  ((uint32_t)0x00040000)        /*!< I2S3 clock source */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m/*******************  Bit definition for RCC_CFGR2 register  ******************/[m
[32m+[m[32m/*!< PREDIV1 configuration */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1                  ((uint32_t)0x0000000F)        /*!< PREDIV1[3:0] bits */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV1             ((uint32_t)0x00000000)        /*!< PREDIV1 input clock not divided */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV2             ((uint32_t)0x00000001)        /*!< PREDIV1 input clock divided by 2 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV3             ((uint32_t)0x00000002)        /*!< PREDIV1 input clock divided by 3 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV4             ((uint32_t)0x00000003)        /*!< PREDIV1 input clock divided by 4 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV5             ((uint32_t)0x00000004)        /*!< PREDIV1 input clock divided by 5 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV6             ((uint32_t)0x00000005)        /*!< PREDIV1 input clock divided by 6 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV7             ((uint32_t)0x00000006)        /*!< PREDIV1 input clock divided by 7 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV8             ((uint32_t)0x00000007)        /*!< PREDIV1 input clock divided by 8 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV9             ((uint32_t)0x00000008)        /*!< PREDIV1 input clock divided by 9 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV10            ((uint32_t)0x00000009)        /*!< PREDIV1 input clock divided by 10 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV11            ((uint32_t)0x0000000A)        /*!< PREDIV1 input clock divided by 11 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV12            ((uint32_t)0x0000000B)        /*!< PREDIV1 input clock divided by 12 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV13            ((uint32_t)0x0000000C)        /*!< PREDIV1 input clock divided by 13 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV14            ((uint32_t)0x0000000D)        /*!< PREDIV1 input clock divided by 14 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV15            ((uint32_t)0x0000000E)        /*!< PREDIV1 input clock divided by 15 */[m
[32m+[m[32m #define  RCC_CFGR2_PREDIV1_DIV16            ((uint32_t)0x0000000F)        /*!< PREDIV1 input clock divided by 16 */[m
[32m+[m[32m#endif[m
[32m+[m[41m [m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                General Purpose and Alternate Function I/O                  */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for GPIO_CRL register  *******************/[m
[32m+[m[32m#define  GPIO_CRL_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE0                      ((uint32_t)0x00000003)        /*!< MODE0[1:0] bits (Port x mode bits, pin 0) */[m
[32m+[m[32m#define  GPIO_CRL_MODE0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE1                      ((uint32_t)0x00000030)        /*!< MODE1[1:0] bits (Port x mode bits, pin 1) */[m
[32m+[m[32m#define  GPIO_CRL_MODE1_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE1_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE2                      ((uint32_t)0x00000300)        /*!< MODE2[1:0] bits (Port x mode bits, pin 2) */[m
[32m+[m[32m#define  GPIO_CRL_MODE2_0                    ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE2_1                    ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE3                      ((uint32_t)0x00003000)        /*!< MODE3[1:0] bits (Port x mode bits, pin 3) */[m
[32m+[m[32m#define  GPIO_CRL_MODE3_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE3_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE4                      ((uint32_t)0x00030000)        /*!< MODE4[1:0] bits (Port x mode bits, pin 4) */[m
[32m+[m[32m#define  GPIO_CRL_MODE4_0                    ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE4_1                    ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE5                      ((uint32_t)0x00300000)        /*!< MODE5[1:0] bits (Port x mode bits, pin 5) */[m
[32m+[m[32m#define  GPIO_CRL_MODE5_0                    ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE5_1                    ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE6                      ((uint32_t)0x03000000)        /*!< MODE6[1:0] bits (Port x mode bits, pin 6) */[m
[32m+[m[32m#define  GPIO_CRL_MODE6_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE6_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_MODE7                      ((uint32_t)0x30000000)        /*!< MODE7[1:0] bits (Port x mode bits, pin 7) */[m
[32m+[m[32m#define  GPIO_CRL_MODE7_0                    ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_MODE7_1                    ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF0                       ((uint32_t)0x0000000C)        /*!< CNF0[1:0] bits (Port x configuration bits, pin 0) */[m
[32m+[m[32m#define  GPIO_CRL_CNF0_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF0_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF1                       ((uint32_t)0x000000C0)        /*!< CNF1[1:0] bits (Port x configuration bits, pin 1) */[m
[32m+[m[32m#define  GPIO_CRL_CNF1_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF1_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF2                       ((uint32_t)0x00000C00)        /*!< CNF2[1:0] bits (Port x configuration bits, pin 2) */[m
[32m+[m[32m#define  GPIO_CRL_CNF2_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF2_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF3                       ((uint32_t)0x0000C000)        /*!< CNF3[1:0] bits (Port x configuration bits, pin 3) */[m
[32m+[m[32m#define  GPIO_CRL_CNF3_0                     ((uint32_t)0x00004000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF3_1                     ((uint32_t)0x00008000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF4                       ((uint32_t)0x000C0000)        /*!< CNF4[1:0] bits (Port x configuration bits, pin 4) */[m
[32m+[m[32m#define  GPIO_CRL_CNF4_0                     ((uint32_t)0x00040000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF4_1                     ((uint32_t)0x00080000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF5                       ((uint32_t)0x00C00000)        /*!< CNF5[1:0] bits (Port x configuration bits, pin 5) */[m
[32m+[m[32m#define  GPIO_CRL_CNF5_0                     ((uint32_t)0x00400000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF5_1                     ((uint32_t)0x00800000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF6                       ((uint32_t)0x0C000000)        /*!< CNF6[1:0] bits (Port x configuration bits, pin 6) */[m
[32m+[m[32m#define  GPIO_CRL_CNF6_0                     ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF6_1                     ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRL_CNF7                       ((uint32_t)0xC0000000)        /*!< CNF7[1:0] bits (Port x configuration bits, pin 7) */[m
[32m+[m[32m#define  GPIO_CRL_CNF7_0                     ((uint32_t)0x40000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRL_CNF7_1                     ((uint32_t)0x80000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for GPIO_CRH register  *******************/[m
[32m+[m[32m#define  GPIO_CRH_MODE                       ((uint32_t)0x33333333)        /*!< Port x mode bits */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE8                      ((uint32_t)0x00000003)        /*!< MODE8[1:0] bits (Port x mode bits, pin 8) */[m
[32m+[m[32m#define  GPIO_CRH_MODE8_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE8_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE9                      ((uint32_t)0x00000030)        /*!< MODE9[1:0] bits (Port x mode bits, pin 9) */[m
[32m+[m[32m#define  GPIO_CRH_MODE9_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE9_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE10                     ((uint32_t)0x00000300)        /*!< MODE10[1:0] bits (Port x mode bits, pin 10) */[m
[32m+[m[32m#define  GPIO_CRH_MODE10_0                   ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE10_1                   ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE11                     ((uint32_t)0x00003000)        /*!< MODE11[1:0] bits (Port x mode bits, pin 11) */[m
[32m+[m[32m#define  GPIO_CRH_MODE11_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE11_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE12                     ((uint32_t)0x00030000)        /*!< MODE12[1:0] bits (Port x mode bits, pin 12) */[m
[32m+[m[32m#define  GPIO_CRH_MODE12_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE12_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE13                     ((uint32_t)0x00300000)        /*!< MODE13[1:0] bits (Port x mode bits, pin 13) */[m
[32m+[m[32m#define  GPIO_CRH_MODE13_0                   ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE13_1                   ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE14                     ((uint32_t)0x03000000)        /*!< MODE14[1:0] bits (Port x mode bits, pin 14) */[m
[32m+[m[32m#define  GPIO_CRH_MODE14_0                   ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE14_1                   ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_MODE15                     ((uint32_t)0x30000000)        /*!< MODE15[1:0] bits (Port x mode bits, pin 15) */[m
[32m+[m[32m#define  GPIO_CRH_MODE15_0                   ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_MODE15_1                   ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF                        ((uint32_t)0xCCCCCCCC)        /*!< Port x configuration bits */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF8                       ((uint32_t)0x0000000C)        /*!< CNF8[1:0] bits (Port x configuration bits, pin 8) */[m
[32m+[m[32m#define  GPIO_CRH_CNF8_0                     ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF8_1                     ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF9                       ((uint32_t)0x000000C0)        /*!< CNF9[1:0] bits (Port x configuration bits, pin 9) */[m
[32m+[m[32m#define  GPIO_CRH_CNF9_0                     ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF9_1                     ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF10                      ((uint32_t)0x00000C00)        /*!< CNF10[1:0] bits (Port x configuration bits, pin 10) */[m
[32m+[m[32m#define  GPIO_CRH_CNF10_0                    ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF10_1                    ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF11                      ((uint32_t)0x0000C000)        /*!< CNF11[1:0] bits (Port x configuration bits, pin 11) */[m
[32m+[m[32m#define  GPIO_CRH_CNF11_0                    ((uint32_t)0x00004000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF11_1                    ((uint32_t)0x00008000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF12                      ((uint32_t)0x000C0000)        /*!< CNF12[1:0] bits (Port x configuration bits, pin 12) */[m
[32m+[m[32m#define  GPIO_CRH_CNF12_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF12_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF13                      ((uint32_t)0x00C00000)        /*!< CNF13[1:0] bits (Port x configuration bits, pin 13) */[m
[32m+[m[32m#define  GPIO_CRH_CNF13_0                    ((uint32_t)0x00400000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF13_1                    ((uint32_t)0x00800000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF14                      ((uint32_t)0x0C000000)        /*!< CNF14[1:0] bits (Port x configuration bits, pin 14) */[m
[32m+[m[32m#define  GPIO_CRH_CNF14_0                    ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF14_1                    ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  GPIO_CRH_CNF15                      ((uint32_t)0xC0000000)        /*!< CNF15[1:0] bits (Port x configuration bits, pin 15) */[m
[32m+[m[32m#define  GPIO_CRH_CNF15_0                    ((uint32_t)0x40000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  GPIO_CRH_CNF15_1                    ((uint32_t)0x80000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*!<******************  Bit definition for GPIO_IDR register  *******************/[m
[32m+[m[32m#define GPIO_IDR_IDR0                        ((uint16_t)0x0001)            /*!< Port input data, bit 0 */[m
[32m+[m[32m#define GPIO_IDR_IDR1                        ((uint16_t)0x0002)            /*!< Port input data, bit 1 */[m
[32m+[m[32m#define GPIO_IDR_IDR2                        ((uint16_t)0x0004)            /*!< Port input data, bit 2 */[m
[32m+[m[32m#define GPIO_IDR_IDR3                        ((uint16_t)0x0008)            /*!< Port input data, bit 3 */[m
[32m+[m[32m#define GPIO_IDR_IDR4                        ((uint16_t)0x0010)            /*!< Port input data, bit 4 */[m
[32m+[m[32m#define GPIO_IDR_IDR5                        ((uint16_t)0x0020)            /*!< Port input data, bit 5 */[m
[32m+[m[32m#define GPIO_IDR_IDR6                        ((uint16_t)0x0040)            /*!< Port input data, bit 6 */[m
[32m+[m[32m#define GPIO_IDR_IDR7                        ((uint16_t)0x0080)            /*!< Port input data, bit 7 */[m
[32m+[m[32m#define GPIO_IDR_IDR8                        ((uint16_t)0x0100)            /*!< Port input data, bit 8 */[m
[32m+[m[32m#define GPIO_IDR_IDR9                        ((uint16_t)0x0200)            /*!< Port input data, bit 9 */[m
[32m+[m[32m#define GPIO_IDR_IDR10                       ((uint16_t)0x0400)            /*!< Port input data, bit 10 */[m
[32m+[m[32m#define GPIO_IDR_IDR11                       ((uint16_t)0x0800)            /*!< Port input data, bit 11 */[m
[32m+[m[32m#define GPIO_IDR_IDR12                       ((uint16_t)0x1000)            /*!< Port input data, bit 12 */[m
[32m+[m[32m#define GPIO_IDR_IDR13                       ((uint16_t)0x2000)            /*!< Port input data, bit 13 */[m
[32m+[m[32m#define GPIO_IDR_IDR14                       ((uint16_t)0x4000)            /*!< Port input data, bit 14 */[m
[32m+[m[32m#define GPIO_IDR_IDR15                       ((uint16_t)0x8000)            /*!< Port input data, bit 15 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for GPIO_ODR register  *******************/[m
[32m+[m[32m#define GPIO_ODR_ODR0                        ((uint16_t)0x0001)            /*!< Port output data, bit 0 */[m
[32m+[m[32m#define GPIO_ODR_ODR1                        ((uint16_t)0x0002)            /*!< Port output data, bit 1 */[m
[32m+[m[32m#define GPIO_ODR_ODR2                        ((uint16_t)0x0004)            /*!< Port output data, bit 2 */[m
[32m+[m[32m#define GPIO_ODR_ODR3                        ((uint16_t)0x0008)            /*!< Port output data, bit 3 */[m
[32m+[m[32m#define GPIO_ODR_ODR4                        ((uint16_t)0x0010)            /*!< Port output data, bit 4 */[m
[32m+[m[32m#define GPIO_ODR_ODR5                        ((uint16_t)0x0020)            /*!< Port output data, bit 5 */[m
[32m+[m[32m#define GPIO_ODR_ODR6                        ((uint16_t)0x0040)            /*!< Port output data, bit 6 */[m
[32m+[m[32m#define GPIO_ODR_ODR7                        ((uint16_t)0x0080)            /*!< Port output data, bit 7 */[m
[32m+[m[32m#define GPIO_ODR_ODR8                        ((uint16_t)0x0100)            /*!< Port output data, bit 8 */[m
[32m+[m[32m#define GPIO_ODR_ODR9                        ((uint16_t)0x0200)            /*!< Port output data, bit 9 */[m
[32m+[m[32m#define GPIO_ODR_ODR10                       ((uint16_t)0x0400)            /*!< Port output data, bit 10 */[m
[32m+[m[32m#define GPIO_ODR_ODR11                       ((uint16_t)0x0800)            /*!< Port output data, bit 11 */[m
[32m+[m[32m#define GPIO_ODR_ODR12                       ((uint16_t)0x1000)            /*!< Port output data, bit 12 */[m
[32m+[m[32m#define GPIO_ODR_ODR13                       ((uint16_t)0x2000)            /*!< Port output data, bit 13 */[m
[32m+[m[32m#define GPIO_ODR_ODR14                       ((uint16_t)0x4000)            /*!< Port output data, bit 14 */[m
[32m+[m[32m#define GPIO_ODR_ODR15                       ((uint16_t)0x8000)            /*!< Port output data, bit 15 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for GPIO_BSRR register  *******************/[m
[32m+[m[32m#define GPIO_BSRR_BS0                        ((uint32_t)0x00000001)        /*!< Port x Set bit 0 */[m
[32m+[m[32m#define GPIO_BSRR_BS1                        ((uint32_t)0x00000002)        /*!< Port x Set bit 1 */[m
[32m+[m[32m#define GPIO_BSRR_BS2                        ((uint32_t)0x00000004)        /*!< Port x Set bit 2 */[m
[32m+[m[32m#define GPIO_BSRR_BS3                        ((uint32_t)0x00000008)        /*!< Port x Set bit 3 */[m
[32m+[m[32m#define GPIO_BSRR_BS4                        ((uint32_t)0x00000010)        /*!< Port x Set bit 4 */[m
[32m+[m[32m#define GPIO_BSRR_BS5                        ((uint32_t)0x00000020)        /*!< Port x Set bit 5 */[m
[32m+[m[32m#define GPIO_BSRR_BS6                        ((uint32_t)0x00000040)        /*!< Port x Set bit 6 */[m
[32m+[m[32m#define GPIO_BSRR_BS7                        ((uint32_t)0x00000080)        /*!< Port x Set bit 7 */[m
[32m+[m[32m#define GPIO_BSRR_BS8                        ((uint32_t)0x00000100)        /*!< Port x Set bit 8 */[m
[32m+[m[32m#define GPIO_BSRR_BS9                        ((uint32_t)0x00000200)        /*!< Port x Set bit 9 */[m
[32m+[m[32m#define GPIO_BSRR_BS10                       ((uint32_t)0x00000400)        /*!< Port x Set bit 10 */[m
[32m+[m[32m#define GPIO_BSRR_BS11                       ((uint32_t)0x00000800)        /*!< Port x Set bit 11 */[m
[32m+[m[32m#define GPIO_BSRR_BS12                       ((uint32_t)0x00001000)        /*!< Port x Set bit 12 */[m
[32m+[m[32m#define GPIO_BSRR_BS13                       ((uint32_t)0x00002000)        /*!< Port x Set bit 13 */[m
[32m+[m[32m#define GPIO_BSRR_BS14                       ((uint32_t)0x00004000)        /*!< Port x Set bit 14 */[m
[32m+[m[32m#define GPIO_BSRR_BS15                       ((uint32_t)0x00008000)        /*!< Port x Set bit 15 */[m
[32m+[m
[32m+[m[32m#define GPIO_BSRR_BR0                        ((uint32_t)0x00010000)        /*!< Port x Reset bit 0 */[m
[32m+[m[32m#define GPIO_BSRR_BR1                        ((uint32_t)0x00020000)        /*!< Port x Reset bit 1 */[m
[32m+[m[32m#define GPIO_BSRR_BR2                        ((uint32_t)0x00040000)        /*!< Port x Reset bit 2 */[m
[32m+[m[32m#define GPIO_BSRR_BR3                        ((uint32_t)0x00080000)        /*!< Port x Reset bit 3 */[m
[32m+[m[32m#define GPIO_BSRR_BR4                        ((uint32_t)0x00100000)        /*!< Port x Reset bit 4 */[m
[32m+[m[32m#define GPIO_BSRR_BR5                        ((uint32_t)0x00200000)        /*!< Port x Reset bit 5 */[m
[32m+[m[32m#define GPIO_BSRR_BR6                        ((uint32_t)0x00400000)        /*!< Port x Reset bit 6 */[m
[32m+[m[32m#define GPIO_BSRR_BR7                        ((uint32_t)0x00800000)        /*!< Port x Reset bit 7 */[m
[32m+[m[32m#define GPIO_BSRR_BR8                        ((uint32_t)0x01000000)        /*!< Port x Reset bit 8 */[m
[32m+[m[32m#define GPIO_BSRR_BR9                        ((uint32_t)0x02000000)        /*!< Port x Reset bit 9 */[m
[32m+[m[32m#define GPIO_BSRR_BR10                       ((uint32_t)0x04000000)        /*!< Port x Reset bit 10 */[m
[32m+[m[32m#define GPIO_BSRR_BR11                       ((uint32_t)0x08000000)        /*!< Port x Reset bit 11 */[m
[32m+[m[32m#define GPIO_BSRR_BR12                       ((uint32_t)0x10000000)        /*!< Port x Reset bit 12 */[m
[32m+[m[32m#define GPIO_BSRR_BR13                       ((uint32_t)0x20000000)        /*!< Port x Reset bit 13 */[m
[32m+[m[32m#define GPIO_BSRR_BR14                       ((uint32_t)0x40000000)        /*!< Port x Reset bit 14 */[m
[32m+[m[32m#define GPIO_BSRR_BR15                       ((uint32_t)0x80000000)        /*!< Port x Reset bit 15 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for GPIO_BRR register  *******************/[m
[32m+[m[32m#define GPIO_BRR_BR0                         ((uint16_t)0x0001)            /*!< Port x Reset bit 0 */[m
[32m+[m[32m#define GPIO_BRR_BR1                         ((uint16_t)0x0002)            /*!< Port x Reset bit 1 */[m
[32m+[m[32m#define GPIO_BRR_BR2                         ((uint16_t)0x0004)            /*!< Port x Reset bit 2 */[m
[32m+[m[32m#define GPIO_BRR_BR3                         ((uint16_t)0x0008)            /*!< Port x Reset bit 3 */[m
[32m+[m[32m#define GPIO_BRR_BR4                         ((uint16_t)0x0010)            /*!< Port x Reset bit 4 */[m
[32m+[m[32m#define GPIO_BRR_BR5                         ((uint16_t)0x0020)            /*!< Port x Reset bit 5 */[m
[32m+[m[32m#define GPIO_BRR_BR6                         ((uint16_t)0x0040)            /*!< Port x Reset bit 6 */[m
[32m+[m[32m#define GPIO_BRR_BR7                         ((uint16_t)0x0080)            /*!< Port x Reset bit 7 */[m
[32m+[m[32m#define GPIO_BRR_BR8                         ((uint16_t)0x0100)            /*!< Port x Reset bit 8 */[m
[32m+[m[32m#define GPIO_BRR_BR9                         ((uint16_t)0x0200)            /*!< Port x Reset bit 9 */[m
[32m+[m[32m#define GPIO_BRR_BR10                        ((uint16_t)0x0400)            /*!< Port x Reset bit 10 */[m
[32m+[m[32m#define GPIO_BRR_BR11                        ((uint16_t)0x0800)            /*!< Port x Reset bit 11 */[m
[32m+[m[32m#define GPIO_BRR_BR12                        ((uint16_t)0x1000)            /*!< Port x Reset bit 12 */[m
[32m+[m[32m#define GPIO_BRR_BR13                        ((uint16_t)0x2000)            /*!< Port x Reset bit 13 */[m
[32m+[m[32m#define GPIO_BRR_BR14                        ((uint16_t)0x4000)            /*!< Port x Reset bit 14 */[m
[32m+[m[32m#define GPIO_BRR_BR15                        ((uint16_t)0x8000)            /*!< Port x Reset bit 15 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for GPIO_LCKR register  *******************/[m
[32m+[m[32m#define GPIO_LCKR_LCK0                       ((uint32_t)0x00000001)        /*!< Port x Lock bit 0 */[m
[32m+[m[32m#define GPIO_LCKR_LCK1                       ((uint32_t)0x00000002)        /*!< Port x Lock bit 1 */[m
[32m+[m[32m#define GPIO_LCKR_LCK2                       ((uint32_t)0x00000004)        /*!< Port x Lock bit 2 */[m
[32m+[m[32m#define GPIO_LCKR_LCK3                       ((uint32_t)0x00000008)        /*!< Port x Lock bit 3 */[m
[32m+[m[32m#define GPIO_LCKR_LCK4                       ((uint32_t)0x00000010)        /*!< Port x Lock bit 4 */[m
[32m+[m[32m#define GPIO_LCKR_LCK5                       ((uint32_t)0x00000020)        /*!< Port x Lock bit 5 */[m
[32m+[m[32m#define GPIO_LCKR_LCK6                       ((uint32_t)0x00000040)        /*!< Port x Lock bit 6 */[m
[32m+[m[32m#define GPIO_LCKR_LCK7                       ((uint32_t)0x00000080)        /*!< Port x Lock bit 7 */[m
[32m+[m[32m#define GPIO_LCKR_LCK8                       ((uint32_t)0x00000100)        /*!< Port x Lock bit 8 */[m
[32m+[m[32m#define GPIO_LCKR_LCK9                       ((uint32_t)0x00000200)        /*!< Port x Lock bit 9 */[m
[32m+[m[32m#define GPIO_LCKR_LCK10                      ((uint32_t)0x00000400)        /*!< Port x Lock bit 10 */[m
[32m+[m[32m#define GPIO_LCKR_LCK11                      ((uint32_t)0x00000800)        /*!< Port x Lock bit 11 */[m
[32m+[m[32m#define GPIO_LCKR_LCK12                      ((uint32_t)0x00001000)        /*!< Port x Lock bit 12 */[m
[32m+[m[32m#define GPIO_LCKR_LCK13                      ((uint32_t)0x00002000)        /*!< Port x Lock bit 13 */[m
[32m+[m[32m#define GPIO_LCKR_LCK14                      ((uint32_t)0x00004000)        /*!< Port x Lock bit 14 */[m
[32m+[m[32m#define GPIO_LCKR_LCK15                      ((uint32_t)0x00008000)        /*!< Port x Lock bit 15 */[m
[32m+[m[32m#define GPIO_LCKR_LCKK                       ((uint32_t)0x00010000)        /*!< Lock key */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/******************  Bit definition for AFIO_EVCR register  *******************/[m
[32m+[m[32m#define AFIO_EVCR_PIN                        ((uint8_t)0x0F)               /*!< PIN[3:0] bits (Pin selection) */[m
[32m+[m[32m#define AFIO_EVCR_PIN_0                      ((uint8_t)0x01)               /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_EVCR_PIN_1                      ((uint8_t)0x02)               /*!< Bit 1 */[m
[32m+[m[32m#define AFIO_EVCR_PIN_2                      ((uint8_t)0x04)               /*!< Bit 2 */[m
[32m+[m[32m#define AFIO_EVCR_PIN_3                      ((uint8_t)0x08)               /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m/*!< PIN configuration */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX0                    ((uint8_t)0x00)               /*!< Pin 0 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX1                    ((uint8_t)0x01)               /*!< Pin 1 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX2                    ((uint8_t)0x02)               /*!< Pin 2 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX3                    ((uint8_t)0x03)               /*!< Pin 3 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX4                    ((uint8_t)0x04)               /*!< Pin 4 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX5                    ((uint8_t)0x05)               /*!< Pin 5 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX6                    ((uint8_t)0x06)               /*!< Pin 6 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX7                    ((uint8_t)0x07)               /*!< Pin 7 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX8                    ((uint8_t)0x08)               /*!< Pin 8 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX9                    ((uint8_t)0x09)               /*!< Pin 9 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX10                   ((uint8_t)0x0A)               /*!< Pin 10 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX11                   ((uint8_t)0x0B)               /*!< Pin 11 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX12                   ((uint8_t)0x0C)               /*!< Pin 12 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX13                   ((uint8_t)0x0D)               /*!< Pin 13 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX14                   ((uint8_t)0x0E)               /*!< Pin 14 selected */[m
[32m+[m[32m#define AFIO_EVCR_PIN_PX15                   ((uint8_t)0x0F)               /*!< Pin 15 selected */[m
[32m+[m
[32m+[m[32m#define AFIO_EVCR_PORT                       ((uint8_t)0x70)               /*!< PORT[2:0] bits (Port selection) */[m
[32m+[m[32m#define AFIO_EVCR_PORT_0                     ((uint8_t)0x10)               /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_EVCR_PORT_1                     ((uint8_t)0x20)               /*!< Bit 1 */[m
[32m+[m[32m#define AFIO_EVCR_PORT_2                     ((uint8_t)0x40)               /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/*!< PORT configuration */[m
[32m+[m[32m#define AFIO_EVCR_PORT_PA                    ((uint8_t)0x00)               /*!< Port A selected */[m
[32m+[m[32m#define AFIO_EVCR_PORT_PB                    ((uint8_t)0x10)               /*!< Port B selected */[m
[32m+[m[32m#define AFIO_EVCR_PORT_PC                    ((uint8_t)0x20)               /*!< Port C selected */[m
[32m+[m[32m#define AFIO_EVCR_PORT_PD                    ((uint8_t)0x30)               /*!< Port D selected */[m
[32m+[m[32m#define AFIO_EVCR_PORT_PE                    ((uint8_t)0x40)               /*!< Port E selected */[m
[32m+[m
[32m+[m[32m#define AFIO_EVCR_EVOE                       ((uint8_t)0x80)               /*!< Event Output Enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for AFIO_MAPR register  *******************/[m
[32m+[m[32m#define AFIO_MAPR_SPI1_REMAP                 ((uint32_t)0x00000001)        /*!< SPI1 remapping */[m
[32m+[m[32m#define AFIO_MAPR_I2C1_REMAP                 ((uint32_t)0x00000002)        /*!< I2C1 remapping */[m
[32m+[m[32m#define AFIO_MAPR_USART1_REMAP               ((uint32_t)0x00000004)        /*!< USART1 remapping */[m
[32m+[m[32m#define AFIO_MAPR_USART2_REMAP               ((uint32_t)0x00000008)        /*!< USART2 remapping */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_USART3_REMAP               ((uint32_t)0x00000030)        /*!< USART3_REMAP[1:0] bits (USART3 remapping) */[m
[32m+[m[32m#define AFIO_MAPR_USART3_REMAP_0             ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_MAPR_USART3_REMAP_1             ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/* USART3_REMAP configuration */[m
[32m+[m[32m#define AFIO_MAPR_USART3_REMAP_NOREMAP       ((uint32_t)0x00000000)        /*!< No remap (TX/PB10, RX/PB11, CK/PB12, CTS/PB13, RTS/PB14) */[m
[32m+[m[32m#define AFIO_MAPR_USART3_REMAP_PARTIALREMAP  ((uint32_t)0x00000010)        /*!< Partial remap (TX/PC10, RX/PC11, CK/PC12, CTS/PB13, RTS/PB14) */[m
[32m+[m[32m#define AFIO_MAPR_USART3_REMAP_FULLREMAP     ((uint32_t)0x00000030)        /*!< Full remap (TX/PD8, RX/PD9, CK/PD10, CTS/PD11, RTS/PD12) */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_TIM1_REMAP                 ((uint32_t)0x000000C0)        /*!< TIM1_REMAP[1:0] bits (TIM1 remapping) */[m
[32m+[m[32m#define AFIO_MAPR_TIM1_REMAP_0               ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_MAPR_TIM1_REMAP_1               ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*!< TIM1_REMAP configuration */[m
[32m+[m[32m#define AFIO_MAPR_TIM1_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PB12, CH1N/PB13, CH2N/PB14, CH3N/PB15) */[m
[32m+[m[32m#define AFIO_MAPR_TIM1_REMAP_PARTIALREMAP    ((uint32_t)0x00000040)        /*!< Partial remap (ETR/PA12, CH1/PA8, CH2/PA9, CH3/PA10, CH4/PA11, BKIN/PA6, CH1N/PA7, CH2N/PB0, CH3N/PB1) */[m
[32m+[m[32m#define AFIO_MAPR_TIM1_REMAP_FULLREMAP       ((uint32_t)0x000000C0)        /*!< Full remap (ETR/PE7, CH1/PE9, CH2/PE11, CH3/PE13, CH4/PE14, BKIN/PE15, CH1N/PE8, CH2N/PE10, CH3N/PE12) */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP                 ((uint32_t)0x00000300)        /*!< TIM2_REMAP[1:0] bits (TIM2 remapping) */[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*!< TIM2_REMAP configuration */[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/ETR/PA0, CH2/PA1, CH3/PA2, CH4/PA3) */[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP1   ((uint32_t)0x00000100)        /*!< Partial remap (CH1/ETR/PA15, CH2/PB3, CH3/PA2, CH4/PA3) */[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP_PARTIALREMAP2   ((uint32_t)0x00000200)        /*!< Partial remap (CH1/ETR/PA0, CH2/PA1, CH3/PB10, CH4/PB11) */[m
[32m+[m[32m#define AFIO_MAPR_TIM2_REMAP_FULLREMAP       ((uint32_t)0x00000300)        /*!< Full remap (CH1/ETR/PA15, CH2/PB3, CH3/PB10, CH4/PB11) */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_TIM3_REMAP                 ((uint32_t)0x00000C00)        /*!< TIM3_REMAP[1:0] bits (TIM3 remapping) */[m
[32m+[m[32m#define AFIO_MAPR_TIM3_REMAP_0               ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_MAPR_TIM3_REMAP_1               ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*!< TIM3_REMAP configuration */[m
[32m+[m[32m#define AFIO_MAPR_TIM3_REMAP_NOREMAP         ((uint32_t)0x00000000)        /*!< No remap (CH1/PA6, CH2/PA7, CH3/PB0, CH4/PB1) */[m
[32m+[m[32m#define AFIO_MAPR_TIM3_REMAP_PARTIALREMAP    ((uint32_t)0x00000800)        /*!< Partial remap (CH1/PB4, CH2/PB5, CH3/PB0, CH4/PB1) */[m
[32m+[m[32m#define AFIO_MAPR_TIM3_REMAP_FULLREMAP       ((uint32_t)0x00000C00)        /*!< Full remap (CH1/PC6, CH2/PC7, CH3/PC8, CH4/PC9) */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_TIM4_REMAP                 ((uint32_t)0x00001000)        /*!< TIM4_REMAP bit (TIM4 remapping) */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_CAN_REMAP                  ((uint32_t)0x00006000)        /*!< CAN_REMAP[1:0] bits (CAN Alternate function remapping) */[m
[32m+[m[32m#define AFIO_MAPR_CAN_REMAP_0                ((uint32_t)0x00002000)        /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_MAPR_CAN_REMAP_1                ((uint32_t)0x00004000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*!< CAN_REMAP configuration */[m
[32m+[m[32m#define AFIO_MAPR_CAN_REMAP_REMAP1           ((uint32_t)0x00000000)        /*!< CANRX mapped to PA11, CANTX mapped to PA12 */[m
[32m+[m[32m#define AFIO_MAPR_CAN_REMAP_REMAP2           ((uint32_t)0x00004000)        /*!< CANRX mapped to PB8, CANTX mapped to PB9 */[m
[32m+[m[32m#define AFIO_MAPR_CAN_REMAP_REMAP3           ((uint32_t)0x00006000)        /*!< CANRX mapped to PD0, CANTX mapped to PD1 */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_PD01_REMAP                 ((uint32_t)0x00008000)        /*!< Port D0/Port D1 mapping on OSC_IN/OSC_OUT */[m
[32m+[m[32m#define AFIO_MAPR_TIM5CH4_IREMAP             ((uint32_t)0x00010000)        /*!< TIM5 Channel4 Internal Remap */[m
[32m+[m[32m#define AFIO_MAPR_ADC1_ETRGINJ_REMAP         ((uint32_t)0x00020000)        /*!< ADC 1 External Trigger Injected Conversion remapping */[m
[32m+[m[32m#define AFIO_MAPR_ADC1_ETRGREG_REMAP         ((uint32_t)0x00040000)        /*!< ADC 1 External Trigger Regular Conversion remapping */[m
[32m+[m[32m#define AFIO_MAPR_ADC2_ETRGINJ_REMAP         ((uint32_t)0x00080000)        /*!< ADC 2 External Trigger Injected Conversion remapping */[m
[32m+[m[32m#define AFIO_MAPR_ADC2_ETRGREG_REMAP         ((uint32_t)0x00100000)        /*!< ADC 2 External Trigger Regular Conversion remapping */[m
[32m+[m
[32m+[m[32m/*!< SWJ_CFG configuration */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG                    ((uint32_t)0x07000000)        /*!< SWJ_CFG[2:0] bits (Serial Wire JTAG configuration) */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_RESET              ((uint32_t)0x00000000)        /*!< Full SWJ (JTAG-DP + SW-DP) : Reset State */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_NOJNTRST           ((uint32_t)0x01000000)        /*!< Full SWJ (JTAG-DP + SW-DP) but without JNTRST */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_JTAGDISABLE        ((uint32_t)0x02000000)        /*!< JTAG-DP Disabled and SW-DP Enabled */[m
[32m+[m[32m#define AFIO_MAPR_SWJ_CFG_DISABLE            ((uint32_t)0x04000000)        /*!< JTAG-DP Disabled and SW-DP Disabled */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/*!< ETH_REMAP configuration */[m
[32m+[m[32m #define AFIO_MAPR_ETH_REMAP                  ((uint32_t)0x00200000)        /*!< SPI3_REMAP bit (Ethernet MAC I/O remapping) */[m
[32m+[m
[32m+[m[32m/*!< CAN2_REMAP configuration */[m
[32m+[m[32m #define AFIO_MAPR_CAN2_REMAP                 ((uint32_t)0x00400000)        /*!< CAN2_REMAP bit (CAN2 I/O remapping) */[m
[32m+[m
[32m+[m[32m/*!< MII_RMII_SEL configuration */[m
[32m+[m[32m #define AFIO_MAPR_MII_RMII_SEL               ((uint32_t)0x00800000)        /*!< MII_RMII_SEL bit (Ethernet MII or RMII selection) */[m
[32m+[m
[32m+[m[32m/*!< SPI3_REMAP configuration */[m
[32m+[m[32m #define AFIO_MAPR_SPI3_REMAP                 ((uint32_t)0x10000000)        /*!< SPI3_REMAP bit (SPI3 remapping) */[m
[32m+[m
[32m+[m[32m/*!< TIM2ITR1_IREMAP configuration */[m
[32m+[m[32m #define AFIO_MAPR_TIM2ITR1_IREMAP            ((uint32_t)0x20000000)        /*!< TIM2ITR1_IREMAP bit (TIM2 internal trigger 1 remapping) */[m
[32m+[m
[32m+[m[32m/*!< PTP_PPS_REMAP configuration */[m
[32m+[m[32m #define AFIO_MAPR_PTP_PPS_REMAP              ((uint32_t)0x40000000)        /*!< PTP_PPS_REMAP bit (Ethernet PTP PPS remapping) */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for AFIO_EXTICR1 register  *****************/[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0                   ((uint16_t)0x000F)            /*!< EXTI 0 configuration */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1                   ((uint16_t)0x00F0)            /*!< EXTI 1 configuration */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2                   ((uint16_t)0x0F00)            /*!< EXTI 2 configuration */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3                   ((uint16_t)0xF000)            /*!< EXTI 3 configuration */[m
[32m+[m
[32m+[m[32m/*!< EXTI0 configuration */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PA                ((uint16_t)0x0000)            /*!< PA[0] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PB                ((uint16_t)0x0001)            /*!< PB[0] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PC                ((uint16_t)0x0002)            /*!< PC[0] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PD                ((uint16_t)0x0003)            /*!< PD[0] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PE                ((uint16_t)0x0004)            /*!< PE[0] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PF                ((uint16_t)0x0005)            /*!< PF[0] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI0_PG                ((uint16_t)0x0006)            /*!< PG[0] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI1 configuration */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PA                ((uint16_t)0x0000)            /*!< PA[1] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PB                ((uint16_t)0x0010)            /*!< PB[1] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PC                ((uint16_t)0x0020)            /*!< PC[1] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PD                ((uint16_t)0x0030)            /*!< PD[1] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PE                ((uint16_t)0x0040)            /*!< PE[1] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PF                ((uint16_t)0x0050)            /*!< PF[1] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI1_PG                ((uint16_t)0x0060)            /*!< PG[1] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI2 configuration */[m[41m  [m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PA                ((uint16_t)0x0000)            /*!< PA[2] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PB                ((uint16_t)0x0100)            /*!< PB[2] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PC                ((uint16_t)0x0200)            /*!< PC[2] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PD                ((uint16_t)0x0300)            /*!< PD[2] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PE                ((uint16_t)0x0400)            /*!< PE[2] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PF                ((uint16_t)0x0500)            /*!< PF[2] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI2_PG                ((uint16_t)0x0600)            /*!< PG[2] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI3 configuration */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PA                ((uint16_t)0x0000)            /*!< PA[3] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PB                ((uint16_t)0x1000)            /*!< PB[3] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PC                ((uint16_t)0x2000)            /*!< PC[3] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PD                ((uint16_t)0x3000)            /*!< PD[3] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PE                ((uint16_t)0x4000)            /*!< PE[3] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PF                ((uint16_t)0x5000)            /*!< PF[3] pin */[m
[32m+[m[32m#define AFIO_EXTICR1_EXTI3_PG                ((uint16_t)0x6000)            /*!< PG[3] pin */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for AFIO_EXTICR2 register  *****************/[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4                   ((uint16_t)0x000F)            /*!< EXTI 4 configuration */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5                   ((uint16_t)0x00F0)            /*!< EXTI 5 configuration */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6                   ((uint16_t)0x0F00)            /*!< EXTI 6 configuration */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7                   ((uint16_t)0xF000)            /*!< EXTI 7 configuration */[m
[32m+[m
[32m+[m[32m/*!< EXTI4 configuration */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PA                ((uint16_t)0x0000)            /*!< PA[4] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PB                ((uint16_t)0x0001)            /*!< PB[4] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PC                ((uint16_t)0x0002)            /*!< PC[4] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PD                ((uint16_t)0x0003)            /*!< PD[4] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PE                ((uint16_t)0x0004)            /*!< PE[4] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PF                ((uint16_t)0x0005)            /*!< PF[4] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI4_PG                ((uint16_t)0x0006)            /*!< PG[4] pin */[m
[32m+[m
[32m+[m[32m/* EXTI5 configuration */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PA                ((uint16_t)0x0000)            /*!< PA[5] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PB                ((uint16_t)0x0010)            /*!< PB[5] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PC                ((uint16_t)0x0020)            /*!< PC[5] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PD                ((uint16_t)0x0030)            /*!< PD[5] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PE                ((uint16_t)0x0040)            /*!< PE[5] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PF                ((uint16_t)0x0050)            /*!< PF[5] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI5_PG                ((uint16_t)0x0060)            /*!< PG[5] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI6 configuration */[m[41m  [m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PA                ((uint16_t)0x0000)            /*!< PA[6] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PB                ((uint16_t)0x0100)            /*!< PB[6] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PC                ((uint16_t)0x0200)            /*!< PC[6] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PD                ((uint16_t)0x0300)            /*!< PD[6] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PE                ((uint16_t)0x0400)            /*!< PE[6] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PF                ((uint16_t)0x0500)            /*!< PF[6] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI6_PG                ((uint16_t)0x0600)            /*!< PG[6] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI7 configuration */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PA                ((uint16_t)0x0000)            /*!< PA[7] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PB                ((uint16_t)0x1000)            /*!< PB[7] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PC                ((uint16_t)0x2000)            /*!< PC[7] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PD                ((uint16_t)0x3000)            /*!< PD[7] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PE                ((uint16_t)0x4000)            /*!< PE[7] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PF                ((uint16_t)0x5000)            /*!< PF[7] pin */[m
[32m+[m[32m#define AFIO_EXTICR2_EXTI7_PG                ((uint16_t)0x6000)            /*!< PG[7] pin */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for AFIO_EXTICR3 register  *****************/[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8                   ((uint16_t)0x000F)            /*!< EXTI 8 configuration */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9                   ((uint16_t)0x00F0)            /*!< EXTI 9 configuration */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10                  ((uint16_t)0x0F00)            /*!< EXTI 10 configuration */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11                  ((uint16_t)0xF000)            /*!< EXTI 11 configuration */[m
[32m+[m
[32m+[m[32m/*!< EXTI8 configuration */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PA                ((uint16_t)0x0000)            /*!< PA[8] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PB                ((uint16_t)0x0001)            /*!< PB[8] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PC                ((uint16_t)0x0002)            /*!< PC[8] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PD                ((uint16_t)0x0003)            /*!< PD[8] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PE                ((uint16_t)0x0004)            /*!< PE[8] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PF                ((uint16_t)0x0005)            /*!< PF[8] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI8_PG                ((uint16_t)0x0006)            /*!< PG[8] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI9 configuration */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PA                ((uint16_t)0x0000)            /*!< PA[9] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PB                ((uint16_t)0x0010)            /*!< PB[9] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PC                ((uint16_t)0x0020)            /*!< PC[9] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PD                ((uint16_t)0x0030)            /*!< PD[9] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PE                ((uint16_t)0x0040)            /*!< PE[9] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PF                ((uint16_t)0x0050)            /*!< PF[9] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI9_PG                ((uint16_t)0x0060)            /*!< PG[9] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI10 configuration */[m[41m  [m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PA               ((uint16_t)0x0000)            /*!< PA[10] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PB               ((uint16_t)0x0100)            /*!< PB[10] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PC               ((uint16_t)0x0200)            /*!< PC[10] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PD               ((uint16_t)0x0300)            /*!< PD[10] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PE               ((uint16_t)0x0400)            /*!< PE[10] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PF               ((uint16_t)0x0500)            /*!< PF[10] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI10_PG               ((uint16_t)0x0600)            /*!< PG[10] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI11 configuration */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PA               ((uint16_t)0x0000)            /*!< PA[11] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PB               ((uint16_t)0x1000)            /*!< PB[11] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PC               ((uint16_t)0x2000)            /*!< PC[11] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PD               ((uint16_t)0x3000)            /*!< PD[11] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PE               ((uint16_t)0x4000)            /*!< PE[11] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PF               ((uint16_t)0x5000)            /*!< PF[11] pin */[m
[32m+[m[32m#define AFIO_EXTICR3_EXTI11_PG               ((uint16_t)0x6000)            /*!< PG[11] pin */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for AFIO_EXTICR4 register  *****************/[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12                  ((uint16_t)0x000F)            /*!< EXTI 12 configuration */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13                  ((uint16_t)0x00F0)            /*!< EXTI 13 configuration */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14                  ((uint16_t)0x0F00)            /*!< EXTI 14 configuration */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15                  ((uint16_t)0xF000)            /*!< EXTI 15 configuration */[m
[32m+[m
[32m+[m[32m/* EXTI12 configuration */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PA               ((uint16_t)0x0000)            /*!< PA[12] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PB               ((uint16_t)0x0001)            /*!< PB[12] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PC               ((uint16_t)0x0002)            /*!< PC[12] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PD               ((uint16_t)0x0003)            /*!< PD[12] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PE               ((uint16_t)0x0004)            /*!< PE[12] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PF               ((uint16_t)0x0005)            /*!< PF[12] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI12_PG               ((uint16_t)0x0006)            /*!< PG[12] pin */[m
[32m+[m
[32m+[m[32m/* EXTI13 configuration */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PA               ((uint16_t)0x0000)            /*!< PA[13] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PB               ((uint16_t)0x0010)            /*!< PB[13] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PC               ((uint16_t)0x0020)            /*!< PC[13] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PD               ((uint16_t)0x0030)            /*!< PD[13] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PE               ((uint16_t)0x0040)            /*!< PE[13] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PF               ((uint16_t)0x0050)            /*!< PF[13] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI13_PG               ((uint16_t)0x0060)            /*!< PG[13] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI14 configuration */[m[41m  [m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PA               ((uint16_t)0x0000)            /*!< PA[14] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PB               ((uint16_t)0x0100)            /*!< PB[14] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PC               ((uint16_t)0x0200)            /*!< PC[14] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PD               ((uint16_t)0x0300)            /*!< PD[14] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PE               ((uint16_t)0x0400)            /*!< PE[14] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PF               ((uint16_t)0x0500)            /*!< PF[14] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI14_PG               ((uint16_t)0x0600)            /*!< PG[14] pin */[m
[32m+[m
[32m+[m[32m/*!< EXTI15 configuration */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PA               ((uint16_t)0x0000)            /*!< PA[15] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PB               ((uint16_t)0x1000)            /*!< PB[15] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PC               ((uint16_t)0x2000)            /*!< PC[15] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PD               ((uint16_t)0x3000)            /*!< PD[15] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PE               ((uint16_t)0x4000)            /*!< PE[15] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PF               ((uint16_t)0x5000)            /*!< PF[15] pin */[m
[32m+[m[32m#define AFIO_EXTICR4_EXTI15_PG               ((uint16_t)0x6000)            /*!< PG[15] pin */[m
[32m+[m
[32m+[m[32m#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)[m
[32m+[m[32m/******************  Bit definition for AFIO_MAPR2 register  ******************/[m
[32m+[m[32m#define AFIO_MAPR2_TIM15_REMAP               ((uint32_t)0x00000001)        /*!< TIM15 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM16_REMAP               ((uint32_t)0x00000002)        /*!< TIM16 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM17_REMAP               ((uint32_t)0x00000004)        /*!< TIM17 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_CEC_REMAP                 ((uint32_t)0x00000008)        /*!< CEC remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM1_DMA_REMAP            ((uint32_t)0x00000010)        /*!< TIM1_DMA remapping */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_HD_VL[m
[32m+[m[32m#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM67_DAC_DMA_REMAP       ((uint32_t)0x00000800)        /*!< TIM6/TIM7 and DAC DMA remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM12_REMAP               ((uint32_t)0x00001000)        /*!< TIM12 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_MISC_REMAP                ((uint32_t)0x00002000)        /*!< Miscellaneous remapping */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_XL[m[41m [m
[32m+[m[32m/******************  Bit definition for AFIO_MAPR2 register  ******************/[m
[32m+[m[32m#define AFIO_MAPR2_TIM9_REMAP                ((uint32_t)0x00000020)        /*!< TIM9 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM10_REMAP               ((uint32_t)0x00000040)        /*!< TIM10 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM11_REMAP               ((uint32_t)0x00000080)        /*!< TIM11 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM13_REMAP               ((uint32_t)0x00000100)        /*!< TIM13 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_TIM14_REMAP               ((uint32_t)0x00000200)        /*!< TIM14 remapping */[m
[32m+[m[32m#define AFIO_MAPR2_FSMC_NADV_REMAP           ((uint32_t)0x00000400)        /*!< FSMC NADV remapping */[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                               SystemTick                                   */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for SysTick_CTRL register  *****************/[m
[32m+[m[32m#define  SysTick_CTRL_ENABLE                 ((uint32_t)0x00000001)        /*!< Counter enable */[m
[32m+[m[32m#define  SysTick_CTRL_TICKINT                ((uint32_t)0x00000002)        /*!< Counting down to 0 pends the SysTick handler */[m
[32m+[m[32m#define  SysTick_CTRL_CLKSOURCE              ((uint32_t)0x00000004)        /*!< Clock source */[m
[32m+[m[32m#define  SysTick_CTRL_COUNTFLAG              ((uint32_t)0x00010000)        /*!< Count Flag */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for SysTick_LOAD register  *****************/[m
[32m+[m[32m#define  SysTick_LOAD_RELOAD                 ((uint32_t)0x00FFFFFF)        /*!< Value to load into the SysTick Current Value Register when the counter reaches 0 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for SysTick_VAL register  ******************/[m
[32m+[m[32m#define  SysTick_VAL_CURRENT                 ((uint32_t)0x00FFFFFF)        /*!< Current value at the time the register is accessed */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for SysTick_CALIB register  ****************/[m
[32m+[m[32m#define  SysTick_CALIB_TENMS                 ((uint32_t)0x00FFFFFF)        /*!< Reload value to use for 10ms timing */[m
[32m+[m[32m#define  SysTick_CALIB_SKEW                  ((uint32_t)0x40000000)        /*!< Calibration value is not exactly 10 ms */[m
[32m+[m[32m#define  SysTick_CALIB_NOREF                 ((uint32_t)0x80000000)        /*!< The reference clock is not provided */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                  Nested Vectored Interrupt Controller                      */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_ISER register  *******************/[m
[32m+[m[32m#define  NVIC_ISER_SETENA                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set enable bits */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */[m
[32m+[m[32m#define  NVIC_ISER_SETENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_ICER register  *******************/[m
[32m+[m[32m#define  NVIC_ICER_CLRENA                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-enable bits */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_0                  ((uint32_t)0x00000001)        /*!< bit 0 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_1                  ((uint32_t)0x00000002)        /*!< bit 1 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_2                  ((uint32_t)0x00000004)        /*!< bit 2 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_3                  ((uint32_t)0x00000008)        /*!< bit 3 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_4                  ((uint32_t)0x00000010)        /*!< bit 4 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_5                  ((uint32_t)0x00000020)        /*!< bit 5 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_6                  ((uint32_t)0x00000040)        /*!< bit 6 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_7                  ((uint32_t)0x00000080)        /*!< bit 7 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_8                  ((uint32_t)0x00000100)        /*!< bit 8 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_9                  ((uint32_t)0x00000200)        /*!< bit 9 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_10                 ((uint32_t)0x00000400)        /*!< bit 10 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_11                 ((uint32_t)0x00000800)        /*!< bit 11 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_12                 ((uint32_t)0x00001000)        /*!< bit 12 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_13                 ((uint32_t)0x00002000)        /*!< bit 13 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_14                 ((uint32_t)0x00004000)        /*!< bit 14 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_15                 ((uint32_t)0x00008000)        /*!< bit 15 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_16                 ((uint32_t)0x00010000)        /*!< bit 16 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_17                 ((uint32_t)0x00020000)        /*!< bit 17 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_18                 ((uint32_t)0x00040000)        /*!< bit 18 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_19                 ((uint32_t)0x00080000)        /*!< bit 19 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_20                 ((uint32_t)0x00100000)        /*!< bit 20 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_21                 ((uint32_t)0x00200000)        /*!< bit 21 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_22                 ((uint32_t)0x00400000)        /*!< bit 22 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_23                 ((uint32_t)0x00800000)        /*!< bit 23 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_24                 ((uint32_t)0x01000000)        /*!< bit 24 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_25                 ((uint32_t)0x02000000)        /*!< bit 25 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_26                 ((uint32_t)0x04000000)        /*!< bit 26 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_27                 ((uint32_t)0x08000000)        /*!< bit 27 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_28                 ((uint32_t)0x10000000)        /*!< bit 28 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_29                 ((uint32_t)0x20000000)        /*!< bit 29 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_30                 ((uint32_t)0x40000000)        /*!< bit 30 */[m
[32m+[m[32m#define  NVIC_ICER_CLRENA_31                 ((uint32_t)0x80000000)        /*!< bit 31 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_ISPR register  *******************/[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt set-pending bits */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */[m
[32m+[m[32m#define  NVIC_ISPR_SETPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_ICPR register  *******************/[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND                   ((uint32_t)0xFFFFFFFF)        /*!< Interrupt clear-pending bits */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_0                 ((uint32_t)0x00000001)        /*!< bit 0 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_1                 ((uint32_t)0x00000002)        /*!< bit 1 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_2                 ((uint32_t)0x00000004)        /*!< bit 2 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_3                 ((uint32_t)0x00000008)        /*!< bit 3 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_4                 ((uint32_t)0x00000010)        /*!< bit 4 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_5                 ((uint32_t)0x00000020)        /*!< bit 5 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_6                 ((uint32_t)0x00000040)        /*!< bit 6 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_7                 ((uint32_t)0x00000080)        /*!< bit 7 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_8                 ((uint32_t)0x00000100)        /*!< bit 8 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_9                 ((uint32_t)0x00000200)        /*!< bit 9 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_10                ((uint32_t)0x00000400)        /*!< bit 10 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_11                ((uint32_t)0x00000800)        /*!< bit 11 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_12                ((uint32_t)0x00001000)        /*!< bit 12 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_13                ((uint32_t)0x00002000)        /*!< bit 13 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_14                ((uint32_t)0x00004000)        /*!< bit 14 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_15                ((uint32_t)0x00008000)        /*!< bit 15 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_16                ((uint32_t)0x00010000)        /*!< bit 16 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_17                ((uint32_t)0x00020000)        /*!< bit 17 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_18                ((uint32_t)0x00040000)        /*!< bit 18 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_19                ((uint32_t)0x00080000)        /*!< bit 19 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_20                ((uint32_t)0x00100000)        /*!< bit 20 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_21                ((uint32_t)0x00200000)        /*!< bit 21 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_22                ((uint32_t)0x00400000)        /*!< bit 22 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_23                ((uint32_t)0x00800000)        /*!< bit 23 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_24                ((uint32_t)0x01000000)        /*!< bit 24 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_25                ((uint32_t)0x02000000)        /*!< bit 25 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_26                ((uint32_t)0x04000000)        /*!< bit 26 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_27                ((uint32_t)0x08000000)        /*!< bit 27 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_28                ((uint32_t)0x10000000)        /*!< bit 28 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_29                ((uint32_t)0x20000000)        /*!< bit 29 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_30                ((uint32_t)0x40000000)        /*!< bit 30 */[m
[32m+[m[32m#define  NVIC_ICPR_CLRPEND_31                ((uint32_t)0x80000000)        /*!< bit 31 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_IABR register  *******************/[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE                    ((uint32_t)0xFFFFFFFF)        /*!< Interrupt active flags */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_0                  ((uint32_t)0x00000001)        /*!< bit 0 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_1                  ((uint32_t)0x00000002)        /*!< bit 1 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_2                  ((uint32_t)0x00000004)        /*!< bit 2 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_3                  ((uint32_t)0x00000008)        /*!< bit 3 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_4                  ((uint32_t)0x00000010)        /*!< bit 4 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_5                  ((uint32_t)0x00000020)        /*!< bit 5 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_6                  ((uint32_t)0x00000040)        /*!< bit 6 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_7                  ((uint32_t)0x00000080)        /*!< bit 7 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_8                  ((uint32_t)0x00000100)        /*!< bit 8 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_9                  ((uint32_t)0x00000200)        /*!< bit 9 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_10                 ((uint32_t)0x00000400)        /*!< bit 10 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_11                 ((uint32_t)0x00000800)        /*!< bit 11 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_12                 ((uint32_t)0x00001000)        /*!< bit 12 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_13                 ((uint32_t)0x00002000)        /*!< bit 13 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_14                 ((uint32_t)0x00004000)        /*!< bit 14 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_15                 ((uint32_t)0x00008000)        /*!< bit 15 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_16                 ((uint32_t)0x00010000)        /*!< bit 16 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_17                 ((uint32_t)0x00020000)        /*!< bit 17 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_18                 ((uint32_t)0x00040000)        /*!< bit 18 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_19                 ((uint32_t)0x00080000)        /*!< bit 19 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_20                 ((uint32_t)0x00100000)        /*!< bit 20 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_21                 ((uint32_t)0x00200000)        /*!< bit 21 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_22                 ((uint32_t)0x00400000)        /*!< bit 22 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_23                 ((uint32_t)0x00800000)        /*!< bit 23 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_24                 ((uint32_t)0x01000000)        /*!< bit 24 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_25                 ((uint32_t)0x02000000)        /*!< bit 25 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_26                 ((uint32_t)0x04000000)        /*!< bit 26 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_27                 ((uint32_t)0x08000000)        /*!< bit 27 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_28                 ((uint32_t)0x10000000)        /*!< bit 28 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_29                 ((uint32_t)0x20000000)        /*!< bit 29 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_30                 ((uint32_t)0x40000000)        /*!< bit 30 */[m
[32m+[m[32m#define  NVIC_IABR_ACTIVE_31                 ((uint32_t)0x80000000)        /*!< bit 31 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI0 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR0_PRI_0                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 0 */[m
[32m+[m[32m#define  NVIC_IPR0_PRI_1                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 1 */[m
[32m+[m[32m#define  NVIC_IPR0_PRI_2                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 2 */[m
[32m+[m[32m#define  NVIC_IPR0_PRI_3                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 3 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI1 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR1_PRI_4                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 4 */[m
[32m+[m[32m#define  NVIC_IPR1_PRI_5                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 5 */[m
[32m+[m[32m#define  NVIC_IPR1_PRI_6                     ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 6 */[m
[32m+[m[32m#define  NVIC_IPR1_PRI_7                     ((uint32_t)0xFF000000)        /*!< Priority of interrupt 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI2 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR2_PRI_8                     ((uint32_t)0x000000FF)        /*!< Priority of interrupt 8 */[m
[32m+[m[32m#define  NVIC_IPR2_PRI_9                     ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 9 */[m
[32m+[m[32m#define  NVIC_IPR2_PRI_10                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 10 */[m
[32m+[m[32m#define  NVIC_IPR2_PRI_11                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 11 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI3 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR3_PRI_12                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 12 */[m
[32m+[m[32m#define  NVIC_IPR3_PRI_13                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 13 */[m
[32m+[m[32m#define  NVIC_IPR3_PRI_14                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 14 */[m
[32m+[m[32m#define  NVIC_IPR3_PRI_15                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 15 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI4 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR4_PRI_16                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 16 */[m
[32m+[m[32m#define  NVIC_IPR4_PRI_17                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 17 */[m
[32m+[m[32m#define  NVIC_IPR4_PRI_18                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 18 */[m
[32m+[m[32m#define  NVIC_IPR4_PRI_19                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 19 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI5 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR5_PRI_20                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 20 */[m
[32m+[m[32m#define  NVIC_IPR5_PRI_21                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 21 */[m
[32m+[m[32m#define  NVIC_IPR5_PRI_22                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 22 */[m
[32m+[m[32m#define  NVIC_IPR5_PRI_23                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 23 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI6 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR6_PRI_24                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 24 */[m
[32m+[m[32m#define  NVIC_IPR6_PRI_25                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 25 */[m
[32m+[m[32m#define  NVIC_IPR6_PRI_26                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 26 */[m
[32m+[m[32m#define  NVIC_IPR6_PRI_27                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 27 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for NVIC_PRI7 register  *******************/[m
[32m+[m[32m#define  NVIC_IPR7_PRI_28                    ((uint32_t)0x000000FF)        /*!< Priority of interrupt 28 */[m
[32m+[m[32m#define  NVIC_IPR7_PRI_29                    ((uint32_t)0x0000FF00)        /*!< Priority of interrupt 29 */[m
[32m+[m[32m#define  NVIC_IPR7_PRI_30                    ((uint32_t)0x00FF0000)        /*!< Priority of interrupt 30 */[m
[32m+[m[32m#define  NVIC_IPR7_PRI_31                    ((uint32_t)0xFF000000)        /*!< Priority of interrupt 31 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SCB_CPUID register  *******************/[m
[32m+[m[32m#define  SCB_CPUID_REVISION                  ((uint32_t)0x0000000F)        /*!< Implementation defined revision number */[m
[32m+[m[32m#define  SCB_CPUID_PARTNO                    ((uint32_t)0x0000FFF0)        /*!< Number of processor within family */[m
[32m+[m[32m#define  SCB_CPUID_Constant                  ((uint32_t)0x000F0000)        /*!< Reads as 0x0F */[m
[32m+[m[32m#define  SCB_CPUID_VARIANT                   ((uint32_t)0x00F00000)        /*!< Implementation defined variant number */[m
[32m+[m[32m#define  SCB_CPUID_IMPLEMENTER               ((uint32_t)0xFF000000)        /*!< Implementer code. ARM is 0x41 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_ICSR register  *******************/[m
[32m+[m[32m#define  SCB_ICSR_VECTACTIVE                 ((uint32_t)0x000001FF)        /*!< Active ISR number field */[m
[32m+[m[32m#define  SCB_ICSR_RETTOBASE                  ((uint32_t)0x00000800)        /*!< All active exceptions minus the IPSR_current_exception yields the empty set */[m
[32m+[m[32m#define  SCB_ICSR_VECTPENDING                ((uint32_t)0x003FF000)        /*!< Pending ISR number field */[m
[32m+[m[32m#define  SCB_ICSR_ISRPENDING                 ((uint32_t)0x00400000)        /*!< Interrupt pending flag */[m
[32m+[m[32m#define  SCB_ICSR_ISRPREEMPT                 ((uint32_t)0x00800000)        /*!< It indicates that a pending interrupt becomes active in the next running cycle */[m
[32m+[m[32m#define  SCB_ICSR_PENDSTCLR                  ((uint32_t)0x02000000)        /*!< Clear pending SysTick bit */[m
[32m+[m[32m#define  SCB_ICSR_PENDSTSET                  ((uint32_t)0x04000000)        /*!< Set pending SysTick bit */[m
[32m+[m[32m#define  SCB_ICSR_PENDSVCLR                  ((uint32_t)0x08000000)        /*!< Clear pending pendSV bit */[m
[32m+[m[32m#define  SCB_ICSR_PENDSVSET                  ((uint32_t)0x10000000)        /*!< Set pending pendSV bit */[m
[32m+[m[32m#define  SCB_ICSR_NMIPENDSET                 ((uint32_t)0x80000000)        /*!< Set pending NMI bit */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_VTOR register  *******************/[m
[32m+[m[32m#define  SCB_VTOR_TBLOFF                     ((uint32_t)0x1FFFFF80)        /*!< Vector table base offset field */[m
[32m+[m[32m#define  SCB_VTOR_TBLBASE                    ((uint32_t)0x20000000)        /*!< Table base in code(0) or RAM(1) */[m
[32m+[m
[32m+[m[32m/*!<*****************  Bit definition for SCB_AIRCR register  *******************/[m
[32m+[m[32m#define  SCB_AIRCR_VECTRESET                 ((uint32_t)0x00000001)        /*!< System Reset bit */[m
[32m+[m[32m#define  SCB_AIRCR_VECTCLRACTIVE             ((uint32_t)0x00000002)        /*!< Clear active vector bit */[m
[32m+[m[32m#define  SCB_AIRCR_SYSRESETREQ               ((uint32_t)0x00000004)        /*!< Requests chip control logic to generate a reset */[m
[32m+[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP                  ((uint32_t)0x00000700)        /*!< PRIGROUP[2:0] bits (Priority group) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP_0                ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP_1                ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP_2                ((uint32_t)0x00000400)        /*!< Bit 2  */[m
[32m+[m
[32m+[m[32m/* prority group configuration */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP0                 ((uint32_t)0x00000000)        /*!< Priority group=0 (7 bits of pre-emption priority, 1 bit of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP1                 ((uint32_t)0x00000100)        /*!< Priority group=1 (6 bits of pre-emption priority, 2 bits of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP2                 ((uint32_t)0x00000200)        /*!< Priority group=2 (5 bits of pre-emption priority, 3 bits of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP3                 ((uint32_t)0x00000300)        /*!< Priority group=3 (4 bits of pre-emption priority, 4 bits of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP4                 ((uint32_t)0x00000400)        /*!< Priority group=4 (3 bits of pre-emption priority, 5 bits of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP5                 ((uint32_t)0x00000500)        /*!< Priority group=5 (2 bits of pre-emption priority, 6 bits of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP6                 ((uint32_t)0x00000600)        /*!< Priority group=6 (1 bit of pre-emption priority, 7 bits of subpriority) */[m
[32m+[m[32m#define  SCB_AIRCR_PRIGROUP7                 ((uint32_t)0x00000700)        /*!< Priority group=7 (no pre-emption priority, 8 bits of subpriority) */[m
[32m+[m
[32m+[m[32m#define  SCB_AIRCR_ENDIANESS                 ((uint32_t)0x00008000)        /*!< Data endianness bit */[m
[32m+[m[32m#define  SCB_AIRCR_VECTKEY                   ((uint32_t)0xFFFF0000)        /*!< Register key (VECTKEY) - Reads as 0xFA05 (VECTKEYSTAT) */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_SCR register  ********************/[m
[32m+[m[32m#define  SCB_SCR_SLEEPONEXIT                 ((uint8_t)0x02)               /*!< Sleep on exit bit */[m
[32m+[m[32m#define  SCB_SCR_SLEEPDEEP                   ((uint8_t)0x04)               /*!< Sleep deep bit */[m
[32m+[m[32m#define  SCB_SCR_SEVONPEND                   ((uint8_t)0x10)               /*!< Wake up from WFE */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for SCB_CCR register  *******************/[m
[32m+[m[32m#define  SCB_CCR_NONBASETHRDENA              ((uint16_t)0x0001)            /*!< Thread mode can be entered from any level in Handler mode by controlled return value */[m
[32m+[m[32m#define  SCB_CCR_USERSETMPEND                ((uint16_t)0x0002)            /*!< Enables user code to write the Software Trigger Interrupt register to trigger (pend) a Main exception */[m
[32m+[m[32m#define  SCB_CCR_UNALIGN_TRP                 ((uint16_t)0x0008)            /*!< Trap for unaligned access */[m
[32m+[m[32m#define  SCB_CCR_DIV_0_TRP                   ((uint16_t)0x0010)            /*!< Trap on Divide by 0 */[m
[32m+[m[32m#define  SCB_CCR_BFHFNMIGN                   ((uint16_t)0x0100)            /*!< Handlers running at priority -1 and -2 */[m
[32m+[m[32m#define  SCB_CCR_STKALIGN                    ((uint16_t)0x0200)            /*!< On exception entry, the SP used prior to the exception is adjusted to be 8-byte aligned */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_SHPR register ********************/[m
[32m+[m[32m#define  SCB_SHPR_PRI_N                      ((uint32_t)0x000000FF)        /*!< Priority of system handler 4,8, and 12. Mem Manage, reserved and Debug Monitor */[m
[32m+[m[32m#define  SCB_SHPR_PRI_N1                     ((uint32_t)0x0000FF00)        /*!< Priority of system handler 5,9, and 13. Bus Fault, reserved and reserved */[m
[32m+[m[32m#define  SCB_SHPR_PRI_N2                     ((uint32_t)0x00FF0000)        /*!< Priority of system handler 6,10, and 14. Usage Fault, reserved and PendSV */[m
[32m+[m[32m#define  SCB_SHPR_PRI_N3                     ((uint32_t)0xFF000000)        /*!< Priority of system handler 7,11, and 15. Reserved, SVCall and SysTick */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SCB_SHCSR register  *******************/[m
[32m+[m[32m#define  SCB_SHCSR_MEMFAULTACT               ((uint32_t)0x00000001)        /*!< MemManage is active */[m
[32m+[m[32m#define  SCB_SHCSR_BUSFAULTACT               ((uint32_t)0x00000002)        /*!< BusFault is active */[m
[32m+[m[32m#define  SCB_SHCSR_USGFAULTACT               ((uint32_t)0x00000008)        /*!< UsageFault is active */[m
[32m+[m[32m#define  SCB_SHCSR_SVCALLACT                 ((uint32_t)0x00000080)        /*!< SVCall is active */[m
[32m+[m[32m#define  SCB_SHCSR_MONITORACT                ((uint32_t)0x00000100)        /*!< Monitor is active */[m
[32m+[m[32m#define  SCB_SHCSR_PENDSVACT                 ((uint32_t)0x00000400)        /*!< PendSV is active */[m
[32m+[m[32m#define  SCB_SHCSR_SYSTICKACT                ((uint32_t)0x00000800)        /*!< SysTick is active */[m
[32m+[m[32m#define  SCB_SHCSR_USGFAULTPENDED            ((uint32_t)0x00001000)        /*!< Usage Fault is pended */[m
[32m+[m[32m#define  SCB_SHCSR_MEMFAULTPENDED            ((uint32_t)0x00002000)        /*!< MemManage is pended */[m
[32m+[m[32m#define  SCB_SHCSR_BUSFAULTPENDED            ((uint32_t)0x00004000)        /*!< Bus Fault is pended */[m
[32m+[m[32m#define  SCB_SHCSR_SVCALLPENDED              ((uint32_t)0x00008000)        /*!< SVCall is pended */[m
[32m+[m[32m#define  SCB_SHCSR_MEMFAULTENA               ((uint32_t)0x00010000)        /*!< MemManage enable */[m
[32m+[m[32m#define  SCB_SHCSR_BUSFAULTENA               ((uint32_t)0x00020000)        /*!< Bus Fault enable */[m
[32m+[m[32m#define  SCB_SHCSR_USGFAULTENA               ((uint32_t)0x00040000)        /*!< UsageFault enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_CFSR register  *******************/[m
[32m+[m[32m/*!< MFSR */[m
[32m+[m[32m#define  SCB_CFSR_IACCVIOL                   ((uint32_t)0x00000001)        /*!< Instruction access violation */[m
[32m+[m[32m#define  SCB_CFSR_DACCVIOL                   ((uint32_t)0x00000002)        /*!< Data access violation */[m
[32m+[m[32m#define  SCB_CFSR_MUNSTKERR                  ((uint32_t)0x00000008)        /*!< Unstacking error */[m
[32m+[m[32m#define  SCB_CFSR_MSTKERR                    ((uint32_t)0x00000010)        /*!< Stacking error */[m
[32m+[m[32m#define  SCB_CFSR_MMARVALID                  ((uint32_t)0x00000080)        /*!< Memory Manage Address Register address valid flag */[m
[32m+[m[32m/*!< BFSR */[m
[32m+[m[32m#define  SCB_CFSR_IBUSERR                    ((uint32_t)0x00000100)        /*!< Instruction bus error flag */[m
[32m+[m[32m#define  SCB_CFSR_PRECISERR                  ((uint32_t)0x00000200)        /*!< Precise data bus error */[m
[32m+[m[32m#define  SCB_CFSR_IMPRECISERR                ((uint32_t)0x00000400)        /*!< Imprecise data bus error */[m
[32m+[m[32m#define  SCB_CFSR_UNSTKERR                   ((uint32_t)0x00000800)        /*!< Unstacking error */[m
[32m+[m[32m#define  SCB_CFSR_STKERR                     ((uint32_t)0x00001000)        /*!< Stacking error */[m
[32m+[m[32m#define  SCB_CFSR_BFARVALID                  ((uint32_t)0x00008000)        /*!< Bus Fault Address Register address valid flag */[m
[32m+[m[32m/*!< UFSR */[m
[32m+[m[32m#define  SCB_CFSR_UNDEFINSTR                 ((uint32_t)0x00010000)        /*!< The processor attempt to execute an undefined instruction */[m
[32m+[m[32m#define  SCB_CFSR_INVSTATE                   ((uint32_t)0x00020000)        /*!< Invalid combination of EPSR and instruction */[m
[32m+[m[32m#define  SCB_CFSR_INVPC                      ((uint32_t)0x00040000)        /*!< Attempt to load EXC_RETURN into pc illegally */[m
[32m+[m[32m#define  SCB_CFSR_NOCP                       ((uint32_t)0x00080000)        /*!< Attempt to use a coprocessor instruction */[m
[32m+[m[32m#define  SCB_CFSR_UNALIGNED                  ((uint32_t)0x01000000)        /*!< Fault occurs when there is an attempt to make an unaligned memory access */[m
[32m+[m[32m#define  SCB_CFSR_DIVBYZERO                  ((uint32_t)0x02000000)        /*!< Fault occurs when SDIV or DIV instruction is used with a divisor of 0 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_HFSR register  *******************/[m
[32m+[m[32m#define  SCB_HFSR_VECTTBL                    ((uint32_t)0x00000002)        /*!< Fault occurs because of vector table read on exception processing */[m
[32m+[m[32m#define  SCB_HFSR_FORCED                     ((uint32_t)0x40000000)        /*!< Hard Fault activated when a configurable Fault was received and cannot activate */[m
[32m+[m[32m#define  SCB_HFSR_DEBUGEVT                   ((uint32_t)0x80000000)        /*!< Fault related to debug */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_DFSR register  *******************/[m
[32m+[m[32m#define  SCB_DFSR_HALTED                     ((uint8_t)0x01)               /*!< Halt request flag */[m
[32m+[m[32m#define  SCB_DFSR_BKPT                       ((uint8_t)0x02)               /*!< BKPT flag */[m
[32m+[m[32m#define  SCB_DFSR_DWTTRAP                    ((uint8_t)0x04)               /*!< Data Watchpoint and Trace (DWT) flag */[m
[32m+[m[32m#define  SCB_DFSR_VCATCH                     ((uint8_t)0x08)               /*!< Vector catch flag */[m
[32m+[m[32m#define  SCB_DFSR_EXTERNAL                   ((uint8_t)0x10)               /*!< External debug request flag */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_MMFAR register  ******************/[m
[32m+[m[32m#define  SCB_MMFAR_ADDRESS                   ((uint32_t)0xFFFFFFFF)        /*!< Mem Manage fault address field */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_BFAR register  *******************/[m
[32m+[m[32m#define  SCB_BFAR_ADDRESS                    ((uint32_t)0xFFFFFFFF)        /*!< Bus fault address field */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SCB_afsr register  *******************/[m
[32m+[m[32m#define  SCB_AFSR_IMPDEF                     ((uint32_t)0xFFFFFFFF)        /*!< Implementation defined */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                    External Interrupt/Event Controller                     */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for EXTI_IMR register  *******************/[m
[32m+[m[32m#define  EXTI_IMR_MR0                        ((uint32_t)0x00000001)        /*!< Interrupt Mask on line 0 */[m
[32m+[m[32m#define  EXTI_IMR_MR1                        ((uint32_t)0x00000002)        /*!< Interrupt Mask on line 1 */[m
[32m+[m[32m#define  EXTI_IMR_MR2                        ((uint32_t)0x00000004)        /*!< Interrupt Mask on line 2 */[m
[32m+[m[32m#define  EXTI_IMR_MR3                        ((uint32_t)0x00000008)        /*!< Interrupt Mask on line 3 */[m
[32m+[m[32m#define  EXTI_IMR_MR4                        ((uint32_t)0x00000010)        /*!< Interrupt Mask on line 4 */[m
[32m+[m[32m#define  EXTI_IMR_MR5                        ((uint32_t)0x00000020)        /*!< Interrupt Mask on line 5 */[m
[32m+[m[32m#define  EXTI_IMR_MR6                        ((uint32_t)0x00000040)        /*!< Interrupt Mask on line 6 */[m
[32m+[m[32m#define  EXTI_IMR_MR7                        ((uint32_t)0x00000080)        /*!< Interrupt Mask on line 7 */[m
[32m+[m[32m#define  EXTI_IMR_MR8                        ((uint32_t)0x00000100)        /*!< Interrupt Mask on line 8 */[m
[32m+[m[32m#define  EXTI_IMR_MR9                        ((uint32_t)0x00000200)        /*!< Interrupt Mask on line 9 */[m
[32m+[m[32m#define  EXTI_IMR_MR10                       ((uint32_t)0x00000400)        /*!< Interrupt Mask on line 10 */[m
[32m+[m[32m#define  EXTI_IMR_MR11                       ((uint32_t)0x00000800)        /*!< Interrupt Mask on line 11 */[m
[32m+[m[32m#define  EXTI_IMR_MR12                       ((uint32_t)0x00001000)        /*!< Interrupt Mask on line 12 */[m
[32m+[m[32m#define  EXTI_IMR_MR13                       ((uint32_t)0x00002000)        /*!< Interrupt Mask on line 13 */[m
[32m+[m[32m#define  EXTI_IMR_MR14                       ((uint32_t)0x00004000)        /*!< Interrupt Mask on line 14 */[m
[32m+[m[32m#define  EXTI_IMR_MR15                       ((uint32_t)0x00008000)        /*!< Interrupt Mask on line 15 */[m
[32m+[m[32m#define  EXTI_IMR_MR16                       ((uint32_t)0x00010000)        /*!< Interrupt Mask on line 16 */[m
[32m+[m[32m#define  EXTI_IMR_MR17                       ((uint32_t)0x00020000)        /*!< Interrupt Mask on line 17 */[m
[32m+[m[32m#define  EXTI_IMR_MR18                       ((uint32_t)0x00040000)        /*!< Interrupt Mask on line 18 */[m
[32m+[m[32m#define  EXTI_IMR_MR19                       ((uint32_t)0x00080000)        /*!< Interrupt Mask on line 19 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for EXTI_EMR register  *******************/[m
[32m+[m[32m#define  EXTI_EMR_MR0                        ((uint32_t)0x00000001)        /*!< Event Mask on line 0 */[m
[32m+[m[32m#define  EXTI_EMR_MR1                        ((uint32_t)0x00000002)        /*!< Event Mask on line 1 */[m
[32m+[m[32m#define  EXTI_EMR_MR2                        ((uint32_t)0x00000004)        /*!< Event Mask on line 2 */[m
[32m+[m[32m#define  EXTI_EMR_MR3                        ((uint32_t)0x00000008)        /*!< Event Mask on line 3 */[m
[32m+[m[32m#define  EXTI_EMR_MR4                        ((uint32_t)0x00000010)        /*!< Event Mask on line 4 */[m
[32m+[m[32m#define  EXTI_EMR_MR5                        ((uint32_t)0x00000020)        /*!< Event Mask on line 5 */[m
[32m+[m[32m#define  EXTI_EMR_MR6                        ((uint32_t)0x00000040)        /*!< Event Mask on line 6 */[m
[32m+[m[32m#define  EXTI_EMR_MR7                        ((uint32_t)0x00000080)        /*!< Event Mask on line 7 */[m
[32m+[m[32m#define  EXTI_EMR_MR8                        ((uint32_t)0x00000100)        /*!< Event Mask on line 8 */[m
[32m+[m[32m#define  EXTI_EMR_MR9                        ((uint32_t)0x00000200)        /*!< Event Mask on line 9 */[m
[32m+[m[32m#define  EXTI_EMR_MR10                       ((uint32_t)0x00000400)        /*!< Event Mask on line 10 */[m
[32m+[m[32m#define  EXTI_EMR_MR11                       ((uint32_t)0x00000800)        /*!< Event Mask on line 11 */[m
[32m+[m[32m#define  EXTI_EMR_MR12                       ((uint32_t)0x00001000)        /*!< Event Mask on line 12 */[m
[32m+[m[32m#define  EXTI_EMR_MR13                       ((uint32_t)0x00002000)        /*!< Event Mask on line 13 */[m
[32m+[m[32m#define  EXTI_EMR_MR14                       ((uint32_t)0x00004000)        /*!< Event Mask on line 14 */[m
[32m+[m[32m#define  EXTI_EMR_MR15                       ((uint32_t)0x00008000)        /*!< Event Mask on line 15 */[m
[32m+[m[32m#define  EXTI_EMR_MR16                       ((uint32_t)0x00010000)        /*!< Event Mask on line 16 */[m
[32m+[m[32m#define  EXTI_EMR_MR17                       ((uint32_t)0x00020000)        /*!< Event Mask on line 17 */[m
[32m+[m[32m#define  EXTI_EMR_MR18                       ((uint32_t)0x00040000)        /*!< Event Mask on line 18 */[m
[32m+[m[32m#define  EXTI_EMR_MR19                       ((uint32_t)0x00080000)        /*!< Event Mask on line 19 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for EXTI_RTSR register  *******************/[m
[32m+[m[32m#define  EXTI_RTSR_TR0                       ((uint32_t)0x00000001)        /*!< Rising trigger event configuration bit of line 0 */[m
[32m+[m[32m#define  EXTI_RTSR_TR1                       ((uint32_t)0x00000002)        /*!< Rising trigger event configuration bit of line 1 */[m
[32m+[m[32m#define  EXTI_RTSR_TR2                       ((uint32_t)0x00000004)        /*!< Rising trigger event configuration bit of line 2 */[m
[32m+[m[32m#define  EXTI_RTSR_TR3                       ((uint32_t)0x00000008)        /*!< Rising trigger event configuration bit of line 3 */[m
[32m+[m[32m#define  EXTI_RTSR_TR4                       ((uint32_t)0x00000010)        /*!< Rising trigger event configuration bit of line 4 */[m
[32m+[m[32m#define  EXTI_RTSR_TR5                       ((uint32_t)0x00000020)        /*!< Rising trigger event configuration bit of line 5 */[m
[32m+[m[32m#define  EXTI_RTSR_TR6                       ((uint32_t)0x00000040)        /*!< Rising trigger event configuration bit of line 6 */[m
[32m+[m[32m#define  EXTI_RTSR_TR7                       ((uint32_t)0x00000080)        /*!< Rising trigger event configuration bit of line 7 */[m
[32m+[m[32m#define  EXTI_RTSR_TR8                       ((uint32_t)0x00000100)        /*!< Rising trigger event configuration bit of line 8 */[m
[32m+[m[32m#define  EXTI_RTSR_TR9                       ((uint32_t)0x00000200)        /*!< Rising trigger event configuration bit of line 9 */[m
[32m+[m[32m#define  EXTI_RTSR_TR10                      ((uint32_t)0x00000400)        /*!< Rising trigger event configuration bit of line 10 */[m
[32m+[m[32m#define  EXTI_RTSR_TR11                      ((uint32_t)0x00000800)        /*!< Rising trigger event configuration bit of line 11 */[m
[32m+[m[32m#define  EXTI_RTSR_TR12                      ((uint32_t)0x00001000)        /*!< Rising trigger event configuration bit of line 12 */[m
[32m+[m[32m#define  EXTI_RTSR_TR13                      ((uint32_t)0x00002000)        /*!< Rising trigger event configuration bit of line 13 */[m
[32m+[m[32m#define  EXTI_RTSR_TR14                      ((uint32_t)0x00004000)        /*!< Rising trigger event configuration bit of line 14 */[m
[32m+[m[32m#define  EXTI_RTSR_TR15                      ((uint32_t)0x00008000)        /*!< Rising trigger event configuration bit of line 15 */[m
[32m+[m[32m#define  EXTI_RTSR_TR16                      ((uint32_t)0x00010000)        /*!< Rising trigger event configuration bit of line 16 */[m
[32m+[m[32m#define  EXTI_RTSR_TR17                      ((uint32_t)0x00020000)        /*!< Rising trigger event configuration bit of line 17 */[m
[32m+[m[32m#define  EXTI_RTSR_TR18                      ((uint32_t)0x00040000)        /*!< Rising trigger event configuration bit of line 18 */[m
[32m+[m[32m#define  EXTI_RTSR_TR19                      ((uint32_t)0x00080000)        /*!< Rising trigger event configuration bit of line 19 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for EXTI_FTSR register  *******************/[m
[32m+[m[32m#define  EXTI_FTSR_TR0                       ((uint32_t)0x00000001)        /*!< Falling trigger event configuration bit of line 0 */[m
[32m+[m[32m#define  EXTI_FTSR_TR1                       ((uint32_t)0x00000002)        /*!< Falling trigger event configuration bit of line 1 */[m
[32m+[m[32m#define  EXTI_FTSR_TR2                       ((uint32_t)0x00000004)        /*!< Falling trigger event configuration bit of line 2 */[m
[32m+[m[32m#define  EXTI_FTSR_TR3                       ((uint32_t)0x00000008)        /*!< Falling trigger event configuration bit of line 3 */[m
[32m+[m[32m#define  EXTI_FTSR_TR4                       ((uint32_t)0x00000010)        /*!< Falling trigger event configuration bit of line 4 */[m
[32m+[m[32m#define  EXTI_FTSR_TR5                       ((uint32_t)0x00000020)        /*!< Falling trigger event configuration bit of line 5 */[m
[32m+[m[32m#define  EXTI_FTSR_TR6                       ((uint32_t)0x00000040)        /*!< Falling trigger event configuration bit of line 6 */[m
[32m+[m[32m#define  EXTI_FTSR_TR7                       ((uint32_t)0x00000080)        /*!< Falling trigger event configuration bit of line 7 */[m
[32m+[m[32m#define  EXTI_FTSR_TR8                       ((uint32_t)0x00000100)        /*!< Falling trigger event configuration bit of line 8 */[m
[32m+[m[32m#define  EXTI_FTSR_TR9                       ((uint32_t)0x00000200)        /*!< Falling trigger event configuration bit of line 9 */[m
[32m+[m[32m#define  EXTI_FTSR_TR10                      ((uint32_t)0x00000400)        /*!< Falling trigger event configuration bit of line 10 */[m
[32m+[m[32m#define  EXTI_FTSR_TR11                      ((uint32_t)0x00000800)        /*!< Falling trigger event configuration bit of line 11 */[m
[32m+[m[32m#define  EXTI_FTSR_TR12                      ((uint32_t)0x00001000)        /*!< Falling trigger event configuration bit of line 12 */[m
[32m+[m[32m#define  EXTI_FTSR_TR13                      ((uint32_t)0x00002000)        /*!< Falling trigger event configuration bit of line 13 */[m
[32m+[m[32m#define  EXTI_FTSR_TR14                      ((uint32_t)0x00004000)        /*!< Falling trigger event configuration bit of line 14 */[m
[32m+[m[32m#define  EXTI_FTSR_TR15                      ((uint32_t)0x00008000)        /*!< Falling trigger event configuration bit of line 15 */[m
[32m+[m[32m#define  EXTI_FTSR_TR16                      ((uint32_t)0x00010000)        /*!< Falling trigger event configuration bit of line 16 */[m
[32m+[m[32m#define  EXTI_FTSR_TR17                      ((uint32_t)0x00020000)        /*!< Falling trigger event configuration bit of line 17 */[m
[32m+[m[32m#define  EXTI_FTSR_TR18                      ((uint32_t)0x00040000)        /*!< Falling trigger event configuration bit of line 18 */[m
[32m+[m[32m#define  EXTI_FTSR_TR19                      ((uint32_t)0x00080000)        /*!< Falling trigger event configuration bit of line 19 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for EXTI_SWIER register  ******************/[m
[32m+[m[32m#define  EXTI_SWIER_SWIER0                   ((uint32_t)0x00000001)        /*!< Software Interrupt on line 0 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER1                   ((uint32_t)0x00000002)        /*!< Software Interrupt on line 1 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER2                   ((uint32_t)0x00000004)        /*!< Software Interrupt on line 2 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER3                   ((uint32_t)0x00000008)        /*!< Software Interrupt on line 3 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER4                   ((uint32_t)0x00000010)        /*!< Software Interrupt on line 4 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER5                   ((uint32_t)0x00000020)        /*!< Software Interrupt on line 5 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER6                   ((uint32_t)0x00000040)        /*!< Software Interrupt on line 6 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER7                   ((uint32_t)0x00000080)        /*!< Software Interrupt on line 7 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER8                   ((uint32_t)0x00000100)        /*!< Software Interrupt on line 8 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER9                   ((uint32_t)0x00000200)        /*!< Software Interrupt on line 9 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER10                  ((uint32_t)0x00000400)        /*!< Software Interrupt on line 10 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER11                  ((uint32_t)0x00000800)        /*!< Software Interrupt on line 11 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER12                  ((uint32_t)0x00001000)        /*!< Software Interrupt on line 12 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER13                  ((uint32_t)0x00002000)        /*!< Software Interrupt on line 13 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER14                  ((uint32_t)0x00004000)        /*!< Software Interrupt on line 14 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER15                  ((uint32_t)0x00008000)        /*!< Software Interrupt on line 15 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER16                  ((uint32_t)0x00010000)        /*!< Software Interrupt on line 16 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER17                  ((uint32_t)0x00020000)        /*!< Software Interrupt on line 17 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER18                  ((uint32_t)0x00040000)        /*!< Software Interrupt on line 18 */[m
[32m+[m[32m#define  EXTI_SWIER_SWIER19                  ((uint32_t)0x00080000)        /*!< Software Interrupt on line 19 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for EXTI_PR register  ********************/[m
[32m+[m[32m#define  EXTI_PR_PR0                         ((uint32_t)0x00000001)        /*!< Pending bit for line 0 */[m
[32m+[m[32m#define  EXTI_PR_PR1                         ((uint32_t)0x00000002)        /*!< Pending bit for line 1 */[m
[32m+[m[32m#define  EXTI_PR_PR2                         ((uint32_t)0x00000004)        /*!< Pending bit for line 2 */[m
[32m+[m[32m#define  EXTI_PR_PR3                         ((uint32_t)0x00000008)        /*!< Pending bit for line 3 */[m
[32m+[m[32m#define  EXTI_PR_PR4                         ((uint32_t)0x00000010)        /*!< Pending bit for line 4 */[m
[32m+[m[32m#define  EXTI_PR_PR5                         ((uint32_t)0x00000020)        /*!< Pending bit for line 5 */[m
[32m+[m[32m#define  EXTI_PR_PR6                         ((uint32_t)0x00000040)        /*!< Pending bit for line 6 */[m
[32m+[m[32m#define  EXTI_PR_PR7                         ((uint32_t)0x00000080)        /*!< Pending bit for line 7 */[m
[32m+[m[32m#define  EXTI_PR_PR8                         ((uint32_t)0x00000100)        /*!< Pending bit for line 8 */[m
[32m+[m[32m#define  EXTI_PR_PR9                         ((uint32_t)0x00000200)        /*!< Pending bit for line 9 */[m
[32m+[m[32m#define  EXTI_PR_PR10                        ((uint32_t)0x00000400)        /*!< Pending bit for line 10 */[m
[32m+[m[32m#define  EXTI_PR_PR11                        ((uint32_t)0x00000800)        /*!< Pending bit for line 11 */[m
[32m+[m[32m#define  EXTI_PR_PR12                        ((uint32_t)0x00001000)        /*!< Pending bit for line 12 */[m
[32m+[m[32m#define  EXTI_PR_PR13                        ((uint32_t)0x00002000)        /*!< Pending bit for line 13 */[m
[32m+[m[32m#define  EXTI_PR_PR14                        ((uint32_t)0x00004000)        /*!< Pending bit for line 14 */[m
[32m+[m[32m#define  EXTI_PR_PR15                        ((uint32_t)0x00008000)        /*!< Pending bit for line 15 */[m
[32m+[m[32m#define  EXTI_PR_PR16                        ((uint32_t)0x00010000)        /*!< Pending bit for line 16 */[m
[32m+[m[32m#define  EXTI_PR_PR17                        ((uint32_t)0x00020000)        /*!< Pending bit for line 17 */[m
[32m+[m[32m#define  EXTI_PR_PR18                        ((uint32_t)0x00040000)        /*!< Pending bit for line 18 */[m
[32m+[m[32m#define  EXTI_PR_PR19                        ((uint32_t)0x00080000)        /*!< Pending bit for line 19 */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                             DMA Controller                                 */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_ISR register  ********************/[m
[32m+[m[32m#define  DMA_ISR_GIF1                        ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF1                       ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF1                       ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF1                       ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error flag */[m
[32m+[m[32m#define  DMA_ISR_GIF2                        ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF2                       ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF2                       ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF2                       ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error flag */[m
[32m+[m[32m#define  DMA_ISR_GIF3                        ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF3                       ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF3                       ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF3                       ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error flag */[m
[32m+[m[32m#define  DMA_ISR_GIF4                        ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF4                       ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF4                       ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF4                       ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error flag */[m
[32m+[m[32m#define  DMA_ISR_GIF5                        ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF5                       ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF5                       ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF5                       ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error flag */[m
[32m+[m[32m#define  DMA_ISR_GIF6                        ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF6                       ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF6                       ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF6                       ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error flag */[m
[32m+[m[32m#define  DMA_ISR_GIF7                        ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt flag */[m
[32m+[m[32m#define  DMA_ISR_TCIF7                       ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete flag */[m
[32m+[m[32m#define  DMA_ISR_HTIF7                       ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer flag */[m
[32m+[m[32m#define  DMA_ISR_TEIF7                       ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error flag */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_IFCR register  *******************/[m
[32m+[m[32m#define  DMA_IFCR_CGIF1                      ((uint32_t)0x00000001)        /*!< Channel 1 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF1                     ((uint32_t)0x00000002)        /*!< Channel 1 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF1                     ((uint32_t)0x00000004)        /*!< Channel 1 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF1                     ((uint32_t)0x00000008)        /*!< Channel 1 Transfer Error clear */[m
[32m+[m[32m#define  DMA_IFCR_CGIF2                      ((uint32_t)0x00000010)        /*!< Channel 2 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF2                     ((uint32_t)0x00000020)        /*!< Channel 2 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF2                     ((uint32_t)0x00000040)        /*!< Channel 2 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF2                     ((uint32_t)0x00000080)        /*!< Channel 2 Transfer Error clear */[m
[32m+[m[32m#define  DMA_IFCR_CGIF3                      ((uint32_t)0x00000100)        /*!< Channel 3 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF3                     ((uint32_t)0x00000200)        /*!< Channel 3 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF3                     ((uint32_t)0x00000400)        /*!< Channel 3 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF3                     ((uint32_t)0x00000800)        /*!< Channel 3 Transfer Error clear */[m
[32m+[m[32m#define  DMA_IFCR_CGIF4                      ((uint32_t)0x00001000)        /*!< Channel 4 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF4                     ((uint32_t)0x00002000)        /*!< Channel 4 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF4                     ((uint32_t)0x00004000)        /*!< Channel 4 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF4                     ((uint32_t)0x00008000)        /*!< Channel 4 Transfer Error clear */[m
[32m+[m[32m#define  DMA_IFCR_CGIF5                      ((uint32_t)0x00010000)        /*!< Channel 5 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF5                     ((uint32_t)0x00020000)        /*!< Channel 5 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF5                     ((uint32_t)0x00040000)        /*!< Channel 5 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF5                     ((uint32_t)0x00080000)        /*!< Channel 5 Transfer Error clear */[m
[32m+[m[32m#define  DMA_IFCR_CGIF6                      ((uint32_t)0x00100000)        /*!< Channel 6 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF6                     ((uint32_t)0x00200000)        /*!< Channel 6 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF6                     ((uint32_t)0x00400000)        /*!< Channel 6 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF6                     ((uint32_t)0x00800000)        /*!< Channel 6 Transfer Error clear */[m
[32m+[m[32m#define  DMA_IFCR_CGIF7                      ((uint32_t)0x01000000)        /*!< Channel 7 Global interrupt clear */[m
[32m+[m[32m#define  DMA_IFCR_CTCIF7                     ((uint32_t)0x02000000)        /*!< Channel 7 Transfer Complete clear */[m
[32m+[m[32m#define  DMA_IFCR_CHTIF7                     ((uint32_t)0x04000000)        /*!< Channel 7 Half Transfer clear */[m
[32m+[m[32m#define  DMA_IFCR_CTEIF7                     ((uint32_t)0x08000000)        /*!< Channel 7 Transfer Error clear */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_CCR1 register  *******************/[m
[32m+[m[32m#define  DMA_CCR1_EN                         ((uint16_t)0x0001)            /*!< Channel enable*/[m
[32m+[m[32m#define  DMA_CCR1_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR1_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR1_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR1_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR1_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR1_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR1_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR1_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR1_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR1_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR1_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR1_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR1_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR1_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits(Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR1_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR1_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR1_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_CCR2 register  *******************/[m
[32m+[m[32m#define  DMA_CCR2_EN                         ((uint16_t)0x0001)            /*!< Channel enable */[m
[32m+[m[32m#define  DMA_CCR2_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR2_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR2_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR2_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR2_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR2_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR2_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR2_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR2_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR2_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR2_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR2_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR2_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR2_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR2_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR2_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR2_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_CCR3 register  *******************/[m
[32m+[m[32m#define  DMA_CCR3_EN                         ((uint16_t)0x0001)            /*!< Channel enable */[m
[32m+[m[32m#define  DMA_CCR3_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR3_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR3_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR3_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR3_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR3_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR3_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR3_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR3_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR3_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR3_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR3_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR3_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR3_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR3_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR3_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR3_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */[m
[32m+[m
[32m+[m[32m/*!<******************  Bit definition for DMA_CCR4 register  *******************/[m
[32m+[m[32m#define  DMA_CCR4_EN                         ((uint16_t)0x0001)            /*!< Channel enable */[m
[32m+[m[32m#define  DMA_CCR4_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR4_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR4_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR4_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR4_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR4_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR4_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR4_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR4_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR4_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR4_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR4_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR4_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR4_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR4_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR4_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR4_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CCR5 register  *******************/[m
[32m+[m[32m#define  DMA_CCR5_EN                         ((uint16_t)0x0001)            /*!< Channel enable */[m
[32m+[m[32m#define  DMA_CCR5_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR5_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR5_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR5_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR5_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR5_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR5_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR5_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR5_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR5_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR5_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR5_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR5_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR5_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR5_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR5_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR5_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_CCR6 register  *******************/[m
[32m+[m[32m#define  DMA_CCR6_EN                         ((uint16_t)0x0001)            /*!< Channel enable */[m
[32m+[m[32m#define  DMA_CCR6_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR6_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR6_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR6_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR6_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR6_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR6_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR6_PSIZE                      ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR6_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR6_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR6_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR6_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR6_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR6_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR6_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR6_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR6_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DMA_CCR7 register  *******************/[m
[32m+[m[32m#define  DMA_CCR7_EN                         ((uint16_t)0x0001)            /*!< Channel enable */[m
[32m+[m[32m#define  DMA_CCR7_TCIE                       ((uint16_t)0x0002)            /*!< Transfer complete interrupt enable */[m
[32m+[m[32m#define  DMA_CCR7_HTIE                       ((uint16_t)0x0004)            /*!< Half Transfer interrupt enable */[m
[32m+[m[32m#define  DMA_CCR7_TEIE                       ((uint16_t)0x0008)            /*!< Transfer error interrupt enable */[m
[32m+[m[32m#define  DMA_CCR7_DIR                        ((uint16_t)0x0010)            /*!< Data transfer direction */[m
[32m+[m[32m#define  DMA_CCR7_CIRC                       ((uint16_t)0x0020)            /*!< Circular mode */[m
[32m+[m[32m#define  DMA_CCR7_PINC                       ((uint16_t)0x0040)            /*!< Peripheral increment mode */[m
[32m+[m[32m#define  DMA_CCR7_MINC                       ((uint16_t)0x0080)            /*!< Memory increment mode */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR7_PSIZE            ,         ((uint16_t)0x0300)            /*!< PSIZE[1:0] bits (Peripheral size) */[m
[32m+[m[32m#define  DMA_CCR7_PSIZE_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR7_PSIZE_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR7_MSIZE                      ((uint16_t)0x0C00)            /*!< MSIZE[1:0] bits (Memory size) */[m
[32m+[m[32m#define  DMA_CCR7_MSIZE_0                    ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR7_MSIZE_1                    ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR7_PL                         ((uint16_t)0x3000)            /*!< PL[1:0] bits (Channel Priority level) */[m
[32m+[m[32m#define  DMA_CCR7_PL_0                       ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  DMA_CCR7_PL_1                       ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DMA_CCR7_MEM2MEM                    ((uint16_t)0x4000)            /*!< Memory to memory mode enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR1 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR1_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR2 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR2_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR3 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR3_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR4 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR4_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR5 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR5_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR6 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR6_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CNDTR7 register  ******************/[m
[32m+[m[32m#define  DMA_CNDTR7_NDT                      ((uint16_t)0xFFFF)            /*!< Number of data to Transfer */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR1 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR1_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR2 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR2_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR3 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR3_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR4 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR4_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR5 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR5_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR6 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR6_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CPAR7 register  *******************/[m
[32m+[m[32m#define  DMA_CPAR7_PA                        ((uint32_t)0xFFFFFFFF)        /*!< Peripheral Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR1 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR1_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR2 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR2_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR3 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR3_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR4 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR4_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR5 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR5_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR6 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR6_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DMA_CMAR7 register  *******************/[m
[32m+[m[32m#define  DMA_CMAR7_MA                        ((uint32_t)0xFFFFFFFF)        /*!< Memory Address */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                        Analog to Digital Converter                         */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/********************  Bit definition for ADC_SR register  ********************/[m
[32m+[m[32m#define  ADC_SR_AWD                          ((uint8_t)0x01)               /*!< Analog watchdog flag */[m
[32m+[m[32m#define  ADC_SR_EOC                          ((uint8_t)0x02)               /*!< End of conversion */[m
[32m+[m[32m#define  ADC_SR_JEOC                         ((uint8_t)0x04)               /*!< Injected channel end of conversion */[m
[32m+[m[32m#define  ADC_SR_JSTRT                        ((uint8_t)0x08)               /*!< Injected channel Start flag */[m
[32m+[m[32m#define  ADC_SR_STRT                         ((uint8_t)0x10)               /*!< Regular channel Start flag */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_CR1 register  ********************/[m
[32m+[m[32m#define  ADC_CR1_AWDCH                       ((uint32_t)0x0000001F)        /*!< AWDCH[4:0] bits (Analog watchdog channel select bits) */[m
[32m+[m[32m#define  ADC_CR1_AWDCH_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_CR1_AWDCH_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_CR1_AWDCH_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_CR1_AWDCH_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_CR1_AWDCH_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_CR1_EOCIE                       ((uint32_t)0x00000020)        /*!< Interrupt enable for EOC */[m
[32m+[m[32m#define  ADC_CR1_AWDIE                       ((uint32_t)0x00000040)        /*!< Analog Watchdog interrupt enable */[m
[32m+[m[32m#define  ADC_CR1_JEOCIE                      ((uint32_t)0x00000080)        /*!< Interrupt enable for injected channels */[m
[32m+[m[32m#define  ADC_CR1_SCAN                        ((uint32_t)0x00000100)        /*!< Scan mode */[m
[32m+[m[32m#define  ADC_CR1_AWDSGL                      ((uint32_t)0x00000200)        /*!< Enable the watchdog on a single channel in scan mode */[m
[32m+[m[32m#define  ADC_CR1_JAUTO                       ((uint32_t)0x00000400)        /*!< Automatic injected group conversion */[m
[32m+[m[32m#define  ADC_CR1_DISCEN                      ((uint32_t)0x00000800)        /*!< Discontinuous mode on regular channels */[m
[32m+[m[32m#define  ADC_CR1_JDISCEN                     ((uint32_t)0x00001000)        /*!< Discontinuous mode on injected channels */[m
[32m+[m
[32m+[m[32m#define  ADC_CR1_DISCNUM                     ((uint32_t)0x0000E000)        /*!< DISCNUM[2:0] bits (Discontinuous mode channel count) */[m
[32m+[m[32m#define  ADC_CR1_DISCNUM_0                   ((uint32_t)0x00002000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_CR1_DISCNUM_1                   ((uint32_t)0x00004000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_CR1_DISCNUM_2                   ((uint32_t)0x00008000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_CR1_DUALMOD                     ((uint32_t)0x000F0000)        /*!< DUALMOD[3:0] bits (Dual mode selection) */[m
[32m+[m[32m#define  ADC_CR1_DUALMOD_0                   ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_CR1_DUALMOD_1                   ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_CR1_DUALMOD_2                   ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_CR1_DUALMOD_3                   ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  ADC_CR1_JAWDEN                      ((uint32_t)0x00400000)        /*!< Analog watchdog enable on injected channels */[m
[32m+[m[32m#define  ADC_CR1_AWDEN                       ((uint32_t)0x00800000)        /*!< Analog watchdog enable on regular channels */[m
[32m+[m
[32m+[m[41m  [m
[32m+[m[32m/*******************  Bit definition for ADC_CR2 register  ********************/[m
[32m+[m[32m#define  ADC_CR2_ADON                        ((uint32_t)0x00000001)        /*!< A/D Converter ON / OFF */[m
[32m+[m[32m#define  ADC_CR2_CONT                        ((uint32_t)0x00000002)        /*!< Continuous Conversion */[m
[32m+[m[32m#define  ADC_CR2_CAL                         ((uint32_t)0x00000004)        /*!< A/D Calibration */[m
[32m+[m[32m#define  ADC_CR2_RSTCAL                      ((uint32_t)0x00000008)        /*!< Reset Calibration */[m
[32m+[m[32m#define  ADC_CR2_DMA                         ((uint32_t)0x00000100)        /*!< Direct Memory access mode */[m
[32m+[m[32m#define  ADC_CR2_ALIGN                       ((uint32_t)0x00000800)        /*!< Data Alignment */[m
[32m+[m
[32m+[m[32m#define  ADC_CR2_JEXTSEL                     ((uint32_t)0x00007000)        /*!< JEXTSEL[2:0] bits (External event select for injected group) */[m
[32m+[m[32m#define  ADC_CR2_JEXTSEL_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_CR2_JEXTSEL_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_CR2_JEXTSEL_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_CR2_JEXTTRIG                    ((uint32_t)0x00008000)        /*!< External Trigger Conversion mode for injected channels */[m
[32m+[m
[32m+[m[32m#define  ADC_CR2_EXTSEL                      ((uint32_t)0x000E0000)        /*!< EXTSEL[2:0] bits (External Event Select for regular group) */[m
[32m+[m[32m#define  ADC_CR2_EXTSEL_0                    ((uint32_t)0x00020000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_CR2_EXTSEL_1                    ((uint32_t)0x00040000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_CR2_EXTSEL_2                    ((uint32_t)0x00080000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_CR2_EXTTRIG                     ((uint32_t)0x00100000)        /*!< External Trigger Conversion mode for regular channels */[m
[32m+[m[32m#define  ADC_CR2_JSWSTART                    ((uint32_t)0x00200000)        /*!< Start Conversion of injected channels */[m
[32m+[m[32m#define  ADC_CR2_SWSTART                     ((uint32_t)0x00400000)        /*!< Start Conversion of regular channels */[m
[32m+[m[32m#define  ADC_CR2_TSVREFE                     ((uint32_t)0x00800000)        /*!< Temperature Sensor and VREFINT Enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for ADC_SMPR1 register  *******************/[m
[32m+[m[32m#define  ADC_SMPR1_SMP10                     ((uint32_t)0x00000007)        /*!< SMP10[2:0] bits (Channel 10 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP10_0                   ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP10_1                   ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP10_2                   ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP11                     ((uint32_t)0x00000038)        /*!< SMP11[2:0] bits (Channel 11 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP11_0                   ((uint32_t)0x00000008)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP11_1                   ((uint32_t)0x00000010)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP11_2                   ((uint32_t)0x00000020)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP12                     ((uint32_t)0x000001C0)        /*!< SMP12[2:0] bits (Channel 12 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP12_0                   ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP12_1                   ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP12_2                   ((uint32_t)0x00000100)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP13                     ((uint32_t)0x00000E00)        /*!< SMP13[2:0] bits (Channel 13 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP13_0                   ((uint32_t)0x00000200)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP13_1                   ((uint32_t)0x00000400)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP13_2                   ((uint32_t)0x00000800)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP14                     ((uint32_t)0x00007000)        /*!< SMP14[2:0] bits (Channel 14 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP14_0                   ((uint32_t)0x00001000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP14_1                   ((uint32_t)0x00002000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP14_2                   ((uint32_t)0x00004000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP15                     ((uint32_t)0x00038000)        /*!< SMP15[2:0] bits (Channel 15 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP15_0                   ((uint32_t)0x00008000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP15_1                   ((uint32_t)0x00010000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP15_2                   ((uint32_t)0x00020000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP16                     ((uint32_t)0x001C0000)        /*!< SMP16[2:0] bits (Channel 16 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP16_0                   ((uint32_t)0x00040000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP16_1                   ((uint32_t)0x00080000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP16_2                   ((uint32_t)0x00100000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR1_SMP17                     ((uint32_t)0x00E00000)        /*!< SMP17[2:0] bits (Channel 17 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR1_SMP17_0                   ((uint32_t)0x00200000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP17_1                   ((uint32_t)0x00400000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR1_SMP17_2                   ((uint32_t)0x00800000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for ADC_SMPR2 register  *******************/[m
[32m+[m[32m#define  ADC_SMPR2_SMP0                      ((uint32_t)0x00000007)        /*!< SMP0[2:0] bits (Channel 0 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP0_0                    ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP0_1                    ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP0_2                    ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP1                      ((uint32_t)0x00000038)        /*!< SMP1[2:0] bits (Channel 1 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP1_0                    ((uint32_t)0x00000008)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP1_1                    ((uint32_t)0x00000010)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP1_2                    ((uint32_t)0x00000020)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP2                      ((uint32_t)0x000001C0)        /*!< SMP2[2:0] bits (Channel 2 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP2_0                    ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP2_1                    ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP2_2                    ((uint32_t)0x00000100)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP3                      ((uint32_t)0x00000E00)        /*!< SMP3[2:0] bits (Channel 3 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP3_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP3_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP3_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP4                      ((uint32_t)0x00007000)        /*!< SMP4[2:0] bits (Channel 4 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP4_0                    ((uint32_t)0x00001000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP4_1                    ((uint32_t)0x00002000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP4_2                    ((uint32_t)0x00004000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP5                      ((uint32_t)0x00038000)        /*!< SMP5[2:0] bits (Channel 5 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP5_0                    ((uint32_t)0x00008000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP5_1                    ((uint32_t)0x00010000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP5_2                    ((uint32_t)0x00020000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP6                      ((uint32_t)0x001C0000)        /*!< SMP6[2:0] bits (Channel 6 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP6_0                    ((uint32_t)0x00040000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP6_1                    ((uint32_t)0x00080000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP6_2                    ((uint32_t)0x00100000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP7                      ((uint32_t)0x00E00000)        /*!< SMP7[2:0] bits (Channel 7 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP7_0                    ((uint32_t)0x00200000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP7_1                    ((uint32_t)0x00400000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP7_2                    ((uint32_t)0x00800000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP8                      ((uint32_t)0x07000000)        /*!< SMP8[2:0] bits (Channel 8 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP8_0                    ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP8_1                    ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP8_2                    ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  ADC_SMPR2_SMP9                      ((uint32_t)0x38000000)        /*!< SMP9[2:0] bits (Channel 9 Sample time selection) */[m
[32m+[m[32m#define  ADC_SMPR2_SMP9_0                    ((uint32_t)0x08000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP9_1                    ((uint32_t)0x10000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SMPR2_SMP9_2                    ((uint32_t)0x20000000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for ADC_JOFR1 register  *******************/[m
[32m+[m[32m#define  ADC_JOFR1_JOFFSET1                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for ADC_JOFR2 register  *******************/[m
[32m+[m[32m#define  ADC_JOFR2_JOFFSET2                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 2 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for ADC_JOFR3 register  *******************/[m
[32m+[m[32m#define  ADC_JOFR3_JOFFSET3                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 3 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for ADC_JOFR4 register  *******************/[m
[32m+[m[32m#define  ADC_JOFR4_JOFFSET4                  ((uint16_t)0x0FFF)            /*!< Data offset for injected channel 4 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_HTR register  ********************/[m
[32m+[m[32m#define  ADC_HTR_HT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog high threshold */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_LTR register  ********************/[m
[32m+[m[32m#define  ADC_LTR_LT                          ((uint16_t)0x0FFF)            /*!< Analog watchdog low threshold */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_SQR1 register  *******************/[m
[32m+[m[32m#define  ADC_SQR1_SQ13                       ((uint32_t)0x0000001F)        /*!< SQ13[4:0] bits (13th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR1_SQ13_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR1_SQ13_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR1_SQ13_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR1_SQ13_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR1_SQ13_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR1_SQ14                       ((uint32_t)0x000003E0)        /*!< SQ14[4:0] bits (14th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR1_SQ14_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR1_SQ14_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR1_SQ14_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR1_SQ14_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR1_SQ14_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR1_SQ15                       ((uint32_t)0x00007C00)        /*!< SQ15[4:0] bits (15th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR1_SQ15_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR1_SQ15_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR1_SQ15_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR1_SQ15_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR1_SQ15_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR1_SQ16                       ((uint32_t)0x000F8000)        /*!< SQ16[4:0] bits (16th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR1_SQ16_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR1_SQ16_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR1_SQ16_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR1_SQ16_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR1_SQ16_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR1_L                          ((uint32_t)0x00F00000)        /*!< L[3:0] bits (Regular channel sequence length) */[m
[32m+[m[32m#define  ADC_SQR1_L_0                        ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR1_L_1                        ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR1_L_2                        ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR1_L_3                        ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_SQR2 register  *******************/[m
[32m+[m[32m#define  ADC_SQR2_SQ7                        ((uint32_t)0x0000001F)        /*!< SQ7[4:0] bits (7th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR2_SQ7_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR2_SQ7_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR2_SQ7_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR2_SQ7_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR2_SQ7_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR2_SQ8                        ((uint32_t)0x000003E0)        /*!< SQ8[4:0] bits (8th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR2_SQ8_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR2_SQ8_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR2_SQ8_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR2_SQ8_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR2_SQ8_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR2_SQ9                        ((uint32_t)0x00007C00)        /*!< SQ9[4:0] bits (9th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR2_SQ9_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR2_SQ9_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR2_SQ9_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR2_SQ9_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR2_SQ9_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR2_SQ10                       ((uint32_t)0x000F8000)        /*!< SQ10[4:0] bits (10th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR2_SQ10_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR2_SQ10_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR2_SQ10_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR2_SQ10_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR2_SQ10_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR2_SQ11                       ((uint32_t)0x01F00000)        /*!< SQ11[4:0] bits (11th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR2_SQ11_0                     ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR2_SQ11_1                     ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR2_SQ11_2                     ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR2_SQ11_3                     ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR2_SQ11_4                     ((uint32_t)0x01000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR2_SQ12                       ((uint32_t)0x3E000000)        /*!< SQ12[4:0] bits (12th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR2_SQ12_0                     ((uint32_t)0x02000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR2_SQ12_1                     ((uint32_t)0x04000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR2_SQ12_2                     ((uint32_t)0x08000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR2_SQ12_3                     ((uint32_t)0x10000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR2_SQ12_4                     ((uint32_t)0x20000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_SQR3 register  *******************/[m
[32m+[m[32m#define  ADC_SQR3_SQ1                        ((uint32_t)0x0000001F)        /*!< SQ1[4:0] bits (1st conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR3_SQ1_0                      ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR3_SQ1_1                      ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR3_SQ1_2                      ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR3_SQ1_3                      ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR3_SQ1_4                      ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR3_SQ2                        ((uint32_t)0x000003E0)        /*!< SQ2[4:0] bits (2nd conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR3_SQ2_0                      ((uint32_t)0x00000020)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR3_SQ2_1                      ((uint32_t)0x00000040)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR3_SQ2_2                      ((uint32_t)0x00000080)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR3_SQ2_3                      ((uint32_t)0x00000100)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR3_SQ2_4                      ((uint32_t)0x00000200)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR3_SQ3                        ((uint32_t)0x00007C00)        /*!< SQ3[4:0] bits (3rd conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR3_SQ3_0                      ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR3_SQ3_1                      ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR3_SQ3_2                      ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR3_SQ3_3                      ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR3_SQ3_4                      ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR3_SQ4                        ((uint32_t)0x000F8000)        /*!< SQ4[4:0] bits (4th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR3_SQ4_0                      ((uint32_t)0x00008000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR3_SQ4_1                      ((uint32_t)0x00010000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR3_SQ4_2                      ((uint32_t)0x00020000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR3_SQ4_3                      ((uint32_t)0x00040000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR3_SQ4_4                      ((uint32_t)0x00080000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR3_SQ5                        ((uint32_t)0x01F00000)        /*!< SQ5[4:0] bits (5th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR3_SQ5_0                      ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR3_SQ5_1                      ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR3_SQ5_2                      ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR3_SQ5_3                      ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR3_SQ5_4                      ((uint32_t)0x01000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_SQR3_SQ6                        ((uint32_t)0x3E000000)        /*!< SQ6[4:0] bits (6th conversion in regular sequence) */[m
[32m+[m[32m#define  ADC_SQR3_SQ6_0                      ((uint32_t)0x02000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_SQR3_SQ6_1                      ((uint32_t)0x04000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_SQR3_SQ6_2                      ((uint32_t)0x08000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_SQR3_SQ6_3                      ((uint32_t)0x10000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_SQR3_SQ6_4                      ((uint32_t)0x20000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_JSQR register  *******************/[m
[32m+[m[32m#define  ADC_JSQR_JSQ1                       ((uint32_t)0x0000001F)        /*!< JSQ1[4:0] bits (1st conversion in injected sequence) */[m[41m  [m
[32m+[m[32m#define  ADC_JSQR_JSQ1_0                     ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ1_1                     ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ1_2                     ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ1_3                     ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ1_4                     ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_JSQR_JSQ2                       ((uint32_t)0x000003E0)        /*!< JSQ2[4:0] bits (2nd conversion in injected sequence) */[m
[32m+[m[32m#define  ADC_JSQR_JSQ2_0                     ((uint32_t)0x00000020)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ2_1                     ((uint32_t)0x00000040)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ2_2                     ((uint32_t)0x00000080)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ2_3                     ((uint32_t)0x00000100)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ2_4                     ((uint32_t)0x00000200)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_JSQR_JSQ3                       ((uint32_t)0x00007C00)        /*!< JSQ3[4:0] bits (3rd conversion in injected sequence) */[m
[32m+[m[32m#define  ADC_JSQR_JSQ3_0                     ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ3_1                     ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ3_2                     ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ3_3                     ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ3_4                     ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_JSQR_JSQ4                       ((uint32_t)0x000F8000)        /*!< JSQ4[4:0] bits (4th conversion in injected sequence) */[m
[32m+[m[32m#define  ADC_JSQR_JSQ4_0                     ((uint32_t)0x00008000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ4_1                     ((uint32_t)0x00010000)        /*!< Bit 1 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ4_2                     ((uint32_t)0x00020000)        /*!< Bit 2 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ4_3                     ((uint32_t)0x00040000)        /*!< Bit 3 */[m
[32m+[m[32m#define  ADC_JSQR_JSQ4_4                     ((uint32_t)0x00080000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  ADC_JSQR_JL                         ((uint32_t)0x00300000)        /*!< JL[1:0] bits (Injected Sequence length) */[m
[32m+[m[32m#define  ADC_JSQR_JL_0                       ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  ADC_JSQR_JL_1                       ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_JDR1 register  *******************/[m
[32m+[m[32m#define  ADC_JDR1_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_JDR2 register  *******************/[m
[32m+[m[32m#define  ADC_JDR2_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_JDR3 register  *******************/[m
[32m+[m[32m#define  ADC_JDR3_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for ADC_JDR4 register  *******************/[m
[32m+[m[32m#define  ADC_JDR4_JDATA                      ((uint16_t)0xFFFF)            /*!< Injected data */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for ADC_DR register  ********************/[m
[32m+[m[32m#define  ADC_DR_DATA                         ((uint32_t)0x0000FFFF)        /*!< Regular data */[m
[32m+[m[32m#define  ADC_DR_ADC2DATA                     ((uint32_t)0xFFFF0000)        /*!< ADC2 data */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                      Digital to Analog Converter                           */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/********************  Bit definition for DAC_CR register  ********************/[m
[32m+[m[32m#define  DAC_CR_EN1                          ((uint32_t)0x00000001)        /*!< DAC channel1 enable */[m
[32m+[m[32m#define  DAC_CR_BOFF1                        ((uint32_t)0x00000002)        /*!< DAC channel1 output buffer disable */[m
[32m+[m[32m#define  DAC_CR_TEN1                         ((uint32_t)0x00000004)        /*!< DAC channel1 Trigger enable */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_TSEL1                        ((uint32_t)0x00000038)        /*!< TSEL1[2:0] (DAC channel1 Trigger selection) */[m
[32m+[m[32m#define  DAC_CR_TSEL1_0                      ((uint32_t)0x00000008)        /*!< Bit 0 */[m
[32m+[m[32m#define  DAC_CR_TSEL1_1                      ((uint32_t)0x00000010)        /*!< Bit 1 */[m
[32m+[m[32m#define  DAC_CR_TSEL1_2                      ((uint32_t)0x00000020)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_WAVE1                        ((uint32_t)0x000000C0)        /*!< WAVE1[1:0] (DAC channel1 noise/triangle wave generation enable) */[m
[32m+[m[32m#define  DAC_CR_WAVE1_0                      ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define  DAC_CR_WAVE1_1                      ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_MAMP1                        ((uint32_t)0x00000F00)        /*!< MAMP1[3:0] (DAC channel1 Mask/Amplitude selector) */[m
[32m+[m[32m#define  DAC_CR_MAMP1_0                      ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  DAC_CR_MAMP1_1                      ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  DAC_CR_MAMP1_2                      ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  DAC_CR_MAMP1_3                      ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_DMAEN1                       ((uint32_t)0x00001000)        /*!< DAC channel1 DMA enable */[m
[32m+[m[32m#define  DAC_CR_EN2                          ((uint32_t)0x00010000)        /*!< DAC channel2 enable */[m
[32m+[m[32m#define  DAC_CR_BOFF2                        ((uint32_t)0x00020000)        /*!< DAC channel2 output buffer disable */[m
[32m+[m[32m#define  DAC_CR_TEN2                         ((uint32_t)0x00040000)        /*!< DAC channel2 Trigger enable */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_TSEL2                        ((uint32_t)0x00380000)        /*!< TSEL2[2:0] (DAC channel2 Trigger selection) */[m
[32m+[m[32m#define  DAC_CR_TSEL2_0                      ((uint32_t)0x00080000)        /*!< Bit 0 */[m
[32m+[m[32m#define  DAC_CR_TSEL2_1                      ((uint32_t)0x00100000)        /*!< Bit 1 */[m
[32m+[m[32m#define  DAC_CR_TSEL2_2                      ((uint32_t)0x00200000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_WAVE2                        ((uint32_t)0x00C00000)        /*!< WAVE2[1:0] (DAC channel2 noise/triangle wave generation enable) */[m
[32m+[m[32m#define  DAC_CR_WAVE2_0                      ((uint32_t)0x00400000)        /*!< Bit 0 */[m
[32m+[m[32m#define  DAC_CR_WAVE2_1                      ((uint32_t)0x00800000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_MAMP2                        ((uint32_t)0x0F000000)        /*!< MAMP2[3:0] (DAC channel2 Mask/Amplitude selector) */[m
[32m+[m[32m#define  DAC_CR_MAMP2_0                      ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  DAC_CR_MAMP2_1                      ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  DAC_CR_MAMP2_2                      ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  DAC_CR_MAMP2_3                      ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  DAC_CR_DMAEN2                       ((uint32_t)0x10000000)        /*!< DAC channel2 DMA enabled */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_SWTRIGR register  ******************/[m
[32m+[m[32m#define  DAC_SWTRIGR_SWTRIG1                 ((uint8_t)0x01)               /*!< DAC channel1 software trigger */[m
[32m+[m[32m#define  DAC_SWTRIGR_SWTRIG2                 ((uint8_t)0x02)               /*!< DAC channel2 software trigger */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_DHR12R1 register  ******************/[m
[32m+[m[32m#define  DAC_DHR12R1_DACC1DHR                ((uint16_t)0x0FFF)            /*!< DAC channel1 12-bit Right aligned data */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_DHR12L1 register  ******************/[m
[32m+[m[32m#define  DAC_DHR12L1_DACC1DHR                ((uint16_t)0xFFF0)            /*!< DAC channel1 12-bit Left aligned data */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DAC_DHR8R1 register  ******************/[m
[32m+[m[32m#define  DAC_DHR8R1_DACC1DHR                 ((uint8_t)0xFF)               /*!< DAC channel1 8-bit Right aligned data */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_DHR12R2 register  ******************/[m
[32m+[m[32m#define  DAC_DHR12R2_DACC2DHR                ((uint16_t)0x0FFF)            /*!< DAC channel2 12-bit Right aligned data */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_DHR12L2 register  ******************/[m
[32m+[m[32m#define  DAC_DHR12L2_DACC2DHR                ((uint16_t)0xFFF0)            /*!< DAC channel2 12-bit Left aligned data */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DAC_DHR8R2 register  ******************/[m
[32m+[m[32m#define  DAC_DHR8R2_DACC2DHR                 ((uint8_t)0xFF)               /*!< DAC channel2 8-bit Right aligned data */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_DHR12RD register  ******************/[m
[32m+[m[32m#define  DAC_DHR12RD_DACC1DHR                ((uint32_t)0x00000FFF)        /*!< DAC channel1 12-bit Right aligned data */[m
[32m+[m[32m#define  DAC_DHR12RD_DACC2DHR                ((uint32_t)0x0FFF0000)        /*!< DAC channel2 12-bit Right aligned data */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for DAC_DHR12LD register  ******************/[m
[32m+[m[32m#define  DAC_DHR12LD_DACC1DHR                ((uint32_t)0x0000FFF0)        /*!< DAC channel1 12-bit Left aligned data */[m
[32m+[m[32m#define  DAC_DHR12LD_DACC2DHR                ((uint32_t)0xFFF00000)        /*!< DAC channel2 12-bit Left aligned data */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DAC_DHR8RD register  ******************/[m
[32m+[m[32m#define  DAC_DHR8RD_DACC1DHR                 ((uint16_t)0x00FF)            /*!< DAC channel1 8-bit Right aligned data */[m
[32m+[m[32m#define  DAC_DHR8RD_DACC2DHR                 ((uint16_t)0xFF00)            /*!< DAC channel2 8-bit Right aligned data */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DAC_DOR1 register  *******************/[m
[32m+[m[32m#define  DAC_DOR1_DACC1DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel1 data output */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for DAC_DOR2 register  *******************/[m
[32m+[m[32m#define  DAC_DOR2_DACC2DOR                   ((uint16_t)0x0FFF)            /*!< DAC channel2 data output */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for DAC_SR register  ********************/[m
[32m+[m[32m#define  DAC_SR_DMAUDR1                      ((uint32_t)0x00002000)        /*!< DAC channel1 DMA underrun flag */[m
[32m+[m[32m#define  DAC_SR_DMAUDR2                      ((uint32_t)0x20000000)        /*!< DAC channel2 DMA underrun flag */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                                    CEC                                     */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/********************  Bit definition for CEC_CFGR register  ******************/[m
[32m+[m[32m#define  CEC_CFGR_PE              ((uint16_t)0x0001)     /*!<  Peripheral Enable */[m
[32m+[m[32m#define  CEC_CFGR_IE              ((uint16_t)0x0002)     /*!<  Interrupt Enable */[m
[32m+[m[32m#define  CEC_CFGR_BTEM            ((uint16_t)0x0004)     /*!<  Bit Timing Error Mode */[m
[32m+[m[32m#define  CEC_CFGR_BPEM            ((uint16_t)0x0008)     /*!<  Bit Period Error Mode */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CEC_OAR register  ******************/[m
[32m+[m[32m#define  CEC_OAR_OA               ((uint16_t)0x000F)     /*!<  OA[3:0]: Own Address */[m
[32m+[m[32m#define  CEC_OAR_OA_0             ((uint16_t)0x0001)     /*!<  Bit 0 */[m
[32m+[m[32m#define  CEC_OAR_OA_1             ((uint16_t)0x0002)     /*!<  Bit 1 */[m
[32m+[m[32m#define  CEC_OAR_OA_2             ((uint16_t)0x0004)     /*!<  Bit 2 */[m
[32m+[m[32m#define  CEC_OAR_OA_3             ((uint16_t)0x0008)     /*!<  Bit 3 */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CEC_PRES register  ******************/[m
[32m+[m[32m#define  CEC_PRES_PRES            ((uint16_t)0x3FFF)   /*!<  Prescaler Counter Value */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CEC_ESR register  ******************/[m
[32m+[m[32m#define  CEC_ESR_BTE              ((uint16_t)0x0001)     /*!<  Bit Timing Error */[m
[32m+[m[32m#define  CEC_ESR_BPE              ((uint16_t)0x0002)     /*!<  Bit Period Error */[m
[32m+[m[32m#define  CEC_ESR_RBTFE            ((uint16_t)0x0004)     /*!<  Rx Block Transfer Finished Error */[m
[32m+[m[32m#define  CEC_ESR_SBE              ((uint16_t)0x0008)     /*!<  Start Bit Error */[m
[32m+[m[32m#define  CEC_ESR_ACKE             ((uint16_t)0x0010)     /*!<  Block Acknowledge Error */[m
[32m+[m[32m#define  CEC_ESR_LINE             ((uint16_t)0x0020)     /*!<  Line Error */[m
[32m+[m[32m#define  CEC_ESR_TBTFE            ((uint16_t)0x0040)     /*!<  Tx Block Transfer Finished Error */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CEC_CSR register  ******************/[m
[32m+[m[32m#define  CEC_CSR_TSOM             ((uint16_t)0x0001)     /*!<  Tx Start Of Message */[m
[32m+[m[32m#define  CEC_CSR_TEOM             ((uint16_t)0x0002)     /*!<  Tx End Of Message */[m
[32m+[m[32m#define  CEC_CSR_TERR             ((uint16_t)0x0004)     /*!<  Tx Error */[m
[32m+[m[32m#define  CEC_CSR_TBTRF            ((uint16_t)0x0008)     /*!<  Tx Byte Transfer Request or Block Transfer Finished */[m
[32m+[m[32m#define  CEC_CSR_RSOM             ((uint16_t)0x0010)     /*!<  Rx Start Of Message */[m
[32m+[m[32m#define  CEC_CSR_REOM             ((uint16_t)0x0020)     /*!<  Rx End Of Message */[m
[32m+[m[32m#define  CEC_CSR_RERR             ((uint16_t)0x0040)     /*!<  Rx Error */[m
[32m+[m[32m#define  CEC_CSR_RBTF             ((uint16_t)0x0080)     /*!<  Rx Block Transfer Finished */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CEC_TXD register  ******************/[m
[32m+[m[32m#define  CEC_TXD_TXD              ((uint16_t)0x00FF)     /*!<  Tx Data register */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CEC_RXD register  ******************/[m
[32m+[m[32m#define  CEC_RXD_RXD              ((uint16_t)0x00FF)     /*!<  Rx Data register */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                                    TIM                                     */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CR1 register  ********************/[m
[32m+[m[32m#define  TIM_CR1_CEN                         ((uint16_t)0x0001)            /*!< Counter enable */[m
[32m+[m[32m#define  TIM_CR1_UDIS                        ((uint16_t)0x0002)            /*!< Update disable */[m
[32m+[m[32m#define  TIM_CR1_URS                         ((uint16_t)0x0004)            /*!< Update request source */[m
[32m+[m[32m#define  TIM_CR1_OPM                         ((uint16_t)0x0008)            /*!< One pulse mode */[m
[32m+[m[32m#define  TIM_CR1_DIR                         ((uint16_t)0x0010)            /*!< Direction */[m
[32m+[m
[32m+[m[32m#define  TIM_CR1_CMS                         ((uint16_t)0x0060)            /*!< CMS[1:0] bits (Center-aligned mode selection) */[m
[32m+[m[32m#define  TIM_CR1_CMS_0                       ((uint16_t)0x0020)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CR1_CMS_1                       ((uint16_t)0x0040)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CR1_ARPE                        ((uint16_t)0x0080)            /*!< Auto-reload preload enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CR1_CKD                         ((uint16_t)0x0300)            /*!< CKD[1:0] bits (clock division) */[m
[32m+[m[32m#define  TIM_CR1_CKD_0                       ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CR1_CKD_1                       ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CR2 register  ********************/[m
[32m+[m[32m#define  TIM_CR2_CCPC                        ((uint16_t)0x0001)            /*!< Capture/Compare Preloaded Control */[m
[32m+[m[32m#define  TIM_CR2_CCUS                        ((uint16_t)0x0004)            /*!< Capture/Compare Control Update Selection */[m
[32m+[m[32m#define  TIM_CR2_CCDS                        ((uint16_t)0x0008)            /*!< Capture/Compare DMA Selection */[m
[32m+[m
[32m+[m[32m#define  TIM_CR2_MMS                         ((uint16_t)0x0070)            /*!< MMS[2:0] bits (Master Mode Selection) */[m
[32m+[m[32m#define  TIM_CR2_MMS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CR2_MMS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CR2_MMS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_CR2_TI1S                        ((uint16_t)0x0080)            /*!< TI1 Selection */[m
[32m+[m[32m#define  TIM_CR2_OIS1                        ((uint16_t)0x0100)            /*!< Output Idle state 1 (OC1 output) */[m
[32m+[m[32m#define  TIM_CR2_OIS1N                       ((uint16_t)0x0200)            /*!< Output Idle state 1 (OC1N output) */[m
[32m+[m[32m#define  TIM_CR2_OIS2                        ((uint16_t)0x0400)            /*!< Output Idle state 2 (OC2 output) */[m
[32m+[m[32m#define  TIM_CR2_OIS2N                       ((uint16_t)0x0800)            /*!< Output Idle state 2 (OC2N output) */[m
[32m+[m[32m#define  TIM_CR2_OIS3                        ((uint16_t)0x1000)            /*!< Output Idle state 3 (OC3 output) */[m
[32m+[m[32m#define  TIM_CR2_OIS3N                       ((uint16_t)0x2000)            /*!< Output Idle state 3 (OC3N output) */[m
[32m+[m[32m#define  TIM_CR2_OIS4                        ((uint16_t)0x4000)            /*!< Output Idle state 4 (OC4 output) */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_SMCR register  *******************/[m
[32m+[m[32m#define  TIM_SMCR_SMS                        ((uint16_t)0x0007)            /*!< SMS[2:0] bits (Slave mode selection) */[m
[32m+[m[32m#define  TIM_SMCR_SMS_0                      ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_SMCR_SMS_1                      ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_SMCR_SMS_2                      ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_SMCR_TS                         ((uint16_t)0x0070)            /*!< TS[2:0] bits (Trigger selection) */[m
[32m+[m[32m#define  TIM_SMCR_TS_0                       ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_SMCR_TS_1                       ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_SMCR_TS_2                       ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_SMCR_MSM                        ((uint16_t)0x0080)            /*!< Master/slave mode */[m
[32m+[m
[32m+[m[32m#define  TIM_SMCR_ETF                        ((uint16_t)0x0F00)            /*!< ETF[3:0] bits (External trigger filter) */[m
[32m+[m[32m#define  TIM_SMCR_ETF_0                      ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_SMCR_ETF_1                      ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_SMCR_ETF_2                      ((uint16_t)0x0400)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_SMCR_ETF_3                      ((uint16_t)0x0800)            /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  TIM_SMCR_ETPS                       ((uint16_t)0x3000)            /*!< ETPS[1:0] bits (External trigger prescaler) */[m
[32m+[m[32m#define  TIM_SMCR_ETPS_0                     ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_SMCR_ETPS_1                     ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_SMCR_ECE                        ((uint16_t)0x4000)            /*!< External clock enable */[m
[32m+[m[32m#define  TIM_SMCR_ETP                        ((uint16_t)0x8000)            /*!< External trigger polarity */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_DIER register  *******************/[m
[32m+[m[32m#define  TIM_DIER_UIE                        ((uint16_t)0x0001)            /*!< Update interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_CC1IE                      ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_CC2IE                      ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_CC3IE                      ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_CC4IE                      ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_COMIE                      ((uint16_t)0x0020)            /*!< COM interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_TIE                        ((uint16_t)0x0040)            /*!< Trigger interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_BIE                        ((uint16_t)0x0080)            /*!< Break interrupt enable */[m
[32m+[m[32m#define  TIM_DIER_UDE                        ((uint16_t)0x0100)            /*!< Update DMA request enable */[m
[32m+[m[32m#define  TIM_DIER_CC1DE                      ((uint16_t)0x0200)            /*!< Capture/Compare 1 DMA request enable */[m
[32m+[m[32m#define  TIM_DIER_CC2DE                      ((uint16_t)0x0400)            /*!< Capture/Compare 2 DMA request enable */[m
[32m+[m[32m#define  TIM_DIER_CC3DE                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 DMA request enable */[m
[32m+[m[32m#define  TIM_DIER_CC4DE                      ((uint16_t)0x1000)            /*!< Capture/Compare 4 DMA request enable */[m
[32m+[m[32m#define  TIM_DIER_COMDE                      ((uint16_t)0x2000)            /*!< COM DMA request enable */[m
[32m+[m[32m#define  TIM_DIER_TDE                        ((uint16_t)0x4000)            /*!< Trigger DMA request enable */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for TIM_SR register  ********************/[m
[32m+[m[32m#define  TIM_SR_UIF                          ((uint16_t)0x0001)            /*!< Update interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_CC1IF                        ((uint16_t)0x0002)            /*!< Capture/Compare 1 interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_CC2IF                        ((uint16_t)0x0004)            /*!< Capture/Compare 2 interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_CC3IF                        ((uint16_t)0x0008)            /*!< Capture/Compare 3 interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_CC4IF                        ((uint16_t)0x0010)            /*!< Capture/Compare 4 interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_COMIF                        ((uint16_t)0x0020)            /*!< COM interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_TIF                          ((uint16_t)0x0040)            /*!< Trigger interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_BIF                          ((uint16_t)0x0080)            /*!< Break interrupt Flag */[m
[32m+[m[32m#define  TIM_SR_CC1OF                        ((uint16_t)0x0200)            /*!< Capture/Compare 1 Overcapture Flag */[m
[32m+[m[32m#define  TIM_SR_CC2OF                        ((uint16_t)0x0400)            /*!< Capture/Compare 2 Overcapture Flag */[m
[32m+[m[32m#define  TIM_SR_CC3OF                        ((uint16_t)0x0800)            /*!< Capture/Compare 3 Overcapture Flag */[m
[32m+[m[32m#define  TIM_SR_CC4OF                        ((uint16_t)0x1000)            /*!< Capture/Compare 4 Overcapture Flag */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_EGR register  ********************/[m
[32m+[m[32m#define  TIM_EGR_UG                          ((uint8_t)0x01)               /*!< Update Generation */[m
[32m+[m[32m#define  TIM_EGR_CC1G                        ((uint8_t)0x02)               /*!< Capture/Compare 1 Generation */[m
[32m+[m[32m#define  TIM_EGR_CC2G                        ((uint8_t)0x04)               /*!< Capture/Compare 2 Generation */[m
[32m+[m[32m#define  TIM_EGR_CC3G                        ((uint8_t)0x08)               /*!< Capture/Compare 3 Generation */[m
[32m+[m[32m#define  TIM_EGR_CC4G                        ((uint8_t)0x10)               /*!< Capture/Compare 4 Generation */[m
[32m+[m[32m#define  TIM_EGR_COMG                        ((uint8_t)0x20)               /*!< Capture/Compare Control Update Generation */[m
[32m+[m[32m#define  TIM_EGR_TG                          ((uint8_t)0x40)               /*!< Trigger Generation */[m
[32m+[m[32m#define  TIM_EGR_BG                          ((uint8_t)0x80)               /*!< Break Generation */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for TIM_CCMR1 register  *******************/[m
[32m+[m[32m#define  TIM_CCMR1_CC1S                      ((uint16_t)0x0003)            /*!< CC1S[1:0] bits (Capture/Compare 1 Selection) */[m
[32m+[m[32m#define  TIM_CCMR1_CC1S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_CC1S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_OC1FE                     ((uint16_t)0x0004)            /*!< Output Compare 1 Fast enable */[m
[32m+[m[32m#define  TIM_CCMR1_OC1PE                     ((uint16_t)0x0008)            /*!< Output Compare 1 Preload enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_OC1M                      ((uint16_t)0x0070)            /*!< OC1M[2:0] bits (Output Compare 1 Mode) */[m
[32m+[m[32m#define  TIM_CCMR1_OC1M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_OC1M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR1_OC1M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_OC1CE                     ((uint16_t)0x0080)            /*!< Output Compare 1Clear Enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_CC2S                      ((uint16_t)0x0300)            /*!< CC2S[1:0] bits (Capture/Compare 2 Selection) */[m
[32m+[m[32m#define  TIM_CCMR1_CC2S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_CC2S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_OC2FE                     ((uint16_t)0x0400)            /*!< Output Compare 2 Fast enable */[m
[32m+[m[32m#define  TIM_CCMR1_OC2PE                     ((uint16_t)0x0800)            /*!< Output Compare 2 Preload enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_OC2M                      ((uint16_t)0x7000)            /*!< OC2M[2:0] bits (Output Compare 2 Mode) */[m
[32m+[m[32m#define  TIM_CCMR1_OC2M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_OC2M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR1_OC2M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_OC2CE                     ((uint16_t)0x8000)            /*!< Output Compare 2 Clear Enable */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_IC1PSC                    ((uint16_t)0x000C)            /*!< IC1PSC[1:0] bits (Input Capture 1 Prescaler) */[m
[32m+[m[32m#define  TIM_CCMR1_IC1PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_IC1PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_IC1F                      ((uint16_t)0x00F0)            /*!< IC1F[3:0] bits (Input Capture 1 Filter) */[m
[32m+[m[32m#define  TIM_CCMR1_IC1F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_IC1F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR1_IC1F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_CCMR1_IC1F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_IC2PSC                    ((uint16_t)0x0C00)            /*!< IC2PSC[1:0] bits (Input Capture 2 Prescaler) */[m
[32m+[m[32m#define  TIM_CCMR1_IC2PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_IC2PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR1_IC2F                      ((uint16_t)0xF000)            /*!< IC2F[3:0] bits (Input Capture 2 Filter) */[m
[32m+[m[32m#define  TIM_CCMR1_IC2F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR1_IC2F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR1_IC2F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_CCMR1_IC2F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for TIM_CCMR2 register  *******************/[m
[32m+[m[32m#define  TIM_CCMR2_CC3S                      ((uint16_t)0x0003)            /*!< CC3S[1:0] bits (Capture/Compare 3 Selection) */[m
[32m+[m[32m#define  TIM_CCMR2_CC3S_0                    ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_CC3S_1                    ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_OC3FE                     ((uint16_t)0x0004)            /*!< Output Compare 3 Fast enable */[m
[32m+[m[32m#define  TIM_CCMR2_OC3PE                     ((uint16_t)0x0008)            /*!< Output Compare 3 Preload enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_OC3M                      ((uint16_t)0x0070)            /*!< OC3M[2:0] bits (Output Compare 3 Mode) */[m
[32m+[m[32m#define  TIM_CCMR2_OC3M_0                    ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_OC3M_1                    ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR2_OC3M_2                    ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_OC3CE                     ((uint16_t)0x0080)            /*!< Output Compare 3 Clear Enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_CC4S                      ((uint16_t)0x0300)            /*!< CC4S[1:0] bits (Capture/Compare 4 Selection) */[m
[32m+[m[32m#define  TIM_CCMR2_CC4S_0                    ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_CC4S_1                    ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_OC4FE                     ((uint16_t)0x0400)            /*!< Output Compare 4 Fast enable */[m
[32m+[m[32m#define  TIM_CCMR2_OC4PE                     ((uint16_t)0x0800)            /*!< Output Compare 4 Preload enable */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_OC4M                      ((uint16_t)0x7000)            /*!< OC4M[2:0] bits (Output Compare 4 Mode) */[m
[32m+[m[32m#define  TIM_CCMR2_OC4M_0                    ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_OC4M_1                    ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR2_OC4M_2                    ((uint16_t)0x4000)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_OC4CE                     ((uint16_t)0x8000)            /*!< Output Compare 4 Clear Enable */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_IC3PSC                    ((uint16_t)0x000C)            /*!< IC3PSC[1:0] bits (Input Capture 3 Prescaler) */[m
[32m+[m[32m#define  TIM_CCMR2_IC3PSC_0                  ((uint16_t)0x0004)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_IC3PSC_1                  ((uint16_t)0x0008)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_IC3F                      ((uint16_t)0x00F0)            /*!< IC3F[3:0] bits (Input Capture 3 Filter) */[m
[32m+[m[32m#define  TIM_CCMR2_IC3F_0                    ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_IC3F_1                    ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR2_IC3F_2                    ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_CCMR2_IC3F_3                    ((uint16_t)0x0080)            /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_IC4PSC                    ((uint16_t)0x0C00)            /*!< IC4PSC[1:0] bits (Input Capture 4 Prescaler) */[m
[32m+[m[32m#define  TIM_CCMR2_IC4PSC_0                  ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_IC4PSC_1                  ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_CCMR2_IC4F                      ((uint16_t)0xF000)            /*!< IC4F[3:0] bits (Input Capture 4 Filter) */[m
[32m+[m[32m#define  TIM_CCMR2_IC4F_0                    ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_CCMR2_IC4F_1                    ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_CCMR2_IC4F_2                    ((uint16_t)0x4000)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_CCMR2_IC4F_3                    ((uint16_t)0x8000)            /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CCER register  *******************/[m
[32m+[m[32m#define  TIM_CCER_CC1E                       ((uint16_t)0x0001)            /*!< Capture/Compare 1 output enable */[m
[32m+[m[32m#define  TIM_CCER_CC1P                       ((uint16_t)0x0002)            /*!< Capture/Compare 1 output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC1NE                      ((uint16_t)0x0004)            /*!< Capture/Compare 1 Complementary output enable */[m
[32m+[m[32m#define  TIM_CCER_CC1NP                      ((uint16_t)0x0008)            /*!< Capture/Compare 1 Complementary output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC2E                       ((uint16_t)0x0010)            /*!< Capture/Compare 2 output enable */[m
[32m+[m[32m#define  TIM_CCER_CC2P                       ((uint16_t)0x0020)            /*!< Capture/Compare 2 output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC2NE                      ((uint16_t)0x0040)            /*!< Capture/Compare 2 Complementary output enable */[m
[32m+[m[32m#define  TIM_CCER_CC2NP                      ((uint16_t)0x0080)            /*!< Capture/Compare 2 Complementary output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC3E                       ((uint16_t)0x0100)            /*!< Capture/Compare 3 output enable */[m
[32m+[m[32m#define  TIM_CCER_CC3P                       ((uint16_t)0x0200)            /*!< Capture/Compare 3 output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC3NE                      ((uint16_t)0x0400)            /*!< Capture/Compare 3 Complementary output enable */[m
[32m+[m[32m#define  TIM_CCER_CC3NP                      ((uint16_t)0x0800)            /*!< Capture/Compare 3 Complementary output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC4E                       ((uint16_t)0x1000)            /*!< Capture/Compare 4 output enable */[m
[32m+[m[32m#define  TIM_CCER_CC4P                       ((uint16_t)0x2000)            /*!< Capture/Compare 4 output Polarity */[m
[32m+[m[32m#define  TIM_CCER_CC4NP                      ((uint16_t)0x8000)            /*!< Capture/Compare 4 Complementary output Polarity */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CNT register  ********************/[m
[32m+[m[32m#define  TIM_CNT_CNT                         ((uint16_t)0xFFFF)            /*!< Counter Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_PSC register  ********************/[m
[32m+[m[32m#define  TIM_PSC_PSC                         ((uint16_t)0xFFFF)            /*!< Prescaler Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_ARR register  ********************/[m
[32m+[m[32m#define  TIM_ARR_ARR                         ((uint16_t)0xFFFF)            /*!< actual auto-reload Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_RCR register  ********************/[m
[32m+[m[32m#define  TIM_RCR_REP                         ((uint8_t)0xFF)               /*!< Repetition Counter Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CCR1 register  *******************/[m
[32m+[m[32m#define  TIM_CCR1_CCR1                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 1 Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CCR2 register  *******************/[m
[32m+[m[32m#define  TIM_CCR2_CCR2                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 2 Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CCR3 register  *******************/[m
[32m+[m[32m#define  TIM_CCR3_CCR3                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 3 Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_CCR4 register  *******************/[m
[32m+[m[32m#define  TIM_CCR4_CCR4                       ((uint16_t)0xFFFF)            /*!< Capture/Compare 4 Value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_BDTR register  *******************/[m
[32m+[m[32m#define  TIM_BDTR_DTG                        ((uint16_t)0x00FF)            /*!< DTG[0:7] bits (Dead-Time Generator set-up) */[m
[32m+[m[32m#define  TIM_BDTR_DTG_0                      ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_1                      ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_2                      ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_3                      ((uint16_t)0x0008)            /*!< Bit 3 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_4                      ((uint16_t)0x0010)            /*!< Bit 4 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_5                      ((uint16_t)0x0020)            /*!< Bit 5 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_6                      ((uint16_t)0x0040)            /*!< Bit 6 */[m
[32m+[m[32m#define  TIM_BDTR_DTG_7                      ((uint16_t)0x0080)            /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  TIM_BDTR_LOCK                       ((uint16_t)0x0300)            /*!< LOCK[1:0] bits (Lock Configuration) */[m
[32m+[m[32m#define  TIM_BDTR_LOCK_0                     ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_BDTR_LOCK_1                     ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  TIM_BDTR_OSSI                       ((uint16_t)0x0400)            /*!< Off-State Selection for Idle mode */[m
[32m+[m[32m#define  TIM_BDTR_OSSR                       ((uint16_t)0x0800)            /*!< Off-State Selection for Run mode */[m
[32m+[m[32m#define  TIM_BDTR_BKE                        ((uint16_t)0x1000)            /*!< Break enable */[m
[32m+[m[32m#define  TIM_BDTR_BKP                        ((uint16_t)0x2000)            /*!< Break Polarity */[m
[32m+[m[32m#define  TIM_BDTR_AOE                        ((uint16_t)0x4000)            /*!< Automatic Output enable */[m
[32m+[m[32m#define  TIM_BDTR_MOE                        ((uint16_t)0x8000)            /*!< Main Output enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_DCR register  ********************/[m
[32m+[m[32m#define  TIM_DCR_DBA                         ((uint16_t)0x001F)            /*!< DBA[4:0] bits (DMA Base Address) */[m
[32m+[m[32m#define  TIM_DCR_DBA_0                       ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_DCR_DBA_1                       ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_DCR_DBA_2                       ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_DCR_DBA_3                       ((uint16_t)0x0008)            /*!< Bit 3 */[m
[32m+[m[32m#define  TIM_DCR_DBA_4                       ((uint16_t)0x0010)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  TIM_DCR_DBL                         ((uint16_t)0x1F00)            /*!< DBL[4:0] bits (DMA Burst Length) */[m
[32m+[m[32m#define  TIM_DCR_DBL_0                       ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  TIM_DCR_DBL_1                       ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m[32m#define  TIM_DCR_DBL_2                       ((uint16_t)0x0400)            /*!< Bit 2 */[m
[32m+[m[32m#define  TIM_DCR_DBL_3                       ((uint16_t)0x0800)            /*!< Bit 3 */[m
[32m+[m[32m#define  TIM_DCR_DBL_4                       ((uint16_t)0x1000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for TIM_DMAR register  *******************/[m
[32m+[m[32m#define  TIM_DMAR_DMAB                       ((uint16_t)0xFFFF)            /*!< DMA register for burst accesses */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                             Real-Time Clock                                */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_CRH register  ********************/[m
[32m+[m[32m#define  RTC_CRH_SECIE                       ((uint8_t)0x01)               /*!< Second Interrupt Enable */[m
[32m+[m[32m#define  RTC_CRH_ALRIE                       ((uint8_t)0x02)               /*!< Alarm Interrupt Enable */[m
[32m+[m[32m#define  RTC_CRH_OWIE                        ((uint8_t)0x04)               /*!< OverfloW Interrupt Enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_CRL register  ********************/[m
[32m+[m[32m#define  RTC_CRL_SECF                        ((uint8_t)0x01)               /*!< Second Flag */[m
[32m+[m[32m#define  RTC_CRL_ALRF                        ((uint8_t)0x02)               /*!< Alarm Flag */[m
[32m+[m[32m#define  RTC_CRL_OWF                         ((uint8_t)0x04)               /*!< OverfloW Flag */[m
[32m+[m[32m#define  RTC_CRL_RSF                         ((uint8_t)0x08)               /*!< Registers Synchronized Flag */[m
[32m+[m[32m#define  RTC_CRL_CNF                         ((uint8_t)0x10)               /*!< Configuration Flag */[m
[32m+[m[32m#define  RTC_CRL_RTOFF                       ((uint8_t)0x20)               /*!< RTC operation OFF */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_PRLH register  *******************/[m
[32m+[m[32m#define  RTC_PRLH_PRL                        ((uint16_t)0x000F)            /*!< RTC Prescaler Reload Value High */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_PRLL register  *******************/[m
[32m+[m[32m#define  RTC_PRLL_PRL                        ((uint16_t)0xFFFF)            /*!< RTC Prescaler Reload Value Low */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_DIVH register  *******************/[m
[32m+[m[32m#define  RTC_DIVH_RTC_DIV                    ((uint16_t)0x000F)            /*!< RTC Clock Divider High */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_DIVL register  *******************/[m
[32m+[m[32m#define  RTC_DIVL_RTC_DIV                    ((uint16_t)0xFFFF)            /*!< RTC Clock Divider Low */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_CNTH register  *******************/[m
[32m+[m[32m#define  RTC_CNTH_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter High */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_CNTL register  *******************/[m
[32m+[m[32m#define  RTC_CNTL_RTC_CNT                    ((uint16_t)0xFFFF)            /*!< RTC Counter Low */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_ALRH register  *******************/[m
[32m+[m[32m#define  RTC_ALRH_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm High */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for RTC_ALRL register  *******************/[m
[32m+[m[32m#define  RTC_ALRL_RTC_ALR                    ((uint16_t)0xFFFF)            /*!< RTC Alarm Low */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                           Independent WATCHDOG                             */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for IWDG_KR register  ********************/[m
[32m+[m[32m#define  IWDG_KR_KEY                         ((uint16_t)0xFFFF)            /*!< Key value (write only, read 0000h) */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for IWDG_PR register  ********************/[m
[32m+[m[32m#define  IWDG_PR_PR                          ((uint8_t)0x07)               /*!< PR[2:0] (Prescaler divider) */[m
[32m+[m[32m#define  IWDG_PR_PR_0                        ((uint8_t)0x01)               /*!< Bit 0 */[m
[32m+[m[32m#define  IWDG_PR_PR_1                        ((uint8_t)0x02)               /*!< Bit 1 */[m
[32m+[m[32m#define  IWDG_PR_PR_2                        ((uint8_t)0x04)               /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for IWDG_RLR register  *******************/[m
[32m+[m[32m#define  IWDG_RLR_RL                         ((uint16_t)0x0FFF)            /*!< Watchdog counter reload value */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for IWDG_SR register  ********************/[m
[32m+[m[32m#define  IWDG_SR_PVU                         ((uint8_t)0x01)               /*!< Watchdog prescaler value update */[m
[32m+[m[32m#define  IWDG_SR_RVU                         ((uint8_t)0x02)               /*!< Watchdog counter reload value update */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                            Window WATCHDOG                                 */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for WWDG_CR register  ********************/[m
[32m+[m[32m#define  WWDG_CR_T                           ((uint8_t)0x7F)               /*!< T[6:0] bits (7-Bit counter (MSB to LSB)) */[m
[32m+[m[32m#define  WWDG_CR_T0                          ((uint8_t)0x01)               /*!< Bit 0 */[m
[32m+[m[32m#define  WWDG_CR_T1                          ((uint8_t)0x02)               /*!< Bit 1 */[m
[32m+[m[32m#define  WWDG_CR_T2                          ((uint8_t)0x04)               /*!< Bit 2 */[m
[32m+[m[32m#define  WWDG_CR_T3                          ((uint8_t)0x08)               /*!< Bit 3 */[m
[32m+[m[32m#define  WWDG_CR_T4                          ((uint8_t)0x10)               /*!< Bit 4 */[m
[32m+[m[32m#define  WWDG_CR_T5                          ((uint8_t)0x20)               /*!< Bit 5 */[m
[32m+[m[32m#define  WWDG_CR_T6                          ((uint8_t)0x40)               /*!< Bit 6 */[m
[32m+[m
[32m+[m[32m#define  WWDG_CR_WDGA                        ((uint8_t)0x80)               /*!< Activation bit */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for WWDG_CFR register  *******************/[m
[32m+[m[32m#define  WWDG_CFR_W                          ((uint16_t)0x007F)            /*!< W[6:0] bits (7-bit window value) */[m
[32m+[m[32m#define  WWDG_CFR_W0                         ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  WWDG_CFR_W1                         ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  WWDG_CFR_W2                         ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m[32m#define  WWDG_CFR_W3                         ((uint16_t)0x0008)            /*!< Bit 3 */[m
[32m+[m[32m#define  WWDG_CFR_W4                         ((uint16_t)0x0010)            /*!< Bit 4 */[m
[32m+[m[32m#define  WWDG_CFR_W5                         ((uint16_t)0x0020)            /*!< Bit 5 */[m
[32m+[m[32m#define  WWDG_CFR_W6                         ((uint16_t)0x0040)            /*!< Bit 6 */[m
[32m+[m
[32m+[m[32m#define  WWDG_CFR_WDGTB                      ((uint16_t)0x0180)            /*!< WDGTB[1:0] bits (Timer Base) */[m
[32m+[m[32m#define  WWDG_CFR_WDGTB0                     ((uint16_t)0x0080)            /*!< Bit 0 */[m
[32m+[m[32m#define  WWDG_CFR_WDGTB1                     ((uint16_t)0x0100)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  WWDG_CFR_EWI                        ((uint16_t)0x0200)            /*!< Early Wakeup Interrupt */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for WWDG_SR register  ********************/[m
[32m+[m[32m#define  WWDG_SR_EWIF                        ((uint8_t)0x01)               /*!< Early Wakeup Interrupt Flag */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                       Flexible Static Memory Controller                    */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BCR1 register  *******************/[m
[32m+[m[32m#define  FSMC_BCR1_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */[m
[32m+[m[32m#define  FSMC_BCR1_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR1_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */[m
[32m+[m[32m#define  FSMC_BCR1_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR1_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR1_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */[m
[32m+[m[32m#define  FSMC_BCR1_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR1_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR1_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */[m
[32m+[m[32m#define  FSMC_BCR1_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */[m
[32m+[m[32m#define  FSMC_BCR1_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */[m
[32m+[m[32m#define  FSMC_BCR1_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */[m
[32m+[m[32m#define  FSMC_BCR1_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */[m
[32m+[m[32m#define  FSMC_BCR1_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */[m
[32m+[m[32m#define  FSMC_BCR1_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */[m
[32m+[m[32m#define  FSMC_BCR1_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */[m
[32m+[m[32m#define  FSMC_BCR1_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */[m
[32m+[m[32m#define  FSMC_BCR1_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BCR2 register  *******************/[m
[32m+[m[32m#define  FSMC_BCR2_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */[m
[32m+[m[32m#define  FSMC_BCR2_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR2_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */[m
[32m+[m[32m#define  FSMC_BCR2_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR2_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR2_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */[m
[32m+[m[32m#define  FSMC_BCR2_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR2_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR2_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */[m
[32m+[m[32m#define  FSMC_BCR2_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */[m
[32m+[m[32m#define  FSMC_BCR2_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */[m
[32m+[m[32m#define  FSMC_BCR2_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */[m
[32m+[m[32m#define  FSMC_BCR2_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */[m
[32m+[m[32m#define  FSMC_BCR2_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */[m
[32m+[m[32m#define  FSMC_BCR2_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */[m
[32m+[m[32m#define  FSMC_BCR2_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */[m
[32m+[m[32m#define  FSMC_BCR2_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */[m
[32m+[m[32m#define  FSMC_BCR2_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BCR3 register  *******************/[m
[32m+[m[32m#define  FSMC_BCR3_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */[m
[32m+[m[32m#define  FSMC_BCR3_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR3_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */[m
[32m+[m[32m#define  FSMC_BCR3_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR3_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR3_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */[m
[32m+[m[32m#define  FSMC_BCR3_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR3_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR3_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */[m
[32m+[m[32m#define  FSMC_BCR3_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */[m
[32m+[m[32m#define  FSMC_BCR3_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit. */[m
[32m+[m[32m#define  FSMC_BCR3_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */[m
[32m+[m[32m#define  FSMC_BCR3_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */[m
[32m+[m[32m#define  FSMC_BCR3_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */[m
[32m+[m[32m#define  FSMC_BCR3_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */[m
[32m+[m[32m#define  FSMC_BCR3_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */[m
[32m+[m[32m#define  FSMC_BCR3_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */[m
[32m+[m[32m#define  FSMC_BCR3_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BCR4 register  *******************/[m
[32m+[m[32m#define  FSMC_BCR4_MBKEN                     ((uint32_t)0x00000001)        /*!< Memory bank enable bit */[m
[32m+[m[32m#define  FSMC_BCR4_MUXEN                     ((uint32_t)0x00000002)        /*!< Address/data multiplexing enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR4_MTYP                      ((uint32_t)0x0000000C)        /*!< MTYP[1:0] bits (Memory type) */[m
[32m+[m[32m#define  FSMC_BCR4_MTYP_0                    ((uint32_t)0x00000004)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR4_MTYP_1                    ((uint32_t)0x00000008)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR4_MWID                      ((uint32_t)0x00000030)        /*!< MWID[1:0] bits (Memory data bus width) */[m
[32m+[m[32m#define  FSMC_BCR4_MWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BCR4_MWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BCR4_FACCEN                    ((uint32_t)0x00000040)        /*!< Flash access enable */[m
[32m+[m[32m#define  FSMC_BCR4_BURSTEN                   ((uint32_t)0x00000100)        /*!< Burst enable bit */[m
[32m+[m[32m#define  FSMC_BCR4_WAITPOL                   ((uint32_t)0x00000200)        /*!< Wait signal polarity bit */[m
[32m+[m[32m#define  FSMC_BCR4_WRAPMOD                   ((uint32_t)0x00000400)        /*!< Wrapped burst mode support */[m
[32m+[m[32m#define  FSMC_BCR4_WAITCFG                   ((uint32_t)0x00000800)        /*!< Wait timing configuration */[m
[32m+[m[32m#define  FSMC_BCR4_WREN                      ((uint32_t)0x00001000)        /*!< Write enable bit */[m
[32m+[m[32m#define  FSMC_BCR4_WAITEN                    ((uint32_t)0x00002000)        /*!< Wait enable bit */[m
[32m+[m[32m#define  FSMC_BCR4_EXTMOD                    ((uint32_t)0x00004000)        /*!< Extended mode enable */[m
[32m+[m[32m#define  FSMC_BCR4_ASYNCWAIT                 ((uint32_t)0x00008000)       /*!< Asynchronous wait */[m
[32m+[m[32m#define  FSMC_BCR4_CBURSTRW                  ((uint32_t)0x00080000)        /*!< Write burst enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BTR1 register  ******************/[m
[32m+[m[32m#define  FSMC_BTR1_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BTR1_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR1_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR1_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR1_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BTR1_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR1_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR1_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR1_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BTR1_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR1_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR1_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR1_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */[m
[32m+[m[32m#define  FSMC_BTR1_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR1_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR1_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR1_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BTR1_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR1_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR1_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR1_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BTR1_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR1_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR1_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR1_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BTR1_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR1_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BTR2 register  *******************/[m
[32m+[m[32m#define  FSMC_BTR2_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BTR2_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR2_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR2_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR2_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BTR2_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR2_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR2_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR2_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BTR2_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR2_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR2_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR2_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */[m
[32m+[m[32m#define  FSMC_BTR2_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR2_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR2_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR2_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BTR2_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR2_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR2_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR2_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BTR2_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR2_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR2_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR2_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BTR2_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR2_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FSMC_BTR3 register  *******************/[m
[32m+[m[32m#define  FSMC_BTR3_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BTR3_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR3_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR3_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR3_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BTR3_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR3_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR3_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR3_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BTR3_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR3_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR3_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR3_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */[m
[32m+[m[32m#define  FSMC_BTR3_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR3_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR3_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR3_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BTR3_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR3_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR3_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR3_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BTR3_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR3_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR3_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR3_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BTR3_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR3_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BTR4 register  *******************/[m
[32m+[m[32m#define  FSMC_BTR4_ADDSET                    ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BTR4_ADDSET_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_ADDSET_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR4_ADDSET_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR4_ADDSET_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR4_ADDHLD                    ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BTR4_ADDHLD_0                  ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_ADDHLD_1                  ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR4_ADDHLD_2                  ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR4_ADDHLD_3                  ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR4_DATAST                    ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BTR4_DATAST_0                  ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_DATAST_1                  ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR4_DATAST_2                  ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR4_DATAST_3                  ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR4_BUSTURN                   ((uint32_t)0x000F0000)        /*!< BUSTURN[3:0] bits (Bus turnaround phase duration) */[m
[32m+[m[32m#define  FSMC_BTR4_BUSTURN_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_BUSTURN_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR4_BUSTURN_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR4_BUSTURN_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR4_CLKDIV                    ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BTR4_CLKDIV_0                  ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_CLKDIV_1                  ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR4_CLKDIV_2                  ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR4_CLKDIV_3                  ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR4_DATLAT                    ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BTR4_DATLAT_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_DATLAT_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BTR4_DATLAT_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BTR4_DATLAT_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BTR4_ACCMOD                    ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BTR4_ACCMOD_0                  ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BTR4_ACCMOD_1                  ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BWTR1 register  ******************/[m
[32m+[m[32m#define  FSMC_BWTR1_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR1_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR1_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR1_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR1_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR1_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR1_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR1_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR1_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BWTR1_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR1_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR1_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR1_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR1_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BWTR1_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR1_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR1_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR1_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR1_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BWTR1_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR1_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BWTR2 register  ******************/[m
[32m+[m[32m#define  FSMC_BWTR2_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR2_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR2_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR2_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR2_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR2_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR2_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR2_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR2_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BWTR2_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR2_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1*/[m
[32m+[m[32m#define  FSMC_BWTR2_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR2_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR2_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BWTR2_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR2_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR2_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR2_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR2_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BWTR2_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR2_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BWTR3 register  ******************/[m
[32m+[m[32m#define  FSMC_BWTR3_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR3_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR3_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR3_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR3_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR3_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR3_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR3_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR3_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BWTR3_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR3_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR3_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR3_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR3_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BWTR3_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR3_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR3_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR3_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR3_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BWTR3_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR3_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_BWTR4 register  ******************/[m
[32m+[m[32m#define  FSMC_BWTR4_ADDSET                   ((uint32_t)0x0000000F)        /*!< ADDSET[3:0] bits (Address setup phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDSET_0                 ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDSET_1                 ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDSET_2                 ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDSET_3                 ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR4_ADDHLD                   ((uint32_t)0x000000F0)        /*!< ADDHLD[3:0] bits (Address-hold phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDHLD_0                 ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDHLD_1                 ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDHLD_2                 ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR4_ADDHLD_3                 ((uint32_t)0x00000080)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR4_DATAST                   ((uint32_t)0x0000FF00)        /*!< DATAST [3:0] bits (Data-phase duration) */[m
[32m+[m[32m#define  FSMC_BWTR4_DATAST_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR4_DATAST_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR4_DATAST_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR4_DATAST_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR4_CLKDIV                   ((uint32_t)0x00F00000)        /*!< CLKDIV[3:0] bits (Clock divide ratio) */[m
[32m+[m[32m#define  FSMC_BWTR4_CLKDIV_0                 ((uint32_t)0x00100000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR4_CLKDIV_1                 ((uint32_t)0x00200000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR4_CLKDIV_2                 ((uint32_t)0x00400000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR4_CLKDIV_3                 ((uint32_t)0x00800000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR4_DATLAT                   ((uint32_t)0x0F000000)        /*!< DATLA[3:0] bits (Data latency) */[m
[32m+[m[32m#define  FSMC_BWTR4_DATLAT_0                 ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR4_DATLAT_1                 ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_BWTR4_DATLAT_2                 ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_BWTR4_DATLAT_3                 ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_BWTR4_ACCMOD                   ((uint32_t)0x30000000)        /*!< ACCMOD[1:0] bits (Access mode) */[m
[32m+[m[32m#define  FSMC_BWTR4_ACCMOD_0                 ((uint32_t)0x10000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_BWTR4_ACCMOD_1                 ((uint32_t)0x20000000)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PCR2 register  *******************/[m
[32m+[m[32m#define  FSMC_PCR2_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */[m
[32m+[m[32m#define  FSMC_PCR2_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */[m
[32m+[m[32m#define  FSMC_PCR2_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR2_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */[m
[32m+[m[32m#define  FSMC_PCR2_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR2_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR2_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR2_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */[m
[32m+[m[32m#define  FSMC_PCR2_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR2_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR2_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PCR2_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR2_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */[m
[32m+[m[32m#define  FSMC_PCR2_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR2_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR2_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PCR2_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR2_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[1:0] bits (ECC page size) */[m
[32m+[m[32m#define  FSMC_PCR2_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR2_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR2_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PCR3 register  *******************/[m
[32m+[m[32m#define  FSMC_PCR3_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */[m
[32m+[m[32m#define  FSMC_PCR3_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */[m
[32m+[m[32m#define  FSMC_PCR3_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR3_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */[m
[32m+[m[32m#define  FSMC_PCR3_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR3_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR3_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR3_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */[m
[32m+[m[32m#define  FSMC_PCR3_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR3_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR3_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PCR3_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR3_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */[m
[32m+[m[32m#define  FSMC_PCR3_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR3_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR3_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PCR3_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR3_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */[m
[32m+[m[32m#define  FSMC_PCR3_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR3_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR3_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PCR4 register  *******************/[m
[32m+[m[32m#define  FSMC_PCR4_PWAITEN                   ((uint32_t)0x00000002)        /*!< Wait feature enable bit */[m
[32m+[m[32m#define  FSMC_PCR4_PBKEN                     ((uint32_t)0x00000004)        /*!< PC Card/NAND Flash memory bank enable bit */[m
[32m+[m[32m#define  FSMC_PCR4_PTYP                      ((uint32_t)0x00000008)        /*!< Memory type */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR4_PWID                      ((uint32_t)0x00000030)        /*!< PWID[1:0] bits (NAND Flash databus width) */[m
[32m+[m[32m#define  FSMC_PCR4_PWID_0                    ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR4_PWID_1                    ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR4_ECCEN                     ((uint32_t)0x00000040)        /*!< ECC computation logic enable bit */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR4_TCLR                      ((uint32_t)0x00001E00)        /*!< TCLR[3:0] bits (CLE to RE delay) */[m
[32m+[m[32m#define  FSMC_PCR4_TCLR_0                    ((uint32_t)0x00000200)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR4_TCLR_1                    ((uint32_t)0x00000400)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR4_TCLR_2                    ((uint32_t)0x00000800)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PCR4_TCLR_3                    ((uint32_t)0x00001000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR4_TAR                       ((uint32_t)0x0001E000)        /*!< TAR[3:0] bits (ALE to RE delay) */[m
[32m+[m[32m#define  FSMC_PCR4_TAR_0                     ((uint32_t)0x00002000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR4_TAR_1                     ((uint32_t)0x00004000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR4_TAR_2                     ((uint32_t)0x00008000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PCR4_TAR_3                     ((uint32_t)0x00010000)        /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PCR4_ECCPS                     ((uint32_t)0x000E0000)        /*!< ECCPS[2:0] bits (ECC page size) */[m
[32m+[m[32m#define  FSMC_PCR4_ECCPS_0                   ((uint32_t)0x00020000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PCR4_ECCPS_1                   ((uint32_t)0x00040000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PCR4_ECCPS_2                   ((uint32_t)0x00080000)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FSMC_SR2 register  *******************/[m
[32m+[m[32m#define  FSMC_SR2_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */[m
[32m+[m[32m#define  FSMC_SR2_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */[m
[32m+[m[32m#define  FSMC_SR2_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */[m
[32m+[m[32m#define  FSMC_SR2_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR2_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR2_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR2_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FSMC_SR3 register  *******************/[m
[32m+[m[32m#define  FSMC_SR3_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */[m
[32m+[m[32m#define  FSMC_SR3_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */[m
[32m+[m[32m#define  FSMC_SR3_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */[m
[32m+[m[32m#define  FSMC_SR3_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR3_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR3_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR3_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FSMC_SR4 register  *******************/[m
[32m+[m[32m#define  FSMC_SR4_IRS                        ((uint8_t)0x01)               /*!< Interrupt Rising Edge status */[m
[32m+[m[32m#define  FSMC_SR4_ILS                        ((uint8_t)0x02)               /*!< Interrupt Level status */[m
[32m+[m[32m#define  FSMC_SR4_IFS                        ((uint8_t)0x04)               /*!< Interrupt Falling Edge status */[m
[32m+[m[32m#define  FSMC_SR4_IREN                       ((uint8_t)0x08)               /*!< Interrupt Rising Edge detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR4_ILEN                       ((uint8_t)0x10)               /*!< Interrupt Level detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR4_IFEN                       ((uint8_t)0x20)               /*!< Interrupt Falling Edge detection Enable bit */[m
[32m+[m[32m#define  FSMC_SR4_FEMPT                      ((uint8_t)0x40)               /*!< FIFO empty */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PMEM2 register  ******************/[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2                  ((uint32_t)0x000000FF)        /*!< MEMSET2[7:0] bits (Common memory 2 setup time) */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT2[7:0] bits (Common memory 2 wait time) */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD2[7:0] bits (Common memory 2 hold time) */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2                  ((uint32_t)0xFF000000)        /*!< MEMHIZ2[7:0] bits (Common memory 2 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM2_MEMHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PMEM3 register  ******************/[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3                  ((uint32_t)0x000000FF)        /*!< MEMSET3[7:0] bits (Common memory 3 setup time) */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT3[7:0] bits (Common memory 3 wait time) */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD3[7:0] bits (Common memory 3 hold time) */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3                  ((uint32_t)0xFF000000)        /*!< MEMHIZ3[7:0] bits (Common memory 3 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM3_MEMHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PMEM4 register  ******************/[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4                  ((uint32_t)0x000000FF)        /*!< MEMSET4[7:0] bits (Common memory 4 setup time) */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4                 ((uint32_t)0x0000FF00)        /*!< MEMWAIT4[7:0] bits (Common memory 4 wait time) */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4                 ((uint32_t)0x00FF0000)        /*!< MEMHOLD4[7:0] bits (Common memory 4 hold time) */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4                  ((uint32_t)0xFF000000)        /*!< MEMHIZ4[7:0] bits (Common memory 4 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PMEM4_MEMHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PATT2 register  ******************/[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2                  ((uint32_t)0x000000FF)        /*!< ATTSET2[7:0] bits (Attribute memory 2 setup time) */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_4                ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_5                ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_6                ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTSET2_7                ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT2[7:0] bits (Attribute memory 2 wait time) */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_2               ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_3               ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_4               ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_5               ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_6               ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTWAIT2_7               ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD2[7:0] bits (Attribute memory 2 hold time) */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_0               ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_1               ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_2               ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_3               ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_4               ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_5               ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_6               ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHOLD2_7               ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2                  ((uint32_t)0xFF000000)        /*!< ATTHIZ2[7:0] bits (Attribute memory 2 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_0                ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_1                ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_2                ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_3                ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_4                ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_5                ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_6                ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT2_ATTHIZ2_7                ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PATT3 register  ******************/[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3                  ((uint32_t)0x000000FF)        /*!< ATTSET3[7:0] bits (Attribute memory 3 setup time) */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_4                ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_5                ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_6                ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTSET3_7                ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT3[7:0] bits (Attribute memory 3 wait time) */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_2               ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_3               ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_4               ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_5               ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_6               ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTWAIT3_7               ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD3[7:0] bits (Attribute memory 3 hold time) */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_0               ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_1               ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_2               ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_3               ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_4               ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_5               ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_6               ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHOLD3_7               ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3                  ((uint32_t)0xFF000000)        /*!< ATTHIZ3[7:0] bits (Attribute memory 3 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_0                ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_1                ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_2                ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_3                ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_4                ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_5                ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_6                ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT3_ATTHIZ3_7                ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PATT4 register  ******************/[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4                  ((uint32_t)0x000000FF)        /*!< ATTSET4[7:0] bits (Attribute memory 4 setup time) */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_0                ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_1                ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_2                ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_3                ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_4                ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_5                ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_6                ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTSET4_7                ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4                 ((uint32_t)0x0000FF00)        /*!< ATTWAIT4[7:0] bits (Attribute memory 4 wait time) */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_0               ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_1               ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_2               ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_3               ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_4               ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_5               ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_6               ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTWAIT4_7               ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4                 ((uint32_t)0x00FF0000)        /*!< ATTHOLD4[7:0] bits (Attribute memory 4 hold time) */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_0               ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_1               ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_2               ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_3               ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_4               ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_5               ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_6               ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHOLD4_7               ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4                  ((uint32_t)0xFF000000)        /*!< ATTHIZ4[7:0] bits (Attribute memory 4 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_0                ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_1                ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_2                ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_3                ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_4                ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_5                ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_6                ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PATT4_ATTHIZ4_7                ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_PIO4 register  *******************/[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4                    ((uint32_t)0x000000FF)        /*!< IOSET4[7:0] bits (I/O 4 setup time) */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_0                  ((uint32_t)0x00000001)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_1                  ((uint32_t)0x00000002)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_2                  ((uint32_t)0x00000004)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_3                  ((uint32_t)0x00000008)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_4                  ((uint32_t)0x00000010)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_5                  ((uint32_t)0x00000020)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_6                  ((uint32_t)0x00000040)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PIO4_IOSET4_7                  ((uint32_t)0x00000080)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4                   ((uint32_t)0x0000FF00)        /*!< IOWAIT4[7:0] bits (I/O 4 wait time) */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_0                 ((uint32_t)0x00000100)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_1                 ((uint32_t)0x00000200)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_2                 ((uint32_t)0x00000400)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_3                 ((uint32_t)0x00000800)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_4                 ((uint32_t)0x00001000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_5                 ((uint32_t)0x00002000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_6                 ((uint32_t)0x00004000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PIO4_IOWAIT4_7                 ((uint32_t)0x00008000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4                   ((uint32_t)0x00FF0000)        /*!< IOHOLD4[7:0] bits (I/O 4 hold time) */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_0                 ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_1                 ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_2                 ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_3                 ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_4                 ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_5                 ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_6                 ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHOLD4_7                 ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4                    ((uint32_t)0xFF000000)        /*!< IOHIZ4[7:0] bits (I/O 4 databus HiZ time) */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_0                  ((uint32_t)0x01000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_1                  ((uint32_t)0x02000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_2                  ((uint32_t)0x04000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_3                  ((uint32_t)0x08000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_4                  ((uint32_t)0x10000000)        /*!< Bit 4 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_5                  ((uint32_t)0x20000000)        /*!< Bit 5 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_6                  ((uint32_t)0x40000000)        /*!< Bit 6 */[m
[32m+[m[32m#define  FSMC_PIO4_IOHIZ4_7                  ((uint32_t)0x80000000)        /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_ECCR2 register  ******************/[m
[32m+[m[32m#define  FSMC_ECCR2_ECC2                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FSMC_ECCR3 register  ******************/[m
[32m+[m[32m#define  FSMC_ECCR3_ECC3                     ((uint32_t)0xFFFFFFFF)        /*!< ECC result */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                          SD host Interface                                 */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_POWER register  ******************/[m
[32m+[m[32m#define  SDIO_POWER_PWRCTRL                  ((uint8_t)0x03)               /*!< PWRCTRL[1:0] bits (Power supply control bits) */[m
[32m+[m[32m#define  SDIO_POWER_PWRCTRL_0                ((uint8_t)0x01)               /*!< Bit 0 */[m
[32m+[m[32m#define  SDIO_POWER_PWRCTRL_1                ((uint8_t)0x02)               /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_CLKCR register  ******************/[m
[32m+[m[32m#define  SDIO_CLKCR_CLKDIV                   ((uint16_t)0x00FF)            /*!< Clock divide factor */[m
[32m+[m[32m#define  SDIO_CLKCR_CLKEN                    ((uint16_t)0x0100)            /*!< Clock enable bit */[m
[32m+[m[32m#define  SDIO_CLKCR_PWRSAV                   ((uint16_t)0x0200)            /*!< Power saving configuration bit */[m
[32m+[m[32m#define  SDIO_CLKCR_BYPASS                   ((uint16_t)0x0400)            /*!< Clock divider bypass enable bit */[m
[32m+[m
[32m+[m[32m#define  SDIO_CLKCR_WIDBUS                   ((uint16_t)0x1800)            /*!< WIDBUS[1:0] bits (Wide bus mode enable bit) */[m
[32m+[m[32m#define  SDIO_CLKCR_WIDBUS_0                 ((uint16_t)0x0800)            /*!< Bit 0 */[m
[32m+[m[32m#define  SDIO_CLKCR_WIDBUS_1                 ((uint16_t)0x1000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  SDIO_CLKCR_NEGEDGE                  ((uint16_t)0x2000)            /*!< SDIO_CK dephasing selection bit */[m
[32m+[m[32m#define  SDIO_CLKCR_HWFC_EN                  ((uint16_t)0x4000)            /*!< HW Flow Control enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SDIO_ARG register  *******************/[m
[32m+[m[32m#define  SDIO_ARG_CMDARG                     ((uint32_t)0xFFFFFFFF)            /*!< Command argument */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SDIO_CMD register  *******************/[m
[32m+[m[32m#define  SDIO_CMD_CMDINDEX                   ((uint16_t)0x003F)            /*!< Command Index */[m
[32m+[m
[32m+[m[32m#define  SDIO_CMD_WAITRESP                   ((uint16_t)0x00C0)            /*!< WAITRESP[1:0] bits (Wait for response bits) */[m
[32m+[m[32m#define  SDIO_CMD_WAITRESP_0                 ((uint16_t)0x0040)            /*!<  Bit 0 */[m
[32m+[m[32m#define  SDIO_CMD_WAITRESP_1                 ((uint16_t)0x0080)            /*!<  Bit 1 */[m
[32m+[m
[32m+[m[32m#define  SDIO_CMD_WAITINT                    ((uint16_t)0x0100)            /*!< CPSM Waits for Interrupt Request */[m
[32m+[m[32m#define  SDIO_CMD_WAITPEND                   ((uint16_t)0x0200)            /*!< CPSM Waits for ends of data transfer (CmdPend internal signal) */[m
[32m+[m[32m#define  SDIO_CMD_CPSMEN                     ((uint16_t)0x0400)            /*!< Command path state machine (CPSM) Enable bit */[m
[32m+[m[32m#define  SDIO_CMD_SDIOSUSPEND                ((uint16_t)0x0800)            /*!< SD I/O suspend command */[m
[32m+[m[32m#define  SDIO_CMD_ENCMDCOMPL                 ((uint16_t)0x1000)            /*!< Enable CMD completion */[m
[32m+[m[32m#define  SDIO_CMD_NIEN                       ((uint16_t)0x2000)            /*!< Not Interrupt Enable */[m
[32m+[m[32m#define  SDIO_CMD_CEATACMD                   ((uint16_t)0x4000)            /*!< CE-ATA command */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for SDIO_RESPCMD register  *****************/[m
[32m+[m[32m#define  SDIO_RESPCMD_RESPCMD                ((uint8_t)0x3F)               /*!< Response command index */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_RESP0 register  ******************/[m
[32m+[m[32m#define  SDIO_RESP0_CARDSTATUS0              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_RESP1 register  ******************/[m
[32m+[m[32m#define  SDIO_RESP1_CARDSTATUS1              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_RESP2 register  ******************/[m
[32m+[m[32m#define  SDIO_RESP2_CARDSTATUS2              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_RESP3 register  ******************/[m
[32m+[m[32m#define  SDIO_RESP3_CARDSTATUS3              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_RESP4 register  ******************/[m
[32m+[m[32m#define  SDIO_RESP4_CARDSTATUS4              ((uint32_t)0xFFFFFFFF)        /*!< Card Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_DTIMER register  *****************/[m
[32m+[m[32m#define  SDIO_DTIMER_DATATIME                ((uint32_t)0xFFFFFFFF)        /*!< Data timeout period. */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_DLEN register  *******************/[m
[32m+[m[32m#define  SDIO_DLEN_DATALENGTH                ((uint32_t)0x01FFFFFF)        /*!< Data length value */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_DCTRL register  ******************/[m
[32m+[m[32m#define  SDIO_DCTRL_DTEN                     ((uint16_t)0x0001)            /*!< Data transfer enabled bit */[m
[32m+[m[32m#define  SDIO_DCTRL_DTDIR                    ((uint16_t)0x0002)            /*!< Data transfer direction selection */[m
[32m+[m[32m#define  SDIO_DCTRL_DTMODE                   ((uint16_t)0x0004)            /*!< Data transfer mode selection */[m
[32m+[m[32m#define  SDIO_DCTRL_DMAEN                    ((uint16_t)0x0008)            /*!< DMA enabled bit */[m
[32m+[m
[32m+[m[32m#define  SDIO_DCTRL_DBLOCKSIZE               ((uint16_t)0x00F0)            /*!< DBLOCKSIZE[3:0] bits (Data block size) */[m
[32m+[m[32m#define  SDIO_DCTRL_DBLOCKSIZE_0             ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  SDIO_DCTRL_DBLOCKSIZE_1             ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m[32m#define  SDIO_DCTRL_DBLOCKSIZE_2             ((uint16_t)0x0040)            /*!< Bit 2 */[m
[32m+[m[32m#define  SDIO_DCTRL_DBLOCKSIZE_3             ((uint16_t)0x0080)            /*!< Bit 3 */[m
[32m+[m
[32m+[m[32m#define  SDIO_DCTRL_RWSTART                  ((uint16_t)0x0100)            /*!< Read wait start */[m
[32m+[m[32m#define  SDIO_DCTRL_RWSTOP                   ((uint16_t)0x0200)            /*!< Read wait stop */[m
[32m+[m[32m#define  SDIO_DCTRL_RWMOD                    ((uint16_t)0x0400)            /*!< Read wait mode */[m
[32m+[m[32m#define  SDIO_DCTRL_SDIOEN                   ((uint16_t)0x0800)            /*!< SD I/O enable functions */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_DCOUNT register  *****************/[m
[32m+[m[32m#define  SDIO_DCOUNT_DATACOUNT               ((uint32_t)0x01FFFFFF)        /*!< Data count value */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_STA register  ********************/[m
[32m+[m[32m#define  SDIO_STA_CCRCFAIL                   ((uint32_t)0x00000001)        /*!< Command response received (CRC check failed) */[m
[32m+[m[32m#define  SDIO_STA_DCRCFAIL                   ((uint32_t)0x00000002)        /*!< Data block sent/received (CRC check failed) */[m
[32m+[m[32m#define  SDIO_STA_CTIMEOUT                   ((uint32_t)0x00000004)        /*!< Command response timeout */[m
[32m+[m[32m#define  SDIO_STA_DTIMEOUT                   ((uint32_t)0x00000008)        /*!< Data timeout */[m
[32m+[m[32m#define  SDIO_STA_TXUNDERR                   ((uint32_t)0x00000010)        /*!< Transmit FIFO underrun error */[m
[32m+[m[32m#define  SDIO_STA_RXOVERR                    ((uint32_t)0x00000020)        /*!< Received FIFO overrun error */[m
[32m+[m[32m#define  SDIO_STA_CMDREND                    ((uint32_t)0x00000040)        /*!< Command response received (CRC check passed) */[m
[32m+[m[32m#define  SDIO_STA_CMDSENT                    ((uint32_t)0x00000080)        /*!< Command sent (no response required) */[m
[32m+[m[32m#define  SDIO_STA_DATAEND                    ((uint32_t)0x00000100)        /*!< Data end (data counter, SDIDCOUNT, is zero) */[m
[32m+[m[32m#define  SDIO_STA_STBITERR                   ((uint32_t)0x00000200)        /*!< Start bit not detected on all data signals in wide bus mode */[m
[32m+[m[32m#define  SDIO_STA_DBCKEND                    ((uint32_t)0x00000400)        /*!< Data block sent/received (CRC check passed) */[m
[32m+[m[32m#define  SDIO_STA_CMDACT                     ((uint32_t)0x00000800)        /*!< Command transfer in progress */[m
[32m+[m[32m#define  SDIO_STA_TXACT                      ((uint32_t)0x00001000)        /*!< Data transmit in progress */[m
[32m+[m[32m#define  SDIO_STA_RXACT                      ((uint32_t)0x00002000)        /*!< Data receive in progress */[m
[32m+[m[32m#define  SDIO_STA_TXFIFOHE                   ((uint32_t)0x00004000)        /*!< Transmit FIFO Half Empty: at least 8 words can be written into the FIFO */[m
[32m+[m[32m#define  SDIO_STA_RXFIFOHF                   ((uint32_t)0x00008000)        /*!< Receive FIFO Half Full: there are at least 8 words in the FIFO */[m
[32m+[m[32m#define  SDIO_STA_TXFIFOF                    ((uint32_t)0x00010000)        /*!< Transmit FIFO full */[m
[32m+[m[32m#define  SDIO_STA_RXFIFOF                    ((uint32_t)0x00020000)        /*!< Receive FIFO full */[m
[32m+[m[32m#define  SDIO_STA_TXFIFOE                    ((uint32_t)0x00040000)        /*!< Transmit FIFO empty */[m
[32m+[m[32m#define  SDIO_STA_RXFIFOE                    ((uint32_t)0x00080000)        /*!< Receive FIFO empty */[m
[32m+[m[32m#define  SDIO_STA_TXDAVL                     ((uint32_t)0x00100000)        /*!< Data available in transmit FIFO */[m
[32m+[m[32m#define  SDIO_STA_RXDAVL                     ((uint32_t)0x00200000)        /*!< Data available in receive FIFO */[m
[32m+[m[32m#define  SDIO_STA_SDIOIT                     ((uint32_t)0x00400000)        /*!< SDIO interrupt received */[m
[32m+[m[32m#define  SDIO_STA_CEATAEND                   ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received for CMD61 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SDIO_ICR register  *******************/[m
[32m+[m[32m#define  SDIO_ICR_CCRCFAILC                  ((uint32_t)0x00000001)        /*!< CCRCFAIL flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_DCRCFAILC                  ((uint32_t)0x00000002)        /*!< DCRCFAIL flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_CTIMEOUTC                  ((uint32_t)0x00000004)        /*!< CTIMEOUT flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_DTIMEOUTC                  ((uint32_t)0x00000008)        /*!< DTIMEOUT flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_TXUNDERRC                  ((uint32_t)0x00000010)        /*!< TXUNDERR flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_RXOVERRC                   ((uint32_t)0x00000020)        /*!< RXOVERR flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_CMDRENDC                   ((uint32_t)0x00000040)        /*!< CMDREND flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_CMDSENTC                   ((uint32_t)0x00000080)        /*!< CMDSENT flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_DATAENDC                   ((uint32_t)0x00000100)        /*!< DATAEND flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_STBITERRC                  ((uint32_t)0x00000200)        /*!< STBITERR flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_DBCKENDC                   ((uint32_t)0x00000400)        /*!< DBCKEND flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_SDIOITC                    ((uint32_t)0x00400000)        /*!< SDIOIT flag clear bit */[m
[32m+[m[32m#define  SDIO_ICR_CEATAENDC                  ((uint32_t)0x00800000)        /*!< CEATAEND flag clear bit */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_MASK register  *******************/[m
[32m+[m[32m#define  SDIO_MASK_CCRCFAILIE                ((uint32_t)0x00000001)        /*!< Command CRC Fail Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_DCRCFAILIE                ((uint32_t)0x00000002)        /*!< Data CRC Fail Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_CTIMEOUTIE                ((uint32_t)0x00000004)        /*!< Command TimeOut Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_DTIMEOUTIE                ((uint32_t)0x00000008)        /*!< Data TimeOut Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_TXUNDERRIE                ((uint32_t)0x00000010)        /*!< Tx FIFO UnderRun Error Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_RXOVERRIE                 ((uint32_t)0x00000020)        /*!< Rx FIFO OverRun Error Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_CMDRENDIE                 ((uint32_t)0x00000040)        /*!< Command Response Received Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_CMDSENTIE                 ((uint32_t)0x00000080)        /*!< Command Sent Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_DATAENDIE                 ((uint32_t)0x00000100)        /*!< Data End Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_STBITERRIE                ((uint32_t)0x00000200)        /*!< Start Bit Error Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_DBCKENDIE                 ((uint32_t)0x00000400)        /*!< Data Block End Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_CMDACTIE                  ((uint32_t)0x00000800)        /*!< Command Acting Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_TXACTIE                   ((uint32_t)0x00001000)        /*!< Data Transmit Acting Interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_RXACTIE                   ((uint32_t)0x00002000)        /*!< Data receive acting interrupt enabled */[m
[32m+[m[32m#define  SDIO_MASK_TXFIFOHEIE                ((uint32_t)0x00004000)        /*!< Tx FIFO Half Empty interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_RXFIFOHFIE                ((uint32_t)0x00008000)        /*!< Rx FIFO Half Full interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_TXFIFOFIE                 ((uint32_t)0x00010000)        /*!< Tx FIFO Full interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_RXFIFOFIE                 ((uint32_t)0x00020000)        /*!< Rx FIFO Full interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_TXFIFOEIE                 ((uint32_t)0x00040000)        /*!< Tx FIFO Empty interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_RXFIFOEIE                 ((uint32_t)0x00080000)        /*!< Rx FIFO Empty interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_TXDAVLIE                  ((uint32_t)0x00100000)        /*!< Data available in Tx FIFO interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_RXDAVLIE                  ((uint32_t)0x00200000)        /*!< Data available in Rx FIFO interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_SDIOITIE                  ((uint32_t)0x00400000)        /*!< SDIO Mode Interrupt Received interrupt Enable */[m
[32m+[m[32m#define  SDIO_MASK_CEATAENDIE                ((uint32_t)0x00800000)        /*!< CE-ATA command completion signal received Interrupt Enable */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for SDIO_FIFOCNT register  *****************/[m
[32m+[m[32m#define  SDIO_FIFOCNT_FIFOCOUNT              ((uint32_t)0x00FFFFFF)        /*!< Remaining number of words to be written to or read from the FIFO */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SDIO_FIFO register  *******************/[m
[32m+[m[32m#define  SDIO_FIFO_FIFODATA                  ((uint32_t)0xFFFFFFFF)        /*!< Receive and transmit FIFO data */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                                   USB Device FS                            */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*!< Endpoint-specific registers */[m
[32m+[m[32m/*******************  Bit definition for USB_EP0R register  *******************/[m
[32m+[m[32m#define  USB_EP0R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP0R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP0R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP0R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP0R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP0R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP0R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP0R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP0R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP0R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP0R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP0R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP0R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP0R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP0R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP0R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP1R register  *******************/[m
[32m+[m[32m#define  USB_EP1R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP1R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP1R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP1R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP1R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP1R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP1R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP1R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP1R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP1R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP1R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP1R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP1R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP1R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP1R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP1R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP2R register  *******************/[m
[32m+[m[32m#define  USB_EP2R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP2R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP2R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP2R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP2R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP2R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP2R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP2R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP2R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP2R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP2R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP2R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP2R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP2R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP2R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP2R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP3R register  *******************/[m
[32m+[m[32m#define  USB_EP3R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP3R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP3R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP3R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP3R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP3R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP3R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP3R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP3R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP3R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP3R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP3R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP3R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP3R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP3R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP3R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP4R register  *******************/[m
[32m+[m[32m#define  USB_EP4R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP4R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP4R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP4R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP4R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP4R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP4R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP4R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP4R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP4R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP4R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP4R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP4R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP4R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP4R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP4R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP5R register  *******************/[m
[32m+[m[32m#define  USB_EP5R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP5R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP5R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP5R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP5R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP5R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP5R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP5R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP5R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP5R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP5R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP5R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP5R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP5R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP5R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP5R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP6R register  *******************/[m
[32m+[m[32m#define  USB_EP6R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP6R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP6R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP6R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP6R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP6R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP6R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP6R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP6R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP6R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP6R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP6R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP6R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP6R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP6R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP6R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_EP7R register  *******************/[m
[32m+[m[32m#define  USB_EP7R_EA                         ((uint16_t)0x000F)            /*!< Endpoint Address */[m
[32m+[m
[32m+[m[32m#define  USB_EP7R_STAT_TX                    ((uint16_t)0x0030)            /*!< STAT_TX[1:0] bits (Status bits, for transmission transfers) */[m
[32m+[m[32m#define  USB_EP7R_STAT_TX_0                  ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP7R_STAT_TX_1                  ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP7R_DTOG_TX                    ((uint16_t)0x0040)            /*!< Data Toggle, for transmission transfers */[m
[32m+[m[32m#define  USB_EP7R_CTR_TX                     ((uint16_t)0x0080)            /*!< Correct Transfer for transmission */[m
[32m+[m[32m#define  USB_EP7R_EP_KIND                    ((uint16_t)0x0100)            /*!< Endpoint Kind */[m
[32m+[m
[32m+[m[32m#define  USB_EP7R_EP_TYPE                    ((uint16_t)0x0600)            /*!< EP_TYPE[1:0] bits (Endpoint type) */[m
[32m+[m[32m#define  USB_EP7R_EP_TYPE_0                  ((uint16_t)0x0200)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP7R_EP_TYPE_1                  ((uint16_t)0x0400)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP7R_SETUP                      ((uint16_t)0x0800)            /*!< Setup transaction completed */[m
[32m+[m
[32m+[m[32m#define  USB_EP7R_STAT_RX                    ((uint16_t)0x3000)            /*!< STAT_RX[1:0] bits (Status bits, for reception transfers) */[m
[32m+[m[32m#define  USB_EP7R_STAT_RX_0                  ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_EP7R_STAT_RX_1                  ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USB_EP7R_DTOG_RX                    ((uint16_t)0x4000)            /*!< Data Toggle, for reception transfers */[m
[32m+[m[32m#define  USB_EP7R_CTR_RX                     ((uint16_t)0x8000)            /*!< Correct Transfer for reception */[m
[32m+[m
[32m+[m[32m/*!< Common registers */[m
[32m+[m[32m/*******************  Bit definition for USB_CNTR register  *******************/[m
[32m+[m[32m#define  USB_CNTR_FRES                       ((uint16_t)0x0001)            /*!< Force USB Reset */[m
[32m+[m[32m#define  USB_CNTR_PDWN                       ((uint16_t)0x0002)            /*!< Power down */[m
[32m+[m[32m#define  USB_CNTR_LP_MODE                    ((uint16_t)0x0004)            /*!< Low-power mode */[m
[32m+[m[32m#define  USB_CNTR_FSUSP                      ((uint16_t)0x0008)            /*!< Force suspend */[m
[32m+[m[32m#define  USB_CNTR_RESUME                     ((uint16_t)0x0010)            /*!< Resume request */[m
[32m+[m[32m#define  USB_CNTR_ESOFM                      ((uint16_t)0x0100)            /*!< Expected Start Of Frame Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_SOFM                       ((uint16_t)0x0200)            /*!< Start Of Frame Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_RESETM                     ((uint16_t)0x0400)            /*!< RESET Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_SUSPM                      ((uint16_t)0x0800)            /*!< Suspend mode Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_WKUPM                      ((uint16_t)0x1000)            /*!< Wakeup Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_ERRM                       ((uint16_t)0x2000)            /*!< Error Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_PMAOVRM                    ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun Interrupt Mask */[m
[32m+[m[32m#define  USB_CNTR_CTRM                       ((uint16_t)0x8000)            /*!< Correct Transfer Interrupt Mask */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_ISTR register  *******************/[m
[32m+[m[32m#define  USB_ISTR_EP_ID                      ((uint16_t)0x000F)            /*!< Endpoint Identifier */[m
[32m+[m[32m#define  USB_ISTR_DIR                        ((uint16_t)0x0010)            /*!< Direction of transaction */[m
[32m+[m[32m#define  USB_ISTR_ESOF                       ((uint16_t)0x0100)            /*!< Expected Start Of Frame */[m
[32m+[m[32m#define  USB_ISTR_SOF                        ((uint16_t)0x0200)            /*!< Start Of Frame */[m
[32m+[m[32m#define  USB_ISTR_RESET                      ((uint16_t)0x0400)            /*!< USB RESET request */[m
[32m+[m[32m#define  USB_ISTR_SUSP                       ((uint16_t)0x0800)            /*!< Suspend mode request */[m
[32m+[m[32m#define  USB_ISTR_WKUP                       ((uint16_t)0x1000)            /*!< Wake up */[m
[32m+[m[32m#define  USB_ISTR_ERR                        ((uint16_t)0x2000)            /*!< Error */[m
[32m+[m[32m#define  USB_ISTR_PMAOVR                     ((uint16_t)0x4000)            /*!< Packet Memory Area Over / Underrun */[m
[32m+[m[32m#define  USB_ISTR_CTR                        ((uint16_t)0x8000)            /*!< Correct Transfer */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USB_FNR register  ********************/[m
[32m+[m[32m#define  USB_FNR_FN                          ((uint16_t)0x07FF)            /*!< Frame Number */[m
[32m+[m[32m#define  USB_FNR_LSOF                        ((uint16_t)0x1800)            /*!< Lost SOF */[m
[32m+[m[32m#define  USB_FNR_LCK                         ((uint16_t)0x2000)            /*!< Locked */[m
[32m+[m[32m#define  USB_FNR_RXDM                        ((uint16_t)0x4000)            /*!< Receive Data - Line Status */[m
[32m+[m[32m#define  USB_FNR_RXDP                        ((uint16_t)0x8000)            /*!< Receive Data + Line Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USB_DADDR register  *******************/[m
[32m+[m[32m#define  USB_DADDR_ADD                       ((uint8_t)0x7F)               /*!< ADD[6:0] bits (Device Address) */[m
[32m+[m[32m#define  USB_DADDR_ADD0                      ((uint8_t)0x01)               /*!< Bit 0 */[m
[32m+[m[32m#define  USB_DADDR_ADD1                      ((uint8_t)0x02)               /*!< Bit 1 */[m
[32m+[m[32m#define  USB_DADDR_ADD2                      ((uint8_t)0x04)               /*!< Bit 2 */[m
[32m+[m[32m#define  USB_DADDR_ADD3                      ((uint8_t)0x08)               /*!< Bit 3 */[m
[32m+[m[32m#define  USB_DADDR_ADD4                      ((uint8_t)0x10)               /*!< Bit 4 */[m
[32m+[m[32m#define  USB_DADDR_ADD5                      ((uint8_t)0x20)               /*!< Bit 5 */[m
[32m+[m[32m#define  USB_DADDR_ADD6                      ((uint8_t)0x40)               /*!< Bit 6 */[m
[32m+[m
[32m+[m[32m#define  USB_DADDR_EF                        ((uint8_t)0x80)               /*!< Enable Function */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USB_BTABLE register  ******************/[m[41m    [m
[32m+[m[32m#define  USB_BTABLE_BTABLE                   ((uint16_t)0xFFF8)            /*!< Buffer Table */[m
[32m+[m
[32m+[m[32m/*!< Buffer descriptor table */[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR0_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR0_TX_ADDR0_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 0 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR1_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR1_TX_ADDR1_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 1 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR2_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR2_TX_ADDR2_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 2 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR3_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR3_TX_ADDR3_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 3 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR4_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR4_TX_ADDR4_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 4 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR5_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR5_TX_ADDR5_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 5 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR6_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR6_TX_ADDR6_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 6 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR7_TX register  *****************/[m
[32m+[m[32m#define  USB_ADDR7_TX_ADDR7_TX               ((uint16_t)0xFFFE)            /*!< Transmission Buffer Address 7 */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT0_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT0_TX_COUNT0_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 0 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT1_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT1_TX_COUNT1_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 1 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT2_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT2_TX_COUNT2_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 2 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT3_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT3_TX_COUNT3_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 3 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT4_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT4_TX_COUNT4_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 4 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT5_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT5_TX_COUNT5_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 5 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT6_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT6_TX_COUNT6_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 6 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT7_TX register  ****************/[m
[32m+[m[32m#define  USB_COUNT7_TX_COUNT7_TX             ((uint16_t)0x03FF)            /*!< Transmission Byte Count 7 */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT0_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT0_TX_0_COUNT0_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 0 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT0_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT0_TX_1_COUNT0_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 0 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT1_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT1_TX_0_COUNT1_TX_0          ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 1 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT1_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT1_TX_1_COUNT1_TX_1          ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 1 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT2_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT2_TX_0_COUNT2_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 2 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT2_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT2_TX_1_COUNT2_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 2 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT3_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT3_TX_0_COUNT3_TX_0         ((uint16_t)0x000003FF)        /*!< Transmission Byte Count 3 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT3_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT3_TX_1_COUNT3_TX_1         ((uint16_t)0x03FF0000)        /*!< Transmission Byte Count 3 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT4_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT4_TX_0_COUNT4_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 4 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT4_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT4_TX_1_COUNT4_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 4 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT5_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT5_TX_0_COUNT5_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 5 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT5_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT5_TX_1_COUNT5_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 5 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT6_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT6_TX_0_COUNT6_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 6 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT6_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT6_TX_1_COUNT6_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 6 (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT7_TX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT7_TX_0_COUNT7_TX_0         ((uint32_t)0x000003FF)        /*!< Transmission Byte Count 7 (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT7_TX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT7_TX_1_COUNT7_TX_1         ((uint32_t)0x03FF0000)        /*!< Transmission Byte Count 7 (high) */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR0_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR0_RX_ADDR0_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 0 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR1_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR1_RX_ADDR1_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 1 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR2_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR2_RX_ADDR2_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 2 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR3_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR3_RX_ADDR3_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 3 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR4_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR4_RX_ADDR4_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 4 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR5_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR5_RX_ADDR5_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 5 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR6_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR6_RX_ADDR6_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 6 */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_ADDR7_RX register  *****************/[m
[32m+[m[32m#define  USB_ADDR7_RX_ADDR7_RX               ((uint16_t)0xFFFE)            /*!< Reception Buffer Address 7 */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT0_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT0_RX_COUNT0_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT0_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT0_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT0_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT0_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT0_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT0_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT0_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT1_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT1_RX_COUNT1_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT1_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT1_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT1_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT1_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT1_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT1_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT1_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT2_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT2_RX_COUNT2_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT2_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT2_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT2_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT2_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT2_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT2_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT2_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT3_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT3_RX_COUNT3_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT3_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT3_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT3_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT3_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT3_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT3_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT3_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT4_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT4_RX_COUNT4_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT4_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT4_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT4_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT4_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT4_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT4_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT4_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT5_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT5_RX_COUNT5_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT5_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT5_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT5_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT5_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT5_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT5_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT5_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT6_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT6_RX_COUNT6_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT6_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT6_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT6_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT6_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT6_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT6_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT6_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for USB_COUNT7_RX register  ****************/[m
[32m+[m[32m#define  USB_COUNT7_RX_COUNT7_RX             ((uint16_t)0x03FF)            /*!< Reception Byte Count */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT7_RX_NUM_BLOCK             ((uint16_t)0x7C00)            /*!< NUM_BLOCK[4:0] bits (Number of blocks) */[m
[32m+[m[32m#define  USB_COUNT7_RX_NUM_BLOCK_0           ((uint16_t)0x0400)            /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT7_RX_NUM_BLOCK_1           ((uint16_t)0x0800)            /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT7_RX_NUM_BLOCK_2           ((uint16_t)0x1000)            /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT7_RX_NUM_BLOCK_3           ((uint16_t)0x2000)            /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT7_RX_NUM_BLOCK_4           ((uint16_t)0x4000)            /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT7_RX_BLSIZE                ((uint16_t)0x8000)            /*!< BLock SIZE */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT0_RX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT0_RX_0_COUNT0_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT0_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT0_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT0_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT0_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT0_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT0_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT0_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT0_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT0_RX_1_COUNT0_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT0_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT0_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT0_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT0_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT0_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT0_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT0_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT1_RX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT1_RX_0_COUNT1_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT1_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT1_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT1_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT1_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT1_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT1_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT1_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT1_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT1_RX_1_COUNT1_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT1_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT1_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT1_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT1_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT1_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT1_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT1_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT2_RX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT2_RX_0_COUNT2_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT2_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT2_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT2_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT2_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT2_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT2_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT2_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT2_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT2_RX_1_COUNT2_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT2_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT2_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT2_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT2_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT2_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT2_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT2_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT3_RX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT3_RX_0_COUNT3_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT3_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT3_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT3_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT3_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT3_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT3_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT3_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT3_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT3_RX_1_COUNT3_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT3_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT3_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT3_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT3_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT3_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT3_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT3_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT4_RX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT4_RX_0_COUNT4_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT4_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT4_RX_0_NUM_BLOCK_0_0      ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT4_RX_0_NUM_BLOCK_0_1      ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT4_RX_0_NUM_BLOCK_0_2      ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT4_RX_0_NUM_BLOCK_0_3      ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT4_RX_0_NUM_BLOCK_0_4      ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT4_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT4_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT4_RX_1_COUNT4_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT4_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT4_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT4_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT4_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT4_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT4_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT4_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT5_RX_0 register  ***************/[m
[32m+[m[32m#define  USB_COUNT5_RX_0_COUNT5_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT5_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT5_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT5_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT5_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT5_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT5_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT5_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT5_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT5_RX_1_COUNT5_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT5_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT5_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT5_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT5_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT5_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT5_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT5_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/***************  Bit definition for USB_COUNT6_RX_0  register  ***************/[m
[32m+[m[32m#define  USB_COUNT6_RX_0_COUNT6_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT6_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT6_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT6_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT6_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT6_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT6_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT6_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/****************  Bit definition for USB_COUNT6_RX_1 register  ***************/[m
[32m+[m[32m#define  USB_COUNT6_RX_1_COUNT6_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT6_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT6_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT6_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT6_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT6_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT6_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT6_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/***************  Bit definition for USB_COUNT7_RX_0 register  ****************/[m
[32m+[m[32m#define  USB_COUNT7_RX_0_COUNT7_RX_0         ((uint32_t)0x000003FF)        /*!< Reception Byte Count (low) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT7_RX_0_NUM_BLOCK_0         ((uint32_t)0x00007C00)        /*!< NUM_BLOCK_0[4:0] bits (Number of blocks) (low) */[m
[32m+[m[32m#define  USB_COUNT7_RX_0_NUM_BLOCK_0_0       ((uint32_t)0x00000400)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT7_RX_0_NUM_BLOCK_0_1       ((uint32_t)0x00000800)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT7_RX_0_NUM_BLOCK_0_2       ((uint32_t)0x00001000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT7_RX_0_NUM_BLOCK_0_3       ((uint32_t)0x00002000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT7_RX_0_NUM_BLOCK_0_4       ((uint32_t)0x00004000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT7_RX_0_BLSIZE_0            ((uint32_t)0x00008000)        /*!< BLock SIZE (low) */[m
[32m+[m
[32m+[m[32m/***************  Bit definition for USB_COUNT7_RX_1 register  ****************/[m
[32m+[m[32m#define  USB_COUNT7_RX_1_COUNT7_RX_1         ((uint32_t)0x03FF0000)        /*!< Reception Byte Count (high) */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT7_RX_1_NUM_BLOCK_1         ((uint32_t)0x7C000000)        /*!< NUM_BLOCK_1[4:0] bits (Number of blocks) (high) */[m
[32m+[m[32m#define  USB_COUNT7_RX_1_NUM_BLOCK_1_0       ((uint32_t)0x04000000)        /*!< Bit 0 */[m
[32m+[m[32m#define  USB_COUNT7_RX_1_NUM_BLOCK_1_1       ((uint32_t)0x08000000)        /*!< Bit 1 */[m
[32m+[m[32m#define  USB_COUNT7_RX_1_NUM_BLOCK_1_2       ((uint32_t)0x10000000)        /*!< Bit 2 */[m
[32m+[m[32m#define  USB_COUNT7_RX_1_NUM_BLOCK_1_3       ((uint32_t)0x20000000)        /*!< Bit 3 */[m
[32m+[m[32m#define  USB_COUNT7_RX_1_NUM_BLOCK_1_4       ((uint32_t)0x40000000)        /*!< Bit 4 */[m
[32m+[m
[32m+[m[32m#define  USB_COUNT7_RX_1_BLSIZE_1            ((uint32_t)0x80000000)        /*!< BLock SIZE (high) */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                         Controller Area Network                            */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*!< CAN control and status registers */[m
[32m+[m[32m/*******************  Bit definition for CAN_MCR register  ********************/[m
[32m+[m[32m#define  CAN_MCR_INRQ                        ((uint16_t)0x0001)            /*!< Initialization Request */[m
[32m+[m[32m#define  CAN_MCR_SLEEP                       ((uint16_t)0x0002)            /*!< Sleep Mode Request */[m
[32m+[m[32m#define  CAN_MCR_TXFP                        ((uint16_t)0x0004)            /*!< Transmit FIFO Priority */[m
[32m+[m[32m#define  CAN_MCR_RFLM                        ((uint16_t)0x0008)            /*!< Receive FIFO Locked Mode */[m
[32m+[m[32m#define  CAN_MCR_NART                        ((uint16_t)0x0010)            /*!< No Automatic Retransmission */[m
[32m+[m[32m#define  CAN_MCR_AWUM                        ((uint16_t)0x0020)            /*!< Automatic Wakeup Mode */[m
[32m+[m[32m#define  CAN_MCR_ABOM                        ((uint16_t)0x0040)            /*!< Automatic Bus-Off Management */[m
[32m+[m[32m#define  CAN_MCR_TTCM                        ((uint16_t)0x0080)            /*!< Time Triggered Communication Mode */[m
[32m+[m[32m#define  CAN_MCR_RESET                       ((uint16_t)0x8000)            /*!< CAN software master reset */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_MSR register  ********************/[m
[32m+[m[32m#define  CAN_MSR_INAK                        ((uint16_t)0x0001)            /*!< Initialization Acknowledge */[m
[32m+[m[32m#define  CAN_MSR_SLAK                        ((uint16_t)0x0002)            /*!< Sleep Acknowledge */[m
[32m+[m[32m#define  CAN_MSR_ERRI                        ((uint16_t)0x0004)            /*!< Error Interrupt */[m
[32m+[m[32m#define  CAN_MSR_WKUI                        ((uint16_t)0x0008)            /*!< Wakeup Interrupt */[m
[32m+[m[32m#define  CAN_MSR_SLAKI                       ((uint16_t)0x0010)            /*!< Sleep Acknowledge Interrupt */[m
[32m+[m[32m#define  CAN_MSR_TXM                         ((uint16_t)0x0100)            /*!< Transmit Mode */[m
[32m+[m[32m#define  CAN_MSR_RXM                         ((uint16_t)0x0200)            /*!< Receive Mode */[m
[32m+[m[32m#define  CAN_MSR_SAMP                        ((uint16_t)0x0400)            /*!< Last Sample Point */[m
[32m+[m[32m#define  CAN_MSR_RX                          ((uint16_t)0x0800)            /*!< CAN Rx Signal */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TSR register  ********************/[m
[32m+[m[32m#define  CAN_TSR_RQCP0                       ((uint32_t)0x00000001)        /*!< Request Completed Mailbox0 */[m
[32m+[m[32m#define  CAN_TSR_TXOK0                       ((uint32_t)0x00000002)        /*!< Transmission OK of Mailbox0 */[m
[32m+[m[32m#define  CAN_TSR_ALST0                       ((uint32_t)0x00000004)        /*!< Arbitration Lost for Mailbox0 */[m
[32m+[m[32m#define  CAN_TSR_TERR0                       ((uint32_t)0x00000008)        /*!< Transmission Error of Mailbox0 */[m
[32m+[m[32m#define  CAN_TSR_ABRQ0                       ((uint32_t)0x00000080)        /*!< Abort Request for Mailbox0 */[m
[32m+[m[32m#define  CAN_TSR_RQCP1                       ((uint32_t)0x00000100)        /*!< Request Completed Mailbox1 */[m
[32m+[m[32m#define  CAN_TSR_TXOK1                       ((uint32_t)0x00000200)        /*!< Transmission OK of Mailbox1 */[m
[32m+[m[32m#define  CAN_TSR_ALST1                       ((uint32_t)0x00000400)        /*!< Arbitration Lost for Mailbox1 */[m
[32m+[m[32m#define  CAN_TSR_TERR1                       ((uint32_t)0x00000800)        /*!< Transmission Error of Mailbox1 */[m
[32m+[m[32m#define  CAN_TSR_ABRQ1                       ((uint32_t)0x00008000)        /*!< Abort Request for Mailbox 1 */[m
[32m+[m[32m#define  CAN_TSR_RQCP2                       ((uint32_t)0x00010000)        /*!< Request Completed Mailbox2 */[m
[32m+[m[32m#define  CAN_TSR_TXOK2                       ((uint32_t)0x00020000)        /*!< Transmission OK of Mailbox 2 */[m
[32m+[m[32m#define  CAN_TSR_ALST2                       ((uint32_t)0x00040000)        /*!< Arbitration Lost for mailbox 2 */[m
[32m+[m[32m#define  CAN_TSR_TERR2                       ((uint32_t)0x00080000)        /*!< Transmission Error of Mailbox 2 */[m
[32m+[m[32m#define  CAN_TSR_ABRQ2                       ((uint32_t)0x00800000)        /*!< Abort Request for Mailbox 2 */[m
[32m+[m[32m#define  CAN_TSR_CODE                        ((uint32_t)0x03000000)        /*!< Mailbox Code */[m
[32m+[m
[32m+[m[32m#define  CAN_TSR_TME                         ((uint32_t)0x1C000000)        /*!< TME[2:0] bits */[m
[32m+[m[32m#define  CAN_TSR_TME0                        ((uint32_t)0x04000000)        /*!< Transmit Mailbox 0 Empty */[m
[32m+[m[32m#define  CAN_TSR_TME1                        ((uint32_t)0x08000000)        /*!< Transmit Mailbox 1 Empty */[m
[32m+[m[32m#define  CAN_TSR_TME2                        ((uint32_t)0x10000000)        /*!< Transmit Mailbox 2 Empty */[m
[32m+[m
[32m+[m[32m#define  CAN_TSR_LOW                         ((uint32_t)0xE0000000)        /*!< LOW[2:0] bits */[m
[32m+[m[32m#define  CAN_TSR_LOW0                        ((uint32_t)0x20000000)        /*!< Lowest Priority Flag for Mailbox 0 */[m
[32m+[m[32m#define  CAN_TSR_LOW1                        ((uint32_t)0x40000000)        /*!< Lowest Priority Flag for Mailbox 1 */[m
[32m+[m[32m#define  CAN_TSR_LOW2                        ((uint32_t)0x80000000)        /*!< Lowest Priority Flag for Mailbox 2 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RF0R register  *******************/[m
[32m+[m[32m#define  CAN_RF0R_FMP0                       ((uint8_t)0x03)               /*!< FIFO 0 Message Pending */[m
[32m+[m[32m#define  CAN_RF0R_FULL0                      ((uint8_t)0x08)               /*!< FIFO 0 Full */[m
[32m+[m[32m#define  CAN_RF0R_FOVR0                      ((uint8_t)0x10)               /*!< FIFO 0 Overrun */[m
[32m+[m[32m#define  CAN_RF0R_RFOM0                      ((uint8_t)0x20)               /*!< Release FIFO 0 Output Mailbox */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RF1R register  *******************/[m
[32m+[m[32m#define  CAN_RF1R_FMP1                       ((uint8_t)0x03)               /*!< FIFO 1 Message Pending */[m
[32m+[m[32m#define  CAN_RF1R_FULL1                      ((uint8_t)0x08)               /*!< FIFO 1 Full */[m
[32m+[m[32m#define  CAN_RF1R_FOVR1                      ((uint8_t)0x10)               /*!< FIFO 1 Overrun */[m
[32m+[m[32m#define  CAN_RF1R_RFOM1                      ((uint8_t)0x20)               /*!< Release FIFO 1 Output Mailbox */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CAN_IER register  *******************/[m
[32m+[m[32m#define  CAN_IER_TMEIE                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Empty Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_FMPIE0                      ((uint32_t)0x00000002)        /*!< FIFO Message Pending Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_FFIE0                       ((uint32_t)0x00000004)        /*!< FIFO Full Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_FOVIE0                      ((uint32_t)0x00000008)        /*!< FIFO Overrun Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_FMPIE1                      ((uint32_t)0x00000010)        /*!< FIFO Message Pending Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_FFIE1                       ((uint32_t)0x00000020)        /*!< FIFO Full Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_FOVIE1                      ((uint32_t)0x00000040)        /*!< FIFO Overrun Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_EWGIE                       ((uint32_t)0x00000100)        /*!< Error Warning Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_EPVIE                       ((uint32_t)0x00000200)        /*!< Error Passive Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_BOFIE                       ((uint32_t)0x00000400)        /*!< Bus-Off Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_LECIE                       ((uint32_t)0x00000800)        /*!< Last Error Code Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_ERRIE                       ((uint32_t)0x00008000)        /*!< Error Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_WKUIE                       ((uint32_t)0x00010000)        /*!< Wakeup Interrupt Enable */[m
[32m+[m[32m#define  CAN_IER_SLKIE                       ((uint32_t)0x00020000)        /*!< Sleep Interrupt Enable */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for CAN_ESR register  *******************/[m
[32m+[m[32m#define  CAN_ESR_EWGF                        ((uint32_t)0x00000001)        /*!< Error Warning Flag */[m
[32m+[m[32m#define  CAN_ESR_EPVF                        ((uint32_t)0x00000002)        /*!< Error Passive Flag */[m
[32m+[m[32m#define  CAN_ESR_BOFF                        ((uint32_t)0x00000004)        /*!< Bus-Off Flag */[m
[32m+[m
[32m+[m[32m#define  CAN_ESR_LEC                         ((uint32_t)0x00000070)        /*!< LEC[2:0] bits (Last Error Code) */[m
[32m+[m[32m#define  CAN_ESR_LEC_0                       ((uint32_t)0x00000010)        /*!< Bit 0 */[m
[32m+[m[32m#define  CAN_ESR_LEC_1                       ((uint32_t)0x00000020)        /*!< Bit 1 */[m
[32m+[m[32m#define  CAN_ESR_LEC_2                       ((uint32_t)0x00000040)        /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  CAN_ESR_TEC                         ((uint32_t)0x00FF0000)        /*!< Least significant byte of the 9-bit Transmit Error Counter */[m
[32m+[m[32m#define  CAN_ESR_REC                         ((uint32_t)0xFF000000)        /*!< Receive Error Counter */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_BTR register  ********************/[m
[32m+[m[32m#define  CAN_BTR_BRP                         ((uint32_t)0x000003FF)        /*!< Baud Rate Prescaler */[m
[32m+[m[32m#define  CAN_BTR_TS1                         ((uint32_t)0x000F0000)        /*!< Time Segment 1 */[m
[32m+[m[32m#define  CAN_BTR_TS2                         ((uint32_t)0x00700000)        /*!< Time Segment 2 */[m
[32m+[m[32m#define  CAN_BTR_SJW                         ((uint32_t)0x03000000)        /*!< Resynchronization Jump Width */[m
[32m+[m[32m#define  CAN_BTR_LBKM                        ((uint32_t)0x40000000)        /*!< Loop Back Mode (Debug) */[m
[32m+[m[32m#define  CAN_BTR_SILM                        ((uint32_t)0x80000000)        /*!< Silent Mode */[m
[32m+[m
[32m+[m[32m/*!< Mailbox registers */[m
[32m+[m[32m/******************  Bit definition for CAN_TI0R register  ********************/[m
[32m+[m[32m#define  CAN_TI0R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */[m
[32m+[m[32m#define  CAN_TI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */[m
[32m+[m[32m#define  CAN_TI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */[m
[32m+[m[32m#define  CAN_TI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */[m
[32m+[m[32m#define  CAN_TI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for CAN_TDT0R register  *******************/[m
[32m+[m[32m#define  CAN_TDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */[m
[32m+[m[32m#define  CAN_TDT0R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */[m
[32m+[m[32m#define  CAN_TDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for CAN_TDL0R register  *******************/[m
[32m+[m[32m#define  CAN_TDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */[m
[32m+[m[32m#define  CAN_TDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */[m
[32m+[m[32m#define  CAN_TDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */[m
[32m+[m[32m#define  CAN_TDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for CAN_TDH0R register  *******************/[m
[32m+[m[32m#define  CAN_TDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */[m
[32m+[m[32m#define  CAN_TDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */[m
[32m+[m[32m#define  CAN_TDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */[m
[32m+[m[32m#define  CAN_TDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TI1R register  *******************/[m
[32m+[m[32m#define  CAN_TI1R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */[m
[32m+[m[32m#define  CAN_TI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */[m
[32m+[m[32m#define  CAN_TI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */[m
[32m+[m[32m#define  CAN_TI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */[m
[32m+[m[32m#define  CAN_TI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TDT1R register  ******************/[m
[32m+[m[32m#define  CAN_TDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */[m
[32m+[m[32m#define  CAN_TDT1R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */[m
[32m+[m[32m#define  CAN_TDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TDL1R register  ******************/[m
[32m+[m[32m#define  CAN_TDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */[m
[32m+[m[32m#define  CAN_TDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */[m
[32m+[m[32m#define  CAN_TDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */[m
[32m+[m[32m#define  CAN_TDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TDH1R register  ******************/[m
[32m+[m[32m#define  CAN_TDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */[m
[32m+[m[32m#define  CAN_TDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */[m
[32m+[m[32m#define  CAN_TDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */[m
[32m+[m[32m#define  CAN_TDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TI2R register  *******************/[m
[32m+[m[32m#define  CAN_TI2R_TXRQ                       ((uint32_t)0x00000001)        /*!< Transmit Mailbox Request */[m
[32m+[m[32m#define  CAN_TI2R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */[m
[32m+[m[32m#define  CAN_TI2R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */[m
[32m+[m[32m#define  CAN_TI2R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */[m
[32m+[m[32m#define  CAN_TI2R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TDT2R register  ******************/[m[41m  [m
[32m+[m[32m#define  CAN_TDT2R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */[m
[32m+[m[32m#define  CAN_TDT2R_TGT                       ((uint32_t)0x00000100)        /*!< Transmit Global Time */[m
[32m+[m[32m#define  CAN_TDT2R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TDL2R register  ******************/[m
[32m+[m[32m#define  CAN_TDL2R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */[m
[32m+[m[32m#define  CAN_TDL2R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */[m
[32m+[m[32m#define  CAN_TDL2R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */[m
[32m+[m[32m#define  CAN_TDL2R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_TDH2R register  ******************/[m
[32m+[m[32m#define  CAN_TDH2R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */[m
[32m+[m[32m#define  CAN_TDH2R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */[m
[32m+[m[32m#define  CAN_TDH2R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */[m
[32m+[m[32m#define  CAN_TDH2R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RI0R register  *******************/[m
[32m+[m[32m#define  CAN_RI0R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */[m
[32m+[m[32m#define  CAN_RI0R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */[m
[32m+[m[32m#define  CAN_RI0R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended Identifier */[m
[32m+[m[32m#define  CAN_RI0R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RDT0R register  ******************/[m
[32m+[m[32m#define  CAN_RDT0R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */[m
[32m+[m[32m#define  CAN_RDT0R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */[m
[32m+[m[32m#define  CAN_RDT0R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RDL0R register  ******************/[m
[32m+[m[32m#define  CAN_RDL0R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */[m
[32m+[m[32m#define  CAN_RDL0R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */[m
[32m+[m[32m#define  CAN_RDL0R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */[m
[32m+[m[32m#define  CAN_RDL0R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RDH0R register  ******************/[m
[32m+[m[32m#define  CAN_RDH0R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */[m
[32m+[m[32m#define  CAN_RDH0R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */[m
[32m+[m[32m#define  CAN_RDH0R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */[m
[32m+[m[32m#define  CAN_RDH0R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RI1R register  *******************/[m
[32m+[m[32m#define  CAN_RI1R_RTR                        ((uint32_t)0x00000002)        /*!< Remote Transmission Request */[m
[32m+[m[32m#define  CAN_RI1R_IDE                        ((uint32_t)0x00000004)        /*!< Identifier Extension */[m
[32m+[m[32m#define  CAN_RI1R_EXID                       ((uint32_t)0x001FFFF8)        /*!< Extended identifier */[m
[32m+[m[32m#define  CAN_RI1R_STID                       ((uint32_t)0xFFE00000)        /*!< Standard Identifier or Extended Identifier */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RDT1R register  ******************/[m
[32m+[m[32m#define  CAN_RDT1R_DLC                       ((uint32_t)0x0000000F)        /*!< Data Length Code */[m
[32m+[m[32m#define  CAN_RDT1R_FMI                       ((uint32_t)0x0000FF00)        /*!< Filter Match Index */[m
[32m+[m[32m#define  CAN_RDT1R_TIME                      ((uint32_t)0xFFFF0000)        /*!< Message Time Stamp */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RDL1R register  ******************/[m
[32m+[m[32m#define  CAN_RDL1R_DATA0                     ((uint32_t)0x000000FF)        /*!< Data byte 0 */[m
[32m+[m[32m#define  CAN_RDL1R_DATA1                     ((uint32_t)0x0000FF00)        /*!< Data byte 1 */[m
[32m+[m[32m#define  CAN_RDL1R_DATA2                     ((uint32_t)0x00FF0000)        /*!< Data byte 2 */[m
[32m+[m[32m#define  CAN_RDL1R_DATA3                     ((uint32_t)0xFF000000)        /*!< Data byte 3 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_RDH1R register  ******************/[m
[32m+[m[32m#define  CAN_RDH1R_DATA4                     ((uint32_t)0x000000FF)        /*!< Data byte 4 */[m
[32m+[m[32m#define  CAN_RDH1R_DATA5                     ((uint32_t)0x0000FF00)        /*!< Data byte 5 */[m
[32m+[m[32m#define  CAN_RDH1R_DATA6                     ((uint32_t)0x00FF0000)        /*!< Data byte 6 */[m
[32m+[m[32m#define  CAN_RDH1R_DATA7                     ((uint32_t)0xFF000000)        /*!< Data byte 7 */[m
[32m+[m
[32m+[m[32m/*!< CAN filter registers */[m
[32m+[m[32m/*******************  Bit definition for CAN_FMR register  ********************/[m
[32m+[m[32m#define  CAN_FMR_FINIT                       ((uint8_t)0x01)               /*!< Filter Init Mode */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_FM1R register  *******************/[m
[32m+[m[32m#define  CAN_FM1R_FBM                        ((uint16_t)0x3FFF)            /*!< Filter Mode */[m
[32m+[m[32m#define  CAN_FM1R_FBM0                       ((uint16_t)0x0001)            /*!< Filter Init Mode bit 0 */[m
[32m+[m[32m#define  CAN_FM1R_FBM1                       ((uint16_t)0x0002)            /*!< Filter Init Mode bit 1 */[m
[32m+[m[32m#define  CAN_FM1R_FBM2                       ((uint16_t)0x0004)            /*!< Filter Init Mode bit 2 */[m
[32m+[m[32m#define  CAN_FM1R_FBM3                       ((uint16_t)0x0008)            /*!< Filter Init Mode bit 3 */[m
[32m+[m[32m#define  CAN_FM1R_FBM4                       ((uint16_t)0x0010)            /*!< Filter Init Mode bit 4 */[m
[32m+[m[32m#define  CAN_FM1R_FBM5                       ((uint16_t)0x0020)            /*!< Filter Init Mode bit 5 */[m
[32m+[m[32m#define  CAN_FM1R_FBM6                       ((uint16_t)0x0040)            /*!< Filter Init Mode bit 6 */[m
[32m+[m[32m#define  CAN_FM1R_FBM7                       ((uint16_t)0x0080)            /*!< Filter Init Mode bit 7 */[m
[32m+[m[32m#define  CAN_FM1R_FBM8                       ((uint16_t)0x0100)            /*!< Filter Init Mode bit 8 */[m
[32m+[m[32m#define  CAN_FM1R_FBM9                       ((uint16_t)0x0200)            /*!< Filter Init Mode bit 9 */[m
[32m+[m[32m#define  CAN_FM1R_FBM10                      ((uint16_t)0x0400)            /*!< Filter Init Mode bit 10 */[m
[32m+[m[32m#define  CAN_FM1R_FBM11                      ((uint16_t)0x0800)            /*!< Filter Init Mode bit 11 */[m
[32m+[m[32m#define  CAN_FM1R_FBM12                      ((uint16_t)0x1000)            /*!< Filter Init Mode bit 12 */[m
[32m+[m[32m#define  CAN_FM1R_FBM13                      ((uint16_t)0x2000)            /*!< Filter Init Mode bit 13 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_FS1R register  *******************/[m
[32m+[m[32m#define  CAN_FS1R_FSC                        ((uint16_t)0x3FFF)            /*!< Filter Scale Configuration */[m
[32m+[m[32m#define  CAN_FS1R_FSC0                       ((uint16_t)0x0001)            /*!< Filter Scale Configuration bit 0 */[m
[32m+[m[32m#define  CAN_FS1R_FSC1                       ((uint16_t)0x0002)            /*!< Filter Scale Configuration bit 1 */[m
[32m+[m[32m#define  CAN_FS1R_FSC2                       ((uint16_t)0x0004)            /*!< Filter Scale Configuration bit 2 */[m
[32m+[m[32m#define  CAN_FS1R_FSC3                       ((uint16_t)0x0008)            /*!< Filter Scale Configuration bit 3 */[m
[32m+[m[32m#define  CAN_FS1R_FSC4                       ((uint16_t)0x0010)            /*!< Filter Scale Configuration bit 4 */[m
[32m+[m[32m#define  CAN_FS1R_FSC5                       ((uint16_t)0x0020)            /*!< Filter Scale Configuration bit 5 */[m
[32m+[m[32m#define  CAN_FS1R_FSC6                       ((uint16_t)0x0040)            /*!< Filter Scale Configuration bit 6 */[m
[32m+[m[32m#define  CAN_FS1R_FSC7                       ((uint16_t)0x0080)            /*!< Filter Scale Configuration bit 7 */[m
[32m+[m[32m#define  CAN_FS1R_FSC8                       ((uint16_t)0x0100)            /*!< Filter Scale Configuration bit 8 */[m
[32m+[m[32m#define  CAN_FS1R_FSC9                       ((uint16_t)0x0200)            /*!< Filter Scale Configuration bit 9 */[m
[32m+[m[32m#define  CAN_FS1R_FSC10                      ((uint16_t)0x0400)            /*!< Filter Scale Configuration bit 10 */[m
[32m+[m[32m#define  CAN_FS1R_FSC11                      ((uint16_t)0x0800)            /*!< Filter Scale Configuration bit 11 */[m
[32m+[m[32m#define  CAN_FS1R_FSC12                      ((uint16_t)0x1000)            /*!< Filter Scale Configuration bit 12 */[m
[32m+[m[32m#define  CAN_FS1R_FSC13                      ((uint16_t)0x2000)            /*!< Filter Scale Configuration bit 13 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for CAN_FFA1R register  *******************/[m
[32m+[m[32m#define  CAN_FFA1R_FFA                       ((uint16_t)0x3FFF)            /*!< Filter FIFO Assignment */[m
[32m+[m[32m#define  CAN_FFA1R_FFA0                      ((uint16_t)0x0001)            /*!< Filter FIFO Assignment for Filter 0 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA1                      ((uint16_t)0x0002)            /*!< Filter FIFO Assignment for Filter 1 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA2                      ((uint16_t)0x0004)            /*!< Filter FIFO Assignment for Filter 2 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA3                      ((uint16_t)0x0008)            /*!< Filter FIFO Assignment for Filter 3 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA4                      ((uint16_t)0x0010)            /*!< Filter FIFO Assignment for Filter 4 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA5                      ((uint16_t)0x0020)            /*!< Filter FIFO Assignment for Filter 5 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA6                      ((uint16_t)0x0040)            /*!< Filter FIFO Assignment for Filter 6 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA7                      ((uint16_t)0x0080)            /*!< Filter FIFO Assignment for Filter 7 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA8                      ((uint16_t)0x0100)            /*!< Filter FIFO Assignment for Filter 8 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA9                      ((uint16_t)0x0200)            /*!< Filter FIFO Assignment for Filter 9 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA10                     ((uint16_t)0x0400)            /*!< Filter FIFO Assignment for Filter 10 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA11                     ((uint16_t)0x0800)            /*!< Filter FIFO Assignment for Filter 11 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA12                     ((uint16_t)0x1000)            /*!< Filter FIFO Assignment for Filter 12 */[m
[32m+[m[32m#define  CAN_FFA1R_FFA13                     ((uint16_t)0x2000)            /*!< Filter FIFO Assignment for Filter 13 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_FA1R register  *******************/[m
[32m+[m[32m#define  CAN_FA1R_FACT                       ((uint16_t)0x3FFF)            /*!< Filter Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT0                      ((uint16_t)0x0001)            /*!< Filter 0 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT1                      ((uint16_t)0x0002)            /*!< Filter 1 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT2                      ((uint16_t)0x0004)            /*!< Filter 2 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT3                      ((uint16_t)0x0008)            /*!< Filter 3 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT4                      ((uint16_t)0x0010)            /*!< Filter 4 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT5                      ((uint16_t)0x0020)            /*!< Filter 5 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT6                      ((uint16_t)0x0040)            /*!< Filter 6 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT7                      ((uint16_t)0x0080)            /*!< Filter 7 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT8                      ((uint16_t)0x0100)            /*!< Filter 8 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT9                      ((uint16_t)0x0200)            /*!< Filter 9 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT10                     ((uint16_t)0x0400)            /*!< Filter 10 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT11                     ((uint16_t)0x0800)            /*!< Filter 11 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT12                     ((uint16_t)0x1000)            /*!< Filter 12 Active */[m
[32m+[m[32m#define  CAN_FA1R_FACT13                     ((uint16_t)0x2000)            /*!< Filter 13 Active */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F0R1 register  *******************/[m
[32m+[m[32m#define  CAN_F0R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F0R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F0R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F0R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F0R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F0R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F0R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F0R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F0R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F0R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F0R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F0R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F0R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F0R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F0R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F0R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F0R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F0R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F0R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F0R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F0R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F0R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F0R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F0R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F0R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F0R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F0R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F0R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F0R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F0R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F0R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F0R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F1R1 register  *******************/[m
[32m+[m[32m#define  CAN_F1R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F1R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F1R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F1R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F1R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F1R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F1R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F1R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F1R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F1R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F1R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F1R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F1R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F1R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F1R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F1R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F1R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F1R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F1R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F1R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F1R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F1R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F1R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F1R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F1R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F1R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F1R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F1R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F1R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F1R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F1R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F1R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F2R1 register  *******************/[m
[32m+[m[32m#define  CAN_F2R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F2R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F2R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F2R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F2R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F2R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F2R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F2R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F2R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F2R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F2R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F2R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F2R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F2R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F2R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F2R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F2R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F2R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F2R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F2R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F2R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F2R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F2R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F2R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F2R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F2R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F2R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F2R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F2R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F2R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F2R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F2R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F3R1 register  *******************/[m
[32m+[m[32m#define  CAN_F3R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F3R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F3R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F3R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F3R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F3R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F3R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F3R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F3R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F3R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F3R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F3R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F3R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F3R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F3R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F3R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F3R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F3R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F3R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F3R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F3R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F3R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F3R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F3R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F3R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F3R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F3R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F3R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F3R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F3R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F3R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F3R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F4R1 register  *******************/[m
[32m+[m[32m#define  CAN_F4R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F4R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F4R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F4R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F4R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F4R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F4R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F4R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F4R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F4R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F4R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F4R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F4R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F4R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F4R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F4R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F4R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F4R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F4R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F4R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F4R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F4R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F4R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F4R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F4R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F4R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F4R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F4R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F4R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F4R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F4R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F4R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F5R1 register  *******************/[m
[32m+[m[32m#define  CAN_F5R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F5R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F5R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F5R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F5R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F5R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F5R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F5R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F5R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F5R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F5R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F5R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F5R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F5R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F5R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F5R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F5R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F5R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F5R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F5R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F5R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F5R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F5R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F5R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F5R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F5R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F5R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F5R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F5R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F5R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F5R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F5R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F6R1 register  *******************/[m
[32m+[m[32m#define  CAN_F6R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F6R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F6R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F6R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F6R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F6R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F6R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F6R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F6R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F6R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F6R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F6R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F6R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F6R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F6R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F6R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F6R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F6R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F6R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F6R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F6R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F6R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F6R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F6R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F6R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F6R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F6R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F6R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F6R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F6R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F6R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F6R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F7R1 register  *******************/[m
[32m+[m[32m#define  CAN_F7R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F7R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F7R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F7R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F7R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F7R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F7R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F7R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F7R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F7R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F7R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F7R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F7R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F7R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F7R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F7R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F7R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F7R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F7R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F7R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F7R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F7R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F7R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F7R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F7R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F7R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F7R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F7R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F7R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F7R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F7R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F7R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F8R1 register  *******************/[m
[32m+[m[32m#define  CAN_F8R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F8R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F8R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F8R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F8R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F8R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F8R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F8R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F8R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F8R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F8R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F8R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F8R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F8R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F8R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F8R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F8R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F8R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F8R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F8R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F8R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F8R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F8R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F8R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F8R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F8R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F8R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F8R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F8R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F8R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F8R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F8R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F9R1 register  *******************/[m
[32m+[m[32m#define  CAN_F9R1_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F9R1_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F9R1_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F9R1_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F9R1_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F9R1_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F9R1_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F9R1_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F9R1_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F9R1_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F9R1_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F9R1_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F9R1_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F9R1_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F9R1_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F9R1_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F9R1_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F9R1_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F9R1_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F9R1_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F9R1_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F9R1_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F9R1_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F9R1_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F9R1_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F9R1_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F9R1_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F9R1_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F9R1_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F9R1_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F9R1_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F9R1_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F10R1 register  ******************/[m
[32m+[m[32m#define  CAN_F10R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F10R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F10R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F10R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F10R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F10R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F10R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F10R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F10R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F10R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F10R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F10R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F10R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F10R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F10R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F10R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F10R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F10R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F10R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F10R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F10R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F10R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F10R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F10R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F10R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F10R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F10R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F10R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F10R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F10R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F10R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F10R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F11R1 register  ******************/[m
[32m+[m[32m#define  CAN_F11R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F11R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F11R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F11R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F11R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F11R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F11R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F11R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F11R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F11R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F11R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F11R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F11R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F11R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F11R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F11R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F11R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F11R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F11R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F11R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F11R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F11R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F11R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F11R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F11R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F11R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F11R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F11R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F11R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F11R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F11R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F11R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F12R1 register  ******************/[m
[32m+[m[32m#define  CAN_F12R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F12R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F12R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F12R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F12R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F12R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F12R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F12R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F12R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F12R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F12R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F12R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F12R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F12R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F12R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F12R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F12R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F12R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F12R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F12R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F12R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F12R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F12R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F12R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F12R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F12R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F12R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F12R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F12R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F12R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F12R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F12R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F13R1 register  ******************/[m
[32m+[m[32m#define  CAN_F13R1_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F13R1_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F13R1_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F13R1_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F13R1_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F13R1_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F13R1_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F13R1_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F13R1_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F13R1_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F13R1_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F13R1_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F13R1_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F13R1_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F13R1_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F13R1_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F13R1_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F13R1_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F13R1_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F13R1_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F13R1_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F13R1_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F13R1_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F13R1_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F13R1_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F13R1_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F13R1_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F13R1_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F13R1_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F13R1_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F13R1_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F13R1_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F0R2 register  *******************/[m
[32m+[m[32m#define  CAN_F0R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F0R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F0R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F0R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F0R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F0R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F0R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F0R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F0R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F0R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F0R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F0R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F0R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F0R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F0R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F0R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F0R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F0R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F0R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F0R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F0R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F0R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F0R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F0R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F0R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F0R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F0R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F0R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F0R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F0R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F0R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F0R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F1R2 register  *******************/[m
[32m+[m[32m#define  CAN_F1R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F1R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F1R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F1R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F1R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F1R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F1R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F1R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F1R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F1R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F1R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F1R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F1R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F1R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F1R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F1R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F1R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F1R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F1R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F1R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F1R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F1R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F1R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F1R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F1R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F1R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F1R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F1R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F1R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F1R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F1R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F1R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F2R2 register  *******************/[m
[32m+[m[32m#define  CAN_F2R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F2R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F2R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F2R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F2R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F2R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F2R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F2R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F2R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F2R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F2R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F2R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F2R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F2R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F2R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F2R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F2R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F2R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F2R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F2R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F2R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F2R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F2R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F2R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F2R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F2R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F2R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F2R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F2R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F2R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F2R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F2R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F3R2 register  *******************/[m
[32m+[m[32m#define  CAN_F3R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F3R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F3R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F3R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F3R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F3R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F3R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F3R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F3R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F3R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F3R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F3R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F3R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F3R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F3R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F3R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F3R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F3R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F3R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F3R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F3R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F3R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F3R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F3R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F3R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F3R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F3R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F3R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F3R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F3R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F3R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F3R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F4R2 register  *******************/[m
[32m+[m[32m#define  CAN_F4R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F4R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F4R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F4R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F4R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F4R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F4R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F4R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F4R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F4R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F4R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F4R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F4R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F4R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F4R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F4R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F4R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F4R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F4R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F4R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F4R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F4R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F4R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F4R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F4R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F4R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F4R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F4R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F4R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F4R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F4R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F4R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F5R2 register  *******************/[m
[32m+[m[32m#define  CAN_F5R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F5R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F5R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F5R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F5R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F5R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F5R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F5R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F5R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F5R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F5R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F5R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F5R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F5R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F5R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F5R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F5R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F5R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F5R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F5R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F5R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F5R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F5R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F5R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F5R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F5R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F5R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F5R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F5R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F5R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F5R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F5R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F6R2 register  *******************/[m
[32m+[m[32m#define  CAN_F6R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F6R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F6R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F6R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F6R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F6R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F6R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F6R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F6R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F6R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F6R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F6R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F6R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F6R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F6R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F6R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F6R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F6R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F6R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F6R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F6R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F6R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F6R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F6R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F6R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F6R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F6R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F6R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F6R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F6R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F6R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F6R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F7R2 register  *******************/[m
[32m+[m[32m#define  CAN_F7R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F7R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F7R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F7R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F7R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F7R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F7R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F7R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F7R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F7R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F7R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F7R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F7R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F7R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F7R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F7R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F7R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F7R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F7R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F7R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F7R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F7R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F7R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F7R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F7R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F7R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F7R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F7R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F7R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F7R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F7R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F7R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F8R2 register  *******************/[m
[32m+[m[32m#define  CAN_F8R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F8R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F8R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F8R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F8R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F8R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F8R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F8R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F8R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F8R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F8R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F8R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F8R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F8R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F8R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F8R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F8R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F8R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F8R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F8R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F8R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F8R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F8R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F8R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F8R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F8R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F8R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F8R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F8R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F8R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F8R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F8R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F9R2 register  *******************/[m
[32m+[m[32m#define  CAN_F9R2_FB0                        ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F9R2_FB1                        ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F9R2_FB2                        ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F9R2_FB3                        ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F9R2_FB4                        ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F9R2_FB5                        ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F9R2_FB6                        ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F9R2_FB7                        ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F9R2_FB8                        ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F9R2_FB9                        ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F9R2_FB10                       ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F9R2_FB11                       ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F9R2_FB12                       ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F9R2_FB13                       ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F9R2_FB14                       ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F9R2_FB15                       ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F9R2_FB16                       ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F9R2_FB17                       ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F9R2_FB18                       ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F9R2_FB19                       ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F9R2_FB20                       ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F9R2_FB21                       ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F9R2_FB22                       ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F9R2_FB23                       ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F9R2_FB24                       ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F9R2_FB25                       ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F9R2_FB26                       ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F9R2_FB27                       ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F9R2_FB28                       ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F9R2_FB29                       ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F9R2_FB30                       ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F9R2_FB31                       ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F10R2 register  ******************/[m
[32m+[m[32m#define  CAN_F10R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F10R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F10R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F10R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F10R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F10R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F10R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F10R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F10R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F10R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F10R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F10R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F10R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F10R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F10R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F10R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F10R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F10R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F10R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F10R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F10R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F10R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F10R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F10R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F10R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F10R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F10R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F10R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F10R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F10R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F10R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F10R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F11R2 register  ******************/[m
[32m+[m[32m#define  CAN_F11R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F11R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F11R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F11R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F11R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F11R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F11R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F11R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F11R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F11R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F11R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F11R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F11R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F11R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F11R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F11R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F11R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F11R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F11R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F11R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F11R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F11R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F11R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F11R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F11R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F11R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F11R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F11R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F11R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F11R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F11R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F11R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F12R2 register  ******************/[m
[32m+[m[32m#define  CAN_F12R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F12R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F12R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F12R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F12R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F12R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F12R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F12R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F12R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F12R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F12R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F12R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F12R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F12R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F12R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F12R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F12R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F12R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F12R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F12R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F12R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F12R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F12R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F12R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F12R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F12R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F12R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F12R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F12R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F12R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F12R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F12R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for CAN_F13R2 register  ******************/[m
[32m+[m[32m#define  CAN_F13R2_FB0                       ((uint32_t)0x00000001)        /*!< Filter bit 0 */[m
[32m+[m[32m#define  CAN_F13R2_FB1                       ((uint32_t)0x00000002)        /*!< Filter bit 1 */[m
[32m+[m[32m#define  CAN_F13R2_FB2                       ((uint32_t)0x00000004)        /*!< Filter bit 2 */[m
[32m+[m[32m#define  CAN_F13R2_FB3                       ((uint32_t)0x00000008)        /*!< Filter bit 3 */[m
[32m+[m[32m#define  CAN_F13R2_FB4                       ((uint32_t)0x00000010)        /*!< Filter bit 4 */[m
[32m+[m[32m#define  CAN_F13R2_FB5                       ((uint32_t)0x00000020)        /*!< Filter bit 5 */[m
[32m+[m[32m#define  CAN_F13R2_FB6                       ((uint32_t)0x00000040)        /*!< Filter bit 6 */[m
[32m+[m[32m#define  CAN_F13R2_FB7                       ((uint32_t)0x00000080)        /*!< Filter bit 7 */[m
[32m+[m[32m#define  CAN_F13R2_FB8                       ((uint32_t)0x00000100)        /*!< Filter bit 8 */[m
[32m+[m[32m#define  CAN_F13R2_FB9                       ((uint32_t)0x00000200)        /*!< Filter bit 9 */[m
[32m+[m[32m#define  CAN_F13R2_FB10                      ((uint32_t)0x00000400)        /*!< Filter bit 10 */[m
[32m+[m[32m#define  CAN_F13R2_FB11                      ((uint32_t)0x00000800)        /*!< Filter bit 11 */[m
[32m+[m[32m#define  CAN_F13R2_FB12                      ((uint32_t)0x00001000)        /*!< Filter bit 12 */[m
[32m+[m[32m#define  CAN_F13R2_FB13                      ((uint32_t)0x00002000)        /*!< Filter bit 13 */[m
[32m+[m[32m#define  CAN_F13R2_FB14                      ((uint32_t)0x00004000)        /*!< Filter bit 14 */[m
[32m+[m[32m#define  CAN_F13R2_FB15                      ((uint32_t)0x00008000)        /*!< Filter bit 15 */[m
[32m+[m[32m#define  CAN_F13R2_FB16                      ((uint32_t)0x00010000)        /*!< Filter bit 16 */[m
[32m+[m[32m#define  CAN_F13R2_FB17                      ((uint32_t)0x00020000)        /*!< Filter bit 17 */[m
[32m+[m[32m#define  CAN_F13R2_FB18                      ((uint32_t)0x00040000)        /*!< Filter bit 18 */[m
[32m+[m[32m#define  CAN_F13R2_FB19                      ((uint32_t)0x00080000)        /*!< Filter bit 19 */[m
[32m+[m[32m#define  CAN_F13R2_FB20                      ((uint32_t)0x00100000)        /*!< Filter bit 20 */[m
[32m+[m[32m#define  CAN_F13R2_FB21                      ((uint32_t)0x00200000)        /*!< Filter bit 21 */[m
[32m+[m[32m#define  CAN_F13R2_FB22                      ((uint32_t)0x00400000)        /*!< Filter bit 22 */[m
[32m+[m[32m#define  CAN_F13R2_FB23                      ((uint32_t)0x00800000)        /*!< Filter bit 23 */[m
[32m+[m[32m#define  CAN_F13R2_FB24                      ((uint32_t)0x01000000)        /*!< Filter bit 24 */[m
[32m+[m[32m#define  CAN_F13R2_FB25                      ((uint32_t)0x02000000)        /*!< Filter bit 25 */[m
[32m+[m[32m#define  CAN_F13R2_FB26                      ((uint32_t)0x04000000)        /*!< Filter bit 26 */[m
[32m+[m[32m#define  CAN_F13R2_FB27                      ((uint32_t)0x08000000)        /*!< Filter bit 27 */[m
[32m+[m[32m#define  CAN_F13R2_FB28                      ((uint32_t)0x10000000)        /*!< Filter bit 28 */[m
[32m+[m[32m#define  CAN_F13R2_FB29                      ((uint32_t)0x20000000)        /*!< Filter bit 29 */[m
[32m+[m[32m#define  CAN_F13R2_FB30                      ((uint32_t)0x40000000)        /*!< Filter bit 30 */[m
[32m+[m[32m#define  CAN_F13R2_FB31                      ((uint32_t)0x80000000)        /*!< Filter bit 31 */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                        Serial Peripheral Interface                         */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SPI_CR1 register  ********************/[m
[32m+[m[32m#define  SPI_CR1_CPHA                        ((uint16_t)0x0001)            /*!< Clock Phase */[m
[32m+[m[32m#define  SPI_CR1_CPOL                        ((uint16_t)0x0002)            /*!< Clock Polarity */[m
[32m+[m[32m#define  SPI_CR1_MSTR                        ((uint16_t)0x0004)            /*!< Master Selection */[m
[32m+[m
[32m+[m[32m#define  SPI_CR1_BR                          ((uint16_t)0x0038)            /*!< BR[2:0] bits (Baud Rate Control) */[m
[32m+[m[32m#define  SPI_CR1_BR_0                        ((uint16_t)0x0008)            /*!< Bit 0 */[m
[32m+[m[32m#define  SPI_CR1_BR_1                        ((uint16_t)0x0010)            /*!< Bit 1 */[m
[32m+[m[32m#define  SPI_CR1_BR_2                        ((uint16_t)0x0020)            /*!< Bit 2 */[m
[32m+[m
[32m+[m[32m#define  SPI_CR1_SPE                         ((uint16_t)0x0040)            /*!< SPI Enable */[m
[32m+[m[32m#define  SPI_CR1_LSBFIRST                    ((uint16_t)0x0080)            /*!< Frame Format */[m
[32m+[m[32m#define  SPI_CR1_SSI                         ((uint16_t)0x0100)            /*!< Internal slave select */[m
[32m+[m[32m#define  SPI_CR1_SSM                         ((uint16_t)0x0200)            /*!< Software slave management */[m
[32m+[m[32m#define  SPI_CR1_RXONLY                      ((uint16_t)0x0400)            /*!< Receive only */[m
[32m+[m[32m#define  SPI_CR1_DFF                         ((uint16_t)0x0800)            /*!< Data Frame Format */[m
[32m+[m[32m#define  SPI_CR1_CRCNEXT                     ((uint16_t)0x1000)            /*!< Transmit CRC next */[m
[32m+[m[32m#define  SPI_CR1_CRCEN                       ((uint16_t)0x2000)            /*!< Hardware CRC calculation enable */[m
[32m+[m[32m#define  SPI_CR1_BIDIOE                      ((uint16_t)0x4000)            /*!< Output enable in bidirectional mode */[m
[32m+[m[32m#define  SPI_CR1_BIDIMODE                    ((uint16_t)0x8000)            /*!< Bidirectional data mode enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SPI_CR2 register  ********************/[m
[32m+[m[32m#define  SPI_CR2_RXDMAEN                     ((uint8_t)0x01)               /*!< Rx Buffer DMA Enable */[m
[32m+[m[32m#define  SPI_CR2_TXDMAEN                     ((uint8_t)0x02)               /*!< Tx Buffer DMA Enable */[m
[32m+[m[32m#define  SPI_CR2_SSOE                        ((uint8_t)0x04)               /*!< SS Output Enable */[m
[32m+[m[32m#define  SPI_CR2_ERRIE                       ((uint8_t)0x20)               /*!< Error Interrupt Enable */[m
[32m+[m[32m#define  SPI_CR2_RXNEIE                      ((uint8_t)0x40)               /*!< RX buffer Not Empty Interrupt Enable */[m
[32m+[m[32m#define  SPI_CR2_TXEIE                       ((uint8_t)0x80)               /*!< Tx buffer Empty Interrupt Enable */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for SPI_SR register  ********************/[m
[32m+[m[32m#define  SPI_SR_RXNE                         ((uint8_t)0x01)               /*!< Receive buffer Not Empty */[m
[32m+[m[32m#define  SPI_SR_TXE                          ((uint8_t)0x02)               /*!< Transmit buffer Empty */[m
[32m+[m[32m#define  SPI_SR_CHSIDE                       ((uint8_t)0x04)               /*!< Channel side */[m
[32m+[m[32m#define  SPI_SR_UDR                          ((uint8_t)0x08)               /*!< Underrun flag */[m
[32m+[m[32m#define  SPI_SR_CRCERR                       ((uint8_t)0x10)               /*!< CRC Error flag */[m
[32m+[m[32m#define  SPI_SR_MODF                         ((uint8_t)0x20)               /*!< Mode fault */[m
[32m+[m[32m#define  SPI_SR_OVR                          ((uint8_t)0x40)               /*!< Overrun flag */[m
[32m+[m[32m#define  SPI_SR_BSY                          ((uint8_t)0x80)               /*!< Busy flag */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for SPI_DR register  ********************/[m
[32m+[m[32m#define  SPI_DR_DR                           ((uint16_t)0xFFFF)            /*!< Data Register */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for SPI_CRCPR register  ******************/[m
[32m+[m[32m#define  SPI_CRCPR_CRCPOLY                   ((uint16_t)0xFFFF)            /*!< CRC polynomial register */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SPI_RXCRCR register  ******************/[m
[32m+[m[32m#define  SPI_RXCRCR_RXCRC                    ((uint16_t)0xFFFF)            /*!< Rx CRC Register */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SPI_TXCRCR register  ******************/[m
[32m+[m[32m#define  SPI_TXCRCR_TXCRC                    ((uint16_t)0xFFFF)            /*!< Tx CRC Register */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SPI_I2SCFGR register  *****************/[m
[32m+[m[32m#define  SPI_I2SCFGR_CHLEN                   ((uint16_t)0x0001)            /*!< Channel length (number of bits per audio channel) */[m
[32m+[m
[32m+[m[32m#define  SPI_I2SCFGR_DATLEN                  ((uint16_t)0x0006)            /*!< DATLEN[1:0] bits (Data length to be transferred) */[m
[32m+[m[32m#define  SPI_I2SCFGR_DATLEN_0                ((uint16_t)0x0002)            /*!< Bit 0 */[m
[32m+[m[32m#define  SPI_I2SCFGR_DATLEN_1                ((uint16_t)0x0004)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  SPI_I2SCFGR_CKPOL                   ((uint16_t)0x0008)            /*!< steady state clock polarity */[m
[32m+[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SSTD                  ((uint16_t)0x0030)            /*!< I2SSTD[1:0] bits (I2S standard selection) */[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SSTD_0                ((uint16_t)0x0010)            /*!< Bit 0 */[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SSTD_1                ((uint16_t)0x0020)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  SPI_I2SCFGR_PCMSYNC                 ((uint16_t)0x0080)            /*!< PCM frame synchronization */[m
[32m+[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SCFG                  ((uint16_t)0x0300)            /*!< I2SCFG[1:0] bits (I2S configuration mode) */[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SCFG_0                ((uint16_t)0x0100)            /*!< Bit 0 */[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SCFG_1                ((uint16_t)0x0200)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SE                    ((uint16_t)0x0400)            /*!< I2S Enable */[m
[32m+[m[32m#define  SPI_I2SCFGR_I2SMOD                  ((uint16_t)0x0800)            /*!< I2S mode selection */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for SPI_I2SPR register  *******************/[m
[32m+[m[32m#define  SPI_I2SPR_I2SDIV                    ((uint16_t)0x00FF)            /*!< I2S Linear prescaler */[m
[32m+[m[32m#define  SPI_I2SPR_ODD                       ((uint16_t)0x0100)            /*!< Odd factor for the prescaler */[m
[32m+[m[32m#define  SPI_I2SPR_MCKOE                     ((uint16_t)0x0200)            /*!< Master Clock Output Enable */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                      Inter-integrated Circuit Interface                    */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_CR1 register  ********************/[m
[32m+[m[32m#define  I2C_CR1_PE                          ((uint16_t)0x0001)            /*!< Peripheral Enable */[m
[32m+[m[32m#define  I2C_CR1_SMBUS                       ((uint16_t)0x0002)            /*!< SMBus Mode */[m
[32m+[m[32m#define  I2C_CR1_SMBTYPE                     ((uint16_t)0x0008)            /*!< SMBus Type */[m
[32m+[m[32m#define  I2C_CR1_ENARP                       ((uint16_t)0x0010)            /*!< ARP Enable */[m
[32m+[m[32m#define  I2C_CR1_ENPEC                       ((uint16_t)0x0020)            /*!< PEC Enable */[m
[32m+[m[32m#define  I2C_CR1_ENGC                        ((uint16_t)0x0040)            /*!< General Call Enable */[m
[32m+[m[32m#define  I2C_CR1_NOSTRETCH                   ((uint16_t)0x0080)            /*!< Clock Stretching Disable (Slave mode) */[m
[32m+[m[32m#define  I2C_CR1_START                       ((uint16_t)0x0100)            /*!< Start Generation */[m
[32m+[m[32m#define  I2C_CR1_STOP                        ((uint16_t)0x0200)            /*!< Stop Generation */[m
[32m+[m[32m#define  I2C_CR1_ACK                         ((uint16_t)0x0400)            /*!< Acknowledge Enable */[m
[32m+[m[32m#define  I2C_CR1_POS                         ((uint16_t)0x0800)            /*!< Acknowledge/PEC Position (for data reception) */[m
[32m+[m[32m#define  I2C_CR1_PEC                         ((uint16_t)0x1000)            /*!< Packet Error Checking */[m
[32m+[m[32m#define  I2C_CR1_ALERT                       ((uint16_t)0x2000)            /*!< SMBus Alert */[m
[32m+[m[32m#define  I2C_CR1_SWRST                       ((uint16_t)0x8000)            /*!< Software Reset */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_CR2 register  ********************/[m
[32m+[m[32m#define  I2C_CR2_FREQ                        ((uint16_t)0x003F)            /*!< FREQ[5:0] bits (Peripheral Clock Frequency) */[m
[32m+[m[32m#define  I2C_CR2_FREQ_0                      ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  I2C_CR2_FREQ_1                      ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  I2C_CR2_FREQ_2                      ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m[32m#define  I2C_CR2_FREQ_3                      ((uint16_t)0x0008)            /*!< Bit 3 */[m
[32m+[m[32m#define  I2C_CR2_FREQ_4                      ((uint16_t)0x0010)            /*!< Bit 4 */[m
[32m+[m[32m#define  I2C_CR2_FREQ_5                      ((uint16_t)0x0020)            /*!< Bit 5 */[m
[32m+[m
[32m+[m[32m#define  I2C_CR2_ITERREN                     ((uint16_t)0x0100)            /*!< Error Interrupt Enable */[m
[32m+[m[32m#define  I2C_CR2_ITEVTEN                     ((uint16_t)0x0200)            /*!< Event Interrupt Enable */[m
[32m+[m[32m#define  I2C_CR2_ITBUFEN                     ((uint16_t)0x0400)            /*!< Buffer Interrupt Enable */[m
[32m+[m[32m#define  I2C_CR2_DMAEN                       ((uint16_t)0x0800)            /*!< DMA Requests Enable */[m
[32m+[m[32m#define  I2C_CR2_LAST                        ((uint16_t)0x1000)            /*!< DMA Last Transfer */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_OAR1 register  *******************/[m
[32m+[m[32m#define  I2C_OAR1_ADD1_7                     ((uint16_t)0x00FE)            /*!< Interface Address */[m
[32m+[m[32m#define  I2C_OAR1_ADD8_9                     ((uint16_t)0x0300)            /*!< Interface Address */[m
[32m+[m
[32m+[m[32m#define  I2C_OAR1_ADD0                       ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  I2C_OAR1_ADD1                       ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  I2C_OAR1_ADD2                       ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m[32m#define  I2C_OAR1_ADD3                       ((uint16_t)0x0008)            /*!< Bit 3 */[m
[32m+[m[32m#define  I2C_OAR1_ADD4                       ((uint16_t)0x0010)            /*!< Bit 4 */[m
[32m+[m[32m#define  I2C_OAR1_ADD5                       ((uint16_t)0x0020)            /*!< Bit 5 */[m
[32m+[m[32m#define  I2C_OAR1_ADD6                       ((uint16_t)0x0040)            /*!< Bit 6 */[m
[32m+[m[32m#define  I2C_OAR1_ADD7                       ((uint16_t)0x0080)            /*!< Bit 7 */[m
[32m+[m[32m#define  I2C_OAR1_ADD8                       ((uint16_t)0x0100)            /*!< Bit 8 */[m
[32m+[m[32m#define  I2C_OAR1_ADD9                       ((uint16_t)0x0200)            /*!< Bit 9 */[m
[32m+[m
[32m+[m[32m#define  I2C_OAR1_ADDMODE                    ((uint16_t)0x8000)            /*!< Addressing Mode (Slave mode) */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_OAR2 register  *******************/[m
[32m+[m[32m#define  I2C_OAR2_ENDUAL                     ((uint8_t)0x01)               /*!< Dual addressing mode enable */[m
[32m+[m[32m#define  I2C_OAR2_ADD2                       ((uint8_t)0xFE)               /*!< Interface address */[m
[32m+[m
[32m+[m[32m/********************  Bit definition for I2C_DR register  ********************/[m
[32m+[m[32m#define  I2C_DR_DR                           ((uint8_t)0xFF)               /*!< 8-bit Data Register */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_SR1 register  ********************/[m
[32m+[m[32m#define  I2C_SR1_SB                          ((uint16_t)0x0001)            /*!< Start Bit (Master mode) */[m
[32m+[m[32m#define  I2C_SR1_ADDR                        ((uint16_t)0x0002)            /*!< Address sent (master mode)/matched (slave mode) */[m
[32m+[m[32m#define  I2C_SR1_BTF                         ((uint16_t)0x0004)            /*!< Byte Transfer Finished */[m
[32m+[m[32m#define  I2C_SR1_ADD10                       ((uint16_t)0x0008)            /*!< 10-bit header sent (Master mode) */[m
[32m+[m[32m#define  I2C_SR1_STOPF                       ((uint16_t)0x0010)            /*!< Stop detection (Slave mode) */[m
[32m+[m[32m#define  I2C_SR1_RXNE                        ((uint16_t)0x0040)            /*!< Data Register not Empty (receivers) */[m
[32m+[m[32m#define  I2C_SR1_TXE                         ((uint16_t)0x0080)            /*!< Data Register Empty (transmitters) */[m
[32m+[m[32m#define  I2C_SR1_BERR                        ((uint16_t)0x0100)            /*!< Bus Error */[m
[32m+[m[32m#define  I2C_SR1_ARLO                        ((uint16_t)0x0200)            /*!< Arbitration Lost (master mode) */[m
[32m+[m[32m#define  I2C_SR1_AF                          ((uint16_t)0x0400)            /*!< Acknowledge Failure */[m
[32m+[m[32m#define  I2C_SR1_OVR                         ((uint16_t)0x0800)            /*!< Overrun/Underrun */[m
[32m+[m[32m#define  I2C_SR1_PECERR                      ((uint16_t)0x1000)            /*!< PEC Error in reception */[m
[32m+[m[32m#define  I2C_SR1_TIMEOUT                     ((uint16_t)0x4000)            /*!< Timeout or Tlow Error */[m
[32m+[m[32m#define  I2C_SR1_SMBALERT                    ((uint16_t)0x8000)            /*!< SMBus Alert */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_SR2 register  ********************/[m
[32m+[m[32m#define  I2C_SR2_MSL                         ((uint16_t)0x0001)            /*!< Master/Slave */[m
[32m+[m[32m#define  I2C_SR2_BUSY                        ((uint16_t)0x0002)            /*!< Bus Busy */[m
[32m+[m[32m#define  I2C_SR2_TRA                         ((uint16_t)0x0004)            /*!< Transmitter/Receiver */[m
[32m+[m[32m#define  I2C_SR2_GENCALL                     ((uint16_t)0x0010)            /*!< General Call Address (Slave mode) */[m
[32m+[m[32m#define  I2C_SR2_SMBDEFAULT                  ((uint16_t)0x0020)            /*!< SMBus Device Default Address (Slave mode) */[m
[32m+[m[32m#define  I2C_SR2_SMBHOST                     ((uint16_t)0x0040)            /*!< SMBus Host Header (Slave mode) */[m
[32m+[m[32m#define  I2C_SR2_DUALF                       ((uint16_t)0x0080)            /*!< Dual Flag (Slave mode) */[m
[32m+[m[32m#define  I2C_SR2_PEC                         ((uint16_t)0xFF00)            /*!< Packet Error Checking Register */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for I2C_CCR register  ********************/[m
[32m+[m[32m#define  I2C_CCR_CCR                         ((uint16_t)0x0FFF)            /*!< Clock Control Register in Fast/Standard mode (Master mode) */[m
[32m+[m[32m#define  I2C_CCR_DUTY                        ((uint16_t)0x4000)            /*!< Fast Mode Duty Cycle */[m
[32m+[m[32m#define  I2C_CCR_FS                          ((uint16_t)0x8000)            /*!< I2C Master Mode Selection */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for I2C_TRISE register  *******************/[m
[32m+[m[32m#define  I2C_TRISE_TRISE                     ((uint8_t)0x3F)               /*!< Maximum Rise Time in Fast/Standard mode (Master mode) */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*         Universal Synchronous Asynchronous Receiver Transmitter            */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USART_SR register  *******************/[m
[32m+[m[32m#define  USART_SR_PE                         ((uint16_t)0x0001)            /*!< Parity Error */[m
[32m+[m[32m#define  USART_SR_FE                         ((uint16_t)0x0002)            /*!< Framing Error */[m
[32m+[m[32m#define  USART_SR_NE                         ((uint16_t)0x0004)            /*!< Noise Error Flag */[m
[32m+[m[32m#define  USART_SR_ORE                        ((uint16_t)0x0008)            /*!< OverRun Error */[m
[32m+[m[32m#define  USART_SR_IDLE                       ((uint16_t)0x0010)            /*!< IDLE line detected */[m
[32m+[m[32m#define  USART_SR_RXNE                       ((uint16_t)0x0020)            /*!< Read Data Register Not Empty */[m
[32m+[m[32m#define  USART_SR_TC                         ((uint16_t)0x0040)            /*!< Transmission Complete */[m
[32m+[m[32m#define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Register Empty */[m
[32m+[m[32m#define  USART_SR_LBD                        ((uint16_t)0x0100)            /*!< LIN Break Detection Flag */[m
[32m+[m[32m#define  USART_SR_CTS                        ((uint16_t)0x0200)            /*!< CTS Flag */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for USART_DR register  *******************/[m
[32m+[m[32m#define  USART_DR_DR                         ((uint16_t)0x01FF)            /*!< Data value */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USART_BRR register  *******************/[m
[32m+[m[32m#define  USART_BRR_DIV_Fraction              ((uint16_t)0x000F)            /*!< Fraction of USARTDIV */[m
[32m+[m[32m#define  USART_BRR_DIV_Mantissa              ((uint16_t)0xFFF0)            /*!< Mantissa of USARTDIV */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USART_CR1 register  *******************/[m
[32m+[m[32m#define  USART_CR1_SBK                       ((uint16_t)0x0001)            /*!< Send Break */[m
[32m+[m[32m#define  USART_CR1_RWU                       ((uint16_t)0x0002)            /*!< Receiver wakeup */[m
[32m+[m[32m#define  USART_CR1_RE                        ((uint16_t)0x0004)            /*!< Receiver Enable */[m
[32m+[m[32m#define  USART_CR1_TE                        ((uint16_t)0x0008)            /*!< Transmitter Enable */[m
[32m+[m[32m#define  USART_CR1_IDLEIE                    ((uint16_t)0x0010)            /*!< IDLE Interrupt Enable */[m
[32m+[m[32m#define  USART_CR1_RXNEIE                    ((uint16_t)0x0020)            /*!< RXNE Interrupt Enable */[m
[32m+[m[32m#define  USART_CR1_TCIE                      ((uint16_t)0x0040)            /*!< Transmission Complete Interrupt Enable */[m
[32m+[m[32m#define  USART_CR1_TXEIE                     ((uint16_t)0x0080)            /*!< PE Interrupt Enable */[m
[32m+[m[32m#define  USART_CR1_PEIE                      ((uint16_t)0x0100)            /*!< PE Interrupt Enable */[m
[32m+[m[32m#define  USART_CR1_PS                        ((uint16_t)0x0200)            /*!< Parity Selection */[m
[32m+[m[32m#define  USART_CR1_PCE                       ((uint16_t)0x0400)            /*!< Parity Control Enable */[m
[32m+[m[32m#define  USART_CR1_WAKE                      ((uint16_t)0x0800)            /*!< Wakeup method */[m
[32m+[m[32m#define  USART_CR1_M                         ((uint16_t)0x1000)            /*!< Word length */[m
[32m+[m[32m#define  USART_CR1_UE                        ((uint16_t)0x2000)            /*!< USART Enable */[m
[32m+[m[32m#define  USART_CR1_OVER8                     ((uint16_t)0x8000)            /*!< USART Oversmapling 8-bits */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USART_CR2 register  *******************/[m
[32m+[m[32m#define  USART_CR2_ADD                       ((uint16_t)0x000F)            /*!< Address of the USART node */[m
[32m+[m[32m#define  USART_CR2_LBDL                      ((uint16_t)0x0020)            /*!< LIN Break Detection Length */[m
[32m+[m[32m#define  USART_CR2_LBDIE                     ((uint16_t)0x0040)            /*!< LIN Break Detection Interrupt Enable */[m
[32m+[m[32m#define  USART_CR2_LBCL                      ((uint16_t)0x0100)            /*!< Last Bit Clock pulse */[m
[32m+[m[32m#define  USART_CR2_CPHA                      ((uint16_t)0x0200)            /*!< Clock Phase */[m
[32m+[m[32m#define  USART_CR2_CPOL                      ((uint16_t)0x0400)            /*!< Clock Polarity */[m
[32m+[m[32m#define  USART_CR2_CLKEN                     ((uint16_t)0x0800)            /*!< Clock Enable */[m
[32m+[m
[32m+[m[32m#define  USART_CR2_STOP                      ((uint16_t)0x3000)            /*!< STOP[1:0] bits (STOP bits) */[m
[32m+[m[32m#define  USART_CR2_STOP_0                    ((uint16_t)0x1000)            /*!< Bit 0 */[m
[32m+[m[32m#define  USART_CR2_STOP_1                    ((uint16_t)0x2000)            /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  USART_CR2_LINEN                     ((uint16_t)0x4000)            /*!< LIN mode enable */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USART_CR3 register  *******************/[m
[32m+[m[32m#define  USART_CR3_EIE                       ((uint16_t)0x0001)            /*!< Error Interrupt Enable */[m
[32m+[m[32m#define  USART_CR3_IREN                      ((uint16_t)0x0002)            /*!< IrDA mode Enable */[m
[32m+[m[32m#define  USART_CR3_IRLP                      ((uint16_t)0x0004)            /*!< IrDA Low-Power */[m
[32m+[m[32m#define  USART_CR3_HDSEL                     ((uint16_t)0x0008)            /*!< Half-Duplex Selection */[m
[32m+[m[32m#define  USART_CR3_NACK                      ((uint16_t)0x0010)            /*!< Smartcard NACK enable */[m
[32m+[m[32m#define  USART_CR3_SCEN                      ((uint16_t)0x0020)            /*!< Smartcard mode enable */[m
[32m+[m[32m#define  USART_CR3_DMAR                      ((uint16_t)0x0040)            /*!< DMA Enable Receiver */[m
[32m+[m[32m#define  USART_CR3_DMAT                      ((uint16_t)0x0080)            /*!< DMA Enable Transmitter */[m
[32m+[m[32m#define  USART_CR3_RTSE                      ((uint16_t)0x0100)            /*!< RTS Enable */[m
[32m+[m[32m#define  USART_CR3_CTSE                      ((uint16_t)0x0200)            /*!< CTS Enable */[m
[32m+[m[32m#define  USART_CR3_CTSIE                     ((uint16_t)0x0400)            /*!< CTS Interrupt Enable */[m
[32m+[m[32m#define  USART_CR3_ONEBIT                    ((uint16_t)0x0800)            /*!< One Bit method */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for USART_GTPR register  ******************/[m
[32m+[m[32m#define  USART_GTPR_PSC                      ((uint16_t)0x00FF)            /*!< PSC[7:0] bits (Prescaler value) */[m
[32m+[m[32m#define  USART_GTPR_PSC_0                    ((uint16_t)0x0001)            /*!< Bit 0 */[m
[32m+[m[32m#define  USART_GTPR_PSC_1                    ((uint16_t)0x0002)            /*!< Bit 1 */[m
[32m+[m[32m#define  USART_GTPR_PSC_2                    ((uint16_t)0x0004)            /*!< Bit 2 */[m
[32m+[m[32m#define  USART_GTPR_PSC_3                    ((uint16_t)0x0008)            /*!< Bit 3 */[m
[32m+[m[32m#define  USART_GTPR_PSC_4                    ((uint16_t)0x0010)            /*!< Bit 4 */[m
[32m+[m[32m#define  USART_GTPR_PSC_5                    ((uint16_t)0x0020)            /*!< Bit 5 */[m
[32m+[m[32m#define  USART_GTPR_PSC_6                    ((uint16_t)0x0040)            /*!< Bit 6 */[m
[32m+[m[32m#define  USART_GTPR_PSC_7                    ((uint16_t)0x0080)            /*!< Bit 7 */[m
[32m+[m
[32m+[m[32m#define  USART_GTPR_GT                       ((uint16_t)0xFF00)            /*!< Guard time value */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                                 Debug MCU                                  */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/****************  Bit definition for DBGMCU_IDCODE register  *****************/[m
[32m+[m[32m#define  DBGMCU_IDCODE_DEV_ID                ((uint32_t)0x00000FFF)        /*!< Device Identifier */[m
[32m+[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID                ((uint32_t)0xFFFF0000)        /*!< REV_ID[15:0] bits (Revision Identifier) */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_0              ((uint32_t)0x00010000)        /*!< Bit 0 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_1              ((uint32_t)0x00020000)        /*!< Bit 1 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_2              ((uint32_t)0x00040000)        /*!< Bit 2 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_3              ((uint32_t)0x00080000)        /*!< Bit 3 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_4              ((uint32_t)0x00100000)        /*!< Bit 4 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_5              ((uint32_t)0x00200000)        /*!< Bit 5 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_6              ((uint32_t)0x00400000)        /*!< Bit 6 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_7              ((uint32_t)0x00800000)        /*!< Bit 7 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_8              ((uint32_t)0x01000000)        /*!< Bit 8 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_9              ((uint32_t)0x02000000)        /*!< Bit 9 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_10             ((uint32_t)0x04000000)        /*!< Bit 10 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_11             ((uint32_t)0x08000000)        /*!< Bit 11 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_12             ((uint32_t)0x10000000)        /*!< Bit 12 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_13             ((uint32_t)0x20000000)        /*!< Bit 13 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_14             ((uint32_t)0x40000000)        /*!< Bit 14 */[m
[32m+[m[32m#define  DBGMCU_IDCODE_REV_ID_15             ((uint32_t)0x80000000)        /*!< Bit 15 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for DBGMCU_CR register  *******************/[m
[32m+[m[32m#define  DBGMCU_CR_DBG_SLEEP                 ((uint32_t)0x00000001)        /*!< Debug Sleep Mode */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_STOP                  ((uint32_t)0x00000002)        /*!< Debug Stop Mode */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_STANDBY               ((uint32_t)0x00000004)        /*!< Debug Standby mode */[m
[32m+[m[32m#define  DBGMCU_CR_TRACE_IOEN                ((uint32_t)0x00000020)        /*!< Trace Pin Assignment Control */[m
[32m+[m
[32m+[m[32m#define  DBGMCU_CR_TRACE_MODE                ((uint32_t)0x000000C0)        /*!< TRACE_MODE[1:0] bits (Trace Pin Assignment Control) */[m
[32m+[m[32m#define  DBGMCU_CR_TRACE_MODE_0              ((uint32_t)0x00000040)        /*!< Bit 0 */[m
[32m+[m[32m#define  DBGMCU_CR_TRACE_MODE_1              ((uint32_t)0x00000080)        /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  DBGMCU_CR_DBG_IWDG_STOP             ((uint32_t)0x00000100)        /*!< Debug Independent Watchdog stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_WWDG_STOP             ((uint32_t)0x00000200)        /*!< Debug Window Watchdog stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM1_STOP             ((uint32_t)0x00000400)        /*!< TIM1 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM2_STOP             ((uint32_t)0x00000800)        /*!< TIM2 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM3_STOP             ((uint32_t)0x00001000)        /*!< TIM3 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM4_STOP             ((uint32_t)0x00002000)        /*!< TIM4 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_CAN1_STOP             ((uint32_t)0x00004000)        /*!< Debug CAN1 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00008000)        /*!< SMBUS timeout mode stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00010000)        /*!< SMBUS timeout mode stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM8_STOP             ((uint32_t)0x00020000)        /*!< TIM8 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM5_STOP             ((uint32_t)0x00040000)        /*!< TIM5 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM6_STOP             ((uint32_t)0x00080000)        /*!< TIM6 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM7_STOP             ((uint32_t)0x00100000)        /*!< TIM7 counter stopped when core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_CAN2_STOP             ((uint32_t)0x00200000)        /*!< Debug CAN2 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM15_STOP            ((uint32_t)0x00400000)        /*!< Debug TIM15 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM16_STOP            ((uint32_t)0x00800000)        /*!< Debug TIM16 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM17_STOP            ((uint32_t)0x01000000)        /*!< Debug TIM17 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM12_STOP            ((uint32_t)0x02000000)        /*!< Debug TIM12 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM13_STOP            ((uint32_t)0x04000000)        /*!< Debug TIM13 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM14_STOP            ((uint32_t)0x08000000)        /*!< Debug TIM14 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM9_STOP             ((uint32_t)0x10000000)        /*!< Debug TIM9 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM10_STOP            ((uint32_t)0x20000000)        /*!< Debug TIM10 stopped when Core is halted */[m
[32m+[m[32m#define  DBGMCU_CR_DBG_TIM11_STOP            ((uint32_t)0x40000000)        /*!< Debug TIM11 stopped when Core is halted */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/*                      FLASH and Option Bytes Registers                      */[m
[32m+[m[32m/*                                                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FLASH_ACR register  ******************/[m
[32m+[m[32m#define  FLASH_ACR_LATENCY                   ((uint8_t)0x03)               /*!< LATENCY[2:0] bits (Latency) */[m
[32m+[m[32m#define  FLASH_ACR_LATENCY_0                 ((uint8_t)0x00)               /*!< Bit 0 */[m
[32m+[m[32m#define  FLASH_ACR_LATENCY_1                 ((uint8_t)0x01)               /*!< Bit 0 */[m
[32m+[m[32m#define  FLASH_ACR_LATENCY_2                 ((uint8_t)0x02)               /*!< Bit 1 */[m
[32m+[m
[32m+[m[32m#define  FLASH_ACR_HLFCYA                    ((uint8_t)0x08)               /*!< Flash Half Cycle Access Enable */[m
[32m+[m[32m#define  FLASH_ACR_PRFTBE                    ((uint8_t)0x10)               /*!< Prefetch Buffer Enable */[m
[32m+[m[32m#define  FLASH_ACR_PRFTBS                    ((uint8_t)0x20)               /*!< Prefetch Buffer Status */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_KEYR register  ******************/[m
[32m+[m[32m#define  FLASH_KEYR_FKEYR                    ((uint32_t)0xFFFFFFFF)        /*!< FPEC Key */[m
[32m+[m
[32m+[m[32m/*****************  Bit definition for FLASH_OPTKEYR register  ****************/[m
[32m+[m[32m#define  FLASH_OPTKEYR_OPTKEYR               ((uint32_t)0xFFFFFFFF)        /*!< Option Byte Key */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_SR register  *******************/[m
[32m+[m[32m#define  FLASH_SR_BSY                        ((uint8_t)0x01)               /*!< Busy */[m
[32m+[m[32m#define  FLASH_SR_PGERR                      ((uint8_t)0x04)               /*!< Programming Error */[m
[32m+[m[32m#define  FLASH_SR_WRPRTERR                   ((uint8_t)0x10)               /*!< Write Protection Error */[m
[32m+[m[32m#define  FLASH_SR_EOP                        ((uint8_t)0x20)               /*!< End of operation */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FLASH_CR register  *******************/[m
[32m+[m[32m#define  FLASH_CR_PG                         ((uint16_t)0x0001)            /*!< Programming */[m
[32m+[m[32m#define  FLASH_CR_PER                        ((uint16_t)0x0002)            /*!< Page Erase */[m
[32m+[m[32m#define  FLASH_CR_MER                        ((uint16_t)0x0004)            /*!< Mass Erase */[m
[32m+[m[32m#define  FLASH_CR_OPTPG                      ((uint16_t)0x0010)            /*!< Option Byte Programming */[m
[32m+[m[32m#define  FLASH_CR_OPTER                      ((uint16_t)0x0020)            /*!< Option Byte Erase */[m
[32m+[m[32m#define  FLASH_CR_STRT                       ((uint16_t)0x0040)            /*!< Start */[m
[32m+[m[32m#define  FLASH_CR_LOCK                       ((uint16_t)0x0080)            /*!< Lock */[m
[32m+[m[32m#define  FLASH_CR_OPTWRE                     ((uint16_t)0x0200)            /*!< Option Bytes Write Enable */[m
[32m+[m[32m#define  FLASH_CR_ERRIE                      ((uint16_t)0x0400)            /*!< Error Interrupt Enable */[m
[32m+[m[32m#define  FLASH_CR_EOPIE                      ((uint16_t)0x1000)            /*!< End of operation interrupt enable */[m
[32m+[m
[32m+[m[32m/*******************  Bit definition for FLASH_AR register  *******************/[m
[32m+[m[32m#define  FLASH_AR_FAR                        ((uint32_t)0xFFFFFFFF)        /*!< Flash Address */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_OBR register  *******************/[m
[32m+[m[32m#define  FLASH_OBR_OPTERR                    ((uint16_t)0x0001)            /*!< Option Byte Error */[m
[32m+[m[32m#define  FLASH_OBR_RDPRT                     ((uint16_t)0x0002)            /*!< Read protection */[m
[32m+[m
[32m+[m[32m#define  FLASH_OBR_USER                      ((uint16_t)0x03FC)            /*!< User Option Bytes */[m
[32m+[m[32m#define  FLASH_OBR_WDG_SW                    ((uint16_t)0x0004)            /*!< WDG_SW */[m
[32m+[m[32m#define  FLASH_OBR_nRST_STOP                 ((uint16_t)0x0008)            /*!< nRST_STOP */[m
[32m+[m[32m#define  FLASH_OBR_nRST_STDBY                ((uint16_t)0x0010)            /*!< nRST_STDBY */[m
[32m+[m[32m#define  FLASH_OBR_BFB2                      ((uint16_t)0x0020)            /*!< BFB2 */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_WRPR register  ******************/[m
[32m+[m[32m#define  FLASH_WRPR_WRP                        ((uint32_t)0xFFFFFFFF)        /*!< Write Protect */[m
[32m+[m
[32m+[m[32m/*----------------------------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_RDP register  *******************/[m
[32m+[m[32m#define  FLASH_RDP_RDP                       ((uint32_t)0x000000FF)        /*!< Read protection option byte */[m
[32m+[m[32m#define  FLASH_RDP_nRDP                      ((uint32_t)0x0000FF00)        /*!< Read protection complemented option byte */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_USER register  ******************/[m
[32m+[m[32m#define  FLASH_USER_USER                     ((uint32_t)0x00FF0000)        /*!< User option byte */[m
[32m+[m[32m#define  FLASH_USER_nUSER                    ((uint32_t)0xFF000000)        /*!< User complemented option byte */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_Data0 register  *****************/[m
[32m+[m[32m#define  FLASH_Data0_Data0                   ((uint32_t)0x000000FF)        /*!< User data storage option byte */[m
[32m+[m[32m#define  FLASH_Data0_nData0                  ((uint32_t)0x0000FF00)        /*!< User data storage complemented option byte */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_Data1 register  *****************/[m
[32m+[m[32m#define  FLASH_Data1_Data1                   ((uint32_t)0x00FF0000)        /*!< User data storage option byte */[m
[32m+[m[32m#define  FLASH_Data1_nData1                  ((uint32_t)0xFF000000)        /*!< User data storage complemented option byte */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_WRP0 register  ******************/[m
[32m+[m[32m#define  FLASH_WRP0_WRP0                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */[m
[32m+[m[32m#define  FLASH_WRP0_nWRP0                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_WRP1 register  ******************/[m
[32m+[m[32m#define  FLASH_WRP1_WRP1                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */[m
[32m+[m[32m#define  FLASH_WRP1_nWRP1                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_WRP2 register  ******************/[m
[32m+[m[32m#define  FLASH_WRP2_WRP2                     ((uint32_t)0x000000FF)        /*!< Flash memory write protection option bytes */[m
[32m+[m[32m#define  FLASH_WRP2_nWRP2                    ((uint32_t)0x0000FF00)        /*!< Flash memory write protection complemented option bytes */[m
[32m+[m
[32m+[m[32m/******************  Bit definition for FLASH_WRP3 register  ******************/[m
[32m+[m[32m#define  FLASH_WRP3_WRP3                     ((uint32_t)0x00FF0000)        /*!< Flash memory write protection option bytes */[m
[32m+[m[32m#define  FLASH_WRP3_nWRP3                    ((uint32_t)0xFF000000)        /*!< Flash memory write protection complemented option bytes */[m
[32m+[m
[32m+[m[32m#ifdef STM32F10X_CL[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                Ethernet MAC Registers bits definitions                     */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/* Bit definition for Ethernet MAC Control Register register */[m
[32m+[m[32m#define ETH_MACCR_WD      ((uint32_t)0x00800000)  /* Watchdog disable */[m
[32m+[m[32m#define ETH_MACCR_JD      ((uint32_t)0x00400000)  /* Jabber disable */[m
[32m+[m[32m#define ETH_MACCR_IFG     ((uint32_t)0x000E0000)  /* Inter-frame gap */[m
[32m+[m[32m  #define ETH_MACCR_IFG_96Bit     ((uint32_t)0x00000000)  /* Minimum IFG between frames during transmission is 96Bit */[m
[32m+[m[32m  #define ETH_MACCR_IFG_88Bit     ((uint32_t)0x00020000)  /* Minimum IFG between frames during transmission is 88Bit */[m
[32m+[m[32m  #define ETH_MACCR_IFG_80Bit     ((uint32_t)0x00040000)  /* Minimum IFG between frames during transmission is 80Bit */[m
[32m+[m[32m  #define ETH_MACCR_IFG_72Bit     ((uint32_t)0x00060000)  /* Minimum IFG between frames during transmission is 72Bit */[m
[32m+[m[32m  #define ETH_MACCR_IFG_64Bit     ((uint32_t)0x00080000)  /* Minimum IFG between frames during transmission is 64Bit */[m[41m        [m
[32m+[m[32m  #define ETH_MACCR_IFG_56Bit     ((uint32_t)0x000A0000)  /* Minimum IFG between frames during transmission is 56Bit */[m
[32m+[m[32m  #define ETH_MACCR_IFG_48Bit     ((uint32_t)0x000C0000)  /* Minimum IFG between frames during transmission is 48Bit */[m
[32m+[m[32m  #define ETH_MACCR_IFG_40Bit     ((uint32_t)0x000E0000)  /* Minimum IFG between frames during transmission is 40Bit */[m[41m              [m
[32m+[m[32m#define ETH_MACCR_CSD     ((uint32_t)0x00010000)  /* Carrier sense disable (during transmission) */[m
[32m+[m[32m#define ETH_MACCR_FES     ((uint32_t)0x00004000)  /* Fast ethernet speed */[m
[32m+[m[32m#define ETH_MACCR_ROD     ((uint32_t)0x00002000)  /* Receive own disable */[m
[32m+[m[32m#define ETH_MACCR_LM      ((uint32_t)0x00001000)  /* loopback mode */[m
[32m+[m[32m#define ETH_MACCR_DM      ((uint32_t)0x00000800)  /* Duplex mode */[m
[32m+[m[32m#define ETH_MACCR_IPCO    ((uint32_t)0x00000400)  /* IP Checksum offload */[m
[32m+[m[32m#define ETH_MACCR_RD      ((uint32_t)0x00000200)  /* Retry disable */[m
[32m+[m[32m#define ETH_MACCR_APCS    ((uint32_t)0x00000080)  /* Automatic Pad/CRC stripping */[m
[32m+[m[32m#define ETH_MACCR_BL      ((uint32_t)0x00000060)  /* Back-off limit: random integer number (r) of slot time delays before rescheduling[m
[32m+[m[32m                                                       a transmission attempt during retries after a collision: 0 =< r <2^k */[m
[32m+[m[32m  #define ETH_MACCR_BL_10    ((uint32_t)0x00000000)  /* k = min (n, 10) */[m
[32m+[m[32m  #define ETH_MACCR_BL_8     ((uint32_t)0x00000020)  /* k = min (n, 8) */[m
[32m+[m[32m  #define ETH_MACCR_BL_4     ((uint32_t)0x00000040)  /* k = min (n, 4) */[m
[32m+[m[32m  #define ETH_MACCR_BL_1     ((uint32_t)0x00000060)  /* k = min (n, 1) */[m[41m [m
[32m+[m[32m#define ETH_MACCR_DC      ((uint32_t)0x00000010)  /* Defferal check */[m
[32m+[m[32m#define ETH_MACCR_TE      ((uint32_t)0x00000008)  /* Transmitter enable */[m
[32m+[m[32m#define ETH_MACCR_RE      ((uint32_t)0x00000004)  /* Receiver enable */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Frame Filter Register */[m
[32m+[m[32m#define ETH_MACFFR_RA     ((uint32_t)0x80000000)  /* Receive all */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_HPF    ((uint32_t)0x00000400)  /* Hash or perfect filter */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_SAF    ((uint32_t)0x00000200)  /* Source address filter enable */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_SAIF   ((uint32_t)0x00000100)  /* SA inverse filtering */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_PCF    ((uint32_t)0x000000C0)  /* Pass control frames: 3 cases */[m
[32m+[m[32m  #define ETH_MACFFR_PCF_BlockAll                ((uint32_t)0x00000040)  /* MAC filters all control frames from reaching the application */[m
[32m+[m[32m  #define ETH_MACFFR_PCF_ForwardAll              ((uint32_t)0x00000080)  /* MAC forwards all control frames to application even if they fail the Address Filter */[m
[32m+[m[32m  #define ETH_MACFFR_PCF_ForwardPassedAddrFilter ((uint32_t)0x000000C0)  /* MAC forwards control frames that pass the Address Filter. */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_BFD    ((uint32_t)0x00000020)  /* Broadcast frame disable */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_PAM 	  ((uint32_t)0x00000010)  /* Pass all mutlicast */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_DAIF   ((uint32_t)0x00000008)  /* DA Inverse filtering */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_HM     ((uint32_t)0x00000004)  /* Hash multicast */[m[41m [m
[32m+[m[32m#define ETH_MACFFR_HU     ((uint32_t)0x00000002)  /* Hash unicast */[m
[32m+[m[32m#define ETH_MACFFR_PM     ((uint32_t)0x00000001)  /* Promiscuous mode */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Hash Table High Register */[m
[32m+[m[32m#define ETH_MACHTHR_HTH   ((uint32_t)0xFFFFFFFF)  /* Hash table high */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Hash Table Low Register */[m
[32m+[m[32m#define ETH_MACHTLR_HTL   ((uint32_t)0xFFFFFFFF)  /* Hash table low */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC MII Address Register */[m
[32m+[m[32m#define ETH_MACMIIAR_PA   ((uint32_t)0x0000F800)  /* Physical layer address */[m[41m [m
[32m+[m[32m#define ETH_MACMIIAR_MR   ((uint32_t)0x000007C0)  /* MII register in the selected PHY */[m[41m [m
[32m+[m[32m#define ETH_MACMIIAR_CR   ((uint32_t)0x0000001C)  /* CR clock range: 6 cases */[m[41m [m
[32m+[m[32m  #define ETH_MACMIIAR_CR_Div42   ((uint32_t)0x00000000)  /* HCLK:60-72 MHz; MDC clock= HCLK/42 */[m
[32m+[m[32m  #define ETH_MACMIIAR_CR_Div16   ((uint32_t)0x00000008)  /* HCLK:20-35 MHz; MDC clock= HCLK/16 */[m
[32m+[m[32m  #define ETH_MACMIIAR_CR_Div26   ((uint32_t)0x0000000C)  /* HCLK:35-60 MHz; MDC clock= HCLK/26 */[m
[32m+[m[32m#define ETH_MACMIIAR_MW   ((uint32_t)0x00000002)  /* MII write */[m[41m [m
[32m+[m[32m#define ETH_MACMIIAR_MB   ((uint32_t)0x00000001)  /* MII busy */[m[41m [m
[32m+[m[41m  [m
[32m+[m[32m/* Bit definition for Ethernet MAC MII Data Register */[m
[32m+[m[32m#define ETH_MACMIIDR_MD   ((uint32_t)0x0000FFFF)  /* MII data: read/write data from/to PHY */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Flow Control Register */[m
[32m+[m[32m#define ETH_MACFCR_PT     ((uint32_t)0xFFFF0000)  /* Pause time */[m
[32m+[m[32m#define ETH_MACFCR_ZQPD   ((uint32_t)0x00000080)  /* Zero-quanta pause disable */[m
[32m+[m[32m#define ETH_MACFCR_PLT    ((uint32_t)0x00000030)  /* Pause low threshold: 4 cases */[m
[32m+[m[32m  #define ETH_MACFCR_PLT_Minus4   ((uint32_t)0x00000000)  /* Pause time minus 4 slot times */[m
[32m+[m[32m  #define ETH_MACFCR_PLT_Minus28  ((uint32_t)0x00000010)  /* Pause time minus 28 slot times */[m
[32m+[m[32m  #define ETH_MACFCR_PLT_Minus144 ((uint32_t)0x00000020)  /* Pause time minus 144 slot times */[m
[32m+[m[32m  #define ETH_MACFCR_PLT_Minus256 ((uint32_t)0x00000030)  /* Pause time minus 256 slot times */[m[41m      [m
[32m+[m[32m#define ETH_MACFCR_UPFD   ((uint32_t)0x00000008)  /* Unicast pause frame detect */[m
[32m+[m[32m#define ETH_MACFCR_RFCE   ((uint32_t)0x00000004)  /* Receive flow control enable */[m
[32m+[m[32m#define ETH_MACFCR_TFCE   ((uint32_t)0x00000002)  /* Transmit flow control enable */[m
[32m+[m[32m#define ETH_MACFCR_FCBBPA ((uint32_t)0x00000001)  /* Flow control busy/backpressure activate */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC VLAN Tag Register */[m
[32m+[m[32m#define ETH_MACVLANTR_VLANTC ((uint32_t)0x00010000)  /* 12-bit VLAN tag comparison */[m
[32m+[m[32m#define ETH_MACVLANTR_VLANTI ((uint32_t)0x0000FFFF)  /* VLAN tag identifier (for receive frames) */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Remote Wake-UpFrame Filter Register */[m[41m [m
[32m+[m[32m#define ETH_MACRWUFFR_D   ((uint32_t)0xFFFFFFFF)  /* Wake-up frame filter register data */[m
[32m+[m[32m/* Eight sequential Writes to this address (offset 0x28) will write all Wake-UpFrame Filter Registers.[m
[32m+[m[32m   Eight sequential Reads from this address (offset 0x28) will read all Wake-UpFrame Filter Registers. */[m
[32m+[m[32m/* Wake-UpFrame Filter Reg0 : Filter 0 Byte Mask[m
[32m+[m[32m   Wake-UpFrame Filter Reg1 : Filter 1 Byte Mask[m
[32m+[m[32m   Wake-UpFrame Filter Reg2 : Filter 2 Byte Mask[m
[32m+[m[32m   Wake-UpFrame Filter Reg3 : Filter 3 Byte Mask[m
[32m+[m[32m   Wake-UpFrame Filter Reg4 : RSVD - Filter3 Command - RSVD - Filter2 Command -[m[41m [m
[32m+[m[32m                              RSVD - Filter1 Command - RSVD - Filter0 Command[m
[32m+[m[32m   Wake-UpFrame Filter Re5 : Filter3 Offset - Filter2 Offset - Filter1 Offset - Filter0 Offset[m
[32m+[m[32m   Wake-UpFrame Filter Re6 : Filter1 CRC16 - Filter0 CRC16[m
[32m+[m[32m   Wake-UpFrame Filter Re7 : Filter3 CRC16 - Filter2 CRC16 */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC PMT Control and Status Register */[m[41m [m
[32m+[m[32m#define ETH_MACPMTCSR_WFFRPR ((uint32_t)0x80000000)  /* Wake-Up Frame Filter Register Pointer Reset */[m
[32m+[m[32m#define ETH_MACPMTCSR_GU     ((uint32_t)0x00000200)  /* Global Unicast */[m
[32m+[m[32m#define ETH_MACPMTCSR_WFR    ((uint32_t)0x00000040)  /* Wake-Up Frame Received */[m
[32m+[m[32m#define ETH_MACPMTCSR_MPR    ((uint32_t)0x00000020)  /* Magic Packet Received */[m
[32m+[m[32m#define ETH_MACPMTCSR_WFE    ((uint32_t)0x00000004)  /* Wake-Up Frame Enable */[m
[32m+[m[32m#define ETH_MACPMTCSR_MPE    ((uint32_t)0x00000002)  /* Magic Packet Enable */[m
[32m+[m[32m#define ETH_MACPMTCSR_PD     ((uint32_t)0x00000001)  /* Power Down */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Status Register */[m
[32m+[m[32m#define ETH_MACSR_TSTS      ((uint32_t)0x00000200)  /* Time stamp trigger status */[m
[32m+[m[32m#define ETH_MACSR_MMCTS     ((uint32_t)0x00000040)  /* MMC transmit status */[m
[32m+[m[32m#define ETH_MACSR_MMMCRS    ((uint32_t)0x00000020)  /* MMC receive status */[m
[32m+[m[32m#define ETH_MACSR_MMCS      ((uint32_t)0x00000010)  /* MMC status */[m
[32m+[m[32m#define ETH_MACSR_PMTS      ((uint32_t)0x00000008)  /* PMT status */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Interrupt Mask Register */[m
[32m+[m[32m#define ETH_MACIMR_TSTIM     ((uint32_t)0x00000200)  /* Time stamp trigger interrupt mask */[m
[32m+[m[32m#define ETH_MACIMR_PMTIM     ((uint32_t)0x00000008)  /* PMT interrupt mask */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address0 High Register */[m
[32m+[m[32m#define ETH_MACA0HR_MACA0H   ((uint32_t)0x0000FFFF)  /* MAC address0 high */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address0 Low Register */[m
[32m+[m[32m#define ETH_MACA0LR_MACA0L   ((uint32_t)0xFFFFFFFF)  /* MAC address0 low */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address1 High Register */[m
[32m+[m[32m#define ETH_MACA1HR_AE       ((uint32_t)0x80000000)  /* Address enable */[m
[32m+[m[32m#define ETH_MACA1HR_SA       ((uint32_t)0x40000000)  /* Source address */[m
[32m+[m[32m#define ETH_MACA1HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control: bits to mask for comparison of the MAC Address bytes */[m
[32m+[m[32m  #define ETH_MACA1HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */[m
[32m+[m[32m  #define ETH_MACA1HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */[m
[32m+[m[32m  #define ETH_MACA1HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */[m
[32m+[m[32m  #define ETH_MACA1HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */[m
[32m+[m[32m  #define ETH_MACA1HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */[m
[32m+[m[32m  #define ETH_MACA1HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [7:0] */[m[41m [m
[32m+[m[32m#define ETH_MACA1HR_MACA1H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address1 Low Register */[m
[32m+[m[32m#define ETH_MACA1LR_MACA1L   ((uint32_t)0xFFFFFFFF)  /* MAC address1 low */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address2 High Register */[m
[32m+[m[32m#define ETH_MACA2HR_AE       ((uint32_t)0x80000000)  /* Address enable */[m
[32m+[m[32m#define ETH_MACA2HR_SA       ((uint32_t)0x40000000)  /* Source address */[m
[32m+[m[32m#define ETH_MACA2HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */[m
[32m+[m[32m  #define ETH_MACA2HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */[m
[32m+[m[32m  #define ETH_MACA2HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */[m
[32m+[m[32m  #define ETH_MACA2HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */[m
[32m+[m[32m  #define ETH_MACA2HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */[m
[32m+[m[32m  #define ETH_MACA2HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */[m
[32m+[m[32m  #define ETH_MACA2HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */[m
[32m+[m[32m#define ETH_MACA2HR_MACA2H   ((uint32_t)0x0000FFFF)  /* MAC address1 high */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address2 Low Register */[m
[32m+[m[32m#define ETH_MACA2LR_MACA2L   ((uint32_t)0xFFFFFFFF)  /* MAC address2 low */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address3 High Register */[m
[32m+[m[32m#define ETH_MACA3HR_AE       ((uint32_t)0x80000000)  /* Address enable */[m
[32m+[m[32m#define ETH_MACA3HR_SA       ((uint32_t)0x40000000)  /* Source address */[m
[32m+[m[32m#define ETH_MACA3HR_MBC      ((uint32_t)0x3F000000)  /* Mask byte control */[m
[32m+[m[32m  #define ETH_MACA3HR_MBC_HBits15_8    ((uint32_t)0x20000000)  /* Mask MAC Address high reg bits [15:8] */[m
[32m+[m[32m  #define ETH_MACA3HR_MBC_HBits7_0     ((uint32_t)0x10000000)  /* Mask MAC Address high reg bits [7:0] */[m
[32m+[m[32m  #define ETH_MACA3HR_MBC_LBits31_24   ((uint32_t)0x08000000)  /* Mask MAC Address low reg bits [31:24] */[m
[32m+[m[32m  #define ETH_MACA3HR_MBC_LBits23_16   ((uint32_t)0x04000000)  /* Mask MAC Address low reg bits [23:16] */[m
[32m+[m[32m  #define ETH_MACA3HR_MBC_LBits15_8    ((uint32_t)0x02000000)  /* Mask MAC Address low reg bits [15:8] */[m
[32m+[m[32m  #define ETH_MACA3HR_MBC_LBits7_0     ((uint32_t)0x01000000)  /* Mask MAC Address low reg bits [70] */[m
[32m+[m[32m#define ETH_MACA3HR_MACA3H   ((uint32_t)0x0000FFFF)  /* MAC address3 high */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MAC Address3 Low Register */[m
[32m+[m[32m#define ETH_MACA3LR_MACA3L   ((uint32_t)0xFFFFFFFF)  /* MAC address3 low */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                Ethernet MMC Registers bits definition                      */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Contol Register */[m
[32m+[m[32m#define ETH_MMCCR_MCF        ((uint32_t)0x00000008)  /* MMC Counter Freeze */[m
[32m+[m[32m#define ETH_MMCCR_ROR        ((uint32_t)0x00000004)  /* Reset on Read */[m
[32m+[m[32m#define ETH_MMCCR_CSR        ((uint32_t)0x00000002)  /* Counter Stop Rollover */[m
[32m+[m[32m#define ETH_MMCCR_CR         ((uint32_t)0x00000001)  /* Counters Reset */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Receive Interrupt Register */[m
[32m+[m[32m#define ETH_MMCRIR_RGUFS     ((uint32_t)0x00020000)  /* Set when Rx good unicast frames counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCRIR_RFAES     ((uint32_t)0x00000040)  /* Set when Rx alignment error counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCRIR_RFCES     ((uint32_t)0x00000020)  /* Set when Rx crc error counter reaches half the maximum value */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Transmit Interrupt Register */[m
[32m+[m[32m#define ETH_MMCTIR_TGFS      ((uint32_t)0x00200000)  /* Set when Tx good frame count counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCTIR_TGFMSCS   ((uint32_t)0x00008000)  /* Set when Tx good multi col counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCTIR_TGFSCS    ((uint32_t)0x00004000)  /* Set when Tx good single col counter reaches half the maximum value */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Receive Interrupt Mask Register */[m
[32m+[m[32m#define ETH_MMCRIMR_RGUFM    ((uint32_t)0x00020000)  /* Mask the interrupt when Rx good unicast frames counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCRIMR_RFAEM    ((uint32_t)0x00000040)  /* Mask the interrupt when when Rx alignment error counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCRIMR_RFCEM    ((uint32_t)0x00000020)  /* Mask the interrupt when Rx crc error counter reaches half the maximum value */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Transmit Interrupt Mask Register */[m
[32m+[m[32m#define ETH_MMCTIMR_TGFM     ((uint32_t)0x00200000)  /* Mask the interrupt when Tx good frame count counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCTIMR_TGFMSCM  ((uint32_t)0x00008000)  /* Mask the interrupt when Tx good multi col counter reaches half the maximum value */[m
[32m+[m[32m#define ETH_MMCTIMR_TGFSCM   ((uint32_t)0x00004000)  /* Mask the interrupt when Tx good single col counter reaches half the maximum value */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Transmitted Good Frames after Single Collision Counter Register */[m
[32m+[m[32m#define ETH_MMCTGFSCCR_TGFSCC     ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after a single collision in Half-duplex mode. */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Transmitted Good Frames after More than a Single Collision Counter Register */[m
[32m+[m[32m#define ETH_MMCTGFMSCCR_TGFMSCC   ((uint32_t)0xFFFFFFFF)  /* Number of successfully transmitted frames after more than a single collision in Half-duplex mode. */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Transmitted Good Frames Counter Register */[m
[32m+[m[32m#define ETH_MMCTGFCR_TGFC    ((uint32_t)0xFFFFFFFF)  /* Number of good frames transmitted. */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Received Frames with CRC Error Counter Register */[m
[32m+[m[32m#define ETH_MMCRFCECR_RFCEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with CRC error. */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Received Frames with Alignement Error Counter Register */[m
[32m+[m[32m#define ETH_MMCRFAECR_RFAEC  ((uint32_t)0xFFFFFFFF)  /* Number of frames received with alignment (dribble) error */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet MMC Received Good Unicast Frames Counter Register */[m
[32m+[m[32m#define ETH_MMCRGUFCR_RGUFC  ((uint32_t)0xFFFFFFFF)  /* Number of good unicast frames received. */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*               Ethernet PTP Registers bits definition                       */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Time Stamp Contol Register */[m
[32m+[m[32m#define ETH_PTPTSCR_TSARU    ((uint32_t)0x00000020)  /* Addend register update */[m
[32m+[m[32m#define ETH_PTPTSCR_TSITE    ((uint32_t)0x00000010)  /* Time stamp interrupt trigger enable */[m
[32m+[m[32m#define ETH_PTPTSCR_TSSTU    ((uint32_t)0x00000008)  /* Time stamp update */[m
[32m+[m[32m#define ETH_PTPTSCR_TSSTI    ((uint32_t)0x00000004)  /* Time stamp initialize */[m
[32m+[m[32m#define ETH_PTPTSCR_TSFCU    ((uint32_t)0x00000002)  /* Time stamp fine or coarse update */[m
[32m+[m[32m#define ETH_PTPTSCR_TSE      ((uint32_t)0x00000001)  /* Time stamp enable */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Sub-Second Increment Register */[m
[32m+[m[32m#define ETH_PTPSSIR_STSSI    ((uint32_t)0x000000FF)  /* System time Sub-second increment value */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Time Stamp High Register */[m
[32m+[m[32m#define ETH_PTPTSHR_STS      ((uint32_t)0xFFFFFFFF)  /* System Time second */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Time Stamp Low Register */[m
[32m+[m[32m#define ETH_PTPTSLR_STPNS    ((uint32_t)0x80000000)  /* System Time Positive or negative time */[m
[32m+[m[32m#define ETH_PTPTSLR_STSS     ((uint32_t)0x7FFFFFFF)  /* System Time sub-seconds */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Time Stamp High Update Register */[m
[32m+[m[32m#define ETH_PTPTSHUR_TSUS    ((uint32_t)0xFFFFFFFF)  /* Time stamp update seconds */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Time Stamp Low Update Register */[m
[32m+[m[32m#define ETH_PTPTSLUR_TSUPNS  ((uint32_t)0x80000000)  /* Time stamp update Positive or negative time */[m
[32m+[m[32m#define ETH_PTPTSLUR_TSUSS   ((uint32_t)0x7FFFFFFF)  /* Time stamp update sub-seconds */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Time Stamp Addend Register */[m
[32m+[m[32m#define ETH_PTPTSAR_TSA      ((uint32_t)0xFFFFFFFF)  /* Time stamp addend */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Target Time High Register */[m
[32m+[m[32m#define ETH_PTPTTHR_TTSH     ((uint32_t)0xFFFFFFFF)  /* Target time stamp high */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet PTP Target Time Low Register */[m
[32m+[m[32m#define ETH_PTPTTLR_TTSL     ((uint32_t)0xFFFFFFFF)  /* Target time stamp low */[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                 Ethernet DMA Registers bits definition                     */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Bus Mode Register */[m
[32m+[m[32m#define ETH_DMABMR_AAB       ((uint32_t)0x02000000)  /* Address-Aligned beats */[m
[32m+[m[32m#define ETH_DMABMR_FPM        ((uint32_t)0x01000000)  /* 4xPBL mode */[m
[32m+[m[32m#define ETH_DMABMR_USP       ((uint32_t)0x00800000)  /* Use separate PBL */[m
[32m+[m[32m#define ETH_DMABMR_RDP       ((uint32_t)0x007E0000)  /* RxDMA PBL */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_1Beat    ((uint32_t)0x00020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 1 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_2Beat    ((uint32_t)0x00040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 2 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_4Beat    ((uint32_t)0x00080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_8Beat    ((uint32_t)0x00100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_16Beat   ((uint32_t)0x00200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_32Beat   ((uint32_t)0x00400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */[m[41m                [m
[32m+[m[32m  #define ETH_DMABMR_RDP_4xPBL_4Beat   ((uint32_t)0x01020000)  /* maximum number of beats to be transferred in one RxDMA transaction is 4 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_4xPBL_8Beat   ((uint32_t)0x01040000)  /* maximum number of beats to be transferred in one RxDMA transaction is 8 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_4xPBL_16Beat  ((uint32_t)0x01080000)  /* maximum number of beats to be transferred in one RxDMA transaction is 16 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_4xPBL_32Beat  ((uint32_t)0x01100000)  /* maximum number of beats to be transferred in one RxDMA transaction is 32 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_4xPBL_64Beat  ((uint32_t)0x01200000)  /* maximum number of beats to be transferred in one RxDMA transaction is 64 */[m
[32m+[m[32m  #define ETH_DMABMR_RDP_4xPBL_128Beat ((uint32_t)0x01400000)  /* maximum number of beats to be transferred in one RxDMA transaction is 128 */[m[41m  [m
[32m+[m[32m#define ETH_DMABMR_FB        ((uint32_t)0x00010000)  /* Fixed Burst */[m
[32m+[m[32m#define ETH_DMABMR_RTPR      ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */[m
[32m+[m[32m  #define ETH_DMABMR_RTPR_1_1     ((uint32_t)0x00000000)  /* Rx Tx priority ratio */[m
[32m+[m[32m  #define ETH_DMABMR_RTPR_2_1     ((uint32_t)0x00004000)  /* Rx Tx priority ratio */[m
[32m+[m[32m  #define ETH_DMABMR_RTPR_3_1     ((uint32_t)0x00008000)  /* Rx Tx priority ratio */[m
[32m+[m[32m  #define ETH_DMABMR_RTPR_4_1     ((uint32_t)0x0000C000)  /* Rx Tx priority ratio */[m[41m  [m
[32m+[m[32m#define ETH_DMABMR_PBL    ((uint32_t)0x00003F00)  /* Programmable burst length */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_1Beat    ((uint32_t)0x00000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 1 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_2Beat    ((uint32_t)0x00000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 2 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_4Beat    ((uint32_t)0x00000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_8Beat    ((uint32_t)0x00000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_16Beat   ((uint32_t)0x00001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_32Beat   ((uint32_t)0x00002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */[m[41m                [m
[32m+[m[32m  #define ETH_DMABMR_PBL_4xPBL_4Beat   ((uint32_t)0x01000100)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 4 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_4xPBL_8Beat   ((uint32_t)0x01000200)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 8 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_4xPBL_16Beat  ((uint32_t)0x01000400)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 16 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_4xPBL_32Beat  ((uint32_t)0x01000800)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 32 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_4xPBL_64Beat  ((uint32_t)0x01001000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 64 */[m
[32m+[m[32m  #define ETH_DMABMR_PBL_4xPBL_128Beat ((uint32_t)0x01002000)  /* maximum number of beats to be transferred in one TxDMA (or both) transaction is 128 */[m
[32m+[m[32m#define ETH_DMABMR_DSL       ((uint32_t)0x0000007C)  /* Descriptor Skip Length */[m
[32m+[m[32m#define ETH_DMABMR_DA        ((uint32_t)0x00000002)  /* DMA arbitration scheme */[m
[32m+[m[32m#define ETH_DMABMR_SR        ((uint32_t)0x00000001)  /* Software reset */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Transmit Poll Demand Register */[m
[32m+[m[32m#define ETH_DMATPDR_TPD      ((uint32_t)0xFFFFFFFF)  /* Transmit poll demand */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Receive Poll Demand Register */[m
[32m+[m[32m#define ETH_DMARPDR_RPD      ((uint32_t)0xFFFFFFFF)  /* Receive poll demand  */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Receive Descriptor List Address Register */[m
[32m+[m[32m#define ETH_DMARDLAR_SRL     ((uint32_t)0xFFFFFFFF)  /* Start of receive list */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Transmit Descriptor List Address Register */[m
[32m+[m[32m#define ETH_DMATDLAR_STL     ((uint32_t)0xFFFFFFFF)  /* Start of transmit list */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Status Register */[m
[32m+[m[32m#define ETH_DMASR_TSTS       ((uint32_t)0x20000000)  /* Time-stamp trigger status */[m
[32m+[m[32m#define ETH_DMASR_PMTS       ((uint32_t)0x10000000)  /* PMT status */[m
[32m+[m[32m#define ETH_DMASR_MMCS       ((uint32_t)0x08000000)  /* MMC status */[m
[32m+[m[32m#define ETH_DMASR_EBS        ((uint32_t)0x03800000)  /* Error bits status */[m
[32m+[m[32m  /* combination with EBS[2:0] for GetFlagStatus function */[m
[32m+[m[32m  #define ETH_DMASR_EBS_DescAccess      ((uint32_t)0x02000000)  /* Error bits 0-data buffer, 1-desc. access */[m
[32m+[m[32m  #define ETH_DMASR_EBS_ReadTransf      ((uint32_t)0x01000000)  /* Error bits 0-write trnsf, 1-read transfr */[m
[32m+[m[32m  #define ETH_DMASR_EBS_DataTransfTx    ((uint32_t)0x00800000)  /* Error bits 0-Rx DMA, 1-Tx DMA */[m
[32m+[m[32m#define ETH_DMASR_TPS         ((uint32_t)0x00700000)  /* Transmit process state */[m
[32m+[m[32m  #define ETH_DMASR_TPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Tx Command issued  */[m
[32m+[m[32m  #define ETH_DMASR_TPS_Fetching        ((uint32_t)0x00100000)  /* Running - fetching the Tx descriptor */[m
[32m+[m[32m  #define ETH_DMASR_TPS_Waiting         ((uint32_t)0x00200000)  /* Running - waiting for status */[m
[32m+[m[32m  #define ETH_DMASR_TPS_Reading         ((uint32_t)0x00300000)  /* Running - reading the data from host memory */[m
[32m+[m[32m  #define ETH_DMASR_TPS_Suspended       ((uint32_t)0x00600000)  /* Suspended - Tx Descriptor unavailabe */[m
[32m+[m[32m  #define ETH_DMASR_TPS_Closing         ((uint32_t)0x00700000)  /* Running - closing Rx descriptor */[m
[32m+[m[32m#define ETH_DMASR_RPS         ((uint32_t)0x000E0000)  /* Receive process state */[m
[32m+[m[32m  #define ETH_DMASR_RPS_Stopped         ((uint32_t)0x00000000)  /* Stopped - Reset or Stop Rx Command issued */[m
[32m+[m[32m  #define ETH_DMASR_RPS_Fetching        ((uint32_t)0x00020000)  /* Running - fetching the Rx descriptor */[m
[32m+[m[32m  #define ETH_DMASR_RPS_Waiting         ((uint32_t)0x00060000)  /* Running - waiting for packet */[m
[32m+[m[32m  #define ETH_DMASR_RPS_Suspended       ((uint32_t)0x00080000)  /* Suspended - Rx Descriptor unavailable */[m
[32m+[m[32m  #define ETH_DMASR_RPS_Closing         ((uint32_t)0x000A0000)  /* Running - closing descriptor */[m
[32m+[m[32m  #define ETH_DMASR_RPS_Queuing         ((uint32_t)0x000E0000)  /* Running - queuing the recieve frame into host memory */[m
[32m+[m[32m#define ETH_DMASR_NIS        ((uint32_t)0x00010000)  /* Normal interrupt summary */[m
[32m+[m[32m#define ETH_DMASR_AIS        ((uint32_t)0x00008000)  /* Abnormal interrupt summary */[m
[32m+[m[32m#define ETH_DMASR_ERS        ((uint32_t)0x00004000)  /* Early receive status */[m
[32m+[m[32m#define ETH_DMASR_FBES       ((uint32_t)0x00002000)  /* Fatal bus error status */[m
[32m+[m[32m#define ETH_DMASR_ETS        ((uint32_t)0x00000400)  /* Early transmit status */[m
[32m+[m[32m#define ETH_DMASR_RWTS       ((uint32_t)0x00000200)  /* Receive watchdog timeout status */[m
[32m+[m[32m#define ETH_DMASR_RPSS       ((uint32_t)0x00000100)  /* Receive process stopped status */[m
[32m+[m[32m#define ETH_DMASR_RBUS       ((uint32_t)0x00000080)  /* Receive buffer unavailable status */[m
[32m+[m[32m#define ETH_DMASR_RS         ((uint32_t)0x00000040)  /* Receive status */[m
[32m+[m[32m#define ETH_DMASR_TUS        ((uint32_t)0x00000020)  /* Transmit underflow status */[m
[32m+[m[32m#define ETH_DMASR_ROS        ((uint32_t)0x00000010)  /* Receive overflow status */[m
[32m+[m[32m#define ETH_DMASR_TJTS       ((uint32_t)0x00000008)  /* Transmit jabber timeout status */[m
[32m+[m[32m#define ETH_DMASR_TBUS       ((uint32_t)0x00000004)  /* Transmit buffer unavailable status */[m
[32m+[m[32m#define ETH_DMASR_TPSS       ((uint32_t)0x00000002)  /* Transmit process stopped status */[m
[32m+[m[32m#define ETH_DMASR_TS         ((uint32_t)0x00000001)  /* Transmit status */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Operation Mode Register */[m
[32m+[m[32m#define ETH_DMAOMR_DTCEFD    ((uint32_t)0x04000000)  /* Disable Dropping of TCP/IP checksum error frames */[m
[32m+[m[32m#define ETH_DMAOMR_RSF       ((uint32_t)0x02000000)  /* Receive store and forward */[m
[32m+[m[32m#define ETH_DMAOMR_DFRF      ((uint32_t)0x01000000)  /* Disable flushing of received frames */[m
[32m+[m[32m#define ETH_DMAOMR_TSF       ((uint32_t)0x00200000)  /* Transmit store and forward */[m
[32m+[m[32m#define ETH_DMAOMR_FTF       ((uint32_t)0x00100000)  /* Flush transmit FIFO */[m
[32m+[m[32m#define ETH_DMAOMR_TTC       ((uint32_t)0x0001C000)  /* Transmit threshold control */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Transmit FIFO is 64 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_128Bytes      ((uint32_t)0x00004000)  /* threshold level of the MTL Transmit FIFO is 128 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_192Bytes      ((uint32_t)0x00008000)  /* threshold level of the MTL Transmit FIFO is 192 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_256Bytes      ((uint32_t)0x0000C000)  /* threshold level of the MTL Transmit FIFO is 256 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_40Bytes       ((uint32_t)0x00010000)  /* threshold level of the MTL Transmit FIFO is 40 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_32Bytes       ((uint32_t)0x00014000)  /* threshold level of the MTL Transmit FIFO is 32 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_24Bytes       ((uint32_t)0x00018000)  /* threshold level of the MTL Transmit FIFO is 24 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_TTC_16Bytes       ((uint32_t)0x0001C000)  /* threshold level of the MTL Transmit FIFO is 16 Bytes */[m
[32m+[m[32m#define ETH_DMAOMR_ST        ((uint32_t)0x00002000)  /* Start/stop transmission command */[m
[32m+[m[32m#define ETH_DMAOMR_FEF       ((uint32_t)0x00000080)  /* Forward error frames */[m
[32m+[m[32m#define ETH_DMAOMR_FUGF      ((uint32_t)0x00000040)  /* Forward undersized good frames */[m
[32m+[m[32m#define ETH_DMAOMR_RTC       ((uint32_t)0x00000018)  /* receive threshold control */[m
[32m+[m[32m  #define ETH_DMAOMR_RTC_64Bytes       ((uint32_t)0x00000000)  /* threshold level of the MTL Receive FIFO is 64 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_RTC_32Bytes       ((uint32_t)0x00000008)  /* threshold level of the MTL Receive FIFO is 32 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_RTC_96Bytes       ((uint32_t)0x00000010)  /* threshold level of the MTL Receive FIFO is 96 Bytes */[m
[32m+[m[32m  #define ETH_DMAOMR_RTC_128Bytes      ((uint32_t)0x00000018)  /* threshold level of the MTL Receive FIFO is 128 Bytes */[m
[32m+[m[32m#define ETH_DMAOMR_OSF       ((uint32_t)0x00000004)  /* operate on second frame */[m
[32m+[m[32m#define ETH_DMAOMR_SR        ((uint32_t)0x00000002)  /* Start/stop receive */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Interrupt Enable Register */[m
[32m+[m[32m#define ETH_DMAIER_NISE      ((uint32_t)0x00010000)  /* Normal interrupt summary enable */[m
[32m+[m[32m#define ETH_DMAIER_AISE      ((uint32_t)0x00008000)  /* Abnormal interrupt summary enable */[m
[32m+[m[32m#define ETH_DMAIER_ERIE      ((uint32_t)0x00004000)  /* Early receive interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_FBEIE     ((uint32_t)0x00002000)  /* Fatal bus error interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_ETIE      ((uint32_t)0x00000400)  /* Early transmit interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_RWTIE     ((uint32_t)0x00000200)  /* Receive watchdog timeout interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_RPSIE     ((uint32_t)0x00000100)  /* Receive process stopped interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_RBUIE     ((uint32_t)0x00000080)  /* Receive buffer unavailable interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_RIE       ((uint32_t)0x00000040)  /* Receive interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_TUIE      ((uint32_t)0x00000020)  /* Transmit Underflow interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_ROIE      ((uint32_t)0x00000010)  /* Receive Overflow interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_TJTIE     ((uint32_t)0x00000008)  /* Transmit jabber timeout interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_TBUIE     ((uint32_t)0x00000004)  /* Transmit buffer unavailable interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_TPSIE     ((uint32_t)0x00000002)  /* Transmit process stopped interrupt enable */[m
[32m+[m[32m#define ETH_DMAIER_TIE       ((uint32_t)0x00000001)  /* Transmit interrupt enable */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Missed Frame and Buffer Overflow Counter Register */[m
[32m+[m[32m#define ETH_DMAMFBOCR_OFOC   ((uint32_t)0x10000000)  /* Overflow bit for FIFO overflow counter */[m
[32m+[m[32m#define ETH_DMAMFBOCR_MFA    ((uint32_t)0x0FFE0000)  /* Number of frames missed by the application */[m
[32m+[m[32m#define ETH_DMAMFBOCR_OMFC   ((uint32_t)0x00010000)  /* Overflow bit for missed frame counter */[m
[32m+[m[32m#define ETH_DMAMFBOCR_MFC    ((uint32_t)0x0000FFFF)  /* Number of frames missed by the controller */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Current Host Transmit Descriptor Register */[m
[32m+[m[32m#define ETH_DMACHTDR_HTDAP   ((uint32_t)0xFFFFFFFF)  /* Host transmit descriptor address pointer */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Current Host Receive Descriptor Register */[m
[32m+[m[32m#define ETH_DMACHRDR_HRDAP   ((uint32_t)0xFFFFFFFF)  /* Host receive descriptor address pointer */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Current Host Transmit Buffer Address Register */[m
[32m+[m[32m#define ETH_DMACHTBAR_HTBAP  ((uint32_t)0xFFFFFFFF)  /* Host transmit buffer address pointer */[m
[32m+[m
[32m+[m[32m/* Bit definition for Ethernet DMA Current Host Receive Buffer Address Register */[m
[32m+[m[32m#define ETH_DMACHRBAR_HRBAP  ((uint32_t)0xFFFFFFFF)  /* Host receive buffer address pointer */[m
[32m+[m[32m#endif /* STM32F10X_CL */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m /**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m#ifdef USE_STDPERIPH_DRIVER[m
[32m+[m[32m  #include "stm32f10x_conf.h"[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m/** @addtogroup Exported_macro[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#define SET_BIT(REG, BIT)     ((REG) |= (BIT))[m
[32m+[m
[32m+[m[32m#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))[m
[32m+[m
[32m+[m[32m#define READ_BIT(REG, BIT)    ((REG) & (BIT))[m
[32m+[m
[32m+[m[32m#define CLEAR_REG(REG)        ((REG) = (0x0))[m
[32m+[m
[32m+[m[32m#define WRITE_REG(REG, VAL)   ((REG) = (VAL))[m
[32m+[m
[32m+[m[32m#define READ_REG(REG)         ((REG))[m
[32m+[m
[32m+[m[32m#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_H */[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m  /**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/User/stm32f10x_conf.h b/User/stm32f10x_conf.h[m
[1mnew file mode 100644[m
[1mindex 0000000..cbb8819[m
[1m--- /dev/null[m
[1m+++ b/User/stm32f10x_conf.h[m
[36m@@ -0,0 +1,77 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_conf.h[m[41m [m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    08-April-2011[m
[32m+[m[32m  * @brief   Library configuration file.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_CONF_H[m
[32m+[m[32m#define __STM32F10x_CONF_H[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m/* Uncomment/Comment the line below to enable/disable peripheral header file inclusion */[m
[32m+[m[32m#include "stm32f10x_adc.h"[m
[32m+[m[32m#include "stm32f10x_bkp.h"[m
[32m+[m[32m#include "stm32f10x_can.h"[m
[32m+[m[32m#include "stm32f10x_cec.h"[m
[32m+[m[32m#include "stm32f10x_crc.h"[m
[32m+[m[32m#include "stm32f10x_dac.h"[m
[32m+[m[32m#include "stm32f10x_dbgmcu.h"[m
[32m+[m[32m#include "stm32f10x_dma.h"[m
[32m+[m[32m#include "stm32f10x_exti.h"[m
[32m+[m[32m#include "stm32f10x_flash.h"[m
[32m+[m[32m#include "stm32f10x_fsmc.h"[m
[32m+[m[32m#include "stm32f10x_gpio.h"[m
[32m+[m[32m#include "stm32f10x_i2c.h"[m
[32m+[m[32m#include "stm32f10x_iwdg.h"[m
[32m+[m[32m#include "stm32f10x_pwr.h"[m
[32m+[m[32m#include "stm32f10x_rcc.h"[m
[32m+[m[32m#include "stm32f10x_rtc.h"[m
[32m+[m[32m#include "stm32f10x_sdio.h"[m
[32m+[m[32m#include "stm32f10x_spi.h"[m
[32m+[m[32m#include "stm32f10x_tim.h"[m
[32m+[m[32m#include "stm32f10x_usart.h"[m
[32m+[m[32m#include "stm32f10x_wwdg.h"[m
[32m+[m[32m#include "misc.h" /* High level functions for NVIC and SysTick (add-on to CMSIS functions) */[m
[32m+[m
[32m+[m[32m/* Exported types ------------------------------------------------------------*/[m
[32m+[m[32m/* Exported constants --------------------------------------------------------*/[m
[32m+[m[32m/* Uncomment the line below to expanse the "assert_param" macro in the[m[41m [m
[32m+[m[32m   Standard Peripheral Library drivers code */[m
[32m+[m[32m/* #define USE_FULL_ASSERT    1 */[m
[32m+[m
[32m+[m[32m/* Exported macro ------------------------------------------------------------*/[m
[32m+[m[32m#ifdef  USE_FULL_ASSERT[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  The assert_param macro is used for function's parameters check.[m
[32m+[m[32m  * @param  expr: If expr is false, it calls assert_failed function which reports[m[41m [m
[32m+[m[32m  *         the name of the source file and the source line number of the call[m[41m [m
[32m+[m[32m  *         that failed. If expr is true, it returns no value.[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32m  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((uint8_t *)__FILE__, __LINE__))[m
[32m+[m[32m/* Exported functions ------------------------------------------------------- */[m
[32m+[m[32m  void assert_failed(uint8_t* file, uint32_t line);[m
[32m+[m[32m#else[m
[32m+[m[32m  #define assert_param(expr) ((void)0)[m
[32m+[m[32m#endif /* USE_FULL_ASSERT */[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_CONF_H */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/User/stm32f10x_it.c b/User/stm32f10x_it.c[m
[1mnew file mode 100644[m
[1mindex 0000000..18acee1[m
[1m--- /dev/null[m
[1m+++ b/User/stm32f10x_it.c[m
[36m@@ -0,0 +1,160 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_it.c[m[41m [m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    08-April-2011[m
[32m+[m[32m  * @brief   Main Interrupt Service Routines.[m
[32m+[m[32m  *          This file provides template for all exceptions handler and[m[41m [m
[32m+[m[32m  *          peripherals interrupt service routine.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x_it.h"[m
[32m+[m
[32m+[m[32m/** @addtogroup STM32F10x_StdPeriph_Template[m
[32m+[m[32m  * @{[m
[32m+[m[32m  */[m
[32m+[m
[32m+[m[32m/* Private typedef -----------------------------------------------------------*/[m
[32m+[m[32m/* Private define ------------------------------------------------------------*/[m
[32m+[m[32m/* Private macro -------------------------------------------------------------*/[m
[32m+[m[32m/* Private variables ---------------------------------------------------------*/[m
[32m+[m[32m/* Private function prototypes -----------------------------------------------*/[m
[32m+[m[32m/* Private functions ---------------------------------------------------------*/[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*            Cortex-M3 Processor Exceptions Handlers                         */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles NMI exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid NMI_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles Hard Fault exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid HardFault_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Go to infinite loop when Hard Fault exception occurs */[m
[32m+[m[32m  while (1)[m
[32m+[m[32m  {[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles Memory Manage exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid MemManage_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Go to infinite loop when Memory Manage exception occurs */[m
[32m+[m[32m  while (1)[m
[32m+[m[32m  {[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles Bus Fault exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid BusFault_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Go to infinite loop when Bus Fault exception occurs */[m
[32m+[m[32m  while (1)[m
[32m+[m[32m  {[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles Usage Fault exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid UsageFault_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m  /* Go to infinite loop when Usage Fault exception occurs */[m
[32m+[m[32m  while (1)[m
[32m+[m[32m  {[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles SVCall exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SVC_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles Debug Monitor exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid DebugMon_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles PendSVC exception.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid PendSV_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles SysTick Handler.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32mvoid SysTick_Handler(void)[m
[32m+[m[32m{[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m[32m/*                 STM32F10x Peripherals Interrupt Handlers                   */[m
[32m+[m[32m/*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */[m
[32m+[m[32m/*  available peripheral interrupt handler's name please refer to the startup */[m
[32m+[m[32m/*  file (startup_stm32f10x_xx.s).                                            */[m
[32m+[m[32m/******************************************************************************/[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @brief  This function handles PPP interrupt request.[m
[32m+[m[32m  * @param  None[m
[32m+[m[32m  * @retval None[m
[32m+[m[32m  */[m
[32m+[m[32m/*void PPP_IRQHandler(void)[m
[32m+[m[32m{[m
[32m+[m[32m}*/[m
[32m+[m
[32m+[m[32m/**[m
[32m+[m[32m  * @}[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/User/stm32f10x_it.h b/User/stm32f10x_it.h[m
[1mnew file mode 100644[m
[1mindex 0000000..8890262[m
[1m--- /dev/null[m
[1m+++ b/User/stm32f10x_it.h[m
[36m@@ -0,0 +1,54 @@[m
[32m+[m[32m/**[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @file    Project/STM32F10x_StdPeriph_Template/stm32f10x_it.h[m[41m [m
[32m+[m[32m  * @author  MCD Application Team[m
[32m+[m[32m  * @version V3.5.0[m
[32m+[m[32m  * @date    08-April-2011[m
[32m+[m[32m  * @brief   This file contains the headers of the interrupt handlers.[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  * @attention[m
[32m+[m[32m  *[m
[32m+[m[32m  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS[m
[32m+[m[32m  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE[m
[32m+[m[32m  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY[m
[32m+[m[32m  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING[m
[32m+[m[32m  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE[m
[32m+[m[32m  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.[m
[32m+[m[32m  *[m
[32m+[m[32m  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>[m
[32m+[m[32m  ******************************************************************************[m
[32m+[m[32m  */[m[41m [m
[32m+[m
[32m+[m[32m/* Define to prevent recursive inclusion -------------------------------------*/[m
[32m+[m[32m#ifndef __STM32F10x_IT_H[m
[32m+[m[32m#define __STM32F10x_IT_H[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m extern "C" {[m
[32m+[m[32m#endif[m[41m [m
[32m+[m
[32m+[m[32m/* Includes ------------------------------------------------------------------*/[m
[32m+[m[32m#include "stm32f10x.h"[m
[32m+[m
[32m+[m[32m/* Exported types ------------------------------------------------------------*/[m
[32m+[m[32m/* Exported constants --------------------------------------------------------*/[m
[32m+[m[32m/* Exported macro ------------------------------------------------------------*/[m
[32m+[m[32m/* Exported functions ------------------------------------------------------- */[m
[32m+[m
[32m+[m[32mvoid NMI_Handler(void);[m
[32m+[m[32mvoid HardFault_Handler(void);[m
[32m+[m[32mvoid MemManage_Handler(void);[m
[32m+[m[32mvoid BusFault_Handler(void);[m
[32m+[m[32mvoid UsageFault_Handler(void);[m
[32m+[m[32mvoid SVC_Handler(void);[m
[32m+[m[32mvoid DebugMon_Handler(void);[m
[32m+[m[32mvoid PendSV_Handler(void);[m
[32m+[m[32mvoid SysTick_Handler(void);[m
[32m+[m
[32m+[m[32m#ifdef __cplusplus[m
[32m+[m[32m}[m
[32m+[m[32m#endif[m
[32m+[m
[32m+[m[32m#endif /* __STM32F10x_IT_H */[m
[32m+[m
[32m+[m[32m/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/[m
[1mdiff --git a/keilkilll.bat b/keilkilll.bat[m
[1mnew file mode 100644[m
[1mindex 0000000..accc110[m
[1m--- /dev/null[m
[1m+++ b/keilkilll.bat[m
[36m@@ -0,0 +1,27 @@[m
[32m+[m[32mdel *.bak /s[m
[32m+[m[32mdel *.ddk /s[m
[32m+[m[32mdel *.edk /s[m
[32m+[m[32mdel *.lst /s[m
[32m+[m[32mdel *.lnp /s[m
[32m+[m[32mdel *.mpf /s[m
[32m+[m[32mdel *.mpj /s[m
[32m+[m[32mdel *.obj /s[m
[32m+[m[32mdel *.omf /s[m
[32m+[m[32m::del *.opt /s  ::≤ª‘ –Ì…æ≥˝JLINKµƒ…Ë÷√[m
[32m+[m[32mdel *.plg /s[m
[32m+[m[32mdel *.rpt /s[m
[32m+[m[32mdel *.tmp /s[m
[32m+[m[32mdel *.__i /s[m
[32m+[m[32mdel *.crf /s[m
[32m+[m[32mdel *.o /s[m
[32m+[m[32mdel *.d /s[m
[32m+[m[32mdel *.axf /s[m
[32m+[m[32mdel *.tra /s[m
[32m+[m[32mdel *.dep /s[m[41m           [m
[32m+[m[32mdel JLinkLog.txt /s[m
[32m+[m
[32m+[m[32mdel *.iex /s[m
[32m+[m[32mdel *.htm /s[m
[32m+[m[32mdel *.sct /s[m
[32m+[m[32mdel *.map /s[m
[32m+[m[32mexit[m
